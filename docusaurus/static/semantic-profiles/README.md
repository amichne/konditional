# Semantic Profiles

This directory contains semantic analysis results for Kotlin code snippets, consumed by the `SemanticViewer` component.

## File Format

Each JSON file represents a complete semantic profile:

```typescript
{
  "snippetId": string,       // Unique identifier
  "codeHash": string,        // Hash of code content (for cache invalidation)
  "code": string,            // The Kotlin source code
  "insights": [              // Array of semantic insights
    {
      "id": string,          // Unique insight ID
      "position": {          // Character range in source
        "from": { "line": number, "col": number },
        "to": { "line": number, "col": number }
      },
      "category": string,    // TYPE_INFERENCE | NULLABILITY | SMART_CASTS | ...
      "level": string,       // HIGHLIGHTS | ALL
      "kind": string,        // Specific insight kind (e.g., INFERRED_TYPE)
      "scopeChain": [...],   // Nested scope context
      "data": {...},         // Type-specific insight data (discriminated union)
      "tokenText": string    // The actual source text
    }
  ],
  "rootScopes": [...]        // Scope tree (for future scope navigation UI)
}
```

## Example Files

### `simple-types.json`
Minimal example demonstrating:
- Type inference on `val` declarations
- Extension function call (`map`)
- Lambda parameter inference

**Code:**
```kotlin
val numbers = listOf(1, 2, 3)
val doubled = numbers.map { it * 2 }
```

**Insights:** 4 insights (2 type inference, 1 lambda, 1 extension)

---

### `example-demo.json`
Comprehensive example demonstrating:
- Type inference
- Null-safe calls (`?.`)
- Scope functions (`let`)
- Smart casts (nullable → non-null)
- Nested scopes
- Lambda parameter inference

**Code:**
```kotlin
data class User(val name: String, val email: String?)

fun processUser(user: User?) {
    user?.let { u ->
        val greeting = "Hello, ${u.name}"
        println(greeting)

        u.email?.let { email ->
            sendEmail(email)
        }
    }
}

fun sendEmail(address: String) {
    println("Sending to: $address")
}
```

**Insights:** 9 insights across 6 categories

---

## Insight Data Types

Each insight has a `data` field with type-specific information:

### TypeInference
```json
{
  "type": "TypeInference",
  "inferredType": "List<String>",
  "declaredType": null,           // Present if explicitly declared
  "typeArguments": ["String"]     // Generic arguments
}
```

### SmartCast
```json
{
  "type": "SmartCast",
  "originalType": "User?",
  "narrowedType": "User",
  "evidencePosition": { ... },    // Where the check happened
  "evidenceKind": "null-safe call"
}
```

### Scoping
```json
{
  "type": "Scoping",
  "scopeFunction": "let",
  "outerReceiver": "User",        // Receiver before scope function
  "innerReceiver": "String",      // Receiver inside scope function
  "itParameterType": "String"     // Type of `it` parameter
}
```

### Extension
```json
{
  "type": "Extension",
  "functionOrProperty": "map",
  "extensionReceiverType": "List<Int>",
  "resolvedFrom": "kotlin.collections",
  "competingMember": false        // True if member function was shadowed
}
```

### Lambda
```json
{
  "type": "Lambda",
  "parameterTypes": [
    { "name": "it", "type": "Int" }
  ],
  "returnType": "Int",
  "inferredFromContext": "map transform function",
  "samInterface": null            // Set if SAM conversion occurred
}
```

### Nullability
```json
{
  "type": "Nullability",
  "nullableType": "String?",
  "isNullable": true,
  "isPlatformType": false,        // True for Java interop types
  "narrowedToNonNull": false      // True if smart-cast to non-null
}
```

### Overload
```json
{
  "type": "Overload",
  "selectedSignature": "map(transform: (T) -> R)",
  "candidateCount": 3,
  "resolutionFactors": [
    "more specific receiver",
    "exact parameter match"
  ],
  "defaultArgumentsUsed": []
}
```

---

## Testing the Viewer

### In Markdown
```markdown
```kotlin id="simple-types" semantic
val numbers = listOf(1, 2, 3)
val doubled = numbers.map { it * 2 }
```⁣
```

### In MDX Component
```mdx
<SemanticViewer snippetId="simple-types" />
```

---

## Generation Workflow

These files are generated by the Kotlin semantic analyzer:

1. **Input:** Kotlin source code snippet
2. **Analysis:** Run Analysis API to extract insights
3. **Output:** JSON file in this directory
4. **Consumption:** Frontend loads via `/semantic-profiles/{snippetId}.json`

See `kodeblok-engine` module for the analyzer implementation.

---

## Naming Convention

- File names match `snippetId` field
- Use kebab-case: `example-demo.json`, `simple-types.json`
- Keep IDs short but descriptive
- Prefix test fixtures with `test-` (e.g., `test-nullability.json`)

---

## Cache Invalidation

The `codeHash` field enables cache invalidation:
- Hash the source code (SHA-256 or similar)
- Frontend compares cached hash to loaded hash
- If mismatch, re-fetch the profile

This prevents stale tooltips when code changes.
