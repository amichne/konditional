diff --git a/docs/01-getting-started.md b/docs/01-getting-started.md
index 1a63c1c..11c18ca 100644
--- a/docs/01-getting-started.md
+++ b/docs/01-getting-started.md
@@ -1,27 +1,31 @@
 # Getting Started
 
-Type-safe flags in 5 minutes. If it compiles, it works—no runtime errors, no null checks, no string typos.
+Konditional is a Kotlin feature-flag DSL designed to make configuration *typed*, *deterministic*, and *non-null*.
+The core claim is precise: statically-defined flags have compile-time type correctness, and evaluation is total (you always get a value back).
 
-## Why Konditional?
+---
+
+## Why Konditional (and what it actually guarantees)
 
-Most feature flag systems use runtime strings. Konditional uses compile-time properties instead.
+Most flag systems are stringly-typed: a string key selects a value and the caller chooses a “typed getter”.
+That architecture creates three failure modes that are syntactically valid but semantically wrong at runtime: key typos, type mismatches, and null propagation.
 
-| Feature          | String-Based (Custom)                                                       | Konditional                                                                                   |
-|------------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
-| **Type Safety**  | Exclusively booleans, drives branching explosion in reality                 | Compile-time safety allows runtime usage without risk `feature { Features.FLAG }`             |
-| **Evaluation**   | Hardcoded via boolean flows                                                 | Dynamic and generic, maintaining rigor of type-checking                                       |
-| **Context**      | Enum class with string keys                                                 | Typed data classes with IDE autocomplete                                                      |
-| **Performance**  | Shared module forces full-rebuild at compile-time, unable to leverage cache | Module changes to flags are not invalidating of task-graph for parent                         |
-| **Organization** | Prefixing, shared single source by all                                      | Namespaces (compile-time isolated), with type-enforced boundaries, infitinitely divisible     |
-| **Errors**       | Silent failures, null checks, type casting                                  | Guarnteed valid startup config,<br/> Update failures emerge **before** update, during parsing |
+Konditional changes the failure surface by binding identity and type at definition time via Kotlin properties:
 
-**Core benefits:** 
-* No more invalid configurations, instead, compile errors.
-* First-class Gradle caching support
-* Modules own the feature flags they are concerned with
-* Unified, single-source, for all flagging
-* Your IDE knows everything.
-* Built to scale to multi-tenancy, seamlessly
+- **No string keys at call sites**: flags are accessed as properties (typos become compile errors).
+- **No casts at call sites**: the return type flows from the flag definition (mismatched types become compile errors).
+- **No nulls from evaluation**: defaults are required, so evaluation has a total return path.
+
+```mermaid
+flowchart LR
+  Def["Flag defined as a property"] --> Bound["Key + type bound at compile-time"]
+  Bound --> Eval["Evaluation"]
+  Eval -->|Rule matches| Value["Rule value"]
+  Eval -->|No match| Default["Declared default"]
+  style Bound fill:#e1f5ff
+  style Default fill:#fff3cd
+  style Value fill:#c8e6c9
+```
 
 ---
 
@@ -36,13 +40,13 @@ dependencies {
 
 ---
 
-## Your First Flag
+## Your first flag
 
-Define flags as properties. The compiler enforces types:
+Define a flag as a delegated property in a `FeatureContainer` bound to a `Namespace`:
 
 ```kotlin
-import io.amichne.konditional.core.features.FeatureContainer
 import io.amichne.konditional.core.Namespace
+import io.amichne.konditional.core.features.FeatureContainer
 import io.amichne.konditional.context.*
 
 object AppFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
@@ -54,7 +58,6 @@ object AppFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
     }
 }
 
-// Create context (required for evaluation)
 val context = Context(
     locale = AppLocale.UNITED_STATES,
     platform = Platform.IOS,
@@ -62,59 +65,45 @@ val context = Context(
     stableId = StableId.of("a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6")
 )
 
-// Evaluate - returns Boolean, never null
 val enabled: Boolean = feature { AppFeatures.DARK_MODE }
 ```
 
-**vs String-Based Systems:**
-```kotlin
-// String-based - runtime lookup, can typo, type unknown
-val enabled = featureFlags.getBoolean("dark-mode", false)  // No IDE help, typos fail silently
-
-// Konditional - compile-time property, autocomplete works
-val enabled = feature { AppFeatures.DARK_MODE }  // IDE knows it's Boolean
-```
+Notes:
+- Konditional models evaluation as context-dependent; examples assume you are evaluating within a context-aware scope.
+- `feature { ... }` returns the flag’s declared Kotlin type and never returns null.
 
 ---
 
-## Multiple Types
-
-All primitives work out of the box:
+## A small API surface, intentionally
 
-```kotlin
-object AppConfig : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val DARK_MODE by boolean(default = false)
-    val API_ENDPOINT by string(default = "https://api.example.com")
-    val MAX_RETRIES by int(default = 3)
-    val TIMEOUT by double(default = 30.0)
-}
-```
+Supported value types (out of the box):
 
-Each flag is typed—you can't accidentally treat a string as a boolean.
+| Type    | DSL Method  | Kotlin Type   | Example Default |
+|---------|-------------|---------------|-----------------|
+| Boolean | `boolean()` | `Boolean`     | `false`         |
+| String  | `string()`  | `String`      | `"production"`  |
+| Integer | `int()`     | `Int`         | `42`            |
+| Decimal | `double()`  | `Double`      | `3.14`          |
+| Enum    | `enum<E>()` | `E : Enum<E>` | `LogLevel.INFO` |
 
 ---
 
-## Common Patterns
+## Common patterns
 
-### Pattern 1: Gradual Rollout
-
-Ship to 10% of users, then expand:
+### Gradual rollout (deterministic)
 
 ```kotlin
 val NEW_CHECKOUT by boolean(default = false) {
     rule {
         platforms(Platform.ANDROID)
-        rollout { 10.0 }  // Start small
+        rollout { 10.0 }
     } returns true
 }
-
-// Later: increase to 50%
-// Same users stay enabled (deterministic SHA-256 bucketing)
 ```
 
-### Pattern 2: Platform-Specific Config
+Konditional’s rollouts are deterministic: the same `(stableId, flagKey, salt)` yields the same bucket assignment.
 
-Different values per platform:
+### Platform-specific configuration
 
 ```kotlin
 val API_ENDPOINT by string(default = "https://api.example.com") {
@@ -124,115 +113,36 @@ val API_ENDPOINT by string(default = "https://api.example.com") {
 }
 ```
 
-### Pattern 3: A/B Testing
-
-Split traffic 50/50:
-
-```kotlin
-val RECOMMENDATION_ALGO by string(default = "collaborative") {
-    rule { rollout { 50.0 } } returns "content-based"
-}
-// Same user always gets same variant (deterministic)
-```
-
----
-
-## Evaluation Methods
+### Variants via enums (not strings)
 
 ```kotlin
-// Simple evaluation with default
-val enabled = feature { AppFeatures.DARK_MODE }
+enum class Theme { LIGHT, DARK }
 
+val THEME by enum<Theme, Context>(default = Theme.LIGHT)
 ```
 
 ---
 
-## Organizing by Team/Domain
+## Namespaces scale ownership, not prefixes
 
-Use namespaces to isolate features:
+Namespaces isolate registries. This is both organizational (team/domain boundaries) and structural (no cross-namespace collisions):
 
 ```kotlin
-object AuthFeatures : FeatureContainer<Namespace.Authentication>(
-    Namespace.Authentication
-) {
+object AuthFeatures : FeatureContainer<Namespace.Authentication>(Namespace.Authentication) {
     val SOCIAL_LOGIN by boolean(default = false)
 }
 
-object PaymentFeatures : FeatureContainer<Namespace.Payments>(
-    Namespace.Payments
-) {
+object PaymentFeatures : FeatureContainer<Namespace.Payments>(Namespace.Payments) {
     val APPLE_PAY by boolean(default = false)
 }
 ```
 
-**Benefits:**
-- Features can't collide across namespaces
-- Each team owns their namespace
-- Type system prevents cross-namespace access mistakes
-
 ---
 
-## Key Differentiators
-
-### 1. Compile-Time Safety
-String-based: `getFlag("flag-name")` — Typos fail at runtime (or silently return defaults)
-**Konditional:** `feature { Features.DARK_MODE }` — Typos fail at compile time
-
-### 2. Offline-First Architecture
-String-based (LaunchDarkly/Statsig): Network call or cache required for evaluation
-**Konditional:** All evaluation happens locally. Zero network dependency.
-
-### 3. Zero-Allocation Evaluation
-String-based: HashMap lookups, type casting, object creation per evaluation
-**Konditional:** Immutable data structures, lock-free reads, no GC pressure
-
-### 4. Type-Safe Contexts
-String-based: `context.put("tier", "enterprise")` — String keys, Any values, no validation
-**Konditional:**
-```kotlin
-data class EnterpriseContext(
-    // ... standard fields ...
-    val subscriptionTier: SubscriptionTier  // Enum, not string - compile-time validated
-) : Context
-```
-
-### 5. Deterministic Rollouts
-Most systems use hashing, but Konditional's SHA-256 bucketing is:
-- Platform-stable (same buckets on JVM, Android, iOS, Web)
-- Independent per flag (user in 50% of Flag A ≠ in 50% of Flag B)
-- Salt-controllable (change salt to redistribute users)
-
----
-
-## Next Steps
-
-**Just getting started?** You're done! Start adding flags to your code.
-
-**Need advanced targeting?** See **["Targeting & Rollouts"](04-targeting-rollouts.md)** for rules, specificity, and custom logic.
-
-**Want custom contexts?** See **["Core Concepts"](03-core-concepts.md)** for extending Context with business data.
-
-**Migrating from another system?** See **["Migration Guide"](02-migration.md)** for concept mapping and adoption patterns.
-
-**Loading remote configs?** See **["Remote Configuration"](06-remote-config.md)** for JSON serialization.
-
----
-
-## Quick Reference
-
-```kotlin
-// 1. Define features
-object Features : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val FLAG by boolean(default = false) {
-        rule { platforms(Platform.IOS); rollout { 50.0 } } returns true
-    }
-}
-
-// 2. Create context
-val ctx = Context(locale, platform, version, stableId)
-
-// 3. Evaluate
-val value = feature { Features.FLAG }
-```
+## Next steps
 
-That's it. Type-safe feature flags in 3 steps.
+- Learn the building blocks: ["Core Concepts"](03-core-concepts.md)
+- Write targeting rules and understand rollouts: ["Targeting & Rollouts"](04-targeting-rollouts.md)
+- Understand evaluation order and determinism: ["Evaluation"](05-evaluation.md)
+- Add runtime-validated JSON configuration: ["Remote Configuration"](06-remote-config.md)
+- Understand the exact trust boundary: ["Theory"](07-theory.md)
diff --git a/docs/02-migration.md b/docs/02-migration.md
index aa731ca..d9c2760 100644
--- a/docs/02-migration.md
+++ b/docs/02-migration.md
@@ -1,154 +1,78 @@
 # Migration Guide
 
-Switch from string-based feature flags to compile-time safety. This guide maps concepts and shows adoption patterns.
+This guide maps the conceptual shift from string-based flags to Konditional’s typed, property-based model.
+It focuses on what changes at the definition site, at the call site, and at the trust boundary (runtime JSON).
 
 ---
 
-## Concept Mapping
+## The core mapping
 
-### String-Based Systems → Konditional
+String-based flag systems typically have:
+- a **string key** (`"dark-mode"`)
+- a **typed getter** chosen by the caller (`getBoolean`, `getString`, …)
+- an **untyped context** (often string keys and `Any` values)
 
-| Common Pattern (LaunchDarkly/Statsig/Custom)  | Konditional                       | Key Difference                          |
-|-----------------------------------------------|-----------------------------------|-----------------------------------------|
-| `getFlag("flag-name")` or `client.boolVariation("flag", false)` | `feature { Features.FLAG }` | Compile-time property vs runtime string |
-| Context with `Map<String, Any>` attributes    | `Context` data class              | Typed fields vs HashMap                 |
-| Rules in dashboard or config files            | `rule { }` DSL (code)             | Version-controlled in code              |
-| Percentage rollouts                           | `rollout { 50.0 }`                | Same concept, local computation         |
-| Segments/audiences/conditions                 | Custom `extension { }` logic      | Type-safe predicates                    |
-| Projects/environments/namespaces              | `Namespace`                       | Compile-time isolated                   |
-| Flag variations/treatments                    | `rule {...} returns value`        | Type-safe values                        |
+Konditional replaces those with:
+- a **property** (the property name becomes the key)
+- a **declared type** (from the delegate: `boolean`, `string`, `int`, `double`, `enum`)
+- a **typed `Context`** (and optionally domain-specific context data classes)
 
-### Specific Service Mappings
-
-**LaunchDarkly:**
-- `LDClient.boolVariation()` → `feature { Feature }`
-- `LDContext` → `Context` data class
-- Segments → `extension { Evaluable.factory { ... } }`
-
-**Statsig:**
-- `statsig.getConfig()` → `feature { Feature }`
-- Dynamic Config → String/Int/Double features with rules
-- Feature Gates → Boolean features
-
-**Custom String-Based:**
-- `featureFlags["flag"]` → `feature { Features.FLAG }`
-- String keys → Property delegation
-- Type casting → Compiler-enforced types
+```mermaid
+flowchart LR
+  A["String key"] --> B["Property name"]
+  C["Typed getter"] --> D["Type flows from definition"]
+  E["Untyped context map"] --> F["Typed Context data"]
+```
 
 ---
 
-## Code Comparison
+## Step-by-step adoption (incremental)
 
-### Boolean Flag
-
-**String-Based (LaunchDarkly example):**
+### 0. Start with one container
 
 ```kotlin
-val client = LDClient(sdkKey)
-val context = LDContext.builder("user-123")
-    .set("platform", "ios")
-    .build()
-
-val enabled = client.boolVariation("dark-mode", context, false)
+object Features : FeatureContainer<Namespace.Global>(Namespace.Global) {
+    val DARK_MODE by boolean(default = false)
+}
 ```
 
-**String-Based (Statsig example):**
+### 1. Replace call sites first (value safety)
 
 ```kotlin
-val statsig = Statsig.initialize(sdkKey)
-val user = StatsigUser("user-123")
-    .setCustom(mapOf("platform" to "ios"))
-
-val enabled = statsig.checkGate(user, "dark_mode")
+val enabled: Boolean = feature { Features.DARK_MODE }
 ```
 
-**Konditional:**
+What you gain immediately:
+- key typos are eliminated at the call site (there is no string key)
+- return type is concrete (no cast; `Boolean` is enforced)
+- evaluation is non-null (default is required)
 
-```kotlin
-object Features : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val DARK_MODE by boolean(default = false)
-}
+### 2. Introduce typed context (targeting + rollouts)
 
+```kotlin
 val context = Context(
     locale = AppLocale.UNITED_STATES,
     platform = Platform.IOS,
-    appVersion = Version.parse("1.0.0"),
+    appVersion = Version.parse("2.1.0"),
     stableId = StableId.of("a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6")
 )
-
-val enabled = feature { Features.DARK_MODE }
 ```
 
-**Key differences:**
-
-- No SDK key or network needed (offline-first)
-- StableId requires hex format (deterministic bucketing)
-- Property access with IDE autocomplete
-- Type safety: compiler knows `enabled` is `Boolean`
+`stableId` is the stable input used for deterministic rollout bucketing (see ["Targeting & Rollouts"](04-targeting-rollouts.md)).
 
-### String Configuration
-
-**String-Based (Custom implementation):**
+### 3. Add rules after defaults exist (behavior safety)
 
 ```kotlin
-val config = ConfigManager.getInstance()
-val endpoint = when (config.getString("api-endpoint-variant")) {
-    "ios" -> "https://api-ios.example.com"
-    "android" -> "https://api-android.example.com"
-    else -> "https://api.example.com"
+val API_ENDPOINT by string(default = "https://api.example.com") {
+    rule { platforms(Platform.IOS) } returns "https://api-ios.example.com"
 }
 ```
 
-**String-Based (Statsig Dynamic Config):**
-
-```kotlin
-val config = statsig.getConfig(user, "api_config")
-val endpoint = config.getString("endpoint", "https://api.example.com")
-```
-
-**Konditional:**
-
-```kotlin
-object Config : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val API_ENDPOINT by string(default = "https://api.example.com") {
-        rule { platforms(Platform.IOS) } returns "https://api-ios.example.com"
-        rule { platforms(Platform.ANDROID) } returns "https://api-android.example.com"
-    }
-}
-
-val endpoint = feature { Config.API_ENDPOINT }  // Type: String, never null
-```
-
-**Key differences:**
-
-- No treatment-to-value mapping (direct type-safe values)
-- Rules defined in code (version-controlled)
-- Returns actual config value, not treatment name
-
-### Custom Attributes / Context Fields
-
-**String-Based (LaunchDarkly example):**
-
-```kotlin
-val context = LDContext.builder("user-123")
-    .set("tier", "enterprise")  // String value, no validation
-    .set("organization", "acme-corp")
-    .build()
+---
 
-// In dashboard: target users where tier == "enterprise"
-```
+## Migrating “context maps” to typed contexts
 
-**String-Based (Statsig example):**
-
-```kotlin
-val user = StatsigUser("user-123")
-    .setCustom(mapOf(
-        "tier" to "enterprise",  // String value, no validation
-        "organization" to "acme-corp"
-    ))
-```
-
-**Konditional:**
+If your current system uses string keys (`"tier"`, `"role"`, …), move that information into a custom context:
 
 ```kotlin
 data class EnterpriseContext(
@@ -156,235 +80,64 @@ data class EnterpriseContext(
     override val platform: Platform,
     override val appVersion: Version,
     override val stableId: StableId,
-    val subscriptionTier: SubscriptionTier,  // Typed, not string
-    val organizationId: String
+    val subscriptionTier: SubscriptionTier,
+    val employeeCount: Int
 ) : Context
 
-object PremiumFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val ADVANCED_ANALYTICS by boolean(default = false) {
-        rule {
-            extension {
-                Evaluable.factory { ctx: EnterpriseContext ->
-                    ctx.subscriptionTier == SubscriptionTier.ENTERPRISE
-                }
+enum class SubscriptionTier { FREE, PRO, ENTERPRISE }
+
+val ADVANCED_ANALYTICS by boolean<EnterpriseContext>(default = false) {
+    rule {
+        extension {
+            Evaluable.factory { ctx ->
+                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &&
+                    ctx.employeeCount > 100
             }
-        } returns true
-    }
+        }
+    } returns true
 }
-
-val ctx = EnterpriseContext(..., subscriptionTier = SubscriptionTier.ENTERPRISE, ...)
-val enabled = feature { PremiumFeatures.ADVANCED_ANALYTICS }
 ```
 
-**Key differences:**
-
-- Type-safe enum `SubscriptionTier` vs string "enterprise"
-- Custom fields defined as properties (compiler-validated)
-- Business logic in code (testable, refactorable)
+Result: business targeting logic becomes type-checked and refactor-safe.
 
 ---
 
-## Adoption Patterns
-
-### Pattern 1: Gradual (Recommended)
-
-Run Konditional alongside your existing system, migrate flag-by-flag.
-
-**Steps:**
+## Namespaces replace prefixes
 
-1. Add Konditional dependency
-2. Define one flag in Konditional (mirror existing config)
-3. Evaluate both systems, log differences
-4. Once confident, switch to Konditional for that flag
-5. Repeat for remaining flags
-6. Remove old system dependency
-
-**Example dual evaluation:**
+Instead of `"auth.dark-mode"` / `"payments.dark-mode"` style prefixes, use namespace isolation:
 
 ```kotlin
-// Wrapper to compare both systems
-fun isEnabled(flagName: String, context: Context): Boolean {
-    // Existing system (LaunchDarkly example)
-    val oldResult = featureFlagClient.getBoolean(flagName, false)
-
-    // Konditional
-    val newResult = when (flagName) {
-        "dark_mode" -> feature { Features.DARK_MODE }
-        else -> null
-    }
-
-    if (newResult != null && oldResult != newResult) {
-        logger.warn("Mismatch for $flagName: Old=$oldResult, New=$newResult")
-    }
-
-    return oldResult  // Use old system until validated
+object AuthFeatures : FeatureContainer<Namespace.Authentication>(Namespace.Authentication) {
+    val SOCIAL_LOGIN by boolean(default = false)
 }
-```
-
-### Pattern 2: Big-Bang (Faster, Higher Risk)
-
-Migrate all flags at once.
-
-**Steps:**
-
-1. Export all existing flags (from dashboard, config files, or database)
-2. Define equivalent Konditional features
-3. Test thoroughly in staging
-4. Deploy and monitor closely
-5. Roll back if issues arise
-
-**Use when:** You have comprehensive tests and can tolerate brief outages.
-
-### Pattern 3: New Features Only
-
-Keep existing flags in your current system, use Konditional for new flags.
-
-**Steps:**
-
-1. Add Konditional for new features
-2. Gradually migrate old flags as time permits
-3. Eventually deprecate old system
-
-**Use when:** Migration isn't urgent, want to learn Konditional gradually.
-
----
 
-## Common Migration Challenges
-
-### Challenge 1: StableId Format
-
-**String-based systems:** User IDs can be any string (`"user-123"`, `"alice@example.com"`)
-
-**Konditional:** `StableId` must be valid hexadecimal (32+ characters)
-
-**Solution:** Hash your existing IDs:
-
-```kotlin
-fun userIdToStableId(userId: String): StableId {
-    val hash = MessageDigest.getInstance("SHA-256")
-        .digest(userId.toByteArray())
-        .joinToString("") { "%02x".format(it) }
-    return StableId.of(hash)
+object PaymentFeatures : FeatureContainer<Namespace.Payments>(Namespace.Payments) {
+    val APPLE_PAY by boolean(default = false)
 }
-
-val stableId = userIdToStableId("user-123")
 ```
 
-### Challenge 2: Dynamic Attributes
-
-**String-based systems:** Attributes set at runtime (`context.set("key", value)` or `Map<String, Any>`)
+Each namespace has its own registry and independent configuration lifecycle.
 
-**Konditional:** Context fields must be defined at compile time
-
-**Solution:** Create custom context with all possible fields:
-
-```kotlin
-data class AppContext(
-    override val locale: AppLocale,
-    override val platform: Platform,
-    override val appVersion: Version,
-    override val stableId: StableId,
-    val subscriptionTier: SubscriptionTier?,  // Nullable if optional
-    val betaTester: Boolean,
-    val organizationId: String?
-) : Context
-```
-
-### Challenge 3: Remote Configuration
-
-**String-based systems:** Flags configured via dashboard/API, updated instantly
+---
 
-**Konditional:** Flags defined in code, rules updated via UI or JSON
+## When you need runtime configuration (remote JSON)
 
-**Solution:** Use UI with RBAC or JSON serialization for remote updates:
+Konditional supports JSON configuration as a validated boundary:
 
 ```kotlin
-// Define flags in code with defaults
-object Features : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val DARK_MODE by boolean(default = false)
-}
-
-// Load remote rules (doesn't change code, just rule configuration)
-val remoteJson = fetchFromServer("/flags.json")
-when (val result = SnapshotSerializer.fromJson(remoteJson)) {
+val json = File("flags.json").readText()
+when (val result = SnapshotSerializer.fromJson(json)) {
     is ParseResult.Success -> Namespace.Global.load(result.value)
-    is ParseResult.Failure -> logger.error("Failed to load config")
+    is ParseResult.Failure -> logError("Parse failed: ${result.error}")
 }
 ```
 
-### Challenge 4: Rollout Redistribution
-
-**Issue:** Users in 50% rollout in your old system won't match 50% in Konditional (different bucketing algorithms)
-
-**Solution:** Accept redistribution or use salt to align:
-
-- **Accept:** Users may see different experience temporarily (most teams do this)
-- **Align:** Adjust Konditional salt until distribution matches (trial-and-error, not recommended)
-
-Most teams accept redistribution since rollouts are temporary anyway.
-
----
-
-## Why Migrate?
-
-### 1. Eliminate Runtime Errors
-
-**String-based:**
-
-```kotlin
-getFlag("dark-mod")  // Typo! Returns null or default silently
-```
-
-**Konditional:**
-
-```kotlin
-feature { Features.DARK_MOD }  // Compile error: unresolved reference
-```
-
-### 2. Reduce Infrastructure Costs
-
-**SaaS systems (LaunchDarkly/Statsig):** Monthly fees scale with MAU/seat count
-
-**Konditional:** Zero infrastructure cost (runs locally)
-
-### 3. Improve Performance
-
-**String-based:** Network latency or cache lookup overhead, type casting
-
-**Konditional:** Zero network calls, O(n) local evaluation where n < 10, zero allocation
-
-### 4. Version Control Everything
-
-**Dashboard-based systems:** Flag rules live in UI (audit log separate from code)
-
-**Konditional:** Flags defined in code (Git history + UI with RBAC for rule updates)
-
-### 5. Type Safety
-
-**String-based:** `getInt("flag")` vs `getString("flag")` — must remember type, can typo
-
-**Konditional:** Compiler knows the type, IDE autocomplete works, typos impossible
+The guarantee is intentionally qualified: JSON is not “always safe”; instead, invalid JSON is rejected before it can affect evaluation.
 
 ---
 
-## Decision Matrix
-
-| Factor                   | Stick with Current System                              | Migrate to Konditional             |
-|--------------------------|--------------------------------------------------------|------------------------------------|
-| **Budget**               | SaaS cost not a concern                                | Want to eliminate SaaS fees        |
-| **Tech stack**           | Multi-language (Java, Go, Python, Ruby, etc.)          | Kotlin/JVM only                    |
-| **Type safety priority** | Low (runtime errors acceptable)                        | High (critical for correctness)    |
-| **Offline support**      | Not needed (always connected)                          | Essential (mobile, edge computing) |
-| **Integration effort**   | Already integrated, working well                       | Willing to invest migration time   |
-| **Control & Compliance** | Prefer SaaS management                                 | Need self-hosted with RBAC control |
-
----
-
-## Next Steps
-
-**Ready to migrate?** Start with ["Getting Started"](01-getting-started.md) to run your first Konditional flag.
-
-**Need feature parity?** See ["Targeting & Rollouts"](04-targeting-rollouts.md) for advanced rules matching most feature flag systems.
+## Next steps
 
-**Want to understand the model?** See ["Core Concepts"](03-core-concepts.md) for deep dive into Features, Context, and
-Namespaces.
+- Learn the primitives: ["Core Concepts"](03-core-concepts.md)
+- Understand rule evaluation and determinism: ["Evaluation"](05-evaluation.md)
+- Operate remote config safely: ["Remote Configuration"](06-remote-config.md)
diff --git a/docs/03-core-concepts.md b/docs/03-core-concepts.md
index 8f2a0d2..d9fea5b 100644
--- a/docs/03-core-concepts.md
+++ b/docs/03-core-concepts.md
@@ -1,17 +1,24 @@
 # Core Concepts
 
-Design flags for your domain. This guide covers Features, Context, and Namespaces—the building blocks of type-safe
-feature flags.
+Konditional’s public surface is intentionally small. Understanding three primitives—**Features**, **Context**, and **Namespaces**—is enough to reason about correctness, organization, and runtime behavior.
+
+```mermaid
+flowchart TD
+  N["Namespace"] --> R["Registry"]
+  C["FeatureContainer"] --> R
+  C --> F["Feature (typed)"]
+  F --> D["Default (required)"]
+  F --> Rules["Rules"]
+  Rules --> Rule["rule { ... } returns value"]
+  Rule --> Criteria["platforms/locales/versions/rollout/extension"]
+  X["Context"] --> Rule
+```
 
 ---
 
 ## Features
 
-Features are type-safe flag definitions. Define them once, use them everywhere with compiler guarantees.
-
-### FeatureContainer Pattern (Recommended)
-
-The delegation pattern gives you property access with zero boilerplate:
+A feature is a typed configuration value with an optional rule set. You define features as delegated properties in a `FeatureContainer`:
 
 ```kotlin
 object AppFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
@@ -21,19 +28,16 @@ object AppFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
     val TIMEOUT by double(default = 30.0)
 }
 
-// Property access, not method calls
-val enabled = feature { AppFeatures.DARK_MODE }  // Type: Boolean
-val endpoint = feature { AppFeatures.API_ENDPOINT }  // Type: String
+val enabled: Boolean = feature { AppFeatures.DARK_MODE }
+val endpoint: String = feature { AppFeatures.API_ENDPOINT }
 ```
 
-**What you get:**
-
-- Property names become flag keys automatically
-- Type inference from default values
-- IDE autocomplete
-- Compile-time validation
+What this buys you:
+- **Property name becomes the key** (no string keys at call sites)
+- **Type flows from the delegate** (`boolean` → `Boolean`, etc.)
+- **Non-null evaluation** (default is required)
 
-### Supported Types
+### Supported types
 
 | Type    | DSL Method  | Kotlin Type   | Example Default |
 |---------|-------------|---------------|-----------------|
@@ -43,9 +47,7 @@ val endpoint = feature { AppFeatures.API_ENDPOINT }  // Type: String
 | Decimal | `double()`  | `Double`      | `3.14`          |
 | Enum    | `enum<E>()` | `E : Enum<E>` | `LogLevel.INFO` |
 
-### Enum Flags
-
-For type-safe variants, use enums:
+### Enums instead of strings
 
 ```kotlin
 enum class LogLevel { DEBUG, INFO, WARN, ERROR }
@@ -56,148 +58,36 @@ object AppConfig : FeatureContainer<Namespace.Global>(Namespace.Global) {
     val THEME by enum<Theme, Context>(default = Theme.LIGHT)
 }
 
-// Type-safe evaluation
 val level: LogLevel = feature { AppConfig.LOG_LEVEL }
 ```
 
-**vs string-based systems:**
-
-```kotlin
-// LaunchDarkly - strings, can typo
-val level = client.stringVariation("log-level", "info")
-when (level) {
-    "debug" -> ...
-    "deubg" -> ...  // Typo! Never matches
-}
-
-// Konditional - compiler validates
-val level = feature { AppConfig.LOG_LEVEL }
-when (level) {
-    LogLevel.DEBUG -> ...
-    LogLevel.DEUBG -> ...  // Compile error
-}
-```
+Because variants are enum values, invalid variants cannot compile.
 
 ---
 
-## Context
-
-Context provides the evaluation environment. Every evaluation requires context—it tells Konditional *who* is asking and
-*where* they are.
-
-### Standard Fields
-
-All contexts must have these four fields:
-
-```kotlin
-data class Context(
-    val locale: AppLocale,       // App language/region
-    val platform: Platform,      // Device type
-    val appVersion: Version,     // App version (semantic)
-    val stableId: StableId       // User/device identifier (hex)
-)
-```
-
-**Example:**
-
-```kotlin
-val context = Context(
-    locale = AppLocale.UNITED_STATES,
-    platform = Platform.IOS,
-    appVersion = Version.parse("2.1.0"),
-    stableId = StableId.of("a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6")
-)
-```
-
-### Platform
-
-Where your code runs:
-
-```kotlin
-enum class Platform {
-    IOS,        // iOS apps
-    ANDROID,    // Android apps
-}
-```
-
-Use in rules:
-
-```kotlin
-rule { platforms(Platform.IOS, Platform.ANDROID) } returns mobileValue
-```
-
-### AppLocale
-
-User's language and region. 27 supported locales:
-
-```kotlin
-AppLocale.UNITED_STATES  // en-US
-AppLocale.CANADA         // en-CA
-AppLocale.UNITED_KINGDOM // en-GB
-AppLocale.FRANCE         // fr-FR
-AppLocale.JAPAN          // ja-JP
-// ... 22 more
-```
-
-Use in rules:
-
-```kotlin
-rule { locales(AppLocale.UNITED_STATES, AppLocale.CANADA) } returns "en" locale
-```
-
-### Version
+## Rules
 
-Semantic versioning (major.minor.patch):
+Rules are a typed mapping from a set of criteria to a concrete return value:
 
 ```kotlin
-val version = Version.parse("2.1.0")  // ParseResult<Version>
-val version = Version.of(2, 1, 0)     // Direct construction
-```
-
-Use in rules for version targeting:
-
-```kotlin
-rule {
-    versions {
-        min(2, 0, 0)  // Minimum 2.0.0
-        max(3, 0, 0)  // Below 3.0.0
-    }
-} returns v2Feature
-```
-
-### StableId
-
-Stable user/device identifier for deterministic rollouts. Must be hexadecimal (32+ chars).
-
-```kotlin
-// Valid hex IDs
-val id1 = StableId.of("a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6")
-val id2 = StableId.of("deadbeefcafebabe1234567890abcdef")
-
-// Invalid - will throw
-val bad = StableId.of("user-123")  // Not hex!
-```
-
-**Convert existing IDs:**
-
-```kotlin
-fun toStableId(userId: String): StableId {
-    val hash = MessageDigest.getInstance("SHA-256")
-        .digest(userId.toByteArray())
-        .joinToString("") { "%02x".format(it) }
-    return StableId.of(hash)
+val API_ENDPOINT by string(default = "https://api.example.com") {
+    rule { platforms(Platform.IOS) } returns "https://api-ios.example.com"
+    rule { platforms(Platform.ANDROID) } returns "https://api-android.example.com"
 }
 ```
 
-**Why hex?** Ensures uniform distribution across rollout buckets (0-9999).
-
----
+Criteria you can compose (within a single rule):
+- `platforms(...)`
+- `locales(...)`
+- `versions { min(...); max(...) }`
+- `rollout { percent }`
+- `extension { ... }` for custom predicates
 
-## Custom Contexts
+Within a rule, criteria combine as **AND**: all specified criteria must match for the rule to match.
 
-Extend Context with business-specific fields for advanced targeting.
+### Custom predicates via `extension { }`
 
-### Enterprise Example
+To keep business targeting logic typed (not string-based), define a custom `Context` and use `extension { }`:
 
 ```kotlin
 data class EnterpriseContext(
@@ -205,15 +95,11 @@ data class EnterpriseContext(
     override val platform: Platform,
     override val appVersion: Version,
     override val stableId: StableId,
-    // Custom fields
     val subscriptionTier: SubscriptionTier,
-    val organizationId: String,
-    val userRole: UserRole,
     val employeeCount: Int
 ) : Context
 
 enum class SubscriptionTier { FREE, PRO, ENTERPRISE }
-enum class UserRole { VIEWER, EDITOR, ADMIN }
 
 object PremiumFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
     val ADVANCED_ANALYTICS by boolean<EnterpriseContext>(default = false) {
@@ -221,276 +107,130 @@ object PremiumFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
             extension {
                 Evaluable.factory { ctx ->
                     ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &&
-                    ctx.employeeCount > 100
+                        ctx.employeeCount > 100
                 }
             }
         } returns true
     }
 }
-
-// Evaluation with custom context
-val ctx = EnterpriseContext(
-    locale = AppLocale.UNITED_STATES,
-    platform = Platform.WEB,
-    appVersion = Version.parse("3.0.0"),
-    stableId = StableId.of("..."),
-    subscriptionTier = SubscriptionTier.ENTERPRISE,
-    organizationId = "acme-corp",
-    userRole = UserRole.ADMIN,
-    employeeCount = 500
-)
-
-val enabled = feature { PremiumFeatures.ADVANCED_ANALYTICS }  // true
 ```
 
-### Multi-Tenant Example
-
-```kotlin
-data class TenantContext(
-    override val locale: AppLocale,
-    override val platform: Platform,
-    override val appVersion: Version,
-    override val stableId: StableId,
-    val tenantId: String,
-    val featureAccess: Set<String>  // Purchased features
-) : Context
-
-object SaasFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val PDF_EXPORT by boolean<TenantContext>(default = false) {
-        rule {
-            extension {
-                Evaluable.factory { ctx ->
-                    "pdf-export" in ctx.featureAccess
-                }
-            }
-        } returns true
-    }
-}
-```
-
-**Key principle:** Custom contexts enable type-safe business logic in rules without hardcoding user IDs or organization
-names.
+Because the feature is parameterized with `EnterpriseContext`, `ctx` is strongly typed inside the predicate.
 
 ---
 
-## Namespaces
+## Context
 
-Namespaces isolate features by domain. Each namespace has its own registry—features can't collide across namespaces.
+Context provides evaluation inputs: it tells Konditional who is asking and where they are.
 
-### Built-In Namespaces
+Standard fields (the minimum required by the rule DSL):
 
 ```kotlin
-Namespace.Global            // Shared across app
-Namespace.Authentication    // Login, SSO, 2FA
-Namespace.Payments          // Billing, subscriptions
-Namespace.Messaging         // Chat, notifications
-Namespace.Search            // Search algorithms
-Namespace.Recommendations   // Personalization
+data class Context(
+    val locale: AppLocale,
+    val platform: Platform,
+    val appVersion: Version,
+    val stableId: StableId
+)
 ```
 
-### Using Namespaces
+### StableId (deterministic rollouts)
 
-```kotlin
-object AuthFeatures : FeatureContainer<Namespace.Authentication>(
-    Namespace.Authentication
-) {
-    val SOCIAL_LOGIN by boolean(default = false)
-    val TWO_FACTOR_AUTH by boolean(default = true)
-}
-
-object PaymentFeatures : FeatureContainer<Namespace.Payments>(
-    Namespace.Payments
-) {
-    val APPLE_PAY by boolean(default = false)
-    val STRIPE_INTEGRATION by boolean(default = true)
-}
+`stableId` is a stable identifier used for deterministic bucketing. It must be hex (32+ chars):
 
-// Each namespace isolated
-Namespace.Authentication.load(authConfig)  // Only affects auth features
-Namespace.Payments.load(paymentConfig)     // Only affects payment features
+```kotlin
+val id = StableId.of("a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6")
 ```
 
-### Namespace Benefits
-
-| Benefit                    | What It Means                                              |
-|----------------------------|------------------------------------------------------------|
-| **Compile-time isolation** | Can't accidentally use wrong namespace's features          |
-| **Runtime isolation**      | Separate registries, independent configurations            |
-| **Team ownership**         | Clear boundaries (Auth team owns Authentication namespace) |
-| **Independent deployment** | Update one namespace without affecting others              |
-
-### Custom Namespaces
-
-For team-specific domains:
+If you have an existing user ID, hash it into hex:
 
 ```kotlin
-// Sealed class ensures compile-time exhaustiveness
-sealed class TeamNamespace(id: String) : Namespace(id) {
-    data object Recommendations : TeamNamespace("recommendations")
-    data object Analytics : TeamNamespace("analytics")
-}
-
-object RecFeatures : FeatureContainer<TeamNamespace.Recommendations>(
-    TeamNamespace.Recommendations
-) {
-    val COLLABORATIVE_FILTERING by boolean(default = true)
+fun toStableId(userId: String): StableId {
+    val hash = MessageDigest.getInstance("SHA-256")
+        .digest(userId.toByteArray())
+        .joinToString("") { "%02x".format(it) }
+    return StableId.of(hash)
 }
 ```
 
-**Why sealed?** Governance—new namespaces require code review and PR approval.
-
 ---
 
-## Organizational Patterns
+## Namespaces
 
-### Pattern 1: By Feature Domain
+Namespaces are isolation boundaries: each namespace has its own registry and independent configuration lifecycle.
 
-Organize containers by business capability:
+Built-in namespaces include:
 
 ```kotlin
-object UserManagement : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val PROFILE_EDITING by boolean(default = true)
-    val ACCOUNT_DELETION by boolean(default = true)
-}
-
-object ContentModeration : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val AUTO_MODERATION by boolean(default = false)
-    val MANUAL_REVIEW by boolean(default = true)
-}
+Namespace.Global
+Namespace.Authentication
+Namespace.Payments
+Namespace.Messaging
+Namespace.Search
+Namespace.Recommendations
 ```
 
-### Pattern 2: By Platform
-
-Separate mobile and web flags:
+Usage:
 
 ```kotlin
-object MobileFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val OFFLINE_MODE by boolean(default = true)
-    val PUSH_NOTIFICATIONS by boolean(default = true)
+object AuthFeatures : FeatureContainer<Namespace.Authentication>(Namespace.Authentication) {
+    val SOCIAL_LOGIN by boolean(default = false)
+    val TWO_FACTOR_AUTH by boolean(default = true)
 }
 
-object WebFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val DESKTOP_NOTIFICATIONS by boolean(default = false)
-    val PROGRESSIVE_WEB_APP by boolean(default = false)
+object PaymentFeatures : FeatureContainer<Namespace.Payments>(Namespace.Payments) {
+    val APPLE_PAY by boolean(default = false)
+    val STRIPE_INTEGRATION by boolean(default = true)
 }
-```
 
-### Pattern 3: By Team
+Namespace.Authentication.load(authConfig)
+Namespace.Payments.load(paymentConfig)
+```
 
-Use namespaces for team isolation:
+### Custom namespaces (governance)
 
 ```kotlin
-// Team 1: Growth
-object GrowthFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val REFERRAL_PROGRAM by boolean(default = false)
+sealed class TeamNamespace(id: String) : Namespace(id) {
+    data object Recommendations : TeamNamespace("recommendations")
+    data object Analytics : TeamNamespace("analytics")
 }
 
-// Team 2: Monetization
-object MonetizationFeatures : FeatureContainer<Namespace.Payments>(
-    Namespace.Payments
-) {
-    val SUBSCRIPTION_UPSELL by boolean(default = true)
+object RecFeatures : FeatureContainer<TeamNamespace.Recommendations>(TeamNamespace.Recommendations) {
+    val COLLABORATIVE_FILTERING by boolean(default = true)
 }
 ```
 
 ---
 
-## Type Safety in Action
-
-Konditional's type system prevents entire classes of errors:
+## Type safety in action (what becomes impossible)
 
-### Impossible Runtime Type Errors
+### Wrong value type at call site
 
 ```kotlin
-// LaunchDarkly - wrong type method
-val retries = client.boolVariation("max-retries", false)  // Oops! Should be int
-processWithRetries(retries)  // Type error at runtime
-
-// Konditional - compiler catches it
 object Config : FeatureContainer<Namespace.Global>(Namespace.Global) {
     val MAX_RETRIES by int(default = 3)
 }
-val retries = feature { Config.MAX_RETRIES }  // Type: Int, guaranteed
-```
-
-### Impossible Context Mismatches
-
-```kotlin
-// Wrong context type
-val basicContext: Context = Context(...)
-feature { PremiumFeatures.ADVANCED_ANALYTICS }  // Compile error!
-// Required: EnterpriseContext, Found: Context
-
-// Correct
-val enterpriseContext: EnterpriseContext = EnterpriseContext(...)
-feature { PremiumFeatures.ADVANCED_ANALYTICS }  // ✓
-```
-
-### Impossible Namespace Collisions
-
-```kotlin
-// Can't mix features across namespaces
-Namespace.Authentication.load(paymentConfig)  // Compile error!
-// Type mismatch
-```
-
----
-
-## Best Practices
-
-### 1. Use FeatureContainer for Everything
-
-Unless you have a specific reason (like enum-based patterns), FeatureContainer delegation is the best API.
-
-### 2. Design Contexts for Your Domain
-
-Don't stuff everything into one mega-context. Create focused contexts:
-
-```kotlin
-// Good - focused
-data class ShoppingContext(..., val cartTotal: Double) : Context
-data class CheckoutContext(..., val paymentMethod: PaymentMethod) : Context
 
-// Bad - kitchen sink
-data class AppContext(..., val cartTotal: Double?, val paymentMethod: PaymentMethod?, ...) : Context
+val retries: Int = feature { Config.MAX_RETRIES }
 ```
 
-### 3. Organize by Team/Domain
-
-Use namespaces to reflect your org structure. Each team should own a namespace.
-
-### 4. Start Simple, Extend Later
-
-Begin with basic Context, add custom fields only when needed:
+### Wrong context type for a feature
 
 ```kotlin
-// Start
-val context = Context(locale, platform, version, stableId)
-
-// Later, when needed
-data class CustomContext(..., val newField: String) : Context
+val basicContext: Context = Context(...)
+feature { PremiumFeatures.ADVANCED_ANALYTICS } // Compile error (requires EnterpriseContext)
 ```
 
-### 5. Use Enums for Variants
-
-Don't use strings when enums make sense:
+### Cross-namespace misuse
 
 ```kotlin
-// Bad
-val THEME by string(default = "light")  // Can typo "lite"
-
-// Good
-enum class Theme { LIGHT, DARK }
-val THEME by enum<Theme, Context>(default = Theme.LIGHT)
+Namespace.Authentication.load(paymentConfig) // Compile error (type mismatch)
 ```
 
 ---
 
-## Next Steps
-
-**Need advanced targeting?** See ["Targeting & Rollouts"](04-targeting-rollouts.md) for rules, specificity, and rollout
-strategies.
-
-**Want to evaluate flags?** See ["Evaluation"](05-evaluation.md) for evaluation methods and error handling.
+## Next steps
 
-**Loading from JSON?** See ["Remote Configuration"](06-remote-config.md) for serialization.
+- Understand rule composition and rollouts: ["Targeting & Rollouts"](04-targeting-rollouts.md)
+- Understand evaluation order and determinism: ["Evaluation"](05-evaluation.md)
+- Understand the runtime JSON boundary: ["Remote Configuration"](06-remote-config.md)
diff --git a/docs/04-targeting-rollouts.md b/docs/04-targeting-rollouts.md
index 0f53011..d6623db 100644
--- a/docs/04-targeting-rollouts.md
+++ b/docs/04-targeting-rollouts.md
@@ -1,14 +1,20 @@
 # Targeting & Rollouts
 
-Ship safely with precise control. Rules let you target specific users and roll out features gradually.
+Rules let you target specific contexts and roll out behavior safely. A rule is a typed mapping:
 
----
+```
+criteria(context) -> returns value
+```
 
-## Basic Targeting
+Two properties define how rules behave:
+- **AND semantics within a rule**: all specified criteria must match.
+- **Specificity ordering across rules**: the most specific matching rule wins.
 
-Target users by platform, locale, or version using simple, readable criteria.
+---
 
-### Platform Targeting
+## Criteria you can combine
+
+### Platform
 
 ```kotlin
 val API_ENDPOINT by string(default = "https://api.example.com") {
@@ -18,13 +24,13 @@ val API_ENDPOINT by string(default = "https://api.example.com") {
 }
 ```
 
-Multiple platforms (OR logic):
+Multiple platforms combine as OR:
 
 ```kotlin
 rule { platforms(Platform.IOS, Platform.ANDROID) } returns "mobile value"
 ```
 
-### Locale Targeting
+### Locale
 
 ```kotlin
 val WELCOME_MESSAGE by string(default = "Hello!") {
@@ -34,510 +40,138 @@ val WELCOME_MESSAGE by string(default = "Hello!") {
 }
 ```
 
-### Version Targeting
-
-Target users on specific version ranges:
+### Version ranges
 
 ```kotlin
 val NEW_UI by boolean(default = false) {
-    rule {
-        versions { min(2, 0, 0) }  // Version >= 2.0.0
-    } returns true
-}
-
-val LEGACY_SUPPORT by boolean(default = false) {
-    rule {
-        versions { max(2, 0, 0) }  // Version < 2.0.0
-    } returns true
-}
-
-val TRANSITION_FEATURE by boolean(default = false) {
-    rule {
-        versions {
-            min(1, 5, 0)  // >= 1.5.0
-            max(2, 0, 0)  // < 2.0.0
-        }
-    } returns true
+    rule { versions { min(2, 0, 0) } } returns true
 }
 ```
 
----
-
-## Combining Criteria
-
-All criteria must match (AND logic):
-
 ```kotlin
-val PREMIUM_FEATURE by boolean(default = false) {
-    rule {
-        platforms(Platform.IOS, Platform.ANDROID)  // Must be mobile
-        locales(AppLocale.UNITED_STATES)          // AND US locale
-        versions { min(2, 0, 0) }                  // AND version >= 2.0.0
-        rollout { 50.0 }                           // AND in 50% bucket
-    } returns true
+val LEGACY_SUPPORT by boolean(default = false) {
+    rule { versions { max(2, 0, 0) } } returns true
 }
 ```
 
-**Flow:**
-
-```mermaid
-flowchart LR
-    Context["User Context"] --> Platform{Platform<br/>iOS or Android?}
-    Platform -->|No| Skip["Skip rule"]
-    Platform -->|Yes| Locale{Locale<br/>US?}
-    Locale -->|No| Skip
-    Locale -->|Yes| Version{Version<br/> >= 2.0.0?}
-    Version -->|No| Skip
-    Version -->|Yes| Rollout{In 50%<br/>bucket?}
-    Rollout -->|No| Skip
-    Rollout -->|Yes| Match["Rule matches!"]
-
-    style Match fill:#c8e6c9
-    style Skip fill:#ffcdd2
-```
-
----
-
-## Rollout Strategies
-
-Deploy features incrementally using deterministic percentage-based rollouts.
-
-### Gradual Rollout
-
-Start small, expand over time:
+### Percentage rollout
 
 ```kotlin
-// Day 1: 10% of users
 val NEW_CHECKOUT by boolean(default = false) {
     rule { rollout { 10.0 } } returns true
 }
-
-// Day 3: 50% (includes original 10%)
-val NEW_CHECKOUT by boolean(default = false) {
-    rule { rollout { 50.0 } } returns true
-}
-
-// Day 7: 100% (everyone)
-val NEW_CHECKOUT by boolean(default = false) {
-    rule { rollout { 100.0 } } returns true
-}
 ```
 
-**Key property:** Same users stay enabled (deterministic bucketing).
+Rollouts are deterministic: the same `(stableId, flagKey, salt)` produces the same bucket assignment.
 
-### Segmented Rollout
-
-Different percentages for different segments:
+### Custom predicates via `extension { }`
 
 ```kotlin
-val BETA_FEATURE by boolean<EnterpriseContext>(default = false) {
-    // 100% for internal users
-    rule {
-        extension {
-            Evaluable.factory { ctx -> ctx.organizationId == "internal" }
-        }
-    } returns true
-
-    // 50% for enterprise customers
+val ADVANCED_ANALYTICS by boolean<EnterpriseContext>(default = false) {
     rule {
         extension {
             Evaluable.factory { ctx ->
-                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE
+                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &&
+                    ctx.employeeCount > 100
             }
         }
-        rollout { 50.0 }
-    } returns true
-
-    // 10% for everyone else
-    rule { rollout { 10.0 } } returns true
-}
-```
-
-### Platform-Specific Rollout
-
-Roll out to platforms independently:
-
-```kotlin
-val NEW_FEATURE by boolean(default = false) {
-    rule {
-        platforms(Platform.ANDROID)
-        rollout { 100.0 }  // 100% Android
     } returns true
-
-    rule {
-        platforms(Platform.IOS)
-        rollout { 25.0 }  // 25% iOS (testing)
-    } returns true
-}
-```
-
----
-
-## Rollout Bucketing
-
-Konditional uses SHA-256 hashing for deterministic user bucketing.
-
-### How It Works
-
-```mermaid
-flowchart LR
-    Salt["Salt: 'v1'"] --> Hash
-    Key["Flag Key"] --> Hash
-    StableId["User StableId"] --> Hash
-
-    Hash["SHA-256 Hash"] --> Mod["Modulo 10,000"]
-    Mod --> Bucket["Bucket: 0-9999"]
-    Bucket --> Compare{Bucket <<br/>threshold?}
-
-    Compare -->|Yes| Enabled["User Enabled"]
-    Compare -->|No| Disabled["User Disabled"]
-
-    style Enabled fill:#c8e6c9
-    style Disabled fill:#ffcdd2
-```
-
-**Algorithm:**
-
-```kotlin
-fun bucket(flagKey: String, stableId: StableId, salt: String): Int {
-    val input = "$salt:$flagKey:${stableId.id}"
-    val hash = SHA256(input)
-    val intValue = hash.take(4).toInt()
-    return intValue % 10_000  // 0-9999 (0.01% granularity)
-}
-
-// Check if user is in rollout
-val threshold = (rollout.value * 100).toInt()  // 50.0 → 5000
-val userBucket = bucket("dark_mode", user.stableId, "v1")
-val enabled = userBucket < threshold
-```
-
-### Bucketing Properties
-
-| Property            | Benefit                                                                  |
-|---------------------|--------------------------------------------------------------------------|
-| **Deterministic**   | Same user always gets same bucket                                        |
-| **Independent**     | Each flag has separate bucketing (user in 50% of Flag A ≠ 50% of Flag B) |
-| **Platform-stable** | Same bucket on JVM, Android, iOS, Web                                    |
-| **Redistributable** | Change salt to reassign buckets                                          |
-| **Fine-grained**    | 0.01% granularity (10,000 buckets)                                       |
-
-### Salt-Based Redistribution
-
-Change salt to redistribute users:
-
-```kotlin
-// Original
-val EXPERIMENT by boolean(default = false) {
-    salt("v1")
-    rule { rollout { 50.0 } } returns true
-}
-
-// New bucketing (different 50% of users)
-val EXPERIMENT by boolean(default = false) {
-    salt("v2")  // Changed!
-    rule { rollout { 50.0 } } returns true
 }
 ```
 
-**Use cases:**
-
-- Reset A/B test for new experiment
-- Fix skewed distribution
-- Run same flag with different user sample
-
 ---
 
-## Specificity & Rule Ordering
-
-When multiple rules match, the most specific rule wins. Rules are auto-sorted by specificity (highest first).
+## AND semantics inside a rule
 
-### Specificity Calculation
-
-```
-specificity = (platforms specified? 1 : 0)
-            + (locales specified? 1 : 0)
-            + (versions specified? 1 : 0)
-            + extension.specificity()
-```
-
-### Examples
+All criteria in a rule must match:
 
 ```kotlin
-val VALUE by string(default = "default") {
-    // Specificity = 3 (platform + locale + version)
+val PREMIUM_FEATURE by boolean(default = false) {
     rule {
-        platforms(Platform.IOS)
+        platforms(Platform.IOS, Platform.ANDROID)
         locales(AppLocale.UNITED_STATES)
         versions { min(2, 0, 0) }
-    } returns "very-specific"
-
-    // Specificity = 2 (platform + locale)
-    rule {
-        platforms(Platform.IOS)
-        locales(AppLocale.UNITED_STATES)
-    } returns "medium-specific"
-
-    // Specificity = 1 (platform only)
-    rule {
-        platforms(Platform.IOS)
-    } returns "general"
-
-    // Specificity = 0 (no constraints)
-    rule { } returns "catch-all"
-}
-```
-
-**Evaluation order:**
-
-```mermaid
-graph TD
-    Start["User: iOS, US, v2.1.0"] --> S3["Specificity 3:<br/>iOS + US + v2.0+<br/>→ 'very-specific'"]
-
-    S3 -->|Matches| Return3["Return 'very-specific'"]
-    S3 -->|Doesn't match| S2["Specificity 2:<br/>iOS + US<br/>→ 'medium-specific'"]
-
-    S2 -->|Matches| Return2["Return 'medium-specific'"]
-    S2 -->|Doesn't match| S1["Specificity 1:<br/>iOS<br/>→ 'general'"]
-
-    S1 -->|Matches| Return1["Return 'general'"]
-    S1 -->|Doesn't match| S0["Specificity 0:<br/>(no constraints)<br/>→ 'catch-all'"]
-
-    S0 --> Default["Return 'catch-all'"]
-
-    style S3 fill:#4caf50
-    style Return3 fill:#c8e6c9
-```
-
-**Key insight:** More specific rules override general rules automatically.
-
----
-
-## Custom Targeting Logic
-
-Use `extension { }` for business logic beyond platform/locale/version.
-
-### Context-Parameterized Evaluation
-
-`extension { }` runs as part of rule matching and receives the **same context** used for evaluation.
-
-Crucially, the context type is **parameterized by the flag**:
-
-- `boolean<Context>(...)` (or `boolean(...)`) → `ctx` is a `Context`
-- `boolean<EnterpriseContext>(...)` → `ctx` is an `EnterpriseContext`
-
-That means your custom rule logic is fully type-safe: you can only access fields that exist on that flag’s context, and
-the compiler prevents mixing unrelated contexts.
-
-### Simple Extension
-
-```kotlin
-val PREMIUM_FEATURE by boolean<EnterpriseContext>(default = false) {
-    rule {
-        extension {
-            Evaluable.factory { ctx ->
-                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE
-            }
-        }
-    } returns true
-}
-```
-
-### Complex Extension
-
-Combine multiple business conditions:
-
-```kotlin
-val ADVANCED_ANALYTICS by boolean<EnterpriseContext>(default = false) {
-    rule {
-        platforms(Platform.WEB)  // Technical constraint
-        extension {              // Business logic
-            object : Evaluable<EnterpriseContext> {
-                override fun matches(ctx: EnterpriseContext) =
-                    ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &&
-                    ctx.employeeCount > 100 &&
-                    ctx.userRole == UserRole.ADMIN
-
-                override fun specificity() = 3  // Three conditions
-            }
-        }
+        rollout { 50.0 }
     } returns true
 }
 ```
 
-**Extension specificity adds to total:**
-
-```
-Total = platform (1) + extension (3) = 4
-```
-
-### Specificity Guidelines
-
-`Evaluable.specificity()` feeds into rule ordering. Keep it:
-
-- **Deterministic**: same value every time
-- **Comparable**: higher means “more constrained / more specific”
-- **Aligned**: roughly reflects how many independent checks you’re performing
-
-### Reusable Evaluables
-
-Create evaluable classes for common patterns:
-
-```kotlin
-class SubscriptionTierEvaluable(
-    private val allowedTiers: Set<SubscriptionTier>
-) : Evaluable<EnterpriseContext> {
-    override fun matches(ctx: EnterpriseContext) =
-        ctx.subscriptionTier in allowedTiers
-
-    override fun specificity() = 1
-}
-
-// Reuse across features
-val FEATURE_A by boolean<EnterpriseContext>(default = false) {
-    rule {
-        extension {
-            SubscriptionTierEvaluable(setOf(SubscriptionTier.ENTERPRISE))
-        }
-    } returns true
-}
-
-val FEATURE_B by boolean<EnterpriseContext>(default = false) {
-    rule {
-        extension {
-            SubscriptionTierEvaluable(setOf(
-                SubscriptionTier.PRO,
-                SubscriptionTier.ENTERPRISE
-            ))
-        }
-    } returns true
-}
+```mermaid
+flowchart LR
+  Ctx["Context"] --> P{Platform match?}
+  P -->|No| Skip["Rule fails"]
+  P -->|Yes| L{Locale match?}
+  L -->|No| Skip
+  L -->|Yes| V{Version match?}
+  V -->|No| Skip
+  V -->|Yes| R{Rollout bucket in range?}
+  R -->|No| Skip
+  R -->|Yes| Win["Rule matches"]
+  style Win fill:#c8e6c9
+  style Skip fill:#ffcdd2
 ```
 
 ---
 
-## Best Practices
+## Specificity: which rule wins
 
-### 1. Start with Small Rollouts
-
-Begin with 10%, monitor metrics, then expand:
-
-```kotlin
-// Phase 1: Canary
-rule { rollout { 10.0 } } returns true
+Konditional orders rules by **specificity** before evaluating them. Specificity is the count of criteria present on a rule:
 
-// Phase 2: Expand (if metrics look good)
-rule { rollout { 50.0 } } returns true
-
-// Phase 3: Full rollout
-rule { rollout { 100.0 } } returns true
 ```
-
-### 2. Use Specificity to Your Advantage
-
-Write rules from most to least specific:
-
-```kotlin
-// Good - clear intent
-rule { platforms(Platform.IOS); locales(AppLocale.UNITED_STATES) } returns "ios-us"
-rule { platforms(Platform.IOS) } returns "ios-all"
-rule { } returns "default"
-
-// Also works, but less clear
-rule { } returns "default"
-rule { platforms(Platform.IOS) } returns "ios-all"
-rule { platforms(Platform.IOS); locales(AppLocale.UNITED_STATES) } returns "ios-us"
-```
-
-### 3. Document Non-Obvious Rules
-
-Use `note()` for complex targeting:
-
-```kotlin
-rule {
-    platforms(Platform.ANDROID)
-    versions { min(1, 9, 0); max(2, 1, 0) }
-    rollout { 15.0 }
-    note("Workaround for Android bug #1234 - affects v1.9.0-2.0.x")
-} returns workaroundValue
-```
-
-### 4. Keep Rule Count Low
-
-Fewer rules = faster evaluation:
-
-```kotlin
-// Good: 2-3 rules
-val FEATURE by boolean(default = false) {
-    rule { platforms(Platform.IOS) } returns true
-    rule { versions { min(2, 0, 0) } } returns true
-}
-
-// Avoid: 20+ rules (consider redesigning with custom context)
+specificity(rule):
+  +1 if platforms is set
+  +1 if locales is set
+  +1 if versions has bounds
+  +1 if rollout is set
 ```
 
-### 5. Test Rollout Distribution
-
-Verify rollouts distribute evenly:
+Rules are evaluated in descending specificity; the first rule whose criteria all match determines the value. If no rules match, the default is returned.
 
-```kotlin
-@Test
-fun `50 percent rollout distributes correctly`() {
-    val sampleSize = 1000
-    val enabled = (0 until sampleSize).count { i ->
-        val ctx = Context(..., stableId = StableId.of("user-$i"))
-        feature { Features.ROLLOUT_FLAG }
-    }
-
-    val percentage = (enabled.toDouble() / sampleSize) * 100
-    assertTrue(percentage in 48.0..52.0)  // ±2% variance
-}
+```mermaid
+flowchart TD
+  Rules["Rule set"] --> Sort["Sort by specificity (desc)"]
+  Sort --> Loop["Evaluate rules in order"]
+  Loop -->|First match| Value["Return rule value"]
+  Loop -->|No match| Default["Return default"]
+  style Value fill:#c8e6c9
+  style Default fill:#fff3cd
 ```
 
 ---
 
-## Common Patterns
+## Deterministic rollout bucketing (SHA-256)
 
-### Pattern 1: Kill Switch
+Rollouts are computed locally. The bucketing input is stable and per-flag:
 
-Emergency disable without deployment:
-
-```kotlin
-val PAYMENT_PROCESSING by boolean(default = true)
-// Can be set to false via remote JSON update
 ```
-
-### Pattern 2: A/B Test
-
-Split users 50/50:
-
-```kotlin
-val RECOMMENDATION_ALGO by string(default = "collaborative") {
-    salt("experiment-2024-q1")
-    rule { rollout { 50.0 } } returns "content-based"
-}
+input = "$stableId:$flagKey:$salt"
+hash = SHA256(input)
+percentage = (hash % 10000) / 100.0   // ["0.00, 100.00)
 ```

-### Pattern 3: Beta Program
+This yields three operational properties:
+- **Deterministic**: same inputs → same bucket
+- **Per-flag isolation**: changing one flag does not affect other flags’ buckets
+- **Salt-controlled redistribution**: changing `salt` re-buckets users for that flag

-100% for beta users, 0% for others:
-
-```kotlin
-val BETA_FEATURE by boolean<AppContext>(default = false) {
-    rule {
-        extension {
-            Evaluable.factory { ctx -> ctx.betaTester }
-        }
-    } returns true
-}
+```mermaid
+flowchart LR
+  Id[stableId"] --> In["stableId:flagKey:salt"]
+  Key["flagKey"] --> In
+  Salt["salt"] --> In
+  In --> H["SHA-256"]
+  H --> M["mod 10,000"]
+  M --> P["percentage 0.00..99.99"]
+  P --> T{< rollout % ?}
+  T -->|Yes| Enabled["In rollout"]
+  T -->|No| Disabled["Out of rollout"]
+  style Enabled fill:#c8e6c9
+  style Disabled fill:#ffcdd2
 ```
 
 ---
 
-## Next Steps
-
-**Need to evaluate flags?** See ["Evaluation"](05-evaluation.md) for evaluation methods and flow.
-
-**Want remote updates?** See ["Remote Configuration"](06-remote-config.md) for JSON serialization.
+## Next steps
 
-**Understanding the basics?** See ["Core Concepts"](03-core-concepts.md) for Features, Context, and Namespaces.
+- Understand evaluation flow and performance: ["Evaluation"](05-evaluation.md)
+- Understand the compile-time vs runtime boundary: ["Theory"](07-theory.md)
diff --git a/docs/05-evaluation.md b/docs/05-evaluation.md
index 547d85c..26b2b7a 100644
--- a/docs/05-evaluation.md
+++ b/docs/05-evaluation.md
@@ -1,243 +1,99 @@
 # Evaluation
 
-Predictable results, deterministic behavior. This guide covers evaluation methods and evaluation flow.
+Konditional evaluation is designed to be predictable:
+- **Total**: evaluation always returns a value (rule value or default).
+- **Deterministic**: the same inputs produce the same outputs.
+- **Non-null**: defaults are required, so evaluation does not return `T?`.
 
 ---
 
-## Evaluation Methods
+## `feature { }` (recommended)
 
-Evaluation is a total function: if it compiles, you always get a value back (either from a matching rule or the flag’s
-default).
-
-### feature { } - Recommended
-
-Simple evaluation within a ContextAware scope:
+Concise evaluation inside a context-aware scope:
 
 ```kotlin
-// Within a ContextAware + FeatureAware scope
 val darkMode = feature { Features.DARK_MODE }
-applyDarkMode(darkMode)  // Always non-null
+applyDarkMode(darkMode)
 ```
 
-**Use when:**
-
-- You have sensible defaults
-- Error details don't matter
-- You want the most concise API
-
-**Most common choice for production code.**
+Use this when:
+- defaults are meaningful
+- you want the smallest call-site surface
 
 ---
 
-## Evaluation Flow
-
-Understanding how evaluation works helps debug unexpected behavior.
-
-### Step-by-Step Process
+## Evaluation flow (what happens)
 
 ```mermaid
 flowchart TD
-    Start["Context Created"] --> Lookup["Registry Lookup"]
-    Lookup --> Active{Flag Active?}
-    Active -->|No| Default1["Return Default"]
-    Active -->|Yes| Rules["Get Rules<br/>Sorted by Specificity"]
-
-    Rules --> NextRule{Next Rule}
-    NextRule -->|No more| Default2["Return Default"]
-    NextRule -->|Has rule| Match{Rule<br/>Matches?}
-
-    Match -->|No| NextRule
-    Match -->|Yes| Rollout{In Rollout<br/>Bucket?}
-
-    Rollout -->|No| NextRule
-    Rollout -->|Yes| ReturnValue["Return Rule Value"]
-
-    style Start fill:#e1f5ff
-    style ReturnValue fill:#c8e6c9
-    style Default1 fill:#fff3cd
-    style Default2 fill:#fff3cd
-```
-
-### 1. Registry Lookup
-
-```kotlin
-val flag = namespace.featureFlag(Features.DARK_MODE)
+  Start["Context available"] --> Lookup["Registry lookup"]
+  Lookup --> Active{Flag active?}
+  Active -->|No| Default1["Return default"]
+  Active -->|Yes| Sort["Sort rules by specificity"]
+  Sort --> Next{Next rule?}
+  Next -->|No| Default2["Return default"]
+  Next -->|Yes| Match{All criteria match?}
+  Match -->|No| Next
+  Match -->|Yes| Roll{Rollout passes?}
+  Roll -->|No| Next
+  Roll -->|Yes| Value["Return rule value"]
+  style Default1 fill:#fff3cd
+  style Default2 fill:#fff3cd
+  style Value fill:#c8e6c9
 ```
 
-You can’t reference an undefined flag: flags are defined in code and accessed via properties, so the compiler guarantees
-you can only evaluate known flags in the correct namespace.
+### Rule matching (AND semantics)
 
-### 2. Flag Activity Check
-
-```kotlin
-if (!flag.isActive) {
-    return defaultValue
-}
-```
-
-Inactive flags always return default (kill switch behavior).
-
-### 3. Rule Iteration (by Specificity)
-
-Rules pre-sorted by specificity (highest first):
+All specified criteria must match; empty constraint sets match everything.
 
 ```kotlin
 for (rule in rulesSortedBySpecificity) {
     if (rule.matches(context)) {
-        return rule.value  // First match wins
+        return rule.value
     }
 }
+return default
 ```
 
-### 4. Rule Matching
-
-All criteria must match (AND logic):
-
-```kotlin
-// Platform check
-if (rule.platforms.isNotEmpty() && context.platform !in rule.platforms) {
-    return false
-}
+### Specificity ordering (most specific wins)
 
-// Locale check
-if (rule.locales.isNotEmpty() && context.locale !in rule.locales) {
-    return false
-}
-
-// Version check
-if (!rule.versionRange.contains(context.appVersion)) {
-    return false
-}
-
-// Custom extension
-if (!rule.extension.matches(context)) {
-    return false
-}
-```
-
-Empty constraint sets match everything (no platforms = all platforms).
-
-#### Custom Extensions
-
-Custom rule logic is evaluated via `extension { }` and receives the flag’s context type.
-
-```kotlin
-val ADVANCED_ANALYTICS by boolean<EnterpriseContext>(default = false) {
-    rule {
-        extension {
-            Evaluable.factory { ctx ->
-                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &&
-                ctx.employeeCount > 100
-            }
-        }
-    } returns true
-}
-```
-
-Because the flag is parameterized with `EnterpriseContext`, `ctx` is strongly typed in this scope.
-
-### 5. Rollout Bucketing
-
-Finally, check if user is in rollout bucket:
-
-```kotlin
-val bucket = stableBucket(flagKey, context.stableId, salt)
-val threshold = (rollout.value * 100).toInt()
-if (bucket >= threshold) {
-    return false  // Not in bucket
-}
-```
-
-### 6. Value Resolution
-
-If all checks pass, return rule's value. Otherwise, continue to next rule or return default.
+Rules are sorted by the number of criteria present (platforms/locales/versions/rollout).
+This makes “more targeted” rules win over “more general” rules.
 
 ---
 
-## Performance
-
-### Time Complexity
+## Performance model
 
-- **Registry lookup:** O(1) hash table
-- **Rule iteration:** O(n) where n = number of rules (typically < 10)
+The evaluation path is designed to be constant-time in typical usage:
+- **Registry lookup:** O(1)
+- **Rule iteration:** O(n) where n is rules per flag (typically small)
 - **Rollout bucketing:** O(1) SHA-256 hash
-- **Total:** O(n) where n is small
-
-Typical flags have 1-5 rules, so evaluation is effectively O(1).
-
-### Space Complexity
-
-- Zero allocations during evaluation
-- All data structures pre-allocated and immutable
-- No string concatenation (except bucketing hash input)
 
-**Memory per flag:** ~200-500 bytes (FlagDefinition + rules + strings)
-
-### Concurrency
-
-**Lock-free reads:** No synchronization required for evaluation.
-
-```kotlin
-// Multiple threads evaluating concurrently
-thread1: feature { Features.DARK_MODE }  // No lock
-thread2: feature { Features.DARK_MODE }  // No lock
-```
-
-**Atomic updates:** Registry uses `AtomicReference` for configuration snapshots.
-
-```kotlin
-Namespace.Global.load(newConfig)  // Atomic swap
-// Readers see either old or new, never partial
-```
-
-**Scalability:** Throughput scales linearly with CPU cores (no contention).
+Space model:
+- no allocations during evaluation
+- immutable, pre-built rule structures
 
 ---
 
-## Thread Safety
+## Concurrency model
 
-### Lock-Free Evaluation
+Evaluation is designed for concurrent reads:
+- **Lock-free reads**: evaluation does not require synchronization.
+- **Atomic updates**: configuration updates swap the active snapshot atomically (`Namespace.load`).
 
 ```kotlin
-// Safe concurrent evaluation
-val threads = (1..100).map {
-    thread {
-        repeat(1000) {
-            val value = feature { Features.DARK_MODE }
-            processValue(value)
-        }
-    }
-}
-```
-
-**How it works:**
-
-- Immutable data structures (`FlagDefinition`, rules)
-- AtomicReference for registry
-- Readers see consistent snapshot
-
-### Atomic Updates
-
-```kotlin
-// Thread 1: Updating
+// Thread 1
 Namespace.Global.load(newConfig)
 
-// Thread 2: Reading during update
-val value = feature { Features.DARK_MODE }
-// Sees old OR new, never mixed
+// Thread 2 (during update)
+val value = feature { Features.DARK_MODE } // sees old OR new, never a mixed state
 ```
 
-**Guarantees:**
-
-- Updates are atomic (all-or-nothing)
-- No torn reads
-- No race conditions
-
 ---
 
-## Testing Evaluation
+## Testing evaluation
 
-### Test Rule Matching
+### Rule matching
 
 ```kotlin
 @Test
@@ -254,22 +110,18 @@ fun `iOS users in US get dark mode`() {
 }
 ```
 
-### Test Determinism
+### Determinism
 
 ```kotlin
 @Test
 fun `evaluation is deterministic`() {
     val context = Context(...)
-
-    val results = (1..100).map {
-        feature { Features.DARK_MODE }
-    }
-
+    val results = (1..100).map { feature { Features.DARK_MODE } }
     assertTrue(results.distinct().size == 1, "Non-deterministic!")
 }
 ```
 
-### Test Rollout Distribution
+### Rollout distribution (statistical sanity check)
 
 ```kotlin
 @Test
@@ -277,94 +129,31 @@ fun `50 percent rollout distributes correctly`() {
     val sampleSize = 10_000
     val enabled = (0 until sampleSize).count { i ->
         val ctx = Context(
-            ...
+            ...,
             stableId = StableId.of(i.toString(16).padStart(32, '0'))
         )
         feature { Features.ROLLOUT_FLAG }
     }
 
     val percentage = (enabled.toDouble() / sampleSize) * 100
-    assertTrue(percentage in 48.0..52.0)  // ±2% variance
-}
-```
-
----
-
-## Best Practices
-
-### 1. Prefer feature { }
-
-For most production code:
-
-```kotlin
-// Good - simple, clear
-val enabled = feature { Features.DARK_MODE }
-```
-
-### 2. Cache Contexts
-
-Create once, reuse for multiple evaluations:
-
-```kotlin
-// Good
-val context = createUserContext(user)
-val darkMode = feature { Features.DARK_MODE }
-val apiEndpoint = feature { Config.API_ENDPOINT }
-val maxRetries = feature { Config.MAX_RETRIES }
-
-// Avoid
-createUserContext(user) // then evaluate elsewhere
-```
-
-### 3. Test with Specific Contexts
-
-Create test contexts for specific scenarios:
-
-```kotlin
-fun testContext(
-    platform: Platform = Platform.IOS,
-    locale: AppLocale = AppLocale.UNITED_STATES,
-    version: String = "1.0.0",
-    stableId: String = "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6"
-) = Context(
-    locale = locale,
-    platform = platform,
-    appVersion = Version.parse(version),
-    stableId = StableId.of(stableId)
-)
-
-@Test
-fun testTargeting() {
-    val iosContext = testContext(platform = Platform.IOS)
-    assertTrue(feature { Features.IOS_ONLY })
-
-    val androidContext = testContext(platform = Platform.ANDROID)
-    assertFalse(feature { Features.IOS_ONLY })
+    assertTrue(percentage in 48.0..52.0)
 }
 ```
 
 ---
 
-## Guarantees
+## Guarantees (and boundaries)
 
-| Aspect            | Guarantee                                          |
-|-------------------|----------------------------------------------------|
-| **Type safety**   | Return type matches flag definition (compile-time) |
-| **Determinism**   | Same inputs always produce same outputs            |
-| **Specificity**   | Most specific matching rule always wins            |
-| **Bucketing**     | SHA-256 ensures independent, stable buckets        |
-| **Performance**   | O(n) where n = rules per flag                      |
-| **Thread safety** | Lock-free reads, immutable data                    |
-| **Null safety**   | Never returns null                                 |
-
-**Core principle:** If it compiles, evaluation is correct and deterministic.
+| Aspect | Guarantee | Boundary |
+|---|---|---|
+| Type safety | return type matches definition | compile-time for statically-defined flags |
+| Non-null | evaluation never returns null | relies on required defaults |
+| Determinism | same inputs → same outputs | excludes malformed runtime JSON (see remote config) |
+| Updates | atomic swap of configuration | correctness depends on using `Namespace.load` |
 
 ---
 
-## Next Steps
-
-**Loading remote configs?** See ["Remote Configuration"](06-remote-config.md) for JSON serialization.
-
-**Building targeting rules?** See ["Targeting & Rollouts"](04-targeting-rollouts.md) for rules and specificity.
+## Next steps
 
-**Understanding the basics?** See ["Core Concepts"](03-core-concepts.md) for Features and Context.
+- Understand rollouts and bucketing inputs: ["Targeting & Rollouts"](04-targeting-rollouts.md)
+- Add runtime-validated JSON configuration: ["Remote Configuration"](06-remote-config.md)
diff --git a/docs/06-remote-config.md b/docs/06-remote-config.md
index 8b3d9d2..a1342c6 100644
--- a/docs/06-remote-config.md
+++ b/docs/06-remote-config.md
@@ -1,517 +1,139 @@
 # Remote Configuration
 
-Update flags without redeployment. Konditional provides UI-based management with RBAC or JSON-based configuration for dynamic rule updates.
+Konditional supports dynamic configuration via JSON, but treats JSON as a **trust boundary**:
+- compile-time guarantees apply to statically-defined flags and rules
+- runtime JSON is accepted only after validation (`ParseResult.Success`), otherwise rejected (`ParseResult.Failure`)
 
 ---
 
-## Why Remote Configuration?
+## The lifecycle (end-to-end)
 
-Konditional flags are defined in code (type-safe), but **rules can be updated via UI or JSON** for dynamic updates:
-
-```kotlin
-// Flags defined in code (type-safe, version-controlled)
-object Features : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val DARK_MODE by boolean(default = false)
-    val API_ENDPOINT by string(default = "https://api.example.com")
-}
-
-// Rules loaded from JSON (updatable without deployment)
-val remoteJson = fetchFromServer("/flags.json")
-when (val result = SnapshotSerializer.fromJson(remoteJson)) {
-    is ParseResult.Success -> Namespace.Global.load(result.value)
-    is ParseResult.Failure -> logger.error("Failed to load: ${result.error}")
-}
+```mermaid
+flowchart LR
+  Code["Flags defined in code"] --> Snap["SnapshotSerializer.serialize(...)"]
+  Snap --> Json["JSON snapshot"]
+  Json --> Parse["SnapshotSerializer.fromJson(json)"]
+  Parse -->|Success| Load["Namespace.load(snapshot)"]
+  Parse -->|Failure| Reject["Keep last-known-good + log"]
+  Load --> Eval["Evaluation uses active snapshot"]
+  style Load fill:#c8e6c9
+  style Reject fill:#ffcdd2
 ```
 
-**Key distinction:**
-
-- Flag **definitions** live in code (compile-time safety, version-controlled)
-- Flag **rules** can be updated via UI (RBAC-controlled) or JSON (runtime flexibility)
-
 ---
 
-## JSON Serialization
-
-### Export Configuration
+## Exporting configuration
 
 ```kotlin
-// Serialize current configuration
-val config = Namespace.Global.configuration()
-val json = SnapshotSerializer.serialize(config)
-
-// Save to file
-File("flags.json").writeText(json)
+val json = SnapshotSerializer.serialize(Namespace.Global.configuration())
 ```
 
-**Example output:**
-
-```json
-{
-  "flags": {
-    "dark_mode": {
-      "default": false,
-      "active": true,
-      "salt": "v1",
-      "rules": [
-        {
-          "platforms": ["IOS"],
-          "rollout": 50.0,
-          "value": true
-        }
-      ]
-    }
-  }
-}
-```
+Use this when you want to externalize a namespace’s current configuration state into JSON for storage or transport.
 
-### Import Configuration
+---
+
+## Loading configuration (validated boundary)
 
 ```kotlin
-// Load from file
 val json = File("flags.json").readText()
-
 when (val result = SnapshotSerializer.fromJson(json)) {
-    is ParseResult.Success -> {
-        Namespace.Global.load(result.value)
-        logger.info("Configuration loaded successfully")
-    }
-    is ParseResult.Failure -> {
-        logger.error("Parse failed: ${result.error}")
-        // Keep existing configuration
-    }
-}
-```
-
-### Patch Updates
-
-Apply incremental changes without full replacement:
-
-```kotlin
-val currentConfig = Namespace.Global.configuration()
-
-// Patch JSON contains only changed flags
-val patchJson = """
-{
-  "dark_mode": {
-    "rules": [{
-      "platforms": ["IOS", "ANDROID"],
-      "rollout": 100.0,
-      "value": true
-    }]
-  }
-}
-"""
-
-when (val result = SnapshotSerializer.applyPatchJson(currentConfig, patchJson)) {
     is ParseResult.Success -> Namespace.Global.load(result.value)
-    is ParseResult.Failure -> logger.error("Patch failed: ${result.error}")
+    is ParseResult.Failure -> handleError(result.error)
 }
 ```
 
-**Benefits:**
-
-- Smaller payloads
-- Partial updates (other flags unchanged)
-- Reduced risk (only changed flags affected)
+The contract is explicit:
+- **Success** means you have a type-correct, internally consistent snapshot representation (validated at the boundary).
+- **Failure** means the payload is rejected before it can affect evaluation.
 
 ---
 
-## Storage Patterns
-
-### Pattern 1: File-Based
-
-Store configurations as local files:
-
-```kotlin
-class FileConfigLoader(private val filePath: String) {
-    fun load(): Configuration? {
-        val file = File(filePath)
-        if (!file.exists()) return null
-
-        val json = file.readText()
-        return when (val result = SnapshotSerializer.fromJson(json)) {
-            is ParseResult.Success -> result.value
-            is ParseResult.Failure -> {
-                logger.error("Failed to parse $filePath: ${result.error}")
-                null
-            }
-        }
-    }
-
-    fun save(config: Configuration) {
-        val json = SnapshotSerializer.serialize(config)
-        File(filePath).writeText(json)
-    }
-}
-
-// Usage
-val loader = FileConfigLoader("/etc/app/flags.json")
-loader.load()?.let { Namespace.Global.load(it) }
-```
-
-**Use cases:**
-
-- Desktop applications
-- Server-side with local config files
-- Docker containers with mounted volumes
-
-### Pattern 2: Database
-
-Store in database for multi-instance consistency:
-
-```kotlin
-class DbConfigLoader(private val db: Database) {
-    fun load(namespace: String): Configuration? {
-        val json = db.query("SELECT config FROM flag_configs WHERE namespace = ?", namespace)
-            .firstOrNull()
-            ?: return null
-
-        return when (val result = SnapshotSerializer.fromJson(json)) {
-            is ParseResult.Success -> result.value
-            is ParseResult.Failure -> null
-        }
-    }
-
-    fun save(namespace: String, config: Configuration) {
-        val json = SnapshotSerializer.serialize(config)
-        db.execute(
-            "INSERT INTO flag_configs (namespace, config) VALUES (?, ?) ON CONFLICT (namespace) DO UPDATE SET config = ?",
-            namespace, json, json
-        )
-    }
-}
-```
-
-**Use cases:**
-
-- Multi-instance servers (shared config)
-- Audit trail (store updates in DB)
-- Versioning (store historical configs)
-
-### Pattern 3: Cloud Storage
-
-Fetch from S3, CloudFront CDN, etc.:
+## Incremental updates via patching
 
 ```kotlin
-class CloudConfigLoader(private val httpClient: HttpClient) {
-    suspend fun load(url: String): Configuration? {
-        val json = try {
-            httpClient.get(url).bodyAsText()
-        } catch (e: Exception) {
-            logger.error("Failed to fetch $url", e)
-            return null
-        }
-
-        return when (val result = SnapshotSerializer.fromJson(json)) {
-            is ParseResult.Success -> result.value
-            is ParseResult.Failure -> null
-        }
-    }
-}
-
-// Usage
-val loader = CloudConfigLoader(client)
-launch {
-    val config = loader.load("https://cdn.example.com/flags.json")
-    config?.let { Namespace.Global.load(it) }
+when (val result = SnapshotSerializer.applyPatchJson(currentConfig, patchJson)) {
+    is ParseResult.Success -> Namespace.Global.load(result.value)
+    is ParseResult.Failure -> handleError(result.error)
 }
 ```
 
-**Use cases:**
-
-- Mobile apps (fetch on launch)
-- Edge computing (CDN-backed configs)
-- Global deployments (region-specific endpoints)
+This supports applying incremental JSON updates, then atomically swapping the active configuration via `Namespace.load`.
 
 ---
 
-## Update Strategies
-
-### Strategy 1: Polling
-
-Periodically check for updates:
-
-```kotlin
-class PollingConfigUpdater(
-    private val loader: CloudConfigLoader,
-    private val url: String,
-    private val intervalMs: Long = 60_000  // 1 minute
-) {
-    fun start() {
-        timer(period = intervalMs) {
-            runBlocking {
-                val config = loader.load(url)
-                config?.let {
-                    Namespace.Global.load(it)
-                    logger.info("Configuration updated")
-                }
-            }
-        }
-    }
-}
-
-// Usage
-val updater = PollingConfigUpdater(loader, "https://api.example.com/flags.json")
-updater.start()
-```
-
-**Pros:** Simple, reliable
-**Cons:** Latency (up to poll interval), unnecessary requests
-
-### Strategy 2: Streaming/Push
-
-Server pushes updates to clients:
+## Error handling model (`ParseResult`)
 
-```kotlin
-class StreamingConfigUpdater(private val wsClient: WebSocketClient) {
-    fun connect(url: String) {
-        wsClient.connect(url) { message ->
-            when (val result = SnapshotSerializer.fromJson(message)) {
-                is ParseResult.Success -> {
-                    Namespace.Global.load(result.value)
-                    logger.info("Configuration updated via WebSocket")
-                }
-                is ParseResult.Failure -> logger.error("Invalid config: ${result.error}")
-            }
-        }
-    }
-}
-```
-
-**Pros:** Instant updates, efficient
-**Cons:** More complex, requires WebSocket infrastructure
-
-### Strategy 3: On-Demand
-
-Load on app launch or user action:
+Remote configuration is designed to force explicit handling of invalid input:
 
 ```kotlin
-suspend fun updateConfiguration() {
-    val json = httpClient.get("https://api.example.com/flags.json").bodyAsText()
-    when (val result = SnapshotSerializer.fromJson(json)) {
-        is ParseResult.Success -> {
-            Namespace.Global.load(result.value)
-            showToast("Configuration updated")
-        }
-        is ParseResult.Failure -> showError("Update failed")
-    }
-}
-
-// Usage
-// On app launch
-lifecycleScope.launch {
-    updateConfiguration()
-}
-
-// Or on button click
-button.setOnClickListener {
-    lifecycleScope.launch { updateConfiguration() }
+sealed class ParseResult<out T> {
+    data class Success<T>(val value: T) : ParseResult<T>()
+    data class Failure(val error: ParseError) : ParseResult<Nothing>()
 }
 ```
 
-**Pros:** User-controlled, simple
-**Cons:** Requires user action
+Operationally, treat failures as non-fatal: keep last-known-good configuration, log for alerting, and retry on the next update.
 
 ---
 
-## DSL Quick Reference
+## Hot-reload semantics (atomicity)
 
-### Boolean Flags
+`Namespace.load(newConfiguration)` applies updates with atomic replacement semantics:
+- readers see either the old snapshot or the new snapshot
+- readers never see a partially-applied configuration
 
-```kotlin
-val FLAG by boolean(default = false) {
-    salt("v1")
-    active { true }
-    rule {
-        platforms(Platform.IOS)
-        locales(AppLocale.UNITED_STATES)
-        versions { min(2, 0, 0) }
-        rollout { 50.0 }
-        note("iOS US users, v2+, 50%")
-    } returns true
-}
-```
-
-### String Flags
-
-```kotlin
-val CONFIG by string(default = "default") {
-    rule { platforms(Platform.IOS) } returns "ios-value"
-    rule { platforms(Platform.ANDROID) } returns "android-value"
-}
-```
-
-### Integer/Double Flags
-
-```kotlin
-val MAX_RETRIES by int(default = 3) {
-    rule { platforms(Platform.WEB) } returns 5
-}
-
-val TIMEOUT by double(default = 30.0) {
-    rule { platforms(Platform.MOBILE) } returns 60.0
-}
-```
-
-### Custom Logic
-
-```kotlin
-val PREMIUM by boolean<EnterpriseContext>(default = false) {
-    rule {
-        extension {
-            Evaluable.factory { ctx ->
-                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE
-            }
-        }
-    } returns true
-}
-```
+This aligns with the evaluation model documented in ["Evaluation"](05-evaluation.md).
 
 ---
 
-## Best Practices
+## What’s validated (and what is not)
 
-### 1. Validate After Loading
+Validated at the boundary:
+- JSON syntax validity
+- schema/structure validity
+- value type checking against declared feature types
 
-Always check parse results:
+Not validated by the type system:
+- semantic correctness (e.g., whether 50% is the intended rollout)
+- business correctness (e.g., whether the targeted segment is correct)
 
-```kotlin
-when (val result = SnapshotSerializer.fromJson(json)) {
-    is ParseResult.Success -> {
-        // Optionally validate business rules
-        if (validateConfig(result.value)) {
-            Namespace.Global.load(result.value)
-        } else {
-            logger.error("Configuration failed validation")
-        }
-    }
-    is ParseResult.Failure -> logger.error("Parse failed: ${result.error}")
-}
-```
+---
 
-### 2. Cache Configurations
+## Integration patterns
 
-Avoid repeated network calls:
+### Polling
 
 ```kotlin
-class CachedConfigLoader(
-    private val remoteLoader: CloudConfigLoader,
-    private val cacheFile: File
-) {
-    suspend fun load(url: String): Configuration? {
-        // Try cache first
-        if (cacheFile.exists()) {
-            val cached = loadFromFile(cacheFile)
-            if (cached != null) return cached
-        }
-
-        // Fetch from remote
-        val config = remoteLoader.load(url)
-        config?.let { saveToFile(it, cacheFile) }
-        return config
+while (running) {
+    val json = fetchFromServer()
+    when (val result = SnapshotSerializer.fromJson(json)) {
+        is ParseResult.Success -> Namespace.Global.load(result.value)
+        is ParseResult.Failure -> log.error("Config parse failed: ${result.error}")
     }
+    delay(pollInterval)
 }
 ```
 
-### 3. Handle Load Failures Gracefully
-
-Keep existing configuration on failure:
+### Push-based (streams)
 
 ```kotlin
-val currentConfig = Namespace.Global.configuration()  // Backup
-
-when (val result = loadRemoteConfig()) {
-    is ParseResult.Success -> Namespace.Global.load(result.value)
-    is ParseResult.Failure -> {
-        logger.error("Failed to load remote config, keeping current")
-        // currentConfig still in effect
+configStream.collect { json ->
+    when (val result = SnapshotSerializer.fromJson(json)) {
+        is ParseResult.Success -> Namespace.Global.load(result.value)
+        is ParseResult.Failure -> log.error("Config parse failed: ${result.error}")
     }
 }
 ```
 
-### 4. Version Your Configurations
-
-Track changes over time:
-
-```json
-{
-  "version": "2024-01-15T10:30:00Z",
-  "flags": { ... }
-}
-```
-
-### 5. Use Patches for Incremental Updates
-
-Send only changes, not full configs:
-
-```kotlin
-// Small patch JSON
-val patch = """{"dark_mode": {"rules": ["..."]}}"""
-
-// Apply to current config
-SnapshotSerializer.applyPatchJson(currentConfig, patch)
-```
-
 ---
 
-## Common Patterns
-
-### Pattern: Kill Switch
-
-Remotely disable feature without deployment:
-
-```json
-{
-  "payment_processing": {
-    "active": false,
-    "default": false
-  }
-}
-```
-
-### Pattern: Gradual Rollout
-
-Increase rollout percentage over time:
+## Where Kontracts fits
 
-```json
-// Day 1
-{"new_feature": {"rules": [{"rollout": 10.0, "value": true}]}}
-
-// Day 3
-{"new_feature": {"rules": [{"rollout": 50.0, "value": true}]}}
-
-// Day 7
-{"new_feature": {"rules": [{"rollout": 100.0, "value": true}]}}
-```
-
-### Pattern: Platform-Specific Config
-
-Different settings per platform:
-
-```json
-{
-  "api_endpoint": {
-    "default": "https://api.example.com",
-    "rules": [
-      {
-        "platforms": ["IOS"],
-        "value": "https://api-ios.example.com"
-      },
-      {
-        "platforms": ["ANDROID"],
-        "value": "https://api-android.example.com"
-      }
-    ]
-  }
-}
-```
+Konditional uses Kontracts (a standalone, zero-dependency JSON Schema DSL) for schema validation of configuration payloads.
 
 ---
 
-## Next Steps
-
-**Just getting started?** See ["Getting Started"](01-getting-started.md) for your first flag.
-
-**Need advanced targeting?** See ["Targeting & Rollouts"](04-targeting-rollouts.md) for rules and specificity.
+## Next steps
 
-**Understanding evaluation?** See ["Evaluation"](05-evaluation.md) for evaluation methods and flow.
+- Understand the “if it compiles” claim boundary: ["Theory"](07-theory.md)
+- Understand bucketing determinism inputs: ["Targeting & Rollouts"](04-targeting-rollouts.md)
diff --git a/docs/07-theory.md b/docs/07-theory.md
index 8363dce..6b01f5a 100644
--- a/docs/07-theory.md
+++ b/docs/07-theory.md
@@ -1,128 +1,110 @@
-# Konditional: Type Safety Theory & Justification
-
-**A Technical Brief on Compile-Time Guarantees in Feature Flag Systems**
-
------
-
-## Summary
-
-Konditional makes a bold claim: *“If your code compiles, your flags work.”* 
-
-This brief rigorously examines that assertion, delineating exactly which guarantees are enforced at compile-time, which are enforced at design-time via tooling, and which necessarily remain runtime concerns. The goal is not to prove Konditional is “perfectly safe,” but to provide a precise map of where trust is established and where vigilance remains necessary.
+# Theory: What “If it compiles, it works” means
+
+Konditional’s core claim is intentionally narrow and testable: **for statically-defined flags and rules, the compiler enforces type correctness and evaluation is non-null**. When configuration crosses the JSON boundary, correctness is established via validation and explicit error handling (`ParseResult`), not via compile-time guarantees.
+
+```mermaid
+flowchart LR
+  Code["Flags + rules defined in code"] --> CT["Compile-time guarantees"]
+  CT --> Eval["Evaluation returns typed, non-null values"]
+  Json["JSON payload"] --> RT["Runtime validation boundary"]
+  RT -->|Success| Load["Namespace.load(snapshot)"]
+  RT -->|Failure| Reject["Reject before evaluation"]
+  style CT fill:#e1f5ff
+  style RT fill:#fff3cd
+  style Reject fill:#ffcdd2
+```
 
------
+---
 
-## The Problem Konditional Solves
+## The three failures of stringly-typed flags
 
-Traditional feature flag systems are stringly-typed: flags are identified by string keys and values are retrieved via type-casting APIs. This architecture introduces three categories of failure:
+Traditional flag systems are stringly-typed: a string key selects a value and the caller chooses a typed getter. That architecture introduces three classes of runtime failure:
 
-1. **Key mismatch**: A typo in `"dark_mode"` vs `"darkMode"` silently returns a default or null value.
-1. **Type mismatch**: Retrieving a boolean flag as a string succeeds syntactically but produces incorrect behavior.
-1. **Null propagation**: Missing configurations or evaluation failures surface as null values that propagate through business logic.
+1. **Key mismatch**: `"dark_mode"` vs `"darkMode"` silently returns a default or null.
+2. **Type mismatch**: retrieving a boolean flag as a string is syntactically valid but semantically wrong.
+3. **Null propagation**: missing configurations surface as `null` and leak into business logic.
 
-These failures share a common characteristic: they are *syntactically valid* at compile-time but *semantically incorrect* at runtime. Konditional’s design targets this gap.
+Konditional targets this gap: prevent categories of runtime failure by moving key/type binding into the type system.
 
------
+---
 
-## Mechanism 1: Property Delegation as Type Binding
+## Mechanism 1: Property delegation binds identity + type
 
-Konditional defines features as delegated properties within a `FeatureContainer`:
+Flags are delegated properties in a `FeatureContainer`:
 
 ```kotlin
 object AppFeatures : FeatureContainer<Namespace.Global>(Namespace.Global) {
-    val darkMode by boolean(default = false) { /* rules */ }
-    val timeout by double(default = 30.0) { /* rules */ }
-    val maxRetries by int(default = 3) { /* rules */ }
+    val darkMode by boolean(default = false)
+    val timeout by double(default = 30.0)
+    val maxRetries by int(default = 3)
 }
 ```
 
-The delegation functions (`boolean()`, `double()`, `int()`, `string()`, `jsonObject<T>()`) are generic factory functions that return property delegates parameterized by the value type. When the Kotlin compiler processes `val darkMode by boolean(...)`, it infers:
+Because the delegate (`boolean`, `double`, `int`, …) determines the type parameter, the compiler knows the declared type at the definition site and carries it forward.
 
-- The property `darkMode` has type `Feature<Boolean>` (or an equivalent delegate type).
-- Any access to `darkMode` within the type system carries the `Boolean` type parameter.
+**Guarantee**: the declared type of a feature is statically known and cannot drift without code changes the compiler re-checks.
 
-**Guarantee**: The declared type of a feature is statically known and cannot drift. If `darkMode` is defined via `boolean()`, no amount of refactoring can silently change its type without explicit code modification that the compiler will re-evaluate.
+---
 
------
+## Mechanism 2: Rule return types are constrained
 
-## Mechanism 2: Type-Constrained Rule Returns
-
-The rule DSL enforces that `returns` clauses match the feature’s declared type:
+Rules must return a value of the feature’s declared type:
 
 ```kotlin
 val timeout by double(default = 30.0) {
-    rule {
-        platforms(Platform.ANDROID)
-    } returns 45.0  // Must be Double
+    rule { platforms(Platform.ANDROID) } returns 45.0
 }
 ```
 
-This is enforced via generic constraints on the rule builder. The `returns` function is typed to accept only values matching the feature’s type parameter. Attempting to return a `String` from a `Double` feature results in a compilation error—not a runtime type-casting failure.
-
-**Guarantee**: Rule return values are type-checked at compile-time. A rule cannot produce a value incompatible with its feature’s declared type.
+**Guarantee**: statically-defined rule return values are type-checked at compile time.
 
-**Boundary condition**: This guarantee applies to the statically-defined rules in code. Dynamically loaded rules from JSON (remote configuration) operate under different constraints discussed below.
+Boundary: this applies to rules defined in code; JSON-loaded configurations are validated at the parse boundary.
 
------
+---
 
-## Mechanism 3: Evaluation Site Type Propagation
+## Mechanism 3: Evaluation site preserves the concrete type
 
-The evaluation entry point preserves type information through the call site:
+Evaluation preserves the type parameter from definition to usage:
 
 ```kotlin
 val isDarkMode: Boolean = feature { AppFeatures.darkMode }
 val timeout: Double = feature { AppFeatures.timeout }
 ```
 
-The `feature { }` function is a generic function that captures the type parameter from the accessed property. The return type is not `Any` requiring a cast—it is the concrete type declared at definition. This means:
+**Guarantee**: no casts are required at call sites; incompatible assignments are compile errors.
 
-- Assigning the result to an incompatible type is a compile error.
-- IDE autocomplete correctly shows the return type.
-- Refactoring tools propagate type changes correctly.
+---
 
-**Guarantee**: The call site type matches the definition site type with no manual casting required.
+## Mechanism 4: Required defaults eliminate nulls
 
------
-
-## Mechanism 4: Required Defaults as Non-Null Enforcement
-
-Every feature definition requires a default value:
+Every feature requires a default:
 
 ```kotlin
-val darkMode by boolean(default = false)  // default is mandatory
+val darkMode by boolean(default = false)
 ```
 
-This default is used when no rules match the evaluation context. Because the default is required and typed, the evaluation function can guarantee a non-null return:
-
-```kotlin
-// Simplified signature (illustrative)
-fun <T : Any> feature(accessor: () -> Feature<T>): T
-```
-
-The return type is `T`, not `T?`. The default value ensures that even in the worst case—no rules match, configuration is empty, context is unusual—a valid value of the correct type is returned.
-
-**Guarantee**: Evaluation never returns null. Every call to `feature { }` produces a value of the declared type.
+**Guarantee**: evaluation is total—if no rules match, the default is returned—and does not return null.
 
------
+---
 
-## Mechanism 5: Namespace Isolation via Type Binding
+## Mechanism 5: Namespace isolation is structural
 
-`FeatureContainer` is parameterized by its namespace:
+Containers are bound to a namespace type, and namespaces have separate registries:
 
 ```kotlin
-object AuthFeatures : FeatureContainer<Namespace.Authentication>(Namespace.Authentication)
-object PaymentFeatures : FeatureContainer<Namespace.Payments>(Namespace.Payments)
+object AuthFeatures : FeatureContainer<Namespace.Authentication>(Namespace.Authentication) { ... }
+object PaymentFeatures : FeatureContainer<Namespace.Payments>(Namespace.Payments) { ... }
 ```
 
-This type binding means features are registered to their namespace at the type level. Cross-namespace collisions are not merely unlikely—they are structurally impossible because the registries are distinct objects accessed through typed containers.
+**Guarantee**: feature key collisions across namespaces cannot occur (separate registries bound at the type level).
 
-**Guarantee**: Feature key collisions across namespaces cannot occur.
+Boundary: defining conflicting keys within the same namespace is a design error that can be detected at runtime during registration.
 
------
+---
 
-## The Trust Boundary: Where Compile-Time Guarantees End
+## The trust boundary: runtime JSON
 
-The guarantees above apply to *statically defined* configurations. Konditional also supports *dynamic configuration* via JSON loading:
+When configuration is loaded from JSON, compile-time guarantees necessarily end. Konditional establishes correctness at the boundary:
 
 ```kotlin
 val json = File("flags.json").readText()
@@ -132,60 +114,27 @@ when (val result = SnapshotSerializer.fromJson(json)) {
 }
 ```
 
-At this boundary, compile-time guarantees necessarily yield to runtime validation. The system addresses this via:
-
-1. **Schema validation**: The deserializer validates that JSON structure conforms to expected schema.
-1. **Type checking**: Values in JSON are checked against the declared types of registered features.
-1. **Result types**: `ParseResult.Success | ParseResult.Failure` forces callers to handle validation failures explicitly.
-
-**Critical distinction**: A JSON payload that passes `fromJson` validation will produce type-correct configurations. The guarantee is not “JSON is always valid” but rather “invalid JSON is detected and rejected before it can affect evaluation.” This is the *parse-don’t-validate* pattern—transforming unstructured external data into typed internal structures with validation at the boundary.
-
-**What can still go wrong**:
-
-- A JSON payload could define a feature key that doesn’t exist in code (typically ignored or logged).
-- A JSON payload could be syntactically valid but semantically incorrect (wrong rollout percentage, inverted boolean logic).
-- The system consuming JSON must correctly handle `ParseResult.Failure`.
-
-These are *semantic* errors in configuration authoring, not *type* errors that the compiler could catch.
-
------
-
-## Addressing Common Counterarguments
-
-### “What about reflection-based bypass?”
-
-Kotlin’s type system can be circumvented via reflection. However, this is true of *all* compile-time type systems in JVM languages. The guarantee is: *if you use the public API as designed, types are enforced.* Deliberately subverting the type system via reflection is outside the threat model.
-
-### “What about `jsonObject<T>()` custom types?”
-
-Custom types use Moshi for serialization. The type parameter `T` is preserved through reification, and Moshi adapters enforce type correctness during deserialization. However, if a custom `T` has mutable state or complex invariants beyond JSON structure, those invariants are the responsibility of the type’s design, not Konditional’s.
-
-### “What if I define the same feature name in two containers?”
-
-Features are scoped to their `FeatureContainer` instance, which is bound to a namespace. Two containers in different namespaces can have identically-named properties because they exist in separate registries. Two containers in the *same* namespace would create a conflict—this is a design error that would manifest at runtime during registration, not at compile time. A lint rule or startup validation can catch this.
-
------
-
-## Summary of Guarantees
+The guarantee is qualified:
+- **Guaranteed**: invalid JSON is detected and rejected before it can affect evaluation.
+- **Not guaranteed**: semantic correctness of the configuration (rollout percentage, targeting intent, business correctness).
 
-|Claim                          |Guarantee Level        |Mechanism                             |
-|-------------------------------|-----------------------|--------------------------------------|
-|No typos in flag keys          |**Compile-time**       |Property access, not strings          |
-|Return type matches declaration|**Compile-time**       |Generic type propagation              |
-|Rule return types are correct  |**Compile-time**       |Constrained rule builder              |
-|Evaluation is never null       |**Compile-time**       |Required defaults, non-nullable return|
-|Namespace isolation            |**Compile-time**       |Type-parameterized containers         |
-|Remote config type safety      |**Runtime (validated)**|Parse-don’t-validate with Result types|
-|Semantic correctness of configs|**Not guaranteed**     |Human/process responsibility          |
+---
 
------
+## Summary: what is guaranteed vs what is not
 
-## Conclusion
+| Claim | Guarantee level | Mechanism |
+|---|---|---|
+| No typos in flag keys | Compile-time | property access, not strings |
+| Return type matches definition | Compile-time | generic type propagation |
+| Rule return types are correct | Compile-time | constrained rule DSL |
+| Evaluation is never null | Compile-time | required defaults |
+| Namespace isolation | Compile-time | type-bound containers + separate registries |
+| Remote config type safety | Runtime (validated boundary) | `ParseResult.Success` / `Failure` |
+| Semantic correctness of configs | Not guaranteed | human/process responsibility |
 
-Konditional’s type safety is not magic—it is the systematic application of Kotlin’s type system to eliminate categories of runtime failure. By using property delegation, generic constraints, required defaults, and typed namespaces, the library ensures that correctly-compiled code cannot suffer from key typos, type mismatches, or null propagation in flag evaluation.
+---
 
-The boundary of these guarantees is clearly defined: statically defined configurations are compile-time safe; dynamically loaded configurations are runtime-validated with explicit error handling. Within this boundary, the claim holds: *if it compiles, it works.*
+## Next steps
 
-What remains the responsibility of the developer is *semantic* correctness—ensuring that the right rules target the right users with the right values. No type system can verify business logic. But Konditional ensures that the *mechanics* of flag definition and evaluation are structurally sound, freeing developers to focus on the decisions that matter.
-@amichne
-Comment
+- See the runtime boundary mechanics: ["Remote Configuration"](06-remote-config.md)
+- See deterministic behavior and concurrency claims in practice: ["Evaluation"](05-evaluation.md)
