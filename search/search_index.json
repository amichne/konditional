{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Konditional","text":"<p>Type-safe, deterministic feature flags for Kotlin</p> <p>Get Started View on GitHub</p>"},{"location":"#features","title":"Features","text":"<p>Type-Safe: Leverage Kotlin's type system for compile-time safety. No string-based lookups, no runtime casting.</p> <p>Deterministic: SHA-256 based bucketing ensures consistent user experiences across sessions.</p> <p>Parse, Don't Validate: Structured error handling with <code>ParseResult&lt;T&gt;</code> instead of exceptions.</p> <p>Composable: Extensible evaluation logic through <code>Evaluable&lt;C&gt;</code> abstraction.</p> <p>Serializable: Export and import flag configurations with type-safe JSON serialization.</p> <p>Flexible: Support for version ranges, custom types, custom contexts, and complex targeting rules.</p>"},{"location":"advanced/architecture/","title":"Architecture Overview","text":"<p>This document describes the high-level architecture of Konditional and how its core components work together to provide type-safe, deterministic feature flag evaluation.</p>"},{"location":"advanced/architecture/#type-hierarchy","title":"Type Hierarchy","text":"<pre><code>classDiagram\n    class Conditional~S,C~ {\n        &lt;&gt;\n        +key: String\n        +registry: FlagRegistry\n    }\n\n    class Context {\n        &lt;&gt;\n        +locale: AppLocale\n        +platform: Platform\n        +appVersion: Version\n        +stableId: StableId\n    }\n\n    class FlagRegistry {\n        &lt;&gt;\n        +load(config: Konfig)\n        +update(patch: KonfigPatch)\n        +featureFlag(key): FeatureFlag?\n        +allFlags(): Map\n    }\n\n    class FeatureFlag~S,C~ {\n        &lt;&gt;\n        +defaultValue: S\n        +isActive: Boolean\n        +conditional: Conditional\n        +values: List~ConditionalValue~\n        +salt: String\n    }\n\n    class Rule~C~ {\n        +rollout: Rollout\n        +note: String?\n        +baseEvaluable: BaseEvaluable\n        +extension: Evaluable\n        +matches(context): Boolean\n        +specificity(): Int\n    }\n\n    class Evaluable~C~ {\n        &lt;&gt;\n        +matches(context): Boolean\n        +specificity(): Int\n    }\n\n    class ConditionalValue~S,C~ {\n        +rule: Rule\n        +value: S\n    }\n\n    class BaseEvaluable~C~ {\n        +locales: Set~AppLocale~\n        +platforms: Set~Platform~\n        +versionRange: VersionRange\n    }\n\n    Conditional --&gt; FlagRegistry : uses\n    FlagRegistry --&gt; FeatureFlag : stores\n    FeatureFlag --&gt; ConditionalValue : contains\n    ConditionalValue --&gt; Rule : has\n    Rule --&gt; Evaluable : extends\n    Evaluable &lt;|-- Rule\n    Evaluable &lt;|-- BaseEvaluable\n    Rule --&gt; BaseEvaluable : has\n\n    class ParseResult~T~ {\n        &lt;&gt;\n    }\n\n    class Success~T~ {\n        +value: T\n    }\n\n    class Failure {\n        +error: ParseError\n    }\n\n    ParseResult &lt;|-- Success\n    ParseResult &lt;|-- Failure"},{"location":"advanced/architecture/#core-concepts","title":"Core Concepts","text":""},{"location":"advanced/architecture/#1-conditional","title":"1. Conditional\n<p><code>Conditional&lt;S : Any, C : Context&gt;</code> is the central abstraction representing a feature flag or configuration value.</p>\n<ul>\n<li>S: The value type returned when evaluating this conditional (e.g., <code>Boolean</code>, <code>String</code>, custom types)</li>\n<li>C: The context type used for evaluation (e.g., <code>Context</code>, <code>EnterpriseContext</code>)</li>\n</ul>\n<pre><code>interface Conditional&lt;S : Any, C : Context&gt; {\n    val key: String\n    val registry: FlagRegistry\n}\n</code></pre>\n<p>Typically implemented as an enum for convenience:</p>\n<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_UI(\"new_ui\");\n\n    override val registry = FlagRegistry\n}\n</code></pre>\n<p>Note: The <code>with</code> method was removed in recent versions. Use the <code>ConfigBuilder</code> DSL instead for flag configuration.</p>","text":""},{"location":"advanced/architecture/#2-context","title":"2. Context\n<p><code>Context</code> defines what information is available for rule evaluation. The base interface provides:</p>\n<ul>\n<li><code>locale</code>: Application locale</li>\n<li><code>platform</code>: Platform (iOS, Android, Web)</li>\n<li><code>appVersion</code>: Semantic version</li>\n<li><code>stableId</code>: Unique identifier for deterministic bucketing</li>\n</ul>\n<p>You can extend this interface with your own fields:</p>\n<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n) : Context\n</code></pre>","text":""},{"location":"advanced/architecture/#3-featureflag","title":"3. FeatureFlag\n<p><code>FeatureFlag&lt;S : Any, C : Context&gt;</code> (sealed class) contains the evaluation logic for a conditional:</p>\n<ul>\n<li>conditional: Reference to the <code>Conditional&lt;S, C&gt;</code> this flag evaluates</li>\n<li>values: List of <code>ConditionalValue&lt;S, C&gt;</code> (rule \u2192 value mappings)</li>\n<li>defaultValue: Value returned when no rules match</li>\n<li>isActive: Whether the flag is enabled (if false, always returns default)</li>\n<li>salt: String used in hash function for bucketing independence</li>\n</ul>\n<pre><code>sealed class FeatureFlag&lt;S : Any, C : Context&gt;(\n    val defaultValue: S,\n    val isActive: Boolean,\n    val conditional: Conditional&lt;S, C&gt;,\n    val values: List&lt;ConditionalValue&lt;S, C&gt;&gt;,\n    val salt: String = \"v1\"\n)\n</code></pre>\n<p>Evaluation Logic:\n1. If <code>isActive</code> is false, return <code>defaultValue</code>\n2. Sort <code>values</code> by rule specificity (descending)\n3. Find first rule that matches the context\n4. Check if user is in the eligible bucket for that rule's rollout percentage\n5. Return the associated value, or default if no match</p>\n<p>Implementation: The concrete implementation is <code>FlagDefinition&lt;S, C&gt;</code> (internal/package-private).</p>","text":""},{"location":"advanced/architecture/#4-evaluable-base-abstraction","title":"4. Evaluable (Base Abstraction)\n<p><code>Evaluable&lt;C : Context&gt;</code> is the foundation for composable rule evaluation:</p>\n<pre><code>abstract class Evaluable&lt;C : Context&gt; {\n    internal open fun matches(context: C): Boolean = true\n    internal open fun specificity(): Int = 0\n}\n</code></pre>\n<p>Purpose: Provides a composable abstraction for rule evaluation logic that can be combined and extended.</p>\n<p>Key Features:\n- Composability: Multiple Evaluables can be composed together\n- Default behavior: Returns true (matches all) with 0 specificity\n- Extension point: Subclasses override to add custom matching logic</p>","text":""},{"location":"advanced/architecture/#5-baseevaluable","title":"5. BaseEvaluable\n<p><code>BaseEvaluable&lt;C : Context&gt;</code> encapsulates standard client targeting logic:</p>\n<pre><code>data class BaseEvaluable&lt;C : Context&gt;(\n    val locales: Set&lt;AppLocale&gt; = emptySet(),\n    val platforms: Set&lt;Platform&gt; = emptySet(),\n    val versionRange: VersionRange = Unbounded,\n) : Evaluable&lt;C&gt;()\n</code></pre>\n<p>Matching: A rule matches if ALL specified constraints are satisfied:\n- If <code>locales</code> is empty, any locale matches; otherwise context.locale must be in the set\n- If <code>platforms</code> is empty, any platform matches; otherwise context.platform must be in the set\n- If <code>versionRange</code> is unbounded, any version matches; otherwise context.appVersion must be in range</p>\n<p>Specificity: Calculated as:\n<pre><code>(if (locales.isNotEmpty()) 1 else 0) +\n(if (platforms.isNotEmpty()) 1 else 0) +\n(if (versionRange != Unbounded) 1 else 0)\n</code></pre></p>\n<p>Ranges from 0 (no constraints) to 3 (all constraints specified).</p>","text":""},{"location":"advanced/architecture/#6-rule-composable-implementation","title":"6. Rule (Composable Implementation)\n<p><code>Rule&lt;C : Context&gt;</code> composes standard targeting with extensible evaluation:</p>\n<pre><code>data class Rule&lt;C : Context&gt;(\n    val rollout: Rollout = Rollout.of(100.0),\n    val note: String? = null,\n    val baseEvaluable: BaseEvaluable&lt;C&gt; = BaseEvaluable(),\n    val extension: Evaluable&lt;C&gt; = object : Evaluable&lt;C&gt;() {},\n) : Evaluable&lt;C&gt;()\n</code></pre>\n<p>Composition Architecture:\n- baseEvaluable: Handles standard locale, platform, and version targeting\n- extension: Allows custom domain-specific evaluation logic\n- Both must match for the rule to match: <code>baseEvaluable.matches(context) &amp;&amp; extension.matches(context)</code>\n- Total specificity is the sum: <code>baseEvaluable.specificity() + extension.specificity()</code></p>\n<p>DSL Constructor: The <code>RuleBuilder</code> DSL provides a more convenient way to create rules:\n<pre><code>rule {\n    locales(AppLocale.EN_US)\n    platforms(Platform.IOS)\n    versions { min(2, 0) }\n    rollout = Rollout.of(50.0)\n    note(\"iOS US users on v2.0+\")\n} implies true\n</code></pre></p>\n<p>This creates a <code>BaseEvaluable</code> internally with the specified constraints.</p>","text":""},{"location":"advanced/architecture/#7-conditionalvalue","title":"7. ConditionalValue\n<p><code>ConditionalValue&lt;S : Any, C : Context&gt;</code> maps a rule to its output value:</p>\n<pre><code>data class ConditionalValue&lt;S : Any, C : Context&gt;(\n    val rule: Rule&lt;C&gt;,\n    val value: S\n)\n</code></pre>\n<p>Created using the <code>implies</code> infix operator in the DSL:</p>\n<pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(50.0)\n} implies true\n</code></pre>","text":""},{"location":"advanced/architecture/#8-flagregistry-interface","title":"8. FlagRegistry Interface\n<p><code>FlagRegistry</code> is the abstraction for managing feature flag configurations:</p>\n<pre><code>interface FlagRegistry {\n    fun load(config: Konfig)\n    fun update(patch: KonfigPatch)\n    fun &lt;S, C&gt; update(definition: FeatureFlag&lt;S, C&gt;)\n    fun konfig(): Konfig\n    fun &lt;S, C&gt; featureFlag(key: Conditional&lt;S, C&gt;): FeatureFlag&lt;S, C&gt;?\n    fun allFlags(): Map&lt;Conditional&lt;*, *&gt;, FeatureFlag&lt;*, *&gt;&gt;\n}\n\n// Default singleton registry\ncompanion object FlagRegistry : FlagRegistry by SingletonFlagRegistry\n\n// Extension functions for evaluation\nfun &lt;S : Any, C : Context&gt; C.evaluate(\n    key: Conditional&lt;S, C&gt;,\n    registry: FlagRegistry = FlagRegistry\n): S\n\nfun &lt;C : Context&gt; C.evaluate(\n    registry: FlagRegistry = FlagRegistry\n): Map&lt;Conditional&lt;*, *&gt;, Any?&gt;\n</code></pre>\n<p>Key features:\n- Abstraction: <code>FlagRegistry</code> interface allows custom implementations\n- Atomic updates: <code>Konfig</code> is replaced atomically using <code>AtomicReference</code> in default implementation\n- Lock-free reads: Evaluation reads from a stable snapshot\n- Incremental updates: Support for <code>KonfigPatch</code> for efficient partial updates\n- Type safety: Maintains type safety between <code>Conditional&lt;S, C&gt;</code> and <code>FeatureFlag&lt;S, C&gt;</code></p>\n<p>Default Implementation: <code>SingletonFlagRegistry</code> (object) provides thread-safe singleton behavior.</p>","text":""},{"location":"advanced/architecture/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph \"Client Application\"\n        APP[Application Code]\n        CTX[Context Instance]\n    end\n\n    subgraph \"Konditional Core\"\n        COND[Conditional KeysType-Safe Enums]\n        REG[FlagRegistryThread-Safe Store]\n        EVAL[Evaluation Engine]\n    end\n\n    subgraph \"Configuration\"\n        DSL[ConfigBuilder DSL]\n        KONFIG[KonfigImmutable Snapshot]\n        PATCH[KonfigPatchIncremental Updates]\n    end\n\n    APP --&gt;|evaluate| CTX\n    CTX --&gt;|evaluate flag| COND\n    COND --&gt;|query| REG\n    REG --&gt;|retrieve definition| EVAL\n    EVAL --&gt;|match rules| CTX\n\n    DSL --&gt;|builds| KONFIG\n    KONFIG --&gt;|loads into| REG\n    PATCH --&gt;|applies to| KONFIG\n\n    style APP fill:#e1f5ff\n    style CTX fill:#e1f5ff\n    style EVAL fill:#fff4e1\n    style REG fill:#fff4e1\n    style KONFIG fill:#f0e1ff\n</code></pre>"},{"location":"advanced/architecture/#evaluation-flow","title":"Evaluation Flow","text":"<pre><code>flowchart TD\n    START([Context.evaluate]) --&gt; FETCH[Fetch FeatureFlag from Registry]\n    FETCH --&gt; ACTIVE{Is Flag Active?}\n\n    ACTIVE --&gt;|No| DEFAULT[Return Default Value]\n    ACTIVE --&gt;|Yes| SORT[Sort Rules by SpecificityHighest First]\n\n    SORT --&gt; ITERATE[Iterate Rules]\n    ITERATE --&gt; MATCH{Rule MatchesContext?}\n\n    MATCH --&gt;|No| NEXT{More Rules?}\n    MATCH --&gt;|Yes| BUCKET[Calculate BucketSHA-256 Hash]\n\n    BUCKET --&gt; ELIGIBLE{In EligibleSegment?}\n    ELIGIBLE --&gt;|No| NEXT\n    ELIGIBLE --&gt;|Yes| RETURN[Return Rule Value]\n\n    NEXT --&gt;|Yes| ITERATE\n    NEXT --&gt;|No| DEFAULT\n\n    DEFAULT --&gt; END([Return Value])\n    RETURN --&gt; END\n\n    style START fill:#e1f5ff\n    style END fill:#e1f5ff\n    style MATCH fill:#fff4e1\n    style ACTIVE fill:#fff4e1\n    style ELIGIBLE fill:#fff4e1\n    style RETURN fill:#d4edda\n    style DEFAULT fill:#f8d7da\n</code></pre>\n<p>Detailed Steps:</p>\n<ol>\n<li>Application calls: <code>context.evaluate(Features.DARK_MODE)</code></li>\n<li>Extension function uses <code>FlagRegistry</code> (singleton) by default</li>\n<li>Registry retrieves <code>FeatureFlag&lt;S, C&gt;</code> for <code>Features.DARK_MODE</code> from current <code>Konfig</code></li>\n<li>Check if flag <code>isActive</code> (if false, return <code>defaultValue</code>)</li>\n<li>Sort <code>values</code> (ConditionalValue list) by rule specificity (most specific first)</li>\n<li>For each <code>ConditionalValue</code> (in order):</li>\n<li>Check if <code>rule.matches(context)</code></li>\n<li>If matches, check if user is in eligible bucket via SHA-256</li>\n<li>If eligible, return the <code>value</code></li>\n<li>If no rule matches, return <code>defaultValue</code></li>\n</ol>"},{"location":"advanced/architecture/#deterministic-bucketing","title":"Deterministic Bucketing","text":"<p>Each rule has a <code>rollout</code> percentage (0-100%). To determine if a user is eligible:</p>\n<ol>\n<li>Compute <code>bucket = SHA-256(\"$flagKey:$stableId:$salt\") mod 1000</code></li>\n<li>User is eligible if <code>bucket &lt; (rollout * 10)</code></li>\n</ol>\n<p>Properties:\n- Deterministic: Same <code>stableId</code> + <code>flagKey</code> + <code>salt</code> always produces same bucket\n- Independent: Different <code>flagKey</code> values produce independent buckets (no correlation)\n- Granular: 1,000 buckets allows 0.1% precision in rollout percentages</p>\n<pre><code>flowchart LR\n    subgraph \"Input\"\n        KEY[Flag Key]\n        STABLE[StableId]\n        SALT[Salt String]\n    end\n\n    subgraph \"Hashing\"\n        CONCAT[Concatenate:key + stableId + salt]\n        HASH[SHA-256 Hash]\n        BUCKET[bucket = hash % 1000]\n    end\n\n    subgraph \"Decision\"\n        ROLLOUT[Rollout Percentagee.g., 50.0%]\n        THRESHOLD[threshold = rollout * 10]\n        COMPARE{bucket &lt;threshold?}\n    end\n\n    KEY --&gt; CONCAT\n    STABLE --&gt; CONCAT\n    SALT --&gt; CONCAT\n\n    CONCAT --&gt; HASH\n    HASH --&gt; BUCKET\n\n    BUCKET --&gt; COMPARE\n    ROLLOUT --&gt; THRESHOLD\n    THRESHOLD --&gt; COMPARE\n\n    COMPARE --&gt;|Yes| INCLUDE[Include in Rollout]\n    COMPARE --&gt;|No| EXCLUDE[Exclude from Rollout]\n\n    style INCLUDE fill:#d4edda\n    style EXCLUDE fill:#f8d7da\n</code></pre>"},{"location":"advanced/architecture/#rule-specificity-prioritization","title":"Rule Specificity &amp; Prioritization","text":"<pre><code>graph TD\n    subgraph \"Specificity Calculation\"\n        RULE[Rule Specificity]\n        BASE[BaseEvaluable Specificity]\n        EXT[Extension Evaluable Specificity]\n\n        RULE --&gt;|sum| BASE\n        RULE --&gt;|sum| EXT\n\n        BASE --&gt;|+1 if set| LOCALE[Locale Constraint]\n        BASE --&gt;|+1 if set| PLATFORM[Platform Constraint]\n        BASE --&gt;|+1 if set| VERSION[Version Constraint]\n\n        EXT --&gt;|custom| CUSTOM[Custom Logic Specificity]\n    end\n\n    subgraph \"Evaluation Order\"\n        S3[Specificity 3All constraints] --&gt;|evaluated first| S2[Specificity 2Two constraints]\n        S2 --&gt; S1[Specificity 1One constraint]\n        S1 --&gt; S0[Specificity 0No constraints]\n        S0 --&gt;|evaluated last| DEFAULT[Default Value]\n    end\n\n    style S3 fill:#d4edda\n    style DEFAULT fill:#f8d7da\n</code></pre>\n<p>Specificity Rules:\n- Higher specificity = evaluated first\n- Tie-breaking: lexicographic by rule note\n- First matching rule wins (after rollout check)\n- If no rules match, return default value</p>"},{"location":"advanced/architecture/#composable-architecture","title":"Composable Architecture","text":"<p>Konditional's architecture is built on composition rather than inheritance. The key abstraction is <code>Evaluable&lt;C&gt;</code>, which provides two core operations:</p>\n<ul>\n<li>matches(context: C): Determines if a context satisfies the criteria</li>\n<li>specificity(): Returns a numeric value for precedence ordering</li>\n</ul>\n<p>This simple interface enables powerful composition patterns:</p>"},{"location":"advanced/architecture/#composition-in-rule","title":"Composition in Rule\n<p>The <code>Rule&lt;C&gt;</code> class demonstrates composition by combining two Evaluables:</p>\n<pre><code>data class Rule&lt;C : Context&gt;(\n    val baseEvaluable: BaseEvaluable&lt;C&gt;,\n    val extension: Evaluable&lt;C&gt;\n) : Evaluable&lt;C&gt;() {\n    override fun matches(context: C): Boolean =\n        baseEvaluable.matches(context) &amp;&amp; extension.matches(context)\n\n    override fun specificity(): Int =\n        baseEvaluable.specificity() + extension.specificity()\n}\n</code></pre>\n<p>This design provides:\n- Separation of concerns: Standard targeting is separate from custom logic\n- Reusability: Custom Evaluables can be reused across multiple rules\n- Predictable precedence: Specificity values compose additively\n- Extension without modification: Add custom logic without changing Rule class</p>","text":""},{"location":"advanced/architecture/#benefits-of-composable-design","title":"Benefits of Composable Design\n<ol>\n<li>Testability: Each Evaluable can be tested independently</li>\n<li>Flexibility: Mix and match different evaluation strategies</li>\n<li>Type safety: Composition preserves type parameters throughout</li>\n<li>Clear semantics: AND composition for matching, SUM composition for specificity</li>\n</ol>","text":""},{"location":"advanced/architecture/#type-safety-architecture","title":"Type Safety Architecture","text":"<p>The generic type parameters <code>&lt;S : Any, C : Context&gt;</code> flow through the entire system:</p>\n<pre><code>Conditional&lt;S, C&gt;\n    \u2193\nFlagDefinition&lt;S, C&gt;\n    \u2193\nTargetedValue&lt;S, C&gt;\n    \u2193\nRule&lt;C&gt; extends Evaluable&lt;C&gt;\n    \u2193\nUserClientEvaluator&lt;C&gt; + extension: Evaluable&lt;C&gt;\n\nFlagEntry&lt;S, C&gt; wraps FlagDefinition&lt;S, C&gt;\n    \u2193\nMap&lt;Conditional&lt;*, *&gt;, FlagEntry&lt;*, *&gt;&gt; stores all flags\n    \u2193\nRetrieval casts FlagEntry&lt;*, *&gt; to FlagEntry&lt;S, C&gt;\n    \u2193\nFlagEntry.evaluate(context: C): S maintains type safety\n</code></pre>\n<p>The <code>FlagEntry</code> wrapper is crucial: it ensures that when we retrieve a flag by key, the associated condition has matching type parameters. While an unchecked cast is still needed (due to type erasure), the wrapper makes it structurally safe - the types are guaranteed to match if the key matches.</p>"},{"location":"advanced/architecture/#thread-safety","title":"Thread Safety","text":"<pre><code>sequenceDiagram\n    participant T1 as Thread 1\n    participant T2 as Thread 2\n    participant Reg as FlagRegistry(AtomicReference)\n    participant Snap as Konfig(Immutable)\n\n    T1-&gt;&gt;Reg: evaluate(FLAG_A)\n    Reg-&gt;&gt;Snap: Read snapshot\n\n    Note over T2: Concurrent update\n    T2-&gt;&gt;Reg: load(newKonfig)\n    Reg-&gt;&gt;Reg: AtomicReference.set()\n\n    Snap-&gt;&gt;T1: Return value from old snapshot\n\n    T1-&gt;&gt;Reg: evaluate(FLAG_B)\n    Reg-&gt;&gt;Snap: Read NEW snapshot\n    Snap-&gt;&gt;T1: Return value from new snapshot\n\n    Note over Reg: Lock-free readsAtomic writesNo torn reads\n</code></pre>\n<p>Reads (evaluation):\n- Lock-free: read from <code>AtomicReference&lt;Konfig&gt;</code>\n- Konfig is immutable once created\n- Multiple threads can evaluate concurrently\n- No contention between readers</p>\n<p>Writes (configuration updates):\n- <code>AtomicReference.set()</code> provides atomic snapshot replacement\n- Writers never block readers\n- Later writes win if concurrent\n- Eventually consistent: new evaluations see new config</p>"},{"location":"advanced/architecture/#dsl-architecture","title":"DSL Architecture","text":"<p>The configuration DSL is built with type-safe builders:</p>\n<pre><code>ConfigBuilder\n    \u2193 creates\nFlagBuilder&lt;S, C&gt;\n    \u2193 creates\nRuleBuilder&lt;C&gt;\n    \u2193 creates\nRule&lt;C&gt;\n\nFlagBuilder combines:\n- TargetedValue&lt;S, C&gt; instances (from rule { } implies value)\n- Default value\n- Fallback value\n    \u2193 builds\nFlagDefinition&lt;S, C&gt;\n    \u2193 wrapped in\nFlagEntry&lt;S, C&gt;\n    \u2193 added to\nSnapshot\n</code></pre>\n<p>The DSL ensures:\n- Type parameters match throughout construction\n- Required fields (default value) are provided\n- Rules and values have compatible types</p>"},{"location":"advanced/architecture/#extension-points","title":"Extension Points","text":"<p>Konditional is designed for extension through its composable architecture:</p>\n<ol>\n<li>Custom Contexts: Implement <code>Context</code> interface with your fields</li>\n<li>Custom Value Types: Use any <code>S : Any</code> type in <code>Conditional&lt;S, C&gt;</code></li>\n<li>Custom Evaluables: Extend <code>Evaluable&lt;C&gt;</code> to create reusable evaluation logic</li>\n<li>Rule Extensions: Use the <code>extension</code> parameter in <code>Rule&lt;C&gt;</code> to add custom logic</li>\n<li>Custom Builders: Extend builders to add domain-specific DSL methods</li>\n</ol>"},{"location":"advanced/architecture/#example-custom-evaluable","title":"Example: Custom Evaluable\n<pre><code>class SubscriptionTierEvaluator&lt;C : EnterpriseContext&gt;(\n    val requiredTier: SubscriptionTier\n) : Evaluable&lt;C&gt;() {\n    override fun matches(context: C): Boolean =\n        context.subscriptionTier &gt;= requiredTier\n\n    override fun specificity(): Int = 1\n}\n</code></pre>","text":""},{"location":"advanced/architecture/#example-using-custom-evaluable-in-rules","title":"Example: Using Custom Evaluable in Rules\n<pre><code>// Compose custom evaluable with standard targeting\nRule(\n    rollout = Rollout.of(100.0),\n    locales = setOf(AppLocale.EN_US),\n    platforms = setOf(Platform.IOS),\n    extension = SubscriptionTierEvaluator(SubscriptionTier.ENTERPRISE)\n)\n\n// Or create more complex compositions\nRule(\n    rollout = Rollout.of(50.0),\n    extension = object : Evaluable&lt;EnterpriseContext&gt;() {\n        override fun matches(context: EnterpriseContext): Boolean {\n            return context.subscriptionTier &gt;= SubscriptionTier.PREMIUM &amp;&amp;\n                   context.userRole in setOf(UserRole.ADMIN, UserRole.OWNER)\n        }\n        override fun specificity(): Int = 2\n    }\n)\n</code></pre>\n<p>This composable design allows you to build reusable evaluation logic that can be mixed and matched across different rules.</p>","text":""},{"location":"advanced/architecture/#performance-characteristics","title":"Performance Characteristics","text":"<ul>\n<li>Evaluation: O(n) where n = number of surjections for a flag</li>\n<li>Typically very small (1-10 rules per flag)</li>\n<li>Sorted once when condition is created</li>\n<li>\n<p>First match wins (early exit)</p>\n</li>\n<li>\n<p>Memory: O(f \u00d7 r) where f = number of flags, r = average rules per flag</p>\n</li>\n<li>Snapshots are immutable and shared</li>\n<li>\n<p>No per-request allocation</p>\n</li>\n<li>\n<p>Bucketing: O(1) hash computation</p>\n</li>\n<li>SHA-256 with small input</li>\n<li>No synchronization required</li>\n</ul>"},{"location":"advanced/architecture/#summary","title":"Summary","text":"<p>Konditional's architecture prioritizes:\n- Type safety: Generics flow through the entire system\n- Composability: <code>Evaluable&lt;C&gt;</code> abstraction enables flexible composition of evaluation logic\n- Determinism: SHA-256 based bucketing with same inputs \u2192 same outputs\n- Thread safety: Lock-free reads with atomic updates\n- Extensibility: Generic parameters allow custom contexts, value types, and evaluation strategies\n- Separation of concerns: Standard targeting separated from custom logic through composition\n- Performance: Simple evaluation with no synchronization on read path</p>"},{"location":"advanced/conditional-types/","title":"Conditional Value Types","text":"<p>Konditional supports any non-nullable type as a flag value. This document explores the different types you can use and when each is appropriate.</p>"},{"location":"advanced/conditional-types/#the-type-parameter","title":"The Type Parameter","text":"<p><code>Conditional&lt;S : Any, C : Context&gt;</code> uses <code>S</code> to represent the value type:</p> <ul> <li><code>S : Any</code> means any non-nullable type</li> <li>Primitives, collections, data classes, enums - all supported</li> <li>Type safety is maintained end-to-end</li> </ul>"},{"location":"advanced/conditional-types/#boolean-flags","title":"Boolean Flags","text":"<p>The most common type - simple on/off switches.</p> <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ANALYTICS_ENABLED(\"analytics_enabled\"),\n    ;\n\n}\n\nconfig {\n    Features.DARK_MODE with {\n        default(false)\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n        } implies true\n    }\n}\n\n// Usage\nif (context.evaluate(Features.DARK_MODE)) {\n    applyDarkTheme()\n}\n</code></pre> <p>When to use: Simple enable/disable decisions.</p>"},{"location":"advanced/conditional-types/#string-flags","title":"String Flags","text":"<p>Useful for configuration values, endpoints, and variants.</p> <pre><code>enum class Config(override val key: String) : Conditional&lt;String, Context&gt; {\n    API_ENDPOINT(\"api_endpoint\"),\n    THEME_NAME(\"theme_name\"),\n    LOG_LEVEL(\"log_level\"),\n    ;\n\n}\n\nconfig {\n    Config.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n        rule {\n            platforms(Platform.WEB)\n        } implies \"https://api.staging.example.com\"\n    }\n\n    Config.THEME_NAME with {\n        default(\"light\")\n        rule {\n            locales(AppLocale.EN_US)\n        } implies \"dark\"\n        rule {\n            locales(AppLocale.HI_IN)\n        } implies \"vibrant\"\n    }\n}\n\n// Usage\nval endpoint = context.evaluate(Config.API_ENDPOINT)\napiClient.configure(baseUrl = endpoint)\n</code></pre> <p>When to use: - Configuration values that vary by environment - A/B test variants - URLs, keys, or other string configuration</p>"},{"location":"advanced/conditional-types/#integer-flags","title":"Integer Flags","text":"<p>For numeric configuration like timeouts, limits, or sizes.</p> <pre><code>enum class Limits(override val key: String) : Conditional&lt;Int, Context&gt; {\n    MAX_CONNECTIONS(\"max_connections\"),\n    TIMEOUT_SECONDS(\"timeout_seconds\"),\n    CACHE_SIZE_MB(\"cache_size_mb\"),\n    ;\n\n}\n\nconfig {\n    Limits.MAX_CONNECTIONS with {\n        default(10)\n        rule {\n            platforms(Platform.WEB)\n        } implies 50\n        rule {\n            platforms(Platform.WEB)\n            versions {\n                min(3, 0)\n            }\n        } implies 100\n    }\n\n    Limits.TIMEOUT_SECONDS with {\n        default(30)\n        rule {\n            platforms(Platform.ANDROID)\n            versions {\n                max(5, 0, 0)  // Legacy devices\n            }\n        } implies 60  // More generous timeout\n    }\n}\n\n// Usage\nval maxConnections = context.evaluate(Limits.MAX_CONNECTIONS)\nconnectionPool.setMaxSize(maxConnections)\n</code></pre> <p>When to use: - Numeric limits or thresholds - Timeouts and intervals - Buffer sizes and limits - Retry counts</p>"},{"location":"advanced/conditional-types/#enum-flags","title":"Enum Flags","text":"<p>Type-safe multi-variant flags.</p> <pre><code>enum class LogLevel {\n    DEBUG, INFO, WARN, ERROR, NONE\n}\n\nenum class LogConfig(override val key: String) : Conditional&lt;LogLevel, Context&gt; {\n    APP_LOG_LEVEL(\"app_log_level\"),\n    NETWORK_LOG_LEVEL(\"network_log_level\"),\n    ;\n\n}\n\nconfig {\n    LogConfig.APP_LOG_LEVEL with {\n        default(LogLevel.INFO)\n        rule {\n            platforms(Platform.WEB)\n        } implies LogLevel.DEBUG\n        rule {\n            versions {\n                max(1, 0)  // Old versions\n            }\n        } implies LogLevel.ERROR\n    }\n}\n\n// Usage\nval logLevel = context.evaluate(LogConfig.APP_LOG_LEVEL)\nlogger.setLevel(logLevel)\n</code></pre> <p>When to use: - Multiple exclusive options (log levels, modes, strategies) - Type-safe variants in A/B tests - Enums provide exhaustive when expressions</p>"},{"location":"advanced/conditional-types/#data-class-flags","title":"Data Class Flags","text":"<p>Complex configuration objects.</p> <pre><code>data class ApiConfig(\n    val baseUrl: String,\n    val timeout: Int,\n    val retries: Int,\n    val useHttps: Boolean,\n)\n\nenum class NetworkConfig(override val key: String) : Conditional&lt;ApiConfig, Context&gt; {\n    PRIMARY_API(\"primary_api\"),\n    BACKUP_API(\"backup_api\"),\n    ;\n\n}\n\nconfig {\n    NetworkConfig.PRIMARY_API with {\n        default(ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30,\n            retries = 3,\n            useHttps = true,\n        ))\n        rule {\n            platforms(Platform.WEB)\n        } implies ApiConfig(\n            baseUrl = \"http://api.dev.example.com\",\n            timeout = 60,\n            retries = 1,\n            useHttps = false,\n        )\n    }\n}\n\n// Usage\nval apiConfig = context.evaluate(NetworkConfig.PRIMARY_API)\napiClient.configure(\n    baseUrl = apiConfig.baseUrl,\n    timeout = apiConfig.timeout,\n    retries = apiConfig.retries,\n)\n</code></pre> <p>When to use: - Related configuration values that should change together - Complex objects with multiple fields - Configuration that varies as a unit</p>"},{"location":"advanced/conditional-types/#list-flags","title":"List Flags","text":"<p>Collections of values.</p> <pre><code>enum class ModuleConfig(override val key: String) : Conditional&lt;List&lt;String&gt;, Context&gt; {\n    ENABLED_FEATURES(\"enabled_features\"),\n    BETA_MODULES(\"beta_modules\"),\n    ;\n\n}\n\nconfig {\n    ModuleConfig.ENABLED_FEATURES with {\n        default(listOf(\"core\", \"basic\"))\n        rule {\n            versions {\n                min(2, 0)\n            }\n        } implies listOf(\"core\", \"basic\", \"advanced\", \"analytics\")\n    }\n}\n\n// Usage\nval enabledFeatures = context.evaluate(ModuleConfig.ENABLED_FEATURES)\nfor (feature in enabledFeatures) {\n    moduleRegistry.enable(feature)\n}\n</code></pre> <p>When to use: - Variable sets of enabled modules - Lists of allowed values - Configuration arrays</p>"},{"location":"advanced/conditional-types/#map-flags","title":"Map Flags","text":"<p>Key-value configuration.</p> <pre><code>enum class FeatureToggles(override val key: String) : Conditional&lt;Map&lt;String, String&gt;, Context&gt; {\n    TOGGLES(\"feature_toggles\"),\n    ;\n\n}\n\nconfig {\n    FeatureToggles.TOGGLES with {\n        default(mapOf(\n            \"feature1\" to \"off\",\n            \"feature2\" to \"off\",\n        ))\n        rule {\n            locales(AppLocale.EN_US, AppLocale.EN_CA)\n        } implies mapOf(\n            \"feature1\" to \"on\",\n            \"feature2\" to \"on\",\n            \"feature3\" to \"beta\",\n        )\n    }\n}\n\n// Usage\nval toggles = context.evaluate(FeatureToggles.TOGGLES)\nval feature1Status = toggles[\"feature1\"] ?: \"off\"\n</code></pre> <p>When to use: - Flexible key-value configuration - Dynamic sets of toggles - Configuration dictionaries</p>"},{"location":"advanced/conditional-types/#nested-data-structures","title":"Nested Data Structures","text":"<p>Combine types for complex configuration:</p> <pre><code>data class ThemeConfig(\n    val primaryColor: String,\n    val secondaryColor: String,\n    val fontSizes: Map&lt;String, Int&gt;,\n    val enabledFeatures: List&lt;String&gt;,\n)\n\nenum class AppConfig(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    THEME(\"app_theme\"),\n    ;\n\n}\n\nconfig {\n    AppConfig.THEME with {\n        default(ThemeConfig(\n            primaryColor = \"#FFFFFF\",\n            secondaryColor = \"#F0F0F0\",\n            fontSizes = mapOf(\n                \"body\" to 14,\n                \"heading\" to 20,\n            ),\n            enabledFeatures = listOf(\"animations\"),\n        ))\n        rule {\n            locales(AppLocale.EN_US)\n        } implies ThemeConfig(\n            primaryColor = \"#1E1E1E\",\n            secondaryColor = \"#2D2D2D\",\n            fontSizes = mapOf(\n                \"body\" to 16,\n                \"heading\" to 24,\n            ),\n            enabledFeatures = listOf(\"animations\", \"dark-mode\", \"high-contrast\"),\n        )\n    }\n}\n</code></pre>"},{"location":"advanced/conditional-types/#sealed-classes","title":"Sealed Classes","text":"<p>Use sealed classes for type-safe variants:</p> <pre><code>sealed class PaymentMethod {\n    data class CreditCard(val last4: String) : PaymentMethod()\n    data class PayPal(val email: String) : PaymentMethod()\n    data class BankTransfer(val accountNumber: String) : PaymentMethod()\n}\n\nenum class PaymentConfig(override val key: String) : Conditional&lt;PaymentMethod, Context&gt; {\n    DEFAULT_METHOD(\"default_payment_method\"),\n    ;\n\n}\n\nconfig {\n    PaymentConfig.DEFAULT_METHOD with {\n        default(PaymentMethod.CreditCard(\"****\"))\n        rule {\n            locales(AppLocale.EN_US)\n        } implies PaymentMethod.PayPal(\"default@example.com\")\n    }\n}\n\n// Usage\nwhen (val method = context.evaluate(PaymentConfig.DEFAULT_METHOD)) {\n    is PaymentMethod.CreditCard -&gt; processCreditCard(method.last4)\n    is PaymentMethod.PayPal -&gt; processPayPal(method.email)\n    is PaymentMethod.BankTransfer -&gt; processBankTransfer(method.accountNumber)\n}\n</code></pre>"},{"location":"advanced/conditional-types/#type-safety-benefits","title":"Type Safety Benefits","text":""},{"location":"advanced/conditional-types/#compile-time-verification","title":"Compile-Time Verification","text":"<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    FEATURE_A(\"feature_a\"),\n    ;\n\n}\n\nconfig {\n    Features.FEATURE_A with {\n        default(false)\n        rule {\n        } implies true  // \u2713 Type matches (Boolean)\n        // } implies \"invalid\"  // \u2717 Compile error: type mismatch\n    }\n}\n\n// Evaluation is type-safe\nval result: Boolean = context.evaluate(Features.FEATURE_A)  // \u2713 Correct type\n// val result: String = context.evaluate(Features.FEATURE_A)  // \u2717 Compile error\n</code></pre>"},{"location":"advanced/conditional-types/#ide-support","title":"IDE Support","text":"<ul> <li>Auto-completion for all flag names</li> <li>Type inference for evaluation results</li> <li>Refactoring support (rename, extract, etc.)</li> <li>Inline documentation</li> </ul>"},{"location":"advanced/conditional-types/#best-practices","title":"Best Practices","text":""},{"location":"advanced/conditional-types/#1-use-the-right-type-for-the-job","title":"1. Use the Right Type for the Job","text":"<pre><code>// Good: Boolean for on/off decisions\nenum class Features(...) : Conditional&lt;Boolean, Context&gt;\n\n// Good: Enum for multiple options\nenum class LogLevel { DEBUG, INFO, WARN }\nenum class Config(...) : Conditional&lt;LogLevel, Context&gt;\n\n// Bad: String when enum would be better\n// enum class Config(...) : Conditional&lt;String, Context&gt;  // \"debug\", \"info\" prone to typos\n</code></pre>"},{"location":"advanced/conditional-types/#2-keep-value-types-simple","title":"2. Keep Value Types Simple","text":"<pre><code>// Good: Simple data class\ndata class ApiConfig(\n    val url: String,\n    val timeout: Int,\n)\n\n// Bad: Includes behavior or mutable state\ndata class ApiConfig(\n    val url: String,\n    var timeout: Int,  // Mutable\n    val client: HttpClient,  // Heavy object\n)\n</code></pre>"},{"location":"advanced/conditional-types/#3-use-data-classes-for-immutability","title":"3. Use Data Classes for Immutability","text":"<pre><code>// Good: Immutable data class\ndata class Config(val value: String)\n\n// Bad: Mutable class\nclass Config {\n    var value: String = \"\"\n}\n</code></pre>"},{"location":"advanced/conditional-types/#4-document-complex-types","title":"4. Document Complex Types","text":"<pre><code>/**\n * Configuration for the analytics system.\n * @property endpoint The analytics endpoint URL\n * @property batchSize Number of events to batch before sending\n * @property enabled Whether analytics is enabled at all\n */\ndata class AnalyticsConfig(\n    val endpoint: String,\n    val batchSize: Int,\n    val enabled: Boolean,\n)\n</code></pre>"},{"location":"advanced/conditional-types/#5-consider-sealed-classes-for-variants","title":"5. Consider Sealed Classes for Variants","text":"<p>When you have multiple mutually exclusive options with different data, sealed classes are better than enums:</p> <pre><code>// Good: Sealed class with associated data\nsealed class CacheStrategy {\n    data class InMemory(val maxSize: Int) : CacheStrategy()\n    data class OnDisk(val path: String, val maxSize: Long) : CacheStrategy()\n    object None : CacheStrategy()\n}\n\n// Less ideal: Separate flags for each option\n// enum class CacheType : Conditional&lt;String, Context&gt;  // \"inmemory\", \"disk\", \"none\"\n// enum class CacheSize : Conditional&lt;Int, Context&gt;  // Only relevant for some types\n</code></pre>"},{"location":"advanced/conditional-types/#summary","title":"Summary","text":"<p>Konditional's support for arbitrary value types allows you to:</p> <ul> <li>Use the right type for each use case</li> <li>Maintain type safety throughout your codebase</li> <li>Get compile-time errors instead of runtime failures</li> <li>Leverage IDE features like auto-completion and refactoring</li> <li>Express complex configuration with nested data structures</li> </ul> <p>Choose types that accurately model your domain and let Konditional's type system ensure correctness.</p>"},{"location":"advanced/context-polymorphism/","title":"Context Polymorphism","text":"<p>One of Konditional's most powerful features is context polymorphism - the ability to define custom context types tailored to your domain, while maintaining full type safety throughout the system.</p>"},{"location":"advanced/context-polymorphism/#why-custom-contexts","title":"Why Custom Contexts?","text":"<p>The base <code>Context</code> interface provides common properties like <code>locale</code>, <code>platform</code>, <code>appVersion</code>, and <code>stableId</code>. However, your application may need to make decisions based on:</p> <ul> <li>Organization/Tenant ID for multi-tenant applications</li> <li>User roles or permissions for enterprise features</li> <li>Subscription tier for freemium models</li> <li>Experiment groups for A/B testing</li> <li>Device capabilities for hardware-specific features</li> <li>Session attributes for personalization</li> <li>Any domain-specific data your application needs</li> </ul>"},{"location":"advanced/context-polymorphism/#context-extension-hierarchy","title":"Context Extension Hierarchy","text":"<pre><code>classDiagram\n    class Context {\n        &lt;&gt;\n        +locale: AppLocale\n        +platform: Platform\n        +appVersion: Version\n        +stableId: StableId\n    }\n\n    class EnterpriseContext {\n        +organizationId: String\n        +subscriptionTier: Tier\n        +teamSize: Int\n        +features: Set~String~\n    }\n\n    class EducationContext {\n        +studentId: Int\n        +schoolId: String?\n        +isOnTrack: Boolean\n        +achievements: List~String~\n    }\n\n    class CommerceContext {\n        +cartValue: Double\n        +orderCount: Int\n        +loyaltyPoints: Int\n        +segmentId: String\n    }\n\n    Context &lt;|-- EnterpriseContext\n    Context &lt;|-- EducationContext\n    Context &lt;|-- CommerceContext\n\n    note for Context \"Base interface\\nminimal requirements\"\n    note for EnterpriseContext \"B2B SaaS use case\"\n    note for EducationContext \"Gaming app use case\"\n    note for CommerceContext \"Shopping app use case\"\n\n<p>Key Benefits:\n- Extend <code>Context</code> with domain-specific fields\n- Type safety: Generic parameter <code>C</code> flows through the system\n- Custom evaluators can access extended properties\n- Base targeting still works with any context type</p>"},{"location":"advanced/context-polymorphism/#the-context-interface","title":"The Context Interface","text":"<pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n</code></pre>\n<p>This interface is intentionally minimal - it defines only what's needed for the base rule system. You extend it with your own properties.</p>"},{"location":"advanced/context-polymorphism/#creating-a-custom-context","title":"Creating a Custom Context","text":""},{"location":"advanced/context-polymorphism/#example-enterprise-context","title":"Example: Enterprise Context","text":"<pre><code>data class EnterpriseContext(\n    // Required: Base Context properties\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    // Custom: Enterprise-specific properties\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val userRole: UserRole,\n    val featuresEnabled: Set&lt;String&gt;,\n) : Context\n\nenum class SubscriptionTier {\n    FREE, BASIC, PREMIUM, ENTERPRISE\n}\n\nenum class UserRole {\n    VIEWER, EDITOR, ADMIN, OWNER\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#example-experiment-context","title":"Example: Experiment Context","text":"<pre><code>data class ExperimentContext(\n    // Required: Base Context properties\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    // Custom: Experiment-specific properties\n    val experimentGroups: Set&lt;String&gt;,\n    val sessionId: String,\n    val cohortId: String,\n    val firstSeen: Instant,\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#using-custom-contexts-with-flags","title":"Using Custom Contexts with Flags","text":"<p>Once you have a custom context, you use it as the type parameter in your <code>Conditional</code> definitions:</p>\n<pre><code>enum class EnterpriseFeatures(\n    override val key: String\n) : Conditional&lt;Boolean, EnterpriseContext&gt; {  // Note: EnterpriseContext, not Context\n    ADVANCED_ANALYTICS(\"advanced_analytics\"),\n    BULK_EXPORT(\"bulk_export\"),\n    API_ACCESS(\"api_access\"),\n    CUSTOM_BRANDING(\"custom_branding\"),\n    ;\n\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#configuration","title":"Configuration","text":"<p>Configure rules using base Context properties (the custom context implements them):</p>\n<pre><code>config {\n    EnterpriseFeatures.ADVANCED_ANALYTICS with {\n        default(false)\n\n        // Base properties work fine\n        rule {\n            platforms(Platform.WEB)\n            versions {\n                min(2, 0)\n            }\n        } implies true\n    }\n\n    EnterpriseFeatures.API_ACCESS with {\n        default(false)\n\n        // Full rollout for web users on v2.0+\n        rule {\n            platforms(Platform.WEB)\n            versions {\n                min(2, 0)\n            }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#evaluation","title":"Evaluation","text":"<p>Evaluate with your custom context:</p>\n<pre><code>val enterpriseCtx = EnterpriseContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.WEB,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\"),\n    organizationId = \"org-456\",\n    subscriptionTier = SubscriptionTier.ENTERPRISE,\n    userRole = UserRole.ADMIN,\n    featuresEnabled = setOf(\"beta-features\"),\n)\n\n// Type-safe: returns Boolean\nval hasAnalytics = enterpriseCtx.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)\n</code></pre>"},{"location":"advanced/context-polymorphism/#extending-rules-for-custom-contexts","title":"Extending Rules for Custom Contexts","text":"<p>While the base <code>Rule&lt;C&gt;</code> works with any context type, you can create custom rule types that leverage your context's specific properties:</p>\n<pre><code>data class EnterpriseRule(\n    val Rule: Rule&lt;EnterpriseContext&gt;,\n    val minSubscriptionTier: SubscriptionTier? = null,\n    val requiredRole: UserRole? = null,\n    val requiredFeatures: Set&lt;String&gt; = emptySet(),\n) {\n    fun matches(context: EnterpriseContext): Boolean {\n        // First check base rule (platform, locale, version)\n        if (!Rule.matches(context)) return false\n\n        // Then check enterprise-specific requirements\n        if (minSubscriptionTier != null &amp;&amp; context.subscriptionTier.ordinal &lt; minSubscriptionTier.ordinal) {\n            return false\n        }\n\n        if (requiredRole != null &amp;&amp; context.userRole.ordinal &lt; requiredRole.ordinal) {\n            return false\n        }\n\n        if (requiredFeatures.isNotEmpty() &amp;&amp; !context.featuresEnabled.containsAll(requiredFeatures)) {\n            return false\n        }\n\n        return true\n    }\n}\n</code></pre>\n<p>Usage:</p>\n<pre><code>val enterpriseOnlyRule = EnterpriseRule(\n    Rule = Rule(\n        rollout = Rollout.MAX,\n        locales = emptySet(),\n        platforms = setOf(Platform.WEB),\n        versionRange = Unbounded,\n    ),\n    minSubscriptionTier = SubscriptionTier.ENTERPRISE,\n    requiredRole = UserRole.ADMIN,\n)\n\nif (enterpriseOnlyRule.matches(enterpriseCtx)) {\n    // User meets all criteria\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#multiple-context-types-in-the-same-application","title":"Multiple Context Types in the Same Application","text":"<p>You can use multiple context types for different purposes:</p>\n<pre><code>// Standard features use base Context\nenum class StandardFeatures(\n    override val key: String\n) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_UI(\"new_ui\"),\n    ;\n\n}\n\n// Enterprise features use EnterpriseContext\nenum class EnterpriseFeatures(\n    override val key: String\n) : Conditional&lt;Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"advanced_analytics\"),\n    ;\n\n}\n\n// Experiment features use ExperimentContext\nenum class ExperimentFeatures(\n    override val key: String\n) : Conditional&lt;String, ExperimentContext&gt; {  // Note: String value type\n    HOMEPAGE_VARIANT(\"homepage_variant\"),\n    ;\n\n}\n</code></pre>\n<p>Each set of flags operates independently with its own context type.</p>"},{"location":"advanced/context-polymorphism/#context-creation-patterns","title":"Context Creation Patterns","text":""},{"location":"advanced/context-polymorphism/#from-user-session","title":"From User Session","text":"<pre><code>fun createEnterpriseContext(session: UserSession): EnterpriseContext {\n    return EnterpriseContext(\n        locale = session.user.preferredLocale,\n        platform = session.deviceInfo.platform,\n        appVersion = session.appVersion,\n        stableId = StableId.of(session.user.id),\n        organizationId = session.organization.id,\n        subscriptionTier = session.organization.subscriptionTier,\n        userRole = session.user.roleIn(session.organization),\n        featuresEnabled = session.organization.enabledFeatures,\n    )\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#from-api-request","title":"From API Request","text":"<pre><code>fun createContextFromRequest(request: HttpServletRequest): EnterpriseContext {\n    val user = authenticateUser(request)\n    val org = user.organization\n\n    return EnterpriseContext(\n        locale = parseLocale(request.getHeader(\"Accept-Language\")),\n        platform = parsePlatform(request.getHeader(\"User-Agent\")),\n        appVersion = parseVersion(request.getHeader(\"X-App-Version\")),\n        stableId = StableId.of(user.id),\n        organizationId = org.id,\n        subscriptionTier = org.tier,\n        userRole = user.role,\n        featuresEnabled = org.features,\n    )\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#from-graphql-context","title":"From GraphQL Context","text":"<pre><code>data class GraphQLContext(\n    val user: User,\n    val organization: Organization,\n    // ... other GraphQL context fields\n) {\n    fun toEnterpriseContext(): EnterpriseContext {\n        return EnterpriseContext(\n            locale = user.locale,\n            platform = user.lastSeenPlatform,\n            appVersion = user.lastSeenAppVersion,\n            stableId = StableId.of(user.id),\n            organizationId = organization.id,\n            subscriptionTier = organization.tier,\n            userRole = user.role,\n            featuresEnabled = organization.features,\n        )\n    }\n}\n\n// In GraphQL resolver:\nval enterpriseCtx = graphQLContext.toEnterpriseContext()\nval hasAccess = enterpriseCtx.evaluate(EnterpriseFeatures.API_ACCESS)\n</code></pre>"},{"location":"advanced/context-polymorphism/#inheritance-and-context-hierarchies","title":"Inheritance and Context Hierarchies","text":"<p>You can create context hierarchies:</p>\n<pre><code>// Base authenticated context\ninterface AuthenticatedContext : Context {\n    val userId: String\n    val sessionId: String\n}\n\n// Enterprise adds organization info\ndata class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    override val userId: String,\n    override val sessionId: String,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n) : AuthenticatedContext\n\n// Free user doesn't have organization\ndata class FreeUserContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    override val userId: String,\n    override val sessionId: String,\n) : AuthenticatedContext\n</code></pre>"},{"location":"advanced/context-polymorphism/#best-practices","title":"Best Practices","text":""},{"location":"advanced/context-polymorphism/#1-keep-contexts-immutable","title":"1. Keep Contexts Immutable","text":"<p>Use <code>data class</code> and <code>val</code> properties:</p>\n<pre><code>data class MyContext(\n    override val locale: AppLocale,  // val, not var\n    val customField: String,\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#2-use-stable-ids-correctly","title":"2. Use Stable IDs Correctly","text":"<p>The <code>stableId</code> should be:\n- Consistent for the same user across sessions\n- Unique per user\n- Non-PII if possible (hashed user ID, device ID, etc.)</p>\n<pre><code>// Good: Stable, unique identifier\nstableId = StableId.of(user.hashedId)\n\n// Bad: Session ID changes every session\nstableId = StableId.of(session.id)\n\n// Bad: Not unique per user\nstableId = StableId.of(user.organization.id)\n</code></pre>"},{"location":"advanced/context-polymorphism/#3-keep-contexts-lightweight","title":"3. Keep Contexts Lightweight","text":"<p>Don't include heavy objects or computed values:</p>\n<pre><code>// Good: Only data needed for evaluation\ndata class MyContext(\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    // ...\n) : Context\n\n// Bad: Includes heavy objects\ndata class MyContext(\n    override val stableId: StableId,\n    val user: User,  // May contain lots of data\n    val organization: Organization,  // May trigger database queries\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#4-document-custom-fields","title":"4. Document Custom Fields","text":"<p>Add KDoc to explain the purpose of custom fields:</p>\n<pre><code>data class EnterpriseContext(\n    // Base Context properties\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    /**\n     * Unique identifier for the user's organization.\n     * Used for organization-specific feature rollouts.\n     */\n    val organizationId: String,\n\n    /**\n     * Current subscription tier of the organization.\n     * Used to gate premium features.\n     */\n    val subscriptionTier: SubscriptionTier,\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#5-test-with-multiple-context-types","title":"5. Test with Multiple Context Types","text":"<p>Write tests that verify flags work correctly with your custom contexts:</p>\n<pre><code>@Test\nfun `enterprise features evaluate correctly with EnterpriseContext`() {\n    config {\n        EnterpriseFeatures.ADVANCED_ANALYTICS with {\n            default(false)\n            rule {\n                platforms(Platform.WEB)\n            } implies true\n        }\n    }\n\n    val ctx = EnterpriseContext(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"test-user\"),\n        organizationId = \"org-123\",\n        subscriptionTier = SubscriptionTier.ENTERPRISE,\n        userRole = UserRole.ADMIN,\n        featuresEnabled = emptySet(),\n    )\n\n    assertTrue(ctx.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS))\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#summary","title":"Summary","text":"<p>Context polymorphism in Konditional allows you to:</p>\n<ul>\n<li>Extend the base Context with domain-specific fields</li>\n<li>Maintain type safety throughout the system</li>\n<li>Create custom rules that leverage your context's properties</li>\n<li>Use multiple context types in the same application</li>\n<li>Adapt to your domain without modifying the framework</li>\n</ul>\n<p>This makes Konditional flexible enough to handle any use case while keeping the type safety guarantees that make it powerful.</p>"},{"location":"advanced/custom-types/","title":"Custom Types","text":"<p>While Konditional provides built-in support for common types (Boolean, String, Int, Double), you can also use custom types for your feature flags. This enables:</p> <ul> <li>Complex configurations: Use rich domain objects as flag values</li> <li>Type safety: Leverage Kotlin's type system for your custom types</li> <li>Serialization: Integrate custom types with Konditional's serialization system</li> </ul>"},{"location":"advanced/custom-types/#extension-point-hierarchy","title":"Extension Point Hierarchy","text":"<pre><code>graph TB\n    subgraph \"Core Framework\"\n        COND[Conditional~S,C~]\n        CTX[Context]\n        EVAL[Evaluable~C~]\n        REG[FlagRegistry]\n    end\n\n    subgraph \"User Extensions\"\n        CUSTOM_COND[Custom Flag Keysenum class MyFlags]\n        CUSTOM_CTX[Custom Context+ domain fields]\n        CUSTOM_EVAL[Custom Evaluators+ business logic]\n        CUSTOM_REG[Custom Registry+ persistence]\n        CUSTOM_VALUES[Custom Value TypesThemeConfig, etc.]\n    end\n\n    COND -.implements.-&gt; CUSTOM_COND\n    CTX -.implements.-&gt; CUSTOM_CTX\n    EVAL -.extends.-&gt; CUSTOM_EVAL\n    REG -.implements.-&gt; CUSTOM_REG\n\n    CUSTOM_COND --&gt;|works with| CUSTOM_CTX\n    CUSTOM_COND --&gt;|returns| CUSTOM_VALUES\n    CUSTOM_CTX --&gt;|evaluated by| CUSTOM_EVAL\n    CUSTOM_EVAL --&gt;|stored in| CUSTOM_REG\n\n    style CUSTOM_COND fill:#e1f5ff\n    style CUSTOM_CTX fill:#e1f5ff\n    style CUSTOM_EVAL fill:#e1f5ff\n    style CUSTOM_REG fill:#e1f5ff\n    style CUSTOM_VALUES fill:#e1f5ff\n</code></pre> <p>Extension Points: 1. Custom Value Types - Any <code>S : Any</code> type can be used as flag values 2. Custom Contexts - Extend <code>Context</code> interface with domain-specific fields 3. Custom Evaluators - Extend <code>Evaluable&lt;C&gt;</code> for business logic 4. Custom Registries - Implement <code>FlagRegistry</code> for alternative storage</p>"},{"location":"advanced/custom-types/#defining-custom-types","title":"Defining Custom Types","text":""},{"location":"advanced/custom-types/#simple-custom-type","title":"Simple Custom Type","text":"<pre><code>data class ThemeConfig(\n    val primaryColor: String,\n    val secondaryColor: String,\n    val darkMode: Boolean\n)\n\nval themeFlag = Flag(\n    id = \"app-theme\",\n    defaultValue = ThemeConfig(\n        primaryColor = \"#007AFF\",\n        secondaryColor = \"#5856D6\",\n        darkMode = false\n    )\n)\n</code></pre>"},{"location":"advanced/custom-types/#using-the-flag","title":"Using the Flag","text":"<pre><code>val theme = themeFlag.evaluate(context)\nprintln(\"Primary color: ${theme.primaryColor}\")\n</code></pre>"},{"location":"advanced/custom-types/#serialization-support","title":"Serialization Support","text":"<p>To use custom types with serialization, register a <code>ValueType</code> converter:</p>"},{"location":"advanced/custom-types/#step-1-define-your-type","title":"Step 1: Define Your Type","text":"<pre><code>data class FeatureConfig(\n    val maxUsers: Int,\n    val allowedRegions: List&lt;String&gt;,\n    val experimentalFeatures: Set&lt;String&gt;\n)\n</code></pre>"},{"location":"advanced/custom-types/#step-2-create-a-valuetype","title":"Step 2: Create a ValueType","text":"<pre><code>import io.amichne.konditional.core.ValueType\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.json.Json\n\n@Serializable\ndata class SerializableFeatureConfig(\n    val maxUsers: Int,\n    val allowedRegions: List&lt;String&gt;,\n    val experimentalFeatures: Set&lt;String&gt;\n)\n\nobject FeatureConfigType : ValueType&lt;FeatureConfig&gt; {\n    override val name = \"FeatureConfig\"\n\n    override fun serialize(value: FeatureConfig): String {\n        val serializable = SerializableFeatureConfig(\n            maxUsers = value.maxUsers,\n            allowedRegions = value.allowedRegions,\n            experimentalFeatures = value.experimentalFeatures\n        )\n        return Json.encodeToString(\n            SerializableFeatureConfig.serializer(),\n            serializable\n        )\n    }\n\n    override fun deserialize(value: String): FeatureConfig {\n        val serializable = Json.decodeFromString(\n            SerializableFeatureConfig.serializer(),\n            value\n        )\n        return FeatureConfig(\n            maxUsers = serializable.maxUsers,\n            allowedRegions = serializable.allowedRegions,\n            experimentalFeatures = serializable.experimentalFeatures\n        )\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#step-3-register-the-type","title":"Step 3: Register the Type","text":"<pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\n\nval serializer = SnapshotSerializer(\n    customTypes = mapOf(\n        \"FeatureConfig\" to FeatureConfigType\n    )\n)\n</code></pre>"},{"location":"advanced/custom-types/#step-4-use-with-flags","title":"Step 4: Use with Flags","text":"<pre><code>val featureFlag = Flag(\n    id = \"feature-config\",\n    defaultValue = FeatureConfig(\n        maxUsers = 1000,\n        allowedRegions = listOf(\"US\", \"EU\"),\n        experimentalFeatures = setOf()\n    )\n)\n\n// Register flag\nserializer.register(featureFlag)\n\n// Serialize\nval konfig = serializer.serialize()\n\n// Deserialize\nval loaded = serializer.deserialize(konfig)\n</code></pre>"},{"location":"advanced/custom-types/#enum-types","title":"Enum Types","text":"<p>Enums work naturally with Konditional:</p> <pre><code>enum class LogLevel {\n    DEBUG, INFO, WARN, ERROR\n}\n\nval logLevelFlag = Flag(\n    id = \"log-level\",\n    defaultValue = LogLevel.INFO\n)\n\n// With rules\nval logLevelWithRules = Flag(\n    id = \"log-level\",\n    defaultValue = LogLevel.INFO,\n    rules = listOf(\n        Rule(\n            condition = EnvironmentCondition(\"development\"),\n            value = LogLevel.DEBUG\n        ),\n        Rule(\n            condition = EnvironmentCondition(\"production\"),\n            value = LogLevel.WARN\n        )\n    )\n)\n</code></pre>"},{"location":"advanced/custom-types/#enum-serialization","title":"Enum Serialization","text":"<pre><code>object LogLevelType : ValueType&lt;LogLevel&gt; {\n    override val name = \"LogLevel\"\n\n    override fun serialize(value: LogLevel): String = value.name\n\n    override fun deserialize(value: String): LogLevel =\n        LogLevel.valueOf(value)\n}\n</code></pre>"},{"location":"advanced/custom-types/#sealed-classes","title":"Sealed Classes","text":"<p>Sealed classes provide type-safe polymorphism:</p> <pre><code>sealed class PaymentMethod {\n    data class CreditCard(val last4: String) : PaymentMethod()\n    data class PayPal(val email: String) : PaymentMethod()\n    object Cash : PaymentMethod()\n}\n\nval paymentFlag = Flag(\n    id = \"default-payment-method\",\n    defaultValue = PaymentMethod.Cash as PaymentMethod\n)\n</code></pre>"},{"location":"advanced/custom-types/#sealed-class-serialization","title":"Sealed Class Serialization","text":"<pre><code>import kotlinx.serialization.json.*\n\nobject PaymentMethodType : ValueType&lt;PaymentMethod&gt; {\n    override val name = \"PaymentMethod\"\n\n    override fun serialize(value: PaymentMethod): String {\n        val json = when (value) {\n            is PaymentMethod.CreditCard -&gt; buildJsonObject {\n                put(\"type\", \"CreditCard\")\n                put(\"last4\", value.last4)\n            }\n            is PaymentMethod.PayPal -&gt; buildJsonObject {\n                put(\"type\", \"PayPal\")\n                put(\"email\", value.email)\n            }\n            PaymentMethod.Cash -&gt; buildJsonObject {\n                put(\"type\", \"Cash\")\n            }\n        }\n        return json.toString()\n    }\n\n    override fun deserialize(value: String): PaymentMethod {\n        val json = Json.parseToJsonElement(value).jsonObject\n        return when (json[\"type\"]?.jsonPrimitive?.content) {\n            \"CreditCard\" -&gt; PaymentMethod.CreditCard(\n                json[\"last4\"]!!.jsonPrimitive.content\n            )\n            \"PayPal\" -&gt; PaymentMethod.PayPal(\n                json[\"email\"]!!.jsonPrimitive.content\n            )\n            \"Cash\" -&gt; PaymentMethod.Cash\n            else -&gt; throw IllegalArgumentException(\"Unknown payment method\")\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#collections","title":"Collections","text":"<p>Use collections as flag values:</p> <pre><code>// List of strings\nval allowedCountriesFlag = Flag(\n    id = \"allowed-countries\",\n    defaultValue = listOf(\"US\", \"CA\", \"UK\")\n)\n\n// Map\nval featureLimitsFlag = Flag(\n    id = \"feature-limits\",\n    defaultValue = mapOf(\n        \"free\" to 10,\n        \"premium\" to 100,\n        \"enterprise\" to -1\n    )\n)\n\n// Set\nval enabledFeaturesFlag = Flag(\n    id = \"enabled-features\",\n    defaultValue = setOf(\"feature-a\", \"feature-b\")\n)\n</code></pre>"},{"location":"advanced/custom-types/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-types/#keep-types-simple","title":"Keep Types Simple","text":"<p>Prefer simple, serializable types:</p> <pre><code>// Good\ndata class Config(\n    val enabled: Boolean,\n    val timeout: Int,\n    val endpoints: List&lt;String&gt;\n)\n\n// Avoid complex hierarchies\ndata class OverlyComplex(\n    val nested: Level1,\n    val callbacks: List&lt;() -&gt; Unit&gt;, // Not serializable\n    val state: MutableState&lt;Int&gt; // Mutable state\n)\n</code></pre>"},{"location":"advanced/custom-types/#use-immutable-types","title":"Use Immutable Types","text":"<pre><code>// Good - immutable\ndata class FeatureSettings(\n    val maxRetries: Int,\n    val timeout: Duration\n)\n\n// Avoid - mutable\ndata class MutableSettings(\n    var maxRetries: Int,\n    var timeout: Duration\n)\n</code></pre>"},{"location":"advanced/custom-types/#document-type-contracts","title":"Document Type Contracts","text":"<pre><code>/**\n * Configuration for the recommendation engine.\n *\n * @property algorithm The algorithm to use (\"collaborative\", \"content\", \"hybrid\")\n * @property maxResults Maximum number of results to return (1-100)\n * @property minScore Minimum confidence score (0.0-1.0)\n */\ndata class RecommendationConfig(\n    val algorithm: String,\n    val maxResults: Int,\n    val minScore: Double\n) {\n    init {\n        require(algorithm in setOf(\"collaborative\", \"content\", \"hybrid\"))\n        require(maxResults in 1..100)\n        require(minScore in 0.0..1.0)\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#version-your-types","title":"Version Your Types","text":"<p>When types evolve, handle versioning:</p> <pre><code>sealed class ConfigVersion {\n    data class V1(val timeout: Int) : ConfigVersion()\n    data class V2(\n        val timeout: Int,\n        val retries: Int\n    ) : ConfigVersion()\n}\n\nobject ConfigVersionType : ValueType&lt;ConfigVersion&gt; {\n    override fun deserialize(value: String): ConfigVersion {\n        val json = Json.parseToJsonElement(value).jsonObject\n        return when (json[\"version\"]?.jsonPrimitive?.int) {\n            1 -&gt; ConfigVersion.V1(\n                timeout = json[\"timeout\"]!!.jsonPrimitive.int\n            )\n            2 -&gt; ConfigVersion.V2(\n                timeout = json[\"timeout\"]!!.jsonPrimitive.int,\n                retries = json[\"retries\"]!!.jsonPrimitive.int\n            )\n            else -&gt; throw IllegalArgumentException(\"Unknown version\")\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Migration strategies for evolving flag configurations</li> <li>Explore Patch Updates for dynamic configuration changes</li> <li>Review the Serialization API for complete details</li> </ul>"},{"location":"advanced/migration/","title":"Migration Strategies","text":"<p>As your application evolves, you'll need to migrate feature flag configurations. This guide covers strategies for:</p> <ul> <li>Updating flag schemas</li> <li>Migrating between versions</li> <li>Deprecating old flags</li> <li>Evolving configuration structures</li> </ul>"},{"location":"advanced/migration/#schema-evolution","title":"Schema Evolution","text":""},{"location":"advanced/migration/#adding-new-flags","title":"Adding New Flags","text":"<p>New flags can be added without breaking existing configurations:</p> <pre><code>// Original configuration\nval originalFlags = listOf(\n    Flag(\"feature-a\", defaultValue = true),\n    Flag(\"feature-b\", defaultValue = false)\n)\n\n// Add new flag\nval updatedFlags = originalFlags + Flag(\n    \"feature-c\",\n    defaultValue = true\n)\n</code></pre> <p>When deserializing old configurations, new flags use their default values:</p> <pre><code>val serializer = SnapshotSerializer()\n\n// Register all flags (including new ones)\nupdatedFlags.forEach { serializer.register(it) }\n\n// Load old configuration\nval oldSnapshot = loadFromStorage()\nserializer.deserialize(oldSnapshot) // feature-c uses default value\n</code></pre>"},{"location":"advanced/migration/#removing-flags","title":"Removing Flags","text":"<p>To remove a flag safely:</p> <ol> <li>Mark as deprecated (optional documentation step)</li> <li>Stop using in code</li> <li>Remove after grace period</li> </ol> <pre><code>// Step 1: Mark as deprecated\n@Deprecated(\"Use feature-c instead\", ReplaceWith(\"feature-c\"))\nval deprecatedFlag = Flag(\"old-feature\", defaultValue = false)\n\n// Step 2: Migration period - both flags exist\nval currentFlags = listOf(\n    deprecatedFlag,\n    Flag(\"new-feature\", defaultValue = false)\n)\n\n// Step 3: Remove old flag (after users have migrated)\nval cleanFlags = listOf(\n    Flag(\"new-feature\", defaultValue = false)\n)\n</code></pre>"},{"location":"advanced/migration/#renaming-flags","title":"Renaming Flags","text":"<p>Create a migration function to rename flags in stored configurations:</p> <pre><code>fun migrateRenamedFlag(\n    konfig: SerializableSnapshot,\n    oldName: String,\n    newName: String\n): SerializableSnapshot {\n    val updatedFlags = konfig.flags.map { flag -&gt;\n        if (flag.id == oldName) {\n            flag.copy(id = newName)\n        } else {\n            flag\n        }\n    }\n    return konfig.copy(flags = updatedFlags)\n}\n\n// Usage\nval oldSnapshot = loadFromStorage()\nval migratedSnapshot = migrateRenamedFlag(\n    oldSnapshot,\n    oldName = \"oldFeatureName\",\n    newName = \"newFeatureName\"\n)\nserializer.deserialize(migratedSnapshot)\n</code></pre>"},{"location":"advanced/migration/#type-migrations","title":"Type Migrations","text":""},{"location":"advanced/migration/#changing-value-types","title":"Changing Value Types","text":"<p>When changing a flag's value type, provide a conversion function:</p> <pre><code>// Original: Boolean flag\nval oldFlag = Flag(\"max-connections\", defaultValue = false)\n\n// New: Int flag\nval newFlag = Flag(\"max-connections\", defaultValue = 10)\n\nfun migrateBooleanToInt(konfig: SerializableSnapshot): SerializableSnapshot {\n    val updatedFlags = konfig.flags.map { flag -&gt;\n        if (flag.id == \"max-connections\" &amp;&amp; flag.type == \"Boolean\") {\n            flag.copy(\n                type = \"Int\",\n                value = if (flag.value.toBoolean()) \"100\" else \"10\"\n            )\n        } else {\n            flag\n        }\n    }\n    return konfig.copy(flags = updatedFlags)\n}\n</code></pre>"},{"location":"advanced/migration/#complex-type-evolution","title":"Complex Type Evolution","text":"<p>For custom types, handle versioning in your ValueType implementation:</p> <pre><code>// Version 1\ndata class ConfigV1(val timeout: Int)\n\n// Version 2 - added retries\ndata class ConfigV2(val timeout: Int, val retries: Int)\n\nobject ConfigType : ValueType&lt;ConfigV2&gt; {\n    override val name = \"Config\"\n\n    override fun deserialize(value: String): ConfigV2 {\n        val json = Json.parseToJsonElement(value).jsonObject\n\n        // Check version\n        return when (json[\"version\"]?.jsonPrimitive?.int) {\n            1 -&gt; {\n                // Migrate from V1\n                ConfigV2(\n                    timeout = json[\"timeout\"]!!.jsonPrimitive.int,\n                    retries = 3 // Default value for new field\n                )\n            }\n            2, null -&gt; {\n                // V2 or assume current version if no version field\n                ConfigV2(\n                    timeout = json[\"timeout\"]!!.jsonPrimitive.int,\n                    retries = json[\"retries\"]?.jsonPrimitive?.int ?: 3\n                )\n            }\n            else -&gt; throw IllegalArgumentException(\"Unknown version\")\n        }\n    }\n\n    override fun serialize(value: ConfigV2): String {\n        val json = buildJsonObject {\n            put(\"version\", 2)\n            put(\"timeout\", value.timeout)\n            put(\"retries\", value.retries)\n        }\n        return json.toString()\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#version-based-migrations","title":"Version-Based Migrations","text":""},{"location":"advanced/migration/#migration-manager","title":"Migration Manager","text":"<p>Create a migration manager to handle version transitions:</p> <pre><code>class MigrationManager {\n    private val migrations = mutableMapOf&lt;String, (SerializableSnapshot) -&gt; SerializableSnapshot&gt;()\n\n    fun register(version: String, migration: (SerializableSnapshot) -&gt; SerializableSnapshot) {\n        migrations[version] = migration\n    }\n\n    fun migrate(konfig: SerializableSnapshot, targetVersion: String): SerializableSnapshot {\n        var current = konfig\n        val currentVersion = parseVersion(konfig.version.value)\n        val target = parseVersion(targetVersion)\n\n        migrations\n            .filter { (version, _) -&gt;\n                val v = parseVersion(version)\n                v &gt; currentVersion &amp;&amp; v &lt;= target\n            }\n            .toSortedMap()\n            .forEach { (_, migration) -&gt;\n                current = migration(current)\n            }\n\n        return current.copy(version = SerializableVersion(targetVersion))\n    }\n\n    private fun parseVersion(version: String): Int {\n        return version.replace(\".\", \"\").toIntOrNull() ?: 0\n    }\n}\n\n// Usage\nval migrationManager = MigrationManager()\n\nmigrationManager.register(\"1.1.0\") { konfig -&gt;\n    // Migration for 1.1.0\n    migrateRenamedFlag(konfig, \"old-name\", \"new-name\")\n}\n\nmigrationManager.register(\"1.2.0\") { konfig -&gt;\n    // Migration for 1.2.0\n    migrateBooleanToInt(konfig)\n}\n\n// Apply migrations\nval oldSnapshot = loadFromStorage()\nval migratedSnapshot = migrationManager.migrate(oldSnapshot, \"1.2.0\")\n</code></pre>"},{"location":"advanced/migration/#backward-compatibility","title":"Backward Compatibility","text":""},{"location":"advanced/migration/#maintain-old-flag-ids","title":"Maintain Old Flag IDs","text":"<p>Keep a mapping of old to new flag IDs:</p> <pre><code>class FlagRegistry {\n    private val flags = mutableMapOf&lt;String, Flag&lt;*&gt;&gt;()\n    private val aliases = mutableMapOf&lt;String, String&gt;()\n\n    fun register(flag: Flag&lt;*&gt;, vararg aliasIds: String) {\n        flags[flag.id] = flag\n        aliasIds.forEach { alias -&gt;\n            aliases[alias] = flag.id\n        }\n    }\n\n    fun get(id: String): Flag&lt;*&gt;? {\n        val actualId = aliases[id] ?: id\n        return flags[actualId]\n    }\n}\n\n// Usage\nval registry = FlagRegistry()\nregistry.register(\n    Flag(\"new-feature-name\", defaultValue = true),\n    \"old-feature-name\", // Alias for backward compatibility\n    \"legacy-name\"       // Another alias\n)\n</code></pre>"},{"location":"advanced/migration/#graceful-degradation","title":"Graceful Degradation","text":"<p>Handle missing or invalid flags gracefully:</p> <pre><code>fun &lt;T&gt; safeEvaluate(\n    flagId: String,\n    defaultValue: T,\n    context: EvaluationContext = EvaluationContext()\n): T {\n    return try {\n        val flag = registry.get(flagId) as? Flag&lt;T&gt;\n        flag?.evaluate(context) ?: defaultValue\n    } catch (e: Exception) {\n        logger.warn(\"Failed to evaluate flag $flagId: ${e.message}\")\n        defaultValue\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#rolling-migrations","title":"Rolling Migrations","text":"<p>For large deployments, use rolling migrations:</p>"},{"location":"advanced/migration/#phase-1-dual-write","title":"Phase 1: Dual Write","text":"<p>Write to both old and new flags:</p> <pre><code>fun updateFeatureFlag(enabled: Boolean) {\n    // Update old flag\n    oldFlag.setValue(enabled)\n\n    // Update new flag\n    newFlag.setValue(enabled)\n\n    // Persist both\n    persistFlags()\n}\n</code></pre>"},{"location":"advanced/migration/#phase-2-dual-read","title":"Phase 2: Dual Read","text":"<p>Read from new flag, fall back to old:</p> <pre><code>fun isFeatureEnabled(): Boolean {\n    return try {\n        newFlag.evaluate()\n    } catch (e: Exception) {\n        logger.warn(\"Failed to read new flag, falling back to old\")\n        oldFlag.evaluate()\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#phase-3-deprecate-old","title":"Phase 3: Deprecate Old","text":"<p>After all instances are updated:</p> <pre><code>fun isFeatureEnabled(): Boolean {\n    return newFlag.evaluate()\n}\n</code></pre>"},{"location":"advanced/migration/#phase-4-remove-old","title":"Phase 4: Remove Old","text":"<p>Clean up old flag completely.</p>"},{"location":"advanced/migration/#testing-migrations","title":"Testing Migrations","text":""},{"location":"advanced/migration/#unit-tests","title":"Unit Tests","text":"<pre><code>@Test\nfun `test flag rename migration`() {\n    val oldSnapshot = SerializableSnapshot(\n        version = SerializableVersion(\"1.0.0\"),\n        flags = listOf(\n            SerializableFlag(\n                id = \"old-name\",\n                type = \"Boolean\",\n                value = \"true\"\n            )\n        )\n    )\n\n    val migrated = migrateRenamedFlag(oldSnapshot, \"old-name\", \"new-name\")\n\n    assertEquals(\"new-name\", migrated.flags.first().id)\n    assertEquals(\"true\", migrated.flags.first().value)\n}\n</code></pre>"},{"location":"advanced/migration/#integration-tests","title":"Integration Tests","text":"<pre><code>@Test\nfun `test full migration pipeline`() {\n    val serializer = SnapshotSerializer()\n    val migrationManager = MigrationManager()\n\n    // Setup migrations\n    setupMigrations(migrationManager)\n\n    // Load old config\n    val oldConfig = loadTestConfig(\"v1.0.0\")\n\n    // Migrate\n    val migrated = migrationManager.migrate(oldConfig, \"2.0.0\")\n\n    // Deserialize and verify\n    serializer.deserialize(migrated)\n\n    // Verify all flags work correctly\n    assertTrue(featureFlag.evaluate())\n}\n</code></pre>"},{"location":"advanced/migration/#best-practices","title":"Best Practices","text":""},{"location":"advanced/migration/#document-migrations","title":"Document Migrations","text":"<pre><code>/**\n * Migration 1.5.0 -&gt; 1.6.0\n *\n * Changes:\n * - Renamed `maxConnections` to `connectionLimit`\n * - Changed `enableCache` from Boolean to CacheConfig\n * - Removed deprecated `oldFeature` flag\n *\n * Backward compatibility: Maintains aliases for old flag names\n */\nfun migrateToV1_6_0(konfig: SerializableSnapshot): SerializableSnapshot {\n    // Migration implementation\n}\n</code></pre>"},{"location":"advanced/migration/#version-everything","title":"Version Everything","text":"<pre><code>data class SerializableSnapshot(\n    val version: SerializableVersion,\n    val schemaVersion: Int = CURRENT_SCHEMA_VERSION,\n    val flags: List&lt;SerializableFlag&gt;\n) {\n    companion object {\n        const val CURRENT_SCHEMA_VERSION = 3\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#test-migrations-thoroughly","title":"Test Migrations Thoroughly","text":"<ul> <li>Test migration from every previous version</li> <li>Test with missing fields</li> <li>Test with invalid data</li> <li>Test rollback scenarios</li> </ul>"},{"location":"advanced/migration/#provide-migration-tools","title":"Provide Migration Tools","text":"<pre><code>// CLI tool for offline migration\nfun main(args: Array&lt;String&gt;) {\n    val inputFile = args[0]\n    val outputFile = args[1]\n    val targetVersion = args[2]\n\n    val konfig = loadSnapshot(inputFile)\n    val migrated = migrationManager.migrate(konfig, targetVersion)\n    saveSnapshot(outputFile, migrated)\n\n    println(\"Migrated from ${konfig.version} to $targetVersion\")\n}\n</code></pre>"},{"location":"advanced/migration/#next-steps","title":"Next Steps","text":"<ul> <li>Review Patch Updates for incremental configuration changes</li> <li>Learn about Custom Types for complex flag values</li> <li>Explore the Serialization API for complete details</li> </ul>"},{"location":"advanced/patch-updates/","title":"Patch Updates","text":"<p>Patch updates allow you to modify feature flag configurations incrementally without replacing the entire konfig. This is useful for:</p> <ul> <li>Incremental updates: Apply small changes without re-deploying entire configurations</li> <li>Real-time adjustments: Update specific flags in production</li> <li>Efficient syncing: Minimize bandwidth by sending only changes</li> <li>Version control: Track configuration changes over time</li> </ul>"},{"location":"advanced/patch-updates/#what-is-a-snapshotpatch","title":"What is a SnapshotPatch?","text":"<p>A <code>SnapshotPatch</code> represents a set of incremental changes to apply to a <code>Snapshot</code>. Instead of sending a complete konfig, you send only the differences:</p> <pre><code>import io.amichne.konditional.core.instance.KonfigPatch\nimport io.amichne.konditional.core.instance.Konfig// Create a patch from current konfig\nval patch = KonfigPatch.from(currentKonfig) {\n    // Add or update flags\n    add(MY_FLAG to newFlagDefinition)\n    add(OTHER_FLAG to anotherDefinition)\n\n    // Remove flags\n    remove(OLD_FLAG)\n    remove(DEPRECATED_FLAG)\n}\n</code></pre>"},{"location":"advanced/patch-updates/#creating-patches","title":"Creating Patches","text":""},{"location":"advanced/patch-updates/#using-the-builder-dsl","title":"Using the Builder DSL","text":"<p>The recommended way to create patches is using the builder DSL:</p> <pre><code>import io.amichne.konditional.builders.ConfigBuilder\nimport io.amichne.konditional.core.SingletonFlagRegistry\n\n// Get current konfig\nval current = SingletonFlagRegistry.getCurrentSnapshot()\n\n// Build patch with DSL\nval patch = SnapshotPatch.from(current) {\n    // Update a flag's definition\n    add(Features.DARK_MODE to ConfigBuilder.buildDefinition(Features.DARK_MODE) {\n        default(true)\n        rule {\n            platforms(Platform.ANDROID)\n        } implies false\n    })\n\n    // Remove old flag\n    remove(Features.OLD_FEATURE)\n}\n</code></pre>"},{"location":"advanced/patch-updates/#empty-patch","title":"Empty Patch","text":"<p>Create an empty patch with no changes:</p> <pre><code>val emptyPatch = SnapshotPatch.empty()\n</code></pre>"},{"location":"advanced/patch-updates/#applying-patches","title":"Applying Patches","text":""},{"location":"advanced/patch-updates/#to-singletonflagregistry","title":"To SingletonFlagRegistry","text":"<p>Apply a patch to the singleton registry:</p> <pre><code>import io.amichne.konditional.core.SingletonFlagRegistry\n\n// Apply patch atomically\nSingletonFlagRegistry.applyPatch(patch)\n\n// Flags are immediately updated\n</code></pre>"},{"location":"advanced/patch-updates/#to-custom-registry","title":"To Custom Registry","text":"<p>Apply a patch to any FlagRegistry implementation:</p> <pre><code>import io.amichne.konditional.core.FlagRegistry\n\nval customRegistry: FlagRegistry = MyCustomRegistry()\ncustomRegistry.applyPatch(patch)\n</code></pre>"},{"location":"advanced/patch-updates/#to-a-snapshot","title":"To a Snapshot","text":"<p>Apply a patch to create a new konfig without loading it:</p> <pre><code>val currentKonfig = SingletonFlagRegistry.getCurrentSnapshot()\nval updatedSnapshot = patch.applyTo(currentKonfig)\n\n// Save to file, send over network, etc.\n</code></pre>"},{"location":"advanced/patch-updates/#patch-structure","title":"Patch Structure","text":"<p>A <code>SnapshotPatch</code> contains:</p> <pre><code>data class SnapshotPatch(\n    val flags: Map&lt;Conditional&lt;*, *&gt;, ContextualFeatureFlag&lt;*, *&gt;&gt;,\n    val removeKeys: Set&lt;Conditional&lt;*, *&gt;&gt;\n)\n</code></pre> <ul> <li>flags: Map of flags to add or update</li> <li>removeKeys: Set of flag keys to remove</li> </ul> <p>The patch application logic: 1. Removes all flags specified in <code>removeKeys</code> 2. Adds/updates all flags in the <code>flags</code> map 3. Leaves other flags unchanged</p>"},{"location":"advanced/patch-updates/#serialization","title":"Serialization","text":""},{"location":"advanced/patch-updates/#serialize-a-patch","title":"Serialize a Patch","text":"<p>Convert a patch to JSON for storage or transmission:</p> <pre><code>import io.amichne.konditional.core.konfig.SnapshotPatch.Companion.toJson\nimport io.amichne.konditional.serialization.SnapshotSerializer\n\nval serializer = SnapshotSerializer.default\nval patchJson = patch.toJson(serializer)\n\n// Save to file\nFile(\"patch.json\").writeText(patchJson)\n\n// Send over network\nhttpClient.post(\"/patches\", patchJson)\n</code></pre>"},{"location":"advanced/patch-updates/#deserialize-a-patch","title":"Deserialize a Patch","text":"<p>Load a patch from JSON:</p> <pre><code>import io.amichne.konditional.core.konfig.SnapshotPatch.Companion.fromJson\n\nval patchJson = File(\"patch.json\").readText()\nval patch = SnapshotPatch.fromJson(patchJson, serializer)\n\n// Apply to registry\nSingletonFlagRegistry.applyPatch(patch)\n</code></pre>"},{"location":"advanced/patch-updates/#best-practices","title":"Best Practices","text":""},{"location":"advanced/patch-updates/#1-atomic-updates","title":"1. Atomic Updates","text":"<p>The <code>applyPatch</code> method uses atomic operations internally:</p> <pre><code>// \u2705 Thread-safe - uses atomic compare-and-swap\nSingletonFlagRegistry.applyPatch(patch)\n\n// This is safe even with concurrent evaluations\nval value = context.evaluate(MY_FLAG)\n</code></pre>"},{"location":"advanced/patch-updates/#2-version-control","title":"2. Version Control","text":"<p>Track patch history for auditing and rollback:</p> <pre><code>data class PatchRecord(\n    val patch: SnapshotPatch,\n    val timestamp: Instant,\n    val author: String,\n    val description: String\n)\n\nobject PatchHistory {\n    private val history = mutableListOf&lt;PatchRecord&gt;()\n\n    fun applyAndRecord(patch: SnapshotPatch, author: String, description: String) {\n        // Save konfig before applying\n        val before = SingletonFlagRegistry.getCurrentSnapshot()\n\n        try {\n            SingletonFlagRegistry.applyPatch(patch)\n            history.add(PatchRecord(patch, Instant.now(), author, description))\n        } catch (e: Exception) {\n            // Rollback on error\n            SingletonFlagRegistry.load(before)\n            throw e\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/patch-updates/#3-test-patches-before-production","title":"3. Test Patches Before Production","text":"<p>Always test patches in a non-production environment:</p> <pre><code>// Create test konfig\nval testSnapshot = productionSnapshot.copy()\n\n// Apply patch to test\nval result = patch.applyTo(testSnapshot)\n\n// Verify the result\nval testContext = createTestContext()\nresult.flags.forEach { (key, flag) -&gt;\n    val value = flag.evaluate(testContext)\n    println(\"$key -&gt; $value\")\n}\n</code></pre>"},{"location":"advanced/patch-updates/#4-keep-patches-small","title":"4. Keep Patches Small","text":"<p>Prefer multiple small patches over large ones:</p> <pre><code>// \u2705 Good: Small, focused patches\nval patch1 = SnapshotPatch.from(current) {\n    add(Features.NEW_UI to definition)\n}\n\nval patch2 = SnapshotPatch.from(current) {\n    remove(Features.OLD_UI)\n}\n\nSingletonFlagRegistry.applyPatch(patch1)\nSingletonFlagRegistry.applyPatch(patch2)\n\n// \u274c Bad: Large, unfocused patch with many changes\nval megaPatch = SnapshotPatch.from(current) {\n    // 50+ changes...\n}\n</code></pre>"},{"location":"advanced/patch-updates/#common-use-cases","title":"Common Use Cases","text":""},{"location":"advanced/patch-updates/#gradual-rollout-adjustment","title":"Gradual Rollout Adjustment","text":"<p>Adjust rollout percentages dynamically:</p> <pre><code>// Start with 10% rollout\nconfig {\n    Features.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.of(10.0)\n        } implies true\n    }\n}\n\n// Later, increase to 50%\nval patch = SnapshotPatch.from(SingletonFlagRegistry.getCurrentSnapshot()) {\n    add(Features.NEW_CHECKOUT to ConfigBuilder.buildDefinition(Features.NEW_CHECKOUT) {\n        default(false)\n        rule {\n            rollout = Rollout.of(50.0)\n        } implies true\n    })\n}\nSingletonFlagRegistry.applyPatch(patch)\n</code></pre>"},{"location":"advanced/patch-updates/#emergency-kill-switch","title":"Emergency Kill Switch","text":"<p>Quickly disable a problematic feature:</p> <pre><code>val emergencyPatch = SnapshotPatch.from(SingletonFlagRegistry.getCurrentSnapshot()) {\n    add(Features.PROBLEMATIC_FEATURE to ConfigBuilder.buildDefinition(Features.PROBLEMATIC_FEATURE) {\n        default(false)  // Force disable\n    })\n}\n\nSingletonFlagRegistry.applyPatch(emergencyPatch)\n</code></pre>"},{"location":"advanced/patch-updates/#remote-configuration-updates","title":"Remote Configuration Updates","text":"<p>Poll for updates from a remote server:</p> <pre><code>class RemoteConfigSync(\n    private val apiClient: ApiClient,\n    private val serializer: SnapshotSerializer\n) {\n    suspend fun sync() {\n        try {\n            // Fetch latest patch from server\n            val patchJson = apiClient.fetchLatestPatch()\n\n            // Deserialize and apply\n            val patch = SnapshotPatch.fromJson(patchJson, serializer)\n            SingletonFlagRegistry.applyPatch(patch)\n\n            logger.info(\"Successfully applied remote patch\")\n        } catch (e: Exception) {\n            logger.error(\"Failed to sync remote config\", e)\n        }\n    }\n}\n\n// Schedule periodic sync\nscheduler.scheduleAtFixedRate(\n    initialDelay = 0,\n    period = 5,\n    unit = TimeUnit.MINUTES\n) {\n    remoteConfigSync.sync()\n}\n</code></pre>"},{"location":"advanced/patch-updates/#ab-test-lifecycle","title":"A/B Test Lifecycle","text":"<p>Manage A/B tests through their lifecycle:</p> <pre><code>// Phase 1: Start test at 50/50\nval startPatch = SnapshotPatch.from(current) {\n    add(Features.EXPERIMENT to ConfigBuilder.buildDefinition(Features.EXPERIMENT) {\n        default(false)\n        rule {\n            rollout = Rollout.of(50.0)\n        } implies true\n    })\n}\n\n// Phase 2: Winning variant found, roll out to 100%\nval expandPatch = SnapshotPatch.from(current) {\n    add(Features.EXPERIMENT to ConfigBuilder.buildDefinition(Features.EXPERIMENT) {\n        default(true)  // Winner becomes default\n    })\n}\n\n// Phase 3: Remove experiment, make it permanent\nval finalizePatch = SnapshotPatch.from(current) {\n    remove(Features.EXPERIMENT)\n    add(Features.NEW_FEATURE to ConfigBuilder.buildDefinition(Features.NEW_FEATURE) {\n        default(true)\n    })\n}\n</code></pre>"},{"location":"advanced/patch-updates/#integration-with-serialization","title":"Integration with Serialization","text":"<p>Patches integrate seamlessly with the serialization module:</p> <pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\nimport io.amichne.konditional.core.konfig.SnapshotPatch.Companion.toJson\nimport io.amichne.konditional.core.konfig.SnapshotPatch.Companion.fromJson\n\nval serializer = SnapshotSerializer.default\n\n// Serialize\nval json = patch.toJson(serializer)\n\n// Deserialize\nval loaded = SnapshotPatch.fromJson(json, serializer)\n\n// Apply\nSingletonFlagRegistry.applyPatch(loaded)\n</code></pre>"},{"location":"advanced/patch-updates/#thread-safety","title":"Thread Safety","text":"<p>All patch operations are thread-safe:</p> <pre><code>// Thread 1: Apply patch\nCoroutineScope(Dispatchers.IO).launch {\n    SingletonFlagRegistry.applyPatch(patch)\n}\n\n// Thread 2: Evaluate flag (safe during patch application)\nCoroutineScope(Dispatchers.Main).launch {\n    val value = context.evaluate(Features.MY_FLAG)\n    updateUI(value)\n}\n</code></pre> <p>The <code>SingletonFlagRegistry</code> uses atomic operations (<code>AtomicReference.updateAndGet</code>) to ensure: - Patches are applied atomically - Readers never see partial updates - Multiple concurrent patches are handled safely</p>"},{"location":"advanced/patch-updates/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Custom Types for advanced flag values</li> <li>Explore Context Polymorphism for custom contexts</li> <li>Review the Serialization API for complete details</li> <li>See Architecture for implementation details</li> </ul>"},{"location":"getting-started/introduction/","title":"Introduction to Konditional","text":"<p>Konditional is a type-safe, deterministic feature flag library for Kotlin that provides compile-time safety and runtime flexibility for managing feature flags in your applications.</p>"},{"location":"getting-started/introduction/#what-are-feature-flags","title":"What are Feature Flags?","text":"<p>Feature flags (also known as feature toggles) are a software development technique that allows you to enable or disable features without deploying new code. This enables:</p> <ul> <li>Progressive rollouts: Deploy features to a subset of users</li> <li>A/B testing: Test different implementations with different user groups</li> <li>Emergency kill switches: Quickly disable problematic features</li> <li>Development flexibility: Work on features behind flags before they're ready</li> </ul>"},{"location":"getting-started/introduction/#why-konditional","title":"Why Konditional?","text":""},{"location":"getting-started/introduction/#type-safe","title":"Type-Safe","text":"<p>Konditional leverages Kotlin's powerful type system to provide compile-time safety:</p> <ul> <li>No stringly-typed APIs: Feature flags are defined as enum values implementing <code>Conditional&lt;S, C&gt;</code></li> <li>Generic type parameters: Value type <code>S</code> and context type <code>C</code> flow through the entire system</li> <li>IDE support: Full autocomplete and refactoring support across your codebase</li> <li>No runtime casting: Type safety guaranteed by the compiler</li> </ul> <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// Compile-time type safety - returns Boolean\nval isEnabled: Boolean = context.evaluate(Features.DARK_MODE)\n</code></pre>"},{"location":"getting-started/introduction/#deterministic","title":"Deterministic","text":"<p>Flag evaluation uses SHA-256 based bucketing for consistent user experiences:</p> <ul> <li>Stable bucketing: Same user + flag combination always produces the same result</li> <li>Independent rollouts: Different flags produce independent bucket assignments</li> <li>Granular control: 0.1% precision for gradual rollouts (1000 buckets)</li> <li>Predictable rules: Clear specificity-based rule ordering</li> </ul> <pre><code>config {\n    Features.NEW_UI with {\n        default(false)\n        rule {\n            rollout = Rollout.of(25.0)  // 25% of users\n        } implies true\n    }\n}\n</code></pre>"},{"location":"getting-started/introduction/#parse-dont-validate","title":"Parse, Don't Validate","text":"<p>Konditional follows the \"Parse, Don't Validate\" principle for robust error handling:</p> <ul> <li>Structured errors: <code>ParseResult&lt;T&gt;</code> instead of throwing exceptions</li> <li>Type-safe values: Domain types encode invariants (e.g., <code>Rollout</code>, <code>Version</code>)</li> <li>Illegal states unrepresentable: Sealed classes prevent invalid configurations</li> <li>Explicit error handling: Pattern match on success/failure cases</li> </ul> <pre><code>flowchart TD\n    subgraph \"Traditional Validation (Anti-Pattern)\"\n        INPUT1[Raw Input: String]\n        VALIDATE1[Validate: check constraints]\n        PASS1{Valid?}\n        PASS1 --&gt;|Yes| USE1[Use String directly]\n        PASS1 --&gt;|No| ERROR1[Throw Exception]\n        USE1 --&gt; RECHECK1[Re-validate later?]\n\n        style VALIDATE1 fill:#f8d7da\n        style RECHECK1 fill:#f8d7da\n    end\n\n    subgraph \"Parse, Don't Validate (Konditional)\"\n        INPUT2[Raw Input: String]\n        PARSE[Parse into Domain Type]\n        RESULT{ParseResult}\n        RESULT --&gt;|Success| DOMAIN[Typed Domain Objecte.g., Version, Rollout]\n        RESULT --&gt;|Failure| ERROR2[ParseErrorStructured Error]\n        DOMAIN --&gt; USE2[Use with ConfidenceNo Re-checking]\n\n        style PARSE fill:#d4edda\n        style DOMAIN fill:#d4edda\n        style USE2 fill:#d4edda\n    end\n</code></pre> <p>Benefits: - Type Safety: Constraints encoded in types - No Redundant Checks: Parse once at boundary - Composability: Parsed types compose cleanly - Explicit Errors: Structured error types - Compiler Support: Type system prevents misuse</p> <pre><code>when (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n    is ParseResult.Failure -&gt; {\n        when (val error = result.error) {\n            is ParseError.InvalidJson -&gt; log.error(\"Bad JSON: ${error.message}\")\n            is ParseError.ConditionalNotFound -&gt; log.error(\"Unknown flag: ${error.key}\")\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/introduction/#composable-architecture","title":"Composable Architecture","text":"<p>Build reusable evaluation logic through the <code>Evaluable&lt;C&gt;</code> abstraction:</p> <ul> <li>Standard targeting: Locale, platform, version constraints via <code>BaseEvaluable</code></li> <li>Custom logic: Extend <code>Evaluable&lt;C&gt;</code> for domain-specific targeting</li> <li>Rule composition: Combine multiple evaluators with clear semantics</li> <li>Additive specificity: Rule precedence calculated automatically</li> </ul> <pre><code>class PremiumUserEvaluable : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext) =\n        context.subscriptionTier == SubscriptionTier.PREMIUM\n    override fun specificity() = 1\n}\n\nrule {\n    platforms(Platform.IOS)\n    extension { PremiumUserEvaluable() }\n} implies true\n</code></pre>"},{"location":"getting-started/introduction/#serializable","title":"Serializable","text":"<p>Export and import flag configurations with type-safe JSON serialization:</p> <ul> <li>Remote configuration: Load flags from servers or CDNs</li> <li>Incremental updates: Apply patches without full replacement</li> <li>Type preservation: <code>FlagValue&lt;T&gt;</code> sealed class maintains type safety</li> <li>Round-trip guarantee: Serialized configs behave identically to programmatic ones</li> </ul> <pre><code>val serializer = SnapshotSerializer()\n\n// Serialize\nval json = serializer.serialize(FlagRegistry.konfig())\n\n// Deserialize with error handling\nwhen (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre>"},{"location":"getting-started/introduction/#flexible","title":"Flexible","text":"<p>Support for diverse use cases:</p> <ul> <li>Version ranges: Target specific app versions with <code>VersionRange</code> sealed class</li> <li>Custom value types: Use any type for flag values (Boolean, String, Int, custom objects)</li> <li>Custom contexts: Extend <code>Context</code> with domain-specific fields</li> <li>Complex targeting: Combine multiple criteria with rollout percentages</li> </ul>"},{"location":"getting-started/introduction/#how-it-works","title":"How It Works","text":"<pre><code>graph LR\n    subgraph \"1. Define\"\n        ENUM[enum class Featuresimplements Conditional]\n    end\n\n    subgraph \"2. Configure\"\n        DSL[ConfigBuilder DSLrules + defaults]\n    end\n\n    subgraph \"3. Evaluate\"\n        CTX[Contextuser + device data]\n        EVAL[Evaluate Flags]\n    end\n\n    subgraph \"4. Result\"\n        VALUE[Typed ValueBoolean, String, etc.]\n    end\n\n    ENUM --&gt; DSL\n    DSL --&gt; EVAL\n    CTX --&gt; EVAL\n    EVAL --&gt; VALUE\n\n    style ENUM fill:#e1f5ff\n    style DSL fill:#fff4e1\n    style CTX fill:#e1f5ff\n    style EVAL fill:#f0e1ff\n    style VALUE fill:#d4edda\n</code></pre>"},{"location":"getting-started/introduction/#konditional-vs-string-based-systems","title":"Konditional vs. String-Based Systems","text":"<pre><code>graph LR\n    subgraph \"String-Based (LaunchDarkly, etc.)\"\n        S1[String Key] --&gt;|runtime lookup| S2{Exists?}\n        S2 --&gt;|No| S3[Runtime Error]\n        S2 --&gt;|Yes| S4[Untyped Value]\n        S4 --&gt;|manual cast| S5[Usage]\n\n        style S3 fill:#f8d7da\n        style S4 fill:#fff3cd\n    end\n\n    subgraph \"Konditional (Type-Safe)\"\n        K1[Typed Enum] --&gt;|compile-time check| K2[Typed Value]\n        K2 --&gt;|direct usage| K3[Usage]\n\n        style K1 fill:#d4edda\n        style K2 fill:#d4edda\n        style K3 fill:#d4edda\n    end\n</code></pre> <p>Konditional Advantages: - Compile-time safety: Typos caught at compile time - Refactoring support: IDE can rename across codebase - Type safety: No runtime casting or type errors - Autocomplete: Full IDE support - No dependencies: Zero external dependencies (except Moshi for serialization)</p>"},{"location":"getting-started/introduction/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/introduction/#flags","title":"Flags","text":"<p>A flag is a typed configuration value that can change based on conditions. Each flag has: - A unique identifier - A value type (Boolean, String, Int, etc.) - A default value - Optional rules for conditional evaluation</p>"},{"location":"getting-started/introduction/#rules","title":"Rules","text":"<p>Rules define when and how flag values should change. Rules can be based on: - Application version - User attributes - Custom conditions - Time-based criteria</p>"},{"location":"getting-started/introduction/#conditions","title":"Conditions","text":"<p>Conditions are the building blocks of rules. They evaluate to true or false based on runtime context.</p>"},{"location":"getting-started/introduction/#getting-started-journey","title":"Getting Started Journey","text":"<pre><code>journey\n    title First-Time Integration Journey (5 minutes)\n    section Setup\n        Add dependency: 5: Developer\n        Create flag enum: 5: Developer\n        Configure flags: 4: Developer\n    section Testing\n        Create test context: 5: Developer\n        Evaluate flags: 5: Developer\n        Verify behavior: 5: Developer\n    section Production\n        Load from JSON: 4: Developer\n        Deploy to prod: 5: Developer\n</code></pre> <p>Time to First Value: ~5 minutes</p>"},{"location":"getting-started/introduction/#step-by-step-path","title":"Step-by-Step Path","text":"<ol> <li>Add Dependency - Include Konditional in your build.gradle</li> <li>Define Flags - Create enum implementing <code>Conditional&lt;S, C&gt;</code></li> <li>Configure - Use <code>ConfigBuilder.config { }</code> DSL</li> <li>Create Context - Provide user/device information</li> <li>Evaluate - Call <code>context.evaluate(FLAG_KEY)</code></li> <li>Deploy - Serialize to JSON for remote configuration</li> </ol> <pre><code>graph LR\n    A[Add Dependency] --&gt; B[Define Flag Enum]\n    B --&gt; C[Configure with DSL]\n    C --&gt; D[Create Context]\n    D --&gt; E[Evaluate Flags]\n    E --&gt; F{Ready forProduction?}\n    F --&gt;|Yes| G[Serialize to JSON]\n    F --&gt;|No| D\n    G --&gt; H[Deploy Configuration]\n\n    style A fill:#e1f5ff\n    style E fill:#d4edda\n    style H fill:#d4edda\n</code></pre>"},{"location":"getting-started/introduction/#next-steps","title":"Next Steps","text":"<p>Continue to the Quick Start guide to begin using Konditional in your project.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Konditional in your Kotlin project.</p>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<p>Add the Konditional dependency to your project:</p>"},{"location":"getting-started/quick-start/#gradle-kotlin-dsl","title":"Gradle (Kotlin DSL)","text":"<pre><code>dependencies {\n    implementation(\"io.amichne:konditional-core:VERSION\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#gradle-groovy","title":"Gradle (Groovy)","text":"<pre><code>dependencies {\n    implementation 'io.amichne:konditional-core:VERSION'\n}\n</code></pre>"},{"location":"getting-started/quick-start/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.amichne&lt;/groupId&gt;\n    &lt;artifactId&gt;konditional-core&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quick-start/#1-define-your-feature-flags","title":"1. Define Your Feature Flags","text":"<p>Create an enum implementing <code>Conditional&lt;S, C&gt;</code> where <code>S</code> is the value type and <code>C</code> is the context type:</p> <pre><code>import io.amichne.konditional.core.Conditional\nimport io.amichne.konditional.core.instance.FlagRegistry\nimport io.amichne.konditional.context.Context\n\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ANALYTICS(\"analytics\");\n\n    override val registry = FlagRegistry\n}\n</code></pre> <p>Note: Each flag must specify which registry it uses. <code>FlagRegistry</code> is the singleton default registry.</p>"},{"location":"getting-started/quick-start/#2-configure-your-flags","title":"2. Configure Your Flags","text":"<p>Use the DSL to configure flag behavior:</p> <pre><code>import io.amichne.konditional.builders.ConfigBuilder.Companion.config\nimport io.amichne.konditional.context.Platform\n\nconfig {\n    Features.DARK_MODE with {\n        default(false)  // Default value when no rules match\n\n        // Enable for iOS users\n        rule {\n            platforms(Platform.IOS)\n        } implies true\n    }\n\n    Features.NEW_CHECKOUT with {\n        default(false)\n\n        // Enable for version 2.0+\n        rule {\n            versions {\n                min(2, 0)\n            }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#3-create-a-context-and-evaluate","title":"3. Create a Context and Evaluate","text":"<p>Create an evaluation context and check flag values:</p> <pre><code>import io.amichne.konditional.core.evaluate\nimport io.amichne.konditional.context.*\nimport io.amichne.konditional.rules.versions.Version\n\n// Create a context with user/app information\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 1, 0),\n    stableId = HexId.from(\"user-123\")\n)\n\n// Evaluate flags - returns typed values\nval isDarkModeEnabled = context.evaluate(Features.DARK_MODE)  // Boolean: true (iOS)\nval isNewCheckout = context.evaluate(Features.NEW_CHECKOUT)   // Boolean: true (v2.0+)\n\nif (isDarkModeEnabled) {\n    applyDarkTheme()\n}\n</code></pre> <p>StableId Types: Use <code>HexId.from(string)</code> to create a stable identifier for deterministic bucketing.</p>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#string-based-flags","title":"String-Based Flags","text":"<p>For configuration values like API endpoints or theme names:</p> <pre><code>enum class Config(override val key: String) : Conditional&lt;String, Context&gt; {\n    API_ENDPOINT(\"api_endpoint\"),\n    THEME_NAME(\"theme_name\");\n\n    override val registry = FlagRegistry\n}\n\nconfig {\n    Config.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n\n        rule {\n            platforms(Platform.WEB)\n        } implies \"https://api.staging.example.com\"\n    }\n}\n\nval endpoint: String = context.evaluate(Config.API_ENDPOINT)\n</code></pre>"},{"location":"getting-started/quick-start/#integer-based-flags","title":"Integer-Based Flags","text":"<p>For numeric limits and thresholds:</p> <pre><code>enum class Limits(override val key: String) : Conditional&lt;Int, Context&gt; {\n    MAX_CONNECTIONS(\"max_connections\"),\n    TIMEOUT_SECONDS(\"timeout_seconds\");\n\n    override val registry = FlagRegistry\n}\n\nconfig {\n    Limits.MAX_CONNECTIONS with {\n        default(10)\n\n        rule {\n            platforms(Platform.WEB)\n        } implies 50\n    }\n}\n\nval maxConnections: Int = context.evaluate(Limits.MAX_CONNECTIONS)\n</code></pre>"},{"location":"getting-started/quick-start/#gradual-rollouts","title":"Gradual Rollouts","text":"<p>Use rollout percentages for gradual feature releases:</p> <pre><code>import io.amichne.konditional.context.Rollout\n\nconfig {\n    Features.NEW_CHECKOUT with {\n        default(false)\n\n        // 25% rollout to iOS users\n        rule {\n            platforms(Platform.IOS)\n            rollout = Rollout.of(25.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#complex-targeting","title":"Complex Targeting","text":"<p>Combine multiple criteria:</p> <pre><code>config {\n    Features.ANALYTICS with {\n        default(false)\n\n        // Enable for US iOS users on v2.0+ with 50% rollout\n        rule {\n            locales(AppLocale.EN_US)\n            platforms(Platform.IOS)\n            versions {\n                min(2, 0)\n            }\n            rollout = Rollout.of(50.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Architecture to understand how Konditional works</li> <li>Explore Conditional Types for using different value types</li> <li>Read about Context Polymorphism to create custom contexts</li> <li>Learn about Serialization to manage flags remotely</li> </ul>"},{"location":"getting-started/quick-start/#example-project","title":"Example Project","text":"<p>For complete working examples, check out the test suite in the GitHub repository.</p>"},{"location":"serialization/api/","title":"API Reference","text":""},{"location":"serialization/api/#overview","title":"Overview","text":"<p>This page documents all public APIs in the Konditional serialization package.</p>"},{"location":"serialization/api/#snapshotserializer","title":"SnapshotSerializer","text":"<p>Main interface for serialization operations.</p>"},{"location":"serialization/api/#class-definition","title":"Class Definition","text":"<pre><code>class SnapshotSerializer(\n    moshi: Moshi = defaultMoshi()\n)\n</code></pre>"},{"location":"serialization/api/#methods","title":"Methods","text":""},{"location":"serialization/api/#serialize","title":"serialize()","text":"<p>Serializes a <code>Snapshot</code> to JSON string.</p> <pre><code>fun serialize(konfig: Snapshot): String\n</code></pre> <p>Parameters: - <code>konfig</code> - The konfig to serialize</p> <p>Returns: Pretty-printed JSON string</p> <p>Example: <pre><code>val serializer = SnapshotSerializer.default\nval json = serializer.serialize(konfig)\n</code></pre></p>"},{"location":"serialization/api/#deserialize","title":"deserialize()","text":"<p>Deserializes JSON string to <code>Snapshot</code>.</p> <pre><code>fun deserialize(json: String): Snapshot\n</code></pre> <p>Parameters: - <code>json</code> - JSON string to deserialize</p> <p>Returns: Deserialized <code>Snapshot</code></p> <p>Throws: - <code>JsonDataException</code> - If JSON is malformed - <code>IllegalArgumentException</code> - If flag keys are not registered</p> <p>Example: <pre><code>val konfig = serializer.deserialize(json)\n</code></pre></p>"},{"location":"serialization/api/#serializepatch","title":"serializePatch()","text":"<p>Serializes a core <code>SnapshotPatch</code> to JSON.</p> <pre><code>fun serializePatch(patch: SnapshotPatch): String\n</code></pre> <p>Parameters: - <code>patch</code> - The SnapshotPatch to serialize</p> <p>Returns: JSON string</p> <p>Example: <pre><code>val patch = SnapshotPatch.from(konfig) {\n    add(MY_FLAG to flagDefinition)\n}\nval json = serializer.serializePatch(patch)\n</code></pre></p>"},{"location":"serialization/api/#deserializepatch","title":"deserializePatch()","text":"<p>Deserializes JSON to a serializable patch.</p> <pre><code>fun deserializePatch(json: String): SerializablePatch\n</code></pre> <p>Parameters: - <code>json</code> - JSON string containing patch</p> <p>Returns: Deserialized SerializablePatch</p> <p>Throws: - <code>JsonDataException</code> - If JSON is malformed</p> <p>Example: <pre><code>val patch = serializer.deserializePatch(patchJson)\n</code></pre></p>"},{"location":"serialization/api/#deserializepatchtocore","title":"deserializePatchToCore()","text":"<p>Deserializes JSON to a core <code>SnapshotPatch</code>.</p> <pre><code>fun deserializePatchToCore(json: String): SnapshotPatch\n</code></pre> <p>Parameters: - <code>json</code> - JSON string containing patch</p> <p>Returns: Deserialized SnapshotPatch</p> <p>Throws: - <code>JsonDataException</code> - If JSON is malformed - <code>IllegalArgumentException</code> - If flag keys are not registered</p> <p>Example: <pre><code>val patch = serializer.deserializePatchToCore(patchJson)\n</code></pre></p>"},{"location":"serialization/api/#applypatch","title":"applyPatch()","text":"<p>Applies a serializable patch to an existing konfig.</p> <pre><code>fun applyPatch(\n    currentKonfig: Snapshot,\n    patch: SerializablePatch\n): Snapshot\n</code></pre> <p>Parameters: - <code>currentKonfig</code> - Snapshot to patch - <code>patch</code> - Patch to apply</p> <p>Returns: New konfig with patch applied</p> <p>Example: <pre><code>val updated = serializer.applyPatch(current, patch)\n</code></pre></p>"},{"location":"serialization/api/#applypatchjson","title":"applyPatchJson()","text":"<p>Applies a patch from JSON to a konfig.</p> <pre><code>fun applyPatchJson(\n    currentKonfig: Snapshot,\n    patchJson: String\n): Snapshot\n</code></pre> <p>Parameters: - <code>currentKonfig</code> - Snapshot to patch - <code>patchJson</code> - JSON string containing patch</p> <p>Returns: New konfig with patch applied</p> <p>Example: <pre><code>val updated = serializer.applyPatchJson(current, patchJson)\n</code></pre></p>"},{"location":"serialization/api/#companion-object","title":"Companion Object","text":""},{"location":"serialization/api/#defaultmoshi","title":"defaultMoshi()","text":"<p>Creates the default Moshi instance.</p> <pre><code>fun defaultMoshi(): Moshi\n</code></pre> <p>Returns: Configured Moshi instance</p>"},{"location":"serialization/api/#default","title":"default","text":"<p>Default serializer instance.</p> <pre><code>val default: SnapshotSerializer\n</code></pre> <p>Example: <pre><code>val serializer = SnapshotSerializer.default\n</code></pre></p>"},{"location":"serialization/api/#flagregistry","title":"FlagRegistry","text":"<p>Interface for managing feature flag configurations and evaluations.</p>"},{"location":"serialization/api/#interface-definition","title":"Interface Definition","text":"<pre><code>interface FlagRegistry {\n    fun load(config: Snapshot)\n    fun applyPatch(patch: SnapshotPatch)\n    fun &lt;S : Any, C : Context&gt; update(definition: FlagDefinition&lt;S, C&gt;)\n    fun getCurrentSnapshot(): Snapshot\n    fun &lt;S : Any, C : Context&gt; getFlag(key: Conditional&lt;S, C&gt;): ContextualFeatureFlag&lt;S, C&gt;?\n    fun getAllFlags(): Map&lt;Conditional&lt;*, *&gt;, ContextualFeatureFlag&lt;*, *&gt;&gt;\n}\n</code></pre>"},{"location":"serialization/api/#methods_1","title":"Methods","text":""},{"location":"serialization/api/#load","title":"load()","text":"<p>Loads a complete flag configuration from the provided konfig.</p> <pre><code>fun load(config: Snapshot)\n</code></pre> <p>Parameters: - <code>config</code> - The Snapshot containing the flag configuration to load</p> <p>Example: <pre><code>val konfig = ConfigBuilder.buildSnapshot {\n    MY_FLAG with { default(true) }\n}\nSingletonFlagRegistry.load(konfig)\n</code></pre></p>"},{"location":"serialization/api/#applypatch_1","title":"applyPatch()","text":"<p>Applies an incremental patch to the current configuration.</p> <pre><code>fun applyPatch(patch: SnapshotPatch)\n</code></pre> <p>Parameters: - <code>patch</code> - The SnapshotPatch to apply</p> <p>Example: <pre><code>val patch = SnapshotPatch.from(SingletonFlagRegistry.getCurrentSnapshot()) {\n    add(MY_FLAG to newDefinition)\n    remove(OLD_FLAG)\n}\nSingletonFlagRegistry.applyPatch(patch)\n</code></pre></p>"},{"location":"serialization/api/#update","title":"update()","text":"<p>Updates a single flag definition in the current configuration.</p> <pre><code>fun &lt;S : Any, C : Context&gt; update(definition: FlagDefinition&lt;S, C&gt;)\n</code></pre> <p>Parameters: - <code>definition</code> - The FlagDefinition to update</p> <p>Example: <pre><code>SingletonFlagRegistry.update(flagDefinition)\n</code></pre></p>"},{"location":"serialization/api/#getcurrentsnapshot","title":"getCurrentSnapshot()","text":"<p>Retrieves the current konfig of all flag configurations.</p> <pre><code>fun getCurrentSnapshot(): Snapshot\n</code></pre> <p>Returns: The current Snapshot</p> <p>Example: <pre><code>val konfig = SingletonFlagRegistry.getCurrentSnapshot()\n</code></pre></p>"},{"location":"serialization/api/#getflag","title":"getFlag()","text":"<p>Retrieves a specific flag definition from the registry.</p> <pre><code>fun &lt;S : Any, C : Context&gt; getFlag(key: Conditional&lt;S, C&gt;): ContextualFeatureFlag&lt;S, C&gt;?\n</code></pre> <p>Parameters: - <code>key</code> - The Conditional key for the flag</p> <p>Returns: The ContextualFeatureFlag if found, null otherwise</p> <p>Example: <pre><code>val flag = SingletonFlagRegistry.getFlag(MY_FLAG)\n</code></pre></p>"},{"location":"serialization/api/#getallflags","title":"getAllFlags()","text":"<p>Retrieves all flags from the registry.</p> <pre><code>fun getAllFlags(): Map&lt;Conditional&lt;*, *&gt;, ContextualFeatureFlag&lt;*, *&gt;&gt;\n</code></pre> <p>Returns: Map of all Conditional keys to their ContextualFeatureFlag definitions</p> <p>Example: <pre><code>val allFlags = SingletonFlagRegistry.getAllFlags()\n</code></pre></p>"},{"location":"serialization/api/#singletonflagregistry","title":"SingletonFlagRegistry","text":"<p>Default singleton implementation of <code>FlagRegistry</code>.</p>"},{"location":"serialization/api/#object-definition","title":"Object Definition","text":"<pre><code>object SingletonFlagRegistry : FlagRegistry\n</code></pre>"},{"location":"serialization/api/#description","title":"Description","text":"<p>Thread-safe, in-memory registry for managing feature flags. Uses <code>AtomicReference</code> to ensure atomic updates and lock-free reads.</p> <p>Example: <pre><code>// Load configuration\nSingletonFlagRegistry.load(konfig)\n\n// Evaluate flags (uses SingletonFlagRegistry by default)\nval value = context.evaluate(MY_FLAG)\n\n// Use custom registry\nval customRegistry: FlagRegistry = MyCustomRegistry()\nval value = context.evaluate(MY_FLAG, customRegistry)\n</code></pre></p>"},{"location":"serialization/api/#conditionalregistry","title":"ConditionalRegistry","text":"<p>Registry for mapping flag keys to <code>Conditional</code> instances.</p>"},{"location":"serialization/api/#methods_2","title":"Methods","text":""},{"location":"serialization/api/#register","title":"register()","text":"<p>Registers a single conditional.</p> <pre><code>fun &lt;S : Any, C : Context&gt; register(conditional: Conditional&lt;S, C&gt;)\n</code></pre> <p>Parameters: - <code>conditional</code> - The conditional to register</p> <p>Example: <pre><code>ConditionalRegistry.register(FeatureFlags.DARK_MODE)\n</code></pre></p>"},{"location":"serialization/api/#registerenum","title":"registerEnum()","text":"<p>Registers all conditionals from an enum.</p> <pre><code>inline fun &lt;reified T&gt; registerEnum()\n    where T : Enum&lt;T&gt;, T : Conditional&lt;*, *&gt;\n</code></pre> <p>Type Parameters: - <code>T</code> - Enum type implementing <code>Conditional</code></p> <p>Example: <pre><code>ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n</code></pre></p>"},{"location":"serialization/api/#get","title":"get()","text":"<p>Retrieves a conditional by key.</p> <pre><code>fun &lt;S : Any, C : Context&gt; get(key: String): Conditional&lt;S, C&gt;\n</code></pre> <p>Parameters: - <code>key</code> - String key to look up</p> <p>Returns: Conditional instance</p> <p>Throws: - <code>IllegalArgumentException</code> - If key not found</p> <p>Example: <pre><code>val flag = ConditionalRegistry.get&lt;Boolean, Context&gt;(\"dark_mode\")\n</code></pre></p>"},{"location":"serialization/api/#contains","title":"contains()","text":"<p>Checks if a key is registered.</p> <pre><code>fun contains(key: String): Boolean\n</code></pre> <p>Parameters: - <code>key</code> - String key to check</p> <p>Returns: <code>true</code> if registered, <code>false</code> otherwise</p> <p>Example: <pre><code>if (ConditionalRegistry.contains(\"dark_mode\")) {\n    // Key is registered\n}\n</code></pre></p>"},{"location":"serialization/api/#clear","title":"clear()","text":"<p>Clears all registrations. For testing only!</p> <pre><code>fun clear()\n</code></pre> <p>Example: <pre><code>@AfterEach\nfun tearDown() {\n    ConditionalRegistry.clear()\n}\n</code></pre></p>"},{"location":"serialization/api/#serializablesnapshot","title":"SerializableSnapshot","text":"<p>Top-level serializable representation.</p>"},{"location":"serialization/api/#data-class","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableSnapshot(\n    val flags: List&lt;SerializableFlag&gt;\n)\n</code></pre>"},{"location":"serialization/api/#fields","title":"Fields","text":"Field Type Description <code>flags</code> <code>List&lt;SerializableFlag&gt;</code> List of flag configurations"},{"location":"serialization/api/#serializableflag","title":"SerializableFlag","text":"<p>Serializable flag configuration.</p>"},{"location":"serialization/api/#data-class_1","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableFlag(\n    val key: String,\n    val type: ValueType,\n    val defaultValue: Any,\n    val default: SerializableRule.SerializableValue,\n    val salt: String = \"v1\",\n    val isActive: Boolean = true,\n    val rules: List&lt;SerializableRule&gt; = emptyList()\n)\n</code></pre>"},{"location":"serialization/api/#fields_1","title":"Fields","text":"Field Type Required Default Description <code>key</code> <code>String</code> Yes - Unique identifier <code>type</code> <code>ValueType</code> Yes - Value type <code>defaultValue</code> <code>Any</code> Yes - Default value (primitive) <code>default</code> <code>SerializableValue</code> Yes - Typed default wrapper <code>salt</code> <code>String</code> No <code>\"v1\"</code> Bucketing salt <code>isActive</code> <code>Boolean</code> No <code>true</code> Active flag <code>rules</code> <code>List&lt;SerializableRule&gt;</code> No <code>[]</code> Targeting rules"},{"location":"serialization/api/#serializablerule","title":"SerializableRule","text":"<p>Serializable targeting rule.</p>"},{"location":"serialization/api/#data-class_2","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableRule(\n    val value: SerializableValue,\n    val rollout: Double = 100.0,\n    val note: String? = null,\n    val locales: Set&lt;String&gt; = emptySet(),\n    val platforms: Set&lt;String&gt; = emptySet(),\n    val versionRange: SerializableVersionRange? = null\n)\n</code></pre>"},{"location":"serialization/api/#fields_2","title":"Fields","text":"Field Type Required Default Description <code>value</code> <code>SerializableValue</code> Yes - Typed value wrapper <code>rollout</code> <code>Double</code> No <code>100.0</code> Percentage 0-100 <code>note</code> <code>String?</code> No <code>null</code> Description <code>locales</code> <code>Set&lt;String&gt;</code> No <code>[]</code> Locale set (empty = all) <code>platforms</code> <code>Set&lt;String&gt;</code> No <code>[]</code> Platform set (empty = all) <code>versionRange</code> <code>SerializableVersionRange?</code> No <code>null</code> Version constraints"},{"location":"serialization/api/#nested-class-serializablevalue","title":"Nested Class: SerializableValue","text":"<pre><code>data class SerializableValue(\n    val value: Any,\n    val type: ValueType\n)\n</code></pre> <p>Wraps a value with its type for type safety.</p>"},{"location":"serialization/api/#serializableversionrange","title":"SerializableVersionRange","text":"<p>Serializable version range.</p>"},{"location":"serialization/api/#data-class_3","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableVersionRange(\n    val type: VersionRangeType,\n    val min: SerializableVersion? = null,\n    val max: SerializableVersion? = null\n)\n</code></pre>"},{"location":"serialization/api/#fields_3","title":"Fields","text":"Field Type Required Description <code>type</code> <code>VersionRangeType</code> Yes Range type <code>min</code> <code>SerializableVersion?</code> Conditional Min version (required for MIN_BOUND, MIN_AND_MAX_BOUND) <code>max</code> <code>SerializableVersion?</code> Conditional Max version (required for MAX_BOUND, MIN_AND_MAX_BOUND)"},{"location":"serialization/api/#serializableversion","title":"SerializableVersion","text":"<p>Serializable version.</p>"},{"location":"serialization/api/#data-class_4","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableVersion(\n    val major: Int,\n    val minor: Int,\n    val patch: Int\n)\n</code></pre>"},{"location":"serialization/api/#fields_4","title":"Fields","text":"Field Type Description <code>major</code> <code>Int</code> Major version <code>minor</code> <code>Int</code> Minor version <code>patch</code> <code>Int</code> Patch version"},{"location":"serialization/api/#serializablepatch","title":"SerializablePatch","text":"<p>Patch update configuration.</p>"},{"location":"serialization/api/#data-class_5","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializablePatch(\n    val flags: List&lt;SerializableFlag&gt;,\n    val removeKeys: List&lt;String&gt; = emptyList()\n)\n</code></pre>"},{"location":"serialization/api/#fields_5","title":"Fields","text":"Field Type Default Description <code>flags</code> <code>List&lt;SerializableFlag&gt;</code> - Flags to add/update <code>removeKeys</code> <code>List&lt;String&gt;</code> <code>[]</code> Flag keys to remove"},{"location":"serialization/api/#enums","title":"Enums","text":""},{"location":"serialization/api/#valuetype","title":"ValueType","text":"<p>Supported value types.</p> <pre><code>enum class ValueType {\n    BOOLEAN,\n    STRING,\n    INT,\n    LONG,\n    DOUBLE\n}\n</code></pre>"},{"location":"serialization/api/#versionrangetype","title":"VersionRangeType","text":"<p>Version range types.</p> <pre><code>enum class VersionRangeType {\n    UNBOUNDED,\n    MIN_BOUND,\n    MAX_BOUND,\n    MIN_AND_MAX_BOUND\n}\n</code></pre>"},{"location":"serialization/api/#snapshotpatch","title":"SnapshotPatch","text":"<p>Represents an incremental update to a Snapshot.</p>"},{"location":"serialization/api/#class-definition_1","title":"Class Definition","text":"<pre><code>data class SnapshotPatch(\n    val flags: Map&lt;Conditional&lt;*, *&gt;, ContextualFeatureFlag&lt;*, *&gt;&gt;,\n    val removeKeys: Set&lt;Conditional&lt;*, *&gt;&gt;\n)\n</code></pre>"},{"location":"serialization/api/#methods_3","title":"Methods","text":""},{"location":"serialization/api/#applyto","title":"applyTo()","text":"<p>Applies the patch to a konfig, creating a new konfig with the changes.</p> <pre><code>fun applyTo(konfig: Snapshot): Snapshot\n</code></pre> <p>Parameters: - <code>konfig</code> - The konfig to apply the patch to</p> <p>Returns: A new Snapshot with the patch applied</p> <p>Example: <pre><code>val updatedSnapshot = patch.applyTo(currentKonfig)\n</code></pre></p>"},{"location":"serialization/api/#companion-object-methods","title":"Companion Object Methods","text":""},{"location":"serialization/api/#from","title":"from()","text":"<p>Creates a new SnapshotPatch using a builder DSL.</p> <pre><code>fun from(current: Snapshot, builder: PatchBuilder.() -&gt; Unit): SnapshotPatch\n</code></pre> <p>Parameters: - <code>current</code> - The current konfig to base the patch on - <code>builder</code> - A builder function to configure the patch</p> <p>Returns: A new SnapshotPatch</p> <p>Example: <pre><code>val patch = SnapshotPatch.from(currentKonfig) {\n    add(MY_FLAG to myFlagDefinition)\n    remove(OLD_FLAG)\n}\n</code></pre></p>"},{"location":"serialization/api/#empty","title":"empty()","text":"<p>Creates an empty patch with no changes.</p> <pre><code>fun empty(): SnapshotPatch\n</code></pre> <p>Returns: An empty SnapshotPatch</p> <p>Example: <pre><code>val patch = SnapshotPatch.empty()\n</code></pre></p>"},{"location":"serialization/api/#tojson","title":"toJson()","text":"<p>Serializes a SnapshotPatch to JSON.</p> <pre><code>fun SnapshotPatch.toJson(\n    serializer: SnapshotSerializer = SnapshotSerializer.default\n): String\n</code></pre> <p>Parameters: - <code>serializer</code> - The serializer to use</p> <p>Returns: JSON string representation of the patch</p> <p>Example: <pre><code>val json = patch.toJson()\n</code></pre></p>"},{"location":"serialization/api/#fromjson","title":"fromJson()","text":"<p>Deserializes a patch from JSON.</p> <pre><code>fun fromJson(\n    json: String,\n    serializer: SnapshotSerializer = SnapshotSerializer.default\n): SnapshotPatch\n</code></pre> <p>Parameters: - <code>json</code> - The JSON string to deserialize - <code>serializer</code> - The serializer to use</p> <p>Returns: A SnapshotPatch</p> <p>Example: <pre><code>val patch = SnapshotPatch.fromJson(patchJson)\n</code></pre></p>"},{"location":"serialization/api/#patchbuilder","title":"PatchBuilder","text":"<p>Builder for creating patches with a DSL-style API.</p>"},{"location":"serialization/api/#add","title":"add()","text":"<p>Adds or updates a flag in the patch.</p> <pre><code>fun &lt;S : Any, C : Context&gt; add(entry: Pair&lt;Conditional&lt;S, C&gt;, ContextualFeatureFlag&lt;S, C&gt;&gt;)\n</code></pre> <p>Parameters: - <code>entry</code> - Pair of Conditional key and its flag definition</p> <p>Example: <pre><code>SnapshotPatch.from(konfig) {\n    add(MY_FLAG to flagDefinition)\n}\n</code></pre></p>"},{"location":"serialization/api/#remove","title":"remove()","text":"<p>Marks a flag for removal in the patch.</p> <pre><code>fun remove(key: Conditional&lt;*, *&gt;)\n</code></pre> <p>Parameters: - <code>key</code> - The conditional key to remove</p> <p>Example: <pre><code>SnapshotPatch.from(konfig) {\n    remove(OLD_FLAG)\n}\n</code></pre></p>"},{"location":"serialization/api/#extension-functions","title":"Extension Functions","text":""},{"location":"serialization/api/#snapshottojson","title":"Snapshot.toJson()","text":"<p>Convenience method to serialize a konfig directly.</p> <pre><code>fun Snapshot.toJson(\n    serializer: SnapshotSerializer = SnapshotSerializer.default\n): String\n</code></pre> <p>Example: <pre><code>val json = konfig.toJson()\n</code></pre></p>"},{"location":"serialization/api/#snapshotfromjson","title":"Snapshot.fromJson()","text":"<p>Convenience method to deserialize a konfig.</p> <pre><code>fun Snapshot.Companion.fromJson(\n    json: String,\n    serializer: SnapshotSerializer = SnapshotSerializer.default\n): Snapshot\n</code></pre> <p>Example: <pre><code>val konfig = Snapshot.fromJson(json)\n</code></pre></p>"},{"location":"serialization/api/#contextevaluate","title":"Context.evaluate()","text":"<p>Evaluates a specific feature flag in the context.</p> <pre><code>fun &lt;S : Any, C : Context&gt; C.evaluate(\n    key: Conditional&lt;S, C&gt;,\n    registry: FlagRegistry = FlagRegistry\n): S\n</code></pre> <p>Parameters: - <code>key</code> - The feature flag to evaluate - <code>registry</code> - The FlagRegistry to use (defaults to SingletonFlagRegistry)</p> <p>Returns: The evaluated value</p> <p>Throws: - <code>IllegalStateException</code> - If the flag is not found in the registry</p> <p>Example: <pre><code>// Uses SingletonFlagRegistry by default\nval value = context.evaluate(MY_FLAG)\n\n// With custom registry\nval value = context.evaluate(MY_FLAG, customRegistry)\n</code></pre></p>"},{"location":"serialization/api/#contextevaluate-all-flags","title":"Context.evaluate() - All Flags","text":"<p>Evaluates all feature flags in the context.</p> <pre><code>fun &lt;C : Context&gt; C.evaluate(\n    registry: FlagRegistry = FlagRegistry\n): Map&lt;Conditional&lt;*, *&gt;, Any?&gt;\n</code></pre> <p>Parameters: - <code>registry</code> - The FlagRegistry to use (defaults to SingletonFlagRegistry)</p> <p>Returns: A map of Conditional keys to their evaluated values</p> <p>Example: <pre><code>val allValues = context.evaluate()\n</code></pre></p>"},{"location":"serialization/api/#conversion-utilities","title":"Conversion Utilities","text":""},{"location":"serialization/api/#snapshottoserializable","title":"Snapshot.toSerializable()","text":"<p>Converts konfig to serializable form.</p> <pre><code>fun Snapshot.toSerializable(): SerializableSnapshot\n</code></pre> <p>Internal use - Called by <code>SnapshotSerializer.serialize()</code></p>"},{"location":"serialization/api/#serializablesnapshottosnapshot","title":"SerializableSnapshot.toSnapshot()","text":"<p>Converts serializable form to konfig.</p> <pre><code>fun SerializableSnapshot.toSnapshot(): Snapshot\n</code></pre> <p>Internal use - Called by <code>SnapshotSerializer.deserialize()</code></p>"},{"location":"serialization/api/#snapshotpatchtoserializable","title":"SnapshotPatch.toSerializable()","text":"<p>Converts core patch to serializable form.</p> <pre><code>fun SnapshotPatch.toSerializable(): SerializablePatch\n</code></pre> <p>Internal use - Called by <code>SnapshotSerializer.serializePatch()</code></p>"},{"location":"serialization/api/#serializablepatchtopatch","title":"SerializablePatch.toPatch()","text":"<p>Converts serializable form to core patch.</p> <pre><code>fun SerializablePatch.toPatch(): SnapshotPatch\n</code></pre> <p>Internal use - Called by <code>SnapshotSerializer.deserializePatchToCore()</code></p>"},{"location":"serialization/api/#usage-examples","title":"Usage Examples","text":""},{"location":"serialization/api/#complete-example","title":"Complete Example","text":"<pre><code>import io.amichne.konditional.serialization.*\nimport io.amichne.konditional.core.SingletonFlagRegistry\nimport io.amichne.konditional.core.instance.Konfigmport io.amichne.konditional.core.konfig.SnapshotPatch\n\n// Register flags\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n// Create config\nval konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with { default(true) }\n}\n\n// Serialize\nval serializer = SnapshotSerializer.default\nval json = serializer.serialize(konfig)\n\n// Save to file\nFile(\"flags.json\").writeText(json)\n\n// Load from file\nval loadedJson = File(\"flags.json\").readText()\n\n// Deserialize\nval loadedSnapshot = serializer.deserialize(loadedJson)\n\n// Load into runtime\nSingletonFlagRegistry.load(loadedSnapshot)\n\n// Use flags (SingletonFlagRegistry is the default)\nval context = createContext()\nval darkMode = context.evaluate(FeatureFlags.DARK_MODE)\n</code></pre>"},{"location":"serialization/api/#patch-update-example","title":"Patch Update Example","text":"<pre><code>// Get current konfig\nval current = SingletonFlagRegistry.getCurrentSnapshot()\n\n// Create a patch\nval patch = SnapshotPatch.from(current) {\n    add(NEW_FLAG to newFlagDefinition)\n    remove(OLD_FLAG)\n}\n\n// Serialize patch\nval patchJson = patch.toJson()\n\n// Save patch\nFile(\"update.json\").writeText(patchJson)\n\n// Later: load and apply patch\nval loadedPatch = SnapshotPatch.fromJson(File(\"update.json\").readText())\nSingletonFlagRegistry.applyPatch(loadedPatch)\n\n// Or apply directly to a konfig\nval updatedSnapshot = loadedPatch.applyTo(current)\nSingletonFlagRegistry.load(updatedSnapshot)\n</code></pre>"},{"location":"serialization/api/#best-practices","title":"Best Practices","text":""},{"location":"serialization/api/#1-always-register-before-deserializing","title":"1. Always Register Before Deserializing","text":"<pre><code>// \u2705 Correct\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nval konfig = serializer.deserialize(json)\n\n// \u274c Wrong\nval konfig = serializer.deserialize(json)\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;() // Too late!\n</code></pre>"},{"location":"serialization/api/#2-use-default-serializer","title":"2. Use Default Serializer","text":"<pre><code>// \u2705 Preferred\nval serializer = SnapshotSerializer.default\n\n// \u26a0\ufe0f Only if you need custom Moshi config\nval customMoshi = Moshi.Builder()...build()\nval serializer = SnapshotSerializer(customMoshi)\n</code></pre>"},{"location":"serialization/api/#3-handle-errors","title":"3. Handle Errors","text":"<pre><code>try {\n    val konfig = serializer.deserialize(json)\n    SingletonFlagRegistry.load(konfig)\n} catch (e: JsonDataException) {\n    logger.error(\"Invalid JSON\", e)\n    // Load fallback\n} catch (e: IllegalArgumentException) {\n    logger.error(\"Unregistered flag\", e)\n    // Load fallback\n}\n</code></pre>"},{"location":"serialization/api/#4-use-patches-for-incremental-updates","title":"4. Use Patches for Incremental Updates","text":"<pre><code>// \u2705 Efficient - only update what changed\nval patch = SnapshotPatch.from(SingletonFlagRegistry.getCurrentSnapshot()) {\n    add(NEW_FLAG to definition)\n}\nSingletonFlagRegistry.applyPatch(patch)\n\n// \u26a0\ufe0f Less efficient - replaces entire konfig\nval newSnapshot = ConfigBuilder.buildSnapshot { /* ... */ }\nSingletonFlagRegistry.load(newSnapshot)\n</code></pre>"},{"location":"serialization/api/#see-also","title":"See Also","text":"<ul> <li>Integration Guide</li> <li>Step-by-Step Tutorial</li> <li>Full Runthrough</li> </ul>"},{"location":"serialization/integration/","title":"Integration Guide","text":""},{"location":"serialization/integration/#integration-overview","title":"Integration Overview","text":"<p>This guide walks you through integrating the Konditional serialization system into an existing application. We'll cover both greenfield (starting fresh) and brownfield (existing codebase) scenarios.</p> <p>::: note This guide assumes you already have Konditional set up and are using <code>Conditional</code> instances for feature flags. If not, see the Quick Start guide first. :::</p>"},{"location":"serialization/integration/#prerequisites","title":"Prerequisites","text":"<p>Before integrating serialization, ensure you have:</p> <ol> <li>Konditional library added to your project</li> <li>Feature flags defined as <code>Conditional</code> instances (typically enums)</li> <li>Moshi dependencies added to your <code>build.gradle.kts</code></li> <li>Understanding of your deployment strategy (where JSON will be stored/loaded)</li> </ol>"},{"location":"serialization/integration/#integration-patterns","title":"Integration Patterns","text":"<p>Choose the pattern that best fits your architecture:</p>"},{"location":"serialization/integration/#pattern-1-build-time-configuration","title":"Pattern 1: Build-Time Configuration","text":"<p>Best for: Small apps, monoliths, infrequent flag changes</p> <pre><code>Developer \u2192 ConfigBuilder \u2192 JSON \u2192 Git \u2192 Build \u2192 Embed in APK/JAR\n</code></pre> <ul> <li>Configuration is committed to source control</li> <li>Flags are baked into the application at build time</li> <li>Changes require a new build and deployment</li> </ul>"},{"location":"serialization/integration/#pattern-2-runtime-configuration","title":"Pattern 2: Runtime Configuration","text":"<p>Best for: Large apps, microservices, frequent flag changes</p> <pre><code>Developer \u2192 ConfigBuilder \u2192 JSON \u2192 Upload to S3/CDN \u2192 App downloads on launch\n</code></pre> <ul> <li>Configuration is external to the application</li> <li>Flags can be updated without redeploying</li> <li>Requires network access and error handling</li> </ul>"},{"location":"serialization/integration/#pattern-3-hybrid-approach","title":"Pattern 3: Hybrid Approach","text":"<p>Best for: Production apps needing flexibility</p> <pre><code>Developer \u2192 ConfigBuilder \u2192 Default JSON (embedded) + Remote JSON (downloaded)\n                                \u2193                              \u2193\n                          Fallback config              Production overrides\n</code></pre> <ul> <li>Embedded default configuration as fallback</li> <li>Remote configuration overrides defaults</li> <li>Graceful degradation if network fails</li> </ul>"},{"location":"serialization/integration/#architecture-decisions","title":"Architecture Decisions","text":""},{"location":"serialization/integration/#where-to-store-json","title":"Where to Store JSON?","text":"TabEmbedded ResourcesLocal File SystemRemote Server/CDNConfiguration Service <p>Pros: - No network dependency - Guaranteed availability - Fast loading</p> <p>Cons: - Requires rebuild to change - Larger APK/JAR size - No runtime flexibility</p> <pre><code>val json = javaClass.getResourceAsStream(\"/flags.json\")\n    .bufferedReader()\n    .use { it.readText() }\n</code></pre> <p>Pros: - Easy to update locally - No network needed - Fast loading</p> <p>Cons: - Requires file system access - Platform-specific paths - Not suitable for mobile</p> <pre><code>val json = File(\"/etc/myapp/flags.json\").readText()\n</code></pre> <p>Pros: - Update without deploying - Environment-specific configs - A/B testing support</p> <p>Cons: - Network dependency - Requires caching - Potential latency</p> <pre><code>val json = httpClient.get(\"https://cdn.example.com/flags.json\")\n</code></pre> <p>Pros: - Centralized management - Access control - Audit logs</p> <p>Cons: - Added complexity - Service dependency - Requires infrastructure</p> <pre><code>val json = configService.getFlags(environment, version)\n</code></pre>"},{"location":"serialization/integration/#when-to-load-flags","title":"When to Load Flags?","text":"<p>Consider the trade-offs of different loading strategies:</p>"},{"location":"serialization/integration/#application-startup-recommended","title":"Application Startup (Recommended)","text":"<pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Load flags before anything else\n        loadFeatureFlags()\n\n        // Rest of initialization...\n    }\n\n    private fun loadFeatureFlags() {\n        val json = loadFlagsJson() // From wherever you store them\n        val konfig = SnapshotSerializer.default.deserialize(json)\n        Flags.load(konfig)\n    }\n}\n</code></pre> <p>Pros: Flags available immediately, simple error handling Cons: Increases startup time, blocks initialization</p>"},{"location":"serialization/integration/#lazy-loading","title":"Lazy Loading","text":"<pre><code>object FlagManager {\n    private var initialized = false\n\n    fun ensureLoaded() {\n        if (!initialized) {\n            loadFlags()\n            initialized = true\n        }\n    }\n}\n</code></pre> <p>Pros: Faster startup, load only when needed Cons: First access is slower, race conditions possible</p>"},{"location":"serialization/integration/#background-loading","title":"Background Loading","text":"<pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Load with defaults first\n        loadDefaultFlags()\n\n        // Update from remote in background\n        CoroutineScope(Dispatchers.IO).launch {\n            updateFlagsFromRemote()\n        }\n    }\n}\n</code></pre> <p>Pros: Fast startup, eventually consistent Cons: Complex state management, temporary inconsistency</p>"},{"location":"serialization/integration/#registering-conditionals","title":"Registering Conditionals","text":"<p>The registry maps string keys to <code>Conditional</code> instances. Register all flags before deserialization:</p>"},{"location":"serialization/integration/#for-enum-based-flags","title":"For Enum-Based Flags","text":"<pre><code>// Register an entire enum at once\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n</code></pre>"},{"location":"serialization/integration/#for-mixed-flag-types","title":"For Mixed Flag Types","text":"<pre><code>// Register multiple enums\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\nConditionalRegistry.registerEnum&lt;DebugFlags&gt;()\n\n// Or register individually\nConditionalRegistry.register(FeatureFlags.DARK_MODE)\nConditionalRegistry.register(ExperimentFlags.NEW_ONBOARDING)\n</code></pre>"},{"location":"serialization/integration/#registration-timing","title":"Registration Timing","text":"<p>::: caution Critical: Register all flags before calling <code>deserialize()</code>. Missing registrations will cause runtime errors. :::</p> <pre><code>// \u2705 Good: Register first\nfun initializeFlags() {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    val konfig = SnapshotSerializer.default.deserialize(json)\n    Flags.load(konfig)\n}\n\n// \u274c Bad: Deserialize before registering\nfun initializeFlags() {\n    val konfig = SnapshotSerializer.default.deserialize(json) // Error!\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n}\n</code></pre>"},{"location":"serialization/integration/#error-handling","title":"Error Handling","text":"<p>Production applications must handle serialization errors gracefully:</p>"},{"location":"serialization/integration/#strategy-1-fallback-to-defaults","title":"Strategy 1: Fallback to Defaults","text":"<pre><code>fun loadFlags(): Flags.Snapshot {\n    return try {\n        val json = downloadRemoteConfig()\n        SnapshotSerializer.default.deserialize(json)\n    } catch (e: IOException) {\n        logger.warn(\"Failed to load remote config, using defaults\", e)\n        loadDefaultSnapshot()\n    } catch (e: JsonDataException) {\n        logger.error(\"Invalid JSON format, using defaults\", e)\n        loadDefaultSnapshot()\n    }\n}\n\nprivate fun loadDefaultSnapshot(): Flags.Snapshot {\n    val defaultJson = resources.openRawResource(R.raw.default_flags)\n        .bufferedReader()\n        .use { it.readText() }\n    return SnapshotSerializer.default.deserialize(defaultJson)\n}\n</code></pre>"},{"location":"serialization/integration/#strategy-2-partial-updates","title":"Strategy 2: Partial Updates","text":"<pre><code>fun updateFlags() {\n    try {\n        val patchJson = downloadPatch()\n        val currentKonfig = getCurrentSnapshot()\n        val updated = SnapshotSerializer.default.applyPatchJson(\n            currentKonfig,\n            patchJson\n        )\n        Flags.load(updated)\n        logger.info(\"Successfully applied patch update\")\n    } catch (e: Exception) {\n        logger.error(\"Patch update failed, keeping current config\", e)\n        // Don't change anything - keep working configuration\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#strategy-3-validation-before-loading","title":"Strategy 3: Validation Before Loading","text":"<pre><code>fun loadFlags(json: String): Result&lt;Flags.Snapshot&gt; {\n    return try {\n        // Deserialize\n        val konfig = SnapshotSerializer.default.deserialize(json)\n\n        // Validate before loading\n        validateSnapshot(konfig)\n\n        // Load if valid\n        Flags.load(konfig)\n        Result.success(konfig)\n    } catch (e: Exception) {\n        logger.error(\"Flag loading failed\", e)\n        Result.failure(e)\n    }\n}\n\nprivate fun validateSnapshot(konfig: Flags.Snapshot) {\n    require(konfig.flags.isNotEmpty()) {\n        \"Snapshot cannot be empty\"\n    }\n\n    // Validate against schema\n    val requiredFlags = setOf(\"feature_x\", \"feature_y\")\n    val actualFlags = konfig.flags.keys.map { it.key }.toSet()\n\n    require(requiredFlags.all { it in actualFlags }) {\n        \"Missing required flags: ${requiredFlags - actualFlags}\"\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#testing-integration","title":"Testing Integration","text":""},{"location":"serialization/integration/#unit-tests","title":"Unit Tests","text":"<p>Test serialization/deserialization in isolation:</p> <pre><code>class FlagSerializationTest {\n    @BeforeEach\n    fun setup() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        ConditionalRegistry.clear()\n    }\n\n    @Test\n    fun `serialization round-trip preserves behavior`() {\n        val original = createTestSnapshot()\n        val json = SnapshotSerializer.default.serialize(original)\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        val context = createTestContext()\n\n        with(Flags) {\n            Flags.load(original)\n            val originalValue = context.evaluate(FeatureFlags.MY_FLAG)\n\n            Flags.load(restored)\n            val restoredValue = context.evaluate(FeatureFlags.MY_FLAG)\n\n            assertEquals(originalValue, restoredValue)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#integration-tests","title":"Integration Tests","text":"<p>Test the full loading workflow:</p> <pre><code>@Test\nfun `application loads flags on startup`() {\n    // Prepare test JSON\n    val testJson = \"\"\"\n        {\n          \"flags\": [\n            {\n              \"key\": \"my_feature\",\n              \"type\": \"BOOLEAN\",\n              \"defaultValue\": true,\n              \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n              \"rules\": []\n            }\n          ]\n        }\n    \"\"\".trimIndent()\n\n    // Save to test location\n    File(testFlagsPath).writeText(testJson)\n\n    // Initialize app\n    val app = TestApplication()\n    app.onCreate()\n\n    // Verify flags are loaded\n    val context = createTestContext()\n    with(Flags) {\n        val value = context.evaluate(FeatureFlags.MY_FEATURE)\n        assertTrue(value)\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#performance-considerations","title":"Performance Considerations","text":""},{"location":"serialization/integration/#deserialization-performance","title":"Deserialization Performance","text":"<p>For large configurations (100+ flags):</p> <pre><code>// \u2705 Good: Deserialize once, reuse\nval konfig = SnapshotSerializer.default.deserialize(json)\nFlags.load(konfig)\n\n// \u274c Bad: Deserialize repeatedly\nrepeat(100) {\n    val konfig = SnapshotSerializer.default.deserialize(json)\n    // This is very slow!\n}\n</code></pre>"},{"location":"serialization/integration/#memory-usage","title":"Memory Usage","text":"<p>Snapshots are immutable and can be shared:</p> <pre><code>// \u2705 Good: Share konfig across components\nval konfig = loadSnapshot()\ncomponentA.useSnapshot(konfig)\ncomponentB.useSnapshot(konfig)\n\n// \u26a0\ufe0f Consider: Snapshot size in memory\n// For apps with 1000+ flags, monitor memory usage\n</code></pre>"},{"location":"serialization/integration/#caching","title":"Caching","text":"<p>Implement caching for remote configurations:</p> <pre><code>class FlagCache(private val cacheDir: File) {\n    fun getCachedOrFetch(url: String): String {\n        val cacheFile = File(cacheDir, \"flags.json\")\n\n        // Use cached if recent\n        if (cacheFile.exists() &amp;&amp; cacheFile.isRecent()) {\n            return cacheFile.readText()\n        }\n\n        // Fetch new version\n        val json = httpClient.get(url)\n        cacheFile.writeText(json)\n        return json\n    }\n\n    private fun File.isRecent(): Boolean {\n        val age = System.currentTimeMillis() - lastModified()\n        return age &lt; TimeUnit.HOURS.toMillis(1)\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"serialization/integration/#pitfall-1-forgetting-to-register","title":"Pitfall 1: Forgetting to Register","text":"<pre><code>// \u274c This will crash at runtime\nval konfig = SnapshotSerializer.default.deserialize(json)\n// IllegalArgumentException: Conditional with key 'my_flag' not found\n\n// \u2705 Always register first\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nval konfig = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/integration/#pitfall-2-type-mismatches","title":"Pitfall 2: Type Mismatches","text":"<pre><code>// JSON says INT but code expects BOOLEAN\n{\n  \"key\": \"my_flag\",\n  \"type\": \"INT\",  // Wrong!\n  \"defaultValue\": 42\n}\n\n// \u2705 Ensure JSON matches your Conditional definition\nenum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    MY_FLAG(\"my_flag\")  // Expects Boolean, not Int!\n}\n</code></pre>"},{"location":"serialization/integration/#pitfall-3-missing-default-field","title":"Pitfall 3: Missing Default Field","text":"<pre><code>// \u274c Old format without 'default' field\n{\n  \"key\": \"my_flag\",\n  \"type\": \"BOOLEAN\",\n  \"defaultValue\": true\n  // Missing: \"default\": {\"value\": true, \"type\": \"BOOLEAN\"}\n}\n\n// \u2705 Always include the default wrapper\n{\n  \"key\": \"my_flag\",\n  \"type\": \"BOOLEAN\",\n  \"defaultValue\": true,\n  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"}\n}\n</code></pre>"},{"location":"serialization/integration/#next-steps","title":"Next Steps","text":"<p>Now that you understand the integration concepts, proceed to the step-by-step guide:</p> <p>Step 1: Dependencies \u2192</p> <p>Or jump straight to a complete example:</p> <p>Full Runthrough \u2192</p>"},{"location":"serialization/overview/","title":"Serialization Overview","text":""},{"location":"serialization/overview/#what-is-serialization","title":"What is Serialization?","text":"<p>The Konditional serialization system enables you to externalize your feature flag configurations as JSON files. This allows you to:</p> <ul> <li>Separate configuration from code - Update flags without recompiling</li> <li>Version control configurations - Track flag changes over time</li> <li>Environment-specific settings - Different configs for dev/staging/prod</li> <li>Remote configuration - Load flags from a server or CDN</li> <li>Dynamic updates - Apply changes without app restarts</li> </ul>"},{"location":"serialization/overview/#type-safe","title":"Type-Safe","text":"<pre><code>All values are wrapped with their type information, preventing runtime type mismatches\n</code></pre>"},{"location":"serialization/overview/#round-trip-guaranteed","title":"Round-Trip Guaranteed","text":"<pre><code>Serialized configurations behave identically to programmatic ones\n</code></pre>"},{"location":"serialization/overview/#patch-updates","title":"Patch Updates","text":"<pre><code>Apply incremental changes without replacing entire configurations\n</code></pre>"},{"location":"serialization/overview/#production-ready","title":"Production Ready","text":"<pre><code>Comprehensive test coverage with real-world examples\n</code></pre>"},{"location":"serialization/overview/#serialization-architecture","title":"Serialization Architecture","text":"<pre><code>graph TB\n    subgraph \"Runtime Types (Domain)\"\n        KONFIG[Konfig]\n        FLAG[FeatureFlag~S,C~]\n        RULE[Rule~C~]\n        VALUE[ConditionalValue~S,C~]\n    end\n\n    subgraph \"Serializable Models (DTO)\"\n        SSNAP[SerializableSnapshot]\n        SFLAG[SerializableFlag]\n        SRULE[SerializableRule]\n        FVAL[FlagValue~T~Sealed Class]\n    end\n\n    subgraph \"Serialization Layer\"\n        SER[SnapshotSerializer]\n        MOSHI[Moshi JSON]\n        CREG[ConditionalRegistry]\n    end\n\n    subgraph \"Storage\"\n        JSON[JSON File/API]\n    end\n\n    KONFIG --&gt; SER\n    SER --&gt;|toSerializable| SSNAP\n    SSNAP --&gt; MOSHI\n    MOSHI --&gt;|serialize| JSON\n\n    JSON --&gt;|deserialize| MOSHI\n    MOSHI --&gt; SSNAP\n    SSNAP --&gt;|toKonfig| SER\n    SER --&gt;|resolve keys| CREG\n    SER --&gt; KONFIG\n\n    FLAG --&gt; SFLAG\n    RULE --&gt; SRULE\n    VALUE --&gt; FVAL\n\n    style KONFIG fill:#e1f5ff\n    style SSNAP fill:#fff4e1\n    style SER fill:#f0e1ff\n    style JSON fill:#d4edda\n</code></pre> <p>Key Flow: 1. Serialize: <code>Konfig</code> \u2192 <code>SerializableSnapshot</code> \u2192 JSON string 2. Deserialize: JSON string \u2192 <code>SerializableSnapshot</code> \u2192 <code>ParseResult&lt;Konfig&gt;</code> 3. Type Safety: <code>FlagValue&lt;T&gt;</code> sealed class preserves types through serialization 4. Key Resolution: <code>ConditionalRegistry</code> maps string keys back to typed instances</p>"},{"location":"serialization/overview/#architecture-components","title":"Architecture Components","text":"<p>The serialization system consists of three main components:</p>"},{"location":"serialization/overview/#1-serializable-models","title":"1. Serializable Models","text":"<p>Type-safe DTOs that represent your configuration in JSON:</p> <pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableSnapshot(\n    val flags: List&lt;SerializableFlag&gt;\n)\n\n@JsonClass(generateAdapter = true)\ndata class SerializableFlag(\n    val key: String,\n    val defaultValue: FlagValue&lt;*&gt;,\n    val salt: String = \"v1\",\n    val isActive: Boolean = true,\n    val rules: List&lt;SerializableRule&gt; = emptyList()\n)\n\n// FlagValue is a sealed class for type-safe value representation\nsealed class FlagValue&lt;out T : Any&gt; {\n    abstract val value: T\n\n    data class BooleanValue(override val value: Boolean) : FlagValue&lt;Boolean&gt;()\n    data class StringValue(override val value: String) : FlagValue&lt;String&gt;()\n    data class IntValue(override val value: Int) : FlagValue&lt;Int&gt;()\n    data class DoubleValue(override val value: Double) : FlagValue&lt;Double&gt;()\n}\n</code></pre> <p>Key Change: Replaced <code>SerializableValue(value: Any, type: ValueType)</code> with <code>FlagValue&lt;T&gt;</code> sealed class to eliminate type erasure and improve type safety.</p>"},{"location":"serialization/overview/#2-conversion-utilities","title":"2. Conversion Utilities","text":"<p>Bidirectional conversion between runtime types and JSON:</p> <ul> <li>ConditionalRegistry - Maps flag keys to runtime instances (must register before deserialization)</li> <li>Extension functions - Convert between <code>Konfig</code> and <code>SerializableSnapshot</code></li> <li>Type safety - No unchecked casts; <code>FlagValue</code> preserves types</li> </ul>"},{"location":"serialization/overview/#3-serialization-api-with-parseresult","title":"3. Serialization API with ParseResult","text":"<p>Main interface for serialization operations:</p> <pre><code>val serializer = SnapshotSerializer()\n\n// Serialize (always succeeds)\nval json = serializer.serialize(konfig)\n\n// Deserialize with structured error handling\nwhen (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        val konfig = result.value\n        FlagRegistry.load(konfig)\n    }\n    is ParseResult.Failure -&gt; {\n        when (val error = result.error) {\n            is ParseError.InvalidJson -&gt; log.error(\"Bad JSON: ${error.message}\")\n            is ParseError.ConditionalNotFound -&gt; log.error(\"Unknown flag: ${error.key}\")\n            else -&gt; log.error(\"Parse failed: ${error.message}\")\n        }\n    }\n}\n\n// Apply patches with error handling\nwhen (val result = serializer.applyPatchJson(FlagRegistry.konfig(), patchJson)) {\n    is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre> <p>Key Change: All deserialization methods return <code>ParseResult&lt;T&gt;</code> instead of throwing exceptions. This follows the \"Parse, Don't Validate\" principle.</p>"},{"location":"serialization/overview/#key-concepts","title":"Key Concepts","text":""},{"location":"serialization/overview/#type-safety-with-flagvalue","title":"Type Safety with FlagValue","text":"<p>All values are wrapped with their type information using a sealed class:</p> <pre><code>{\n  \"defaultValue\": {\n    \"type\": \"BOOLEAN\",\n    \"value\": true\n  }\n}\n</code></pre> <p>Benefits of FlagValue over old SerializableValue: - Compile-time safety: No <code>Any</code> types or unchecked casts - Illegal states unrepresentable: Can't have <code>INT</code> type with <code>Boolean</code> value - Type preservation: Generic type parameter <code>&lt;T&gt;</code> maintains type information - Self-describing JSON: Type discriminator included in serialization</p>"},{"location":"serialization/overview/#the-registry-pattern","title":"The Registry Pattern","text":"<p>Before deserialization, you must register all your <code>Conditional</code> instances:</p> <pre><code>// Register an enum of flags\nConditionalRegistry.registerEnum&lt;MyFeatureFlags&gt;()\n\n// Or register individual flags\nConditionalRegistry.register(MyFlags.SOME_FLAG)\n</code></pre> <p>This allows the deserializer to map string keys back to typed <code>Conditional</code> instances.</p>"},{"location":"serialization/overview/#parseresult-error-handling","title":"ParseResult Error Handling","text":"<p>All deserialization operations return <code>ParseResult&lt;T&gt;</code> for structured error handling:</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n\nsealed interface ParseError {\n    data class InvalidJson(val message: String) : ParseError\n    data class InvalidSnapshot(val message: String) : ParseError\n    data class ConditionalNotFound(val key: String) : ParseError\n}\n</code></pre> <p>Usage patterns:</p> <pre><code>// Pattern 1: Quick unwrap (throws on error, useful in tests)\nval konfig = serializer.deserialize(json).getOrThrow()\n\n// Pattern 2: Explicit handling\nwhen (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n    is ParseResult.Failure -&gt; log.error(\"Failed: ${result.error}\")\n}\n\n// Pattern 3: Fallback value\nval konfig = serializer.deserialize(json).getOrDefault(emptyKonfig)\n</code></pre>"},{"location":"serialization/overview/#round-trip-equality","title":"Round-Trip Equality","text":"<p>A core guarantee of the system is that serialized configurations behave identically to the originals:</p> <pre><code>val original = ConfigBuilder.buildSnapshot { /* ... */ }\nval json = serializer.serialize(original)\n\nwhen (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        val restored = result.value\n        // These produce identical results\n        assert(context.evaluate(MY_FLAG, original) ==\n               context.evaluate(MY_FLAG, restored))\n    }\n    is ParseResult.Failure -&gt; fail(\"Deserialization failed\")\n}\n</code></pre>"},{"location":"serialization/overview/#json-structure","title":"JSON Structure","text":""},{"location":"serialization/overview/#complete-example","title":"Complete Example","text":"<pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"enable_compact_cards\",\n      \"defaultValue\": {\n        \"type\": \"BOOLEAN\",\n        \"value\": false\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"BOOLEAN\",\n            \"value\": true\n          },\n          \"rollout\": 50.0,\n          \"note\": \"US iOS 50% rollout\",\n          \"locales\": [\"EN_US\"],\n          \"platforms\": [\"IOS\"],\n          \"versionRange\": {\n            \"type\": \"LeftBound\",\n            \"min\": {\n              \"major\": 7,\n              \"minor\": 10,\n              \"patch\": 0\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Key Changes from Previous Versions: - Removed top-level <code>type</code> field (type is now in FlagValue) - Removed redundant <code>default</code> field (replaced by <code>defaultValue</code> with FlagValue) - <code>versionRange.type</code> uses actual sealed class names (<code>LeftBound</code>, <code>RightBound</code>, etc.)</p>"},{"location":"serialization/overview/#field-reference","title":"Field Reference","text":""},{"location":"serialization/overview/#flag-level","title":"Flag Level","text":"Field Type Required Description <code>key</code> String Yes Unique identifier matching <code>Conditional.key</code> <code>defaultValue</code> FlagValue Yes Typed default value when no rules match <code>salt</code> String No Salt for bucketing (default: \"v1\") <code>isActive</code> Boolean No Whether flag is active (default: true) <code>rules</code> Array No List of targeting rules"},{"location":"serialization/overview/#rule-level","title":"Rule Level","text":"Field Type Required Description <code>value</code> FlagValue Yes Typed value to return if rule matches <code>rollout</code> Number No Percentage 0-100 (default: 100) <code>note</code> String No Description of the rule <code>locales</code> Array No Set of locales (empty = all) <code>platforms</code> Array No Set of platforms (empty = all) <code>versionRange</code> Object No Version constraints"},{"location":"serialization/overview/#version-range-types-sealed-class","title":"Version Range Types (Sealed Class)","text":"Type Fields Description <code>Unbounded</code> None No version constraints <code>LeftBound</code> <code>min: Version</code> <code>version &gt;= min</code> <code>RightBound</code> <code>max: Version</code> <code>version &lt;= max</code> <code>FullyBound</code> <code>min: Version</code>, <code>max: Version</code> <code>min &lt;= version &lt;= max</code> <p>Example: <pre><code>{\n  \"type\": \"FullyBound\",\n  \"min\": {\"major\": 1, \"minor\": 0, \"patch\": 0},\n  \"max\": {\"major\": 2, \"minor\": 5, \"patch\": 10}\n}\n</code></pre></p>"},{"location":"serialization/overview/#use-cases","title":"Use Cases","text":""},{"location":"serialization/overview/#1-development-workflow","title":"1. Development Workflow","text":"<pre><code>graph LR\n    DEV[Developer] --&gt; CONFIG[ConfigBuilder DSL]\n    CONFIG --&gt; SNAPSHOT[Konfig]\n    SNAPSHOT --&gt; SER[Serialize to JSON]\n    SER --&gt; FILE[JSON File]\n    FILE --&gt; GIT[Git Commit]\n\n    style DEV fill:#e1f5ff\n    style SNAPSHOT fill:#fff4e1\n    style FILE fill:#d4edda\n</code></pre>"},{"location":"serialization/overview/#2-cicd-pipeline","title":"2. CI/CD Pipeline","text":"<pre><code>graph LR\n    GIT[Git Repo] --&gt; BUILD[Build Process]\n    BUILD --&gt; VALIDATE{Validate JSON}\n    VALIDATE --&gt;|Success| DEPLOY[Deploy to S3/CDN]\n    VALIDATE --&gt;|Failure| ERROR[Build Fails]\n    DEPLOY --&gt; APP[App Downloads]\n    APP --&gt; DESER{Deserialize}\n    DESER --&gt;|ParseResult.Success| LOAD[Load Config]\n    DESER --&gt;|ParseResult.Failure| FALLBACK[Use Cached Config]\n\n    style LOAD fill:#d4edda\n    style ERROR fill:#f8d7da\n    style FALLBACK fill:#fff3cd\n</code></pre>"},{"location":"serialization/overview/#3-remote-configuration-with-error-handling","title":"3. Remote Configuration with Error Handling","text":"<pre><code>// Fetch configuration from server\nval json = fetchFromServer()\n\n// Deserialize with error handling\nwhen (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        FlagRegistry.load(result.value)\n        log.info(\"Configuration updated successfully\")\n    }\n    is ParseResult.Failure -&gt; {\n        log.error(\"Failed to load remote config: ${result.error}\")\n        // Keep using current configuration\n    }\n}\n</code></pre>"},{"location":"serialization/overview/#4-ab-testing-with-deterministic-bucketing","title":"4. A/B Testing with Deterministic Bucketing","text":"<pre><code>graph TB\n    JSON[JSON Config] --&gt; FLAGS[Multiple Ruleswith Rollout %]\n    FLAGS --&gt; HASH[SHA-256 Bucketing]\n    HASH --&gt; STABLE[Stable User Assignment]\n    STABLE --&gt; CONSIST[Consistent Experience]\n\n    style JSON fill:#e1f5ff\n    style STABLE fill:#d4edda\n    style CONSIST fill:#d4edda\n</code></pre>"},{"location":"serialization/overview/#next-steps","title":"Next Steps","text":""},{"location":"serialization/overview/#integration-guide","title":"Integration Guide","text":"<pre><code>Learn how to integrate serialization into your existing codebase\n\n[Read the guide \u2192](integration.md)\n</code></pre>"},{"location":"serialization/overview/#step-by-step-tutorial","title":"Step-by-Step Tutorial","text":"<pre><code>Follow detailed steps to implement serialization from scratch\n\n[Start tutorial \u2192](steps/step-01-dependencies.md)\n</code></pre>"},{"location":"serialization/overview/#full-runthrough","title":"Full Runthrough","text":"<pre><code>See the complete integration in one place\n\n[View runthrough \u2192](runthrough.md)\n</code></pre> <p>::: tip The serialization system is production-ready with comprehensive test coverage. All 11 serialization tests pass, verifying round-trip equality and patch functionality. :::</p>"},{"location":"serialization/runthrough/","title":"Complete Integration Runthrough","text":""},{"location":"serialization/runthrough/#introduction","title":"Introduction","text":"<p>This page provides a complete, end-to-end integration guide for Konditional serialization. Follow these instructions from start to finish to integrate serialization into your application.</p> <p>::: tip Estimated time: 2-3 hours for full integration</p> <p>Prerequisites: - Existing Kotlin project with Gradle - Konditional library already integrated - Feature flags defined as <code>Conditional</code> instances :::</p>"},{"location":"serialization/runthrough/#part-1-project-setup","title":"Part 1: Project Setup","text":""},{"location":"serialization/runthrough/#add-dependencies","title":"Add Dependencies","text":"<p>First, add Moshi to your <code>build.gradle.kts</code>:</p> <p>```kotlin title=\"build.gradle.kts\" {14-16} repositories {     mavenCentral() }</p> <p>dependencies {     // Konditional     implementation(\"io.amichne:konditional:1.0.0\")</p> <pre><code>// Moshi for JSON serialization\nimplementation(\"com.squareup.moshi:moshi:1.15.0\")\nimplementation(\"com.squareup.moshi:moshi-kotlin:1.15.0\")\nimplementation(\"com.squareup.moshi:moshi-adapters:1.15.0\")\n\n// Testing\ntestImplementation(kotlin(\"test\"))\ntestImplementation(\"org.junit.jupiter:junit-jupiter:5.10.3\")\n</code></pre> <p>} <code>Sync your project:</code>bash ./gradlew build ```</p>"},{"location":"serialization/runthrough/#create-flag-registration-helper","title":"Create Flag Registration Helper","text":"<p>Create a centralized registration class:</p> FlagRegistration.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.serialization.ConditionalRegistry\n\nobject FlagRegistration {\n    private var registered = false\n\n    fun registerAll() {\n        if (registered) return\n\n        synchronized(this) {\n            if (registered) return\n\n            // Register all your flag enums\n            ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n            ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n            // Add more as needed\n\n            registered = true\n        }\n    }\n\n    fun clearForTesting() {\n        ConditionalRegistry.clear()\n        registered = false\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#part-2-configuration-creation","title":"Part 2: Configuration Creation","text":""},{"location":"serialization/runthrough/#define-your-flags","title":"Define Your Flags","text":"<p>Example flag enum:</p> FeatureFlags.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.context.Context\nimport io.amichne.konditional.core.Conditional\nimport io.amichne.konditional.builders.FlagBuilder\n\nenum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_ONBOARDING(\"new_onboarding\"),\n    COMPACT_CARDS(\"compact_cards\"),\n    PREMIUM_FEATURE(\"premium_feature\");\n\n}\n</code></pre>"},{"location":"serialization/runthrough/#create-configuration-builder","title":"Create Configuration Builder","text":"<p>Create environment-specific configurations:</p> FlagConfigurations.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.builders.ConfigBuilder\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Rollout\nimport io.amichne.konditional.core.SingletonFlagRegistry\n\nobject FlagConfigurations {\n\n    fun createDevelopmentConfig() = ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        FeatureFlags.NEW_ONBOARDING with {\n            default(true)\n        }\n\n        FeatureFlags.COMPACT_CARDS with {\n            default(true)\n        }\n\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(true)\n        }\n    }\n\n    fun createStagingConfig() = ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        FeatureFlags.NEW_ONBOARDING with {\n            default(false)\n            rule {\n                rollout = Rollout.of(50.0)\n                locales(AppLocale.EN_US)\n            }.implies(true)\n        }\n\n        FeatureFlags.COMPACT_CARDS with {\n            default(true)\n        }\n\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(false)\n            rule {\n                platforms(Platform.IOS, Platform.ANDROID)\n            }.implies(true)\n        }\n    }\n\n    fun createProductionConfig() = ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        FeatureFlags.NEW_ONBOARDING with {\n            default(false)\n            rule {\n                rollout = Rollout.of(10.0)\n                locales(AppLocale.EN_US)\n                note = \"JIRA-456: Gradual rollout for US users\"\n            }.implies(true)\n        }\n\n        FeatureFlags.COMPACT_CARDS with {\n            default(false)\n            rule {\n                platforms(Platform.IOS, Platform.ANDROID)\n                versions {\n                    min(2, 0, 0)\n                }\n            }.implies(true)\n        }\n\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(false)\n            rule {\n                platforms(Platform.IOS)\n                versions {\n                    min(2, 1, 0)\n                }\n            }.implies(true)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#generate-json-files","title":"Generate JSON Files","text":"<p>Create a configuration generator:</p> ConfigGenerator.kt<pre><code>package com.yourapp.tools\n\nimport com.yourapp.flags.FlagConfigurations\nimport com.yourapp.flags.FlagRegistration\nimport io.amichne.konditional.serialization.SnapshotSerializer\nimport java.io.File\n\nfun main() {\n    println(\"Generating feature flag configurations...\")\n\n    // Register flags\n    FlagRegistration.registerAll()\n\n    val serializer = SnapshotSerializer.default\n\n    // Create config directory\n    val configDir = File(\"config\")\n    configDir.mkdirs()\n\n    // Generate development config\n    val devSnapshot = FlagConfigurations.createDevelopmentConfig()\n    val devJson = serializer.serialize(devSnapshot)\n    File(configDir, \"development-flags.json\").writeText(devJson)\n    println(\"\u2713 Generated development configuration\")\n\n    // Generate staging config\n    val stagingSnapshot = FlagConfigurations.createStagingConfig()\n    val stagingJson = serializer.serialize(stagingSnapshot)\n    File(configDir, \"staging-flags.json\").writeText(stagingJson)\n    println(\"\u2713 Generated staging configuration\")\n\n    // Generate production config\n    val productionSnapshot = FlagConfigurations.createProductionConfig()\n    val productionJson = serializer.serialize(productionSnapshot)\n    File(configDir, \"production-flags.json\").writeText(productionJson)\n    println(\"\u2713 Generated production configuration\")\n\n    println(\"\\nAll configurations generated successfully!\")\n}\n</code></pre> <p>Add a Gradle task:</p> build.gradle.kts<pre><code>tasks.register&lt;JavaExec&gt;(\"generateFlagConfigs\") {\n    group = \"flags\"\n    description = \"Generate feature flag configuration files\"\n    mainClass.set(\"com.yourapp.tools.ConfigGeneratorKt\")\n    classpath = sourceSets[\"main\"].runtimeClasspath\n}\n</code></pre> <p>Run it:</p> <pre><code>./gradlew generateFlagConfigs\n</code></pre>"},{"location":"serialization/runthrough/#part-3-application-integration","title":"Part 3: Application Integration","text":""},{"location":"serialization/runthrough/#create-flag-loader","title":"Create Flag Loader","text":"<p>Build a robust flag loader with fallback:</p> FlagLoader.kt<pre><code>package com.yourapp.flags\n\nimport android.content.Context\nimport io.amichne.konditional.core.SingletonFlagRegistry\nimport io.amichne.konditional.serialization.SnapshotSerializer\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport java.io.File\nimport java.net.URL\n\nclass FlagLoader(\n    private val context: Context,\n    private val environment: String\n) {\n    private val serializer = SnapshotSerializer.default\n\n    suspend fun initialize() {\n        // Register flags first\n        FlagRegistration.registerAll()\n\n        // Load embedded flags immediately (fast)\n        loadEmbeddedFlags()\n\n        // Update from remote in background (slow)\n        updateFromRemote()\n    }\n\n    private fun loadEmbeddedFlags() {\n        try {\n            val json = context.assets.open(\"flags.json\")\n                .bufferedReader()\n                .use { it.readText() }\n\n            val konfig = serializer.deserialize(json)\n            Flags.load(konfig)\n\n            logger.info(\"Loaded embedded flags\")\n        } catch (e: Exception) {\n            logger.error(\"Failed to load embedded flags\", e)\n            loadHardcodedDefaults()\n        }\n    }\n\n    private suspend fun updateFromRemote() = withContext(Dispatchers.IO) {\n        try {\n            val url = \"https://cdn.yourcompany.com/flags-$environment.json\"\n            val json = URL(url).readText()\n\n            // Cache for offline use\n            cacheJson(json)\n\n            val konfig = serializer.deserialize(json)\n            Flags.load(konfig)\n\n            logger.info(\"Updated from remote configuration\")\n        } catch (e: Exception) {\n            logger.warn(\"Remote update failed, using embedded config\", e)\n            // App continues with embedded config\n        }\n    }\n\n    private fun cacheJson(json: String) {\n        File(context.cacheDir, \"flags.json\").writeText(json)\n    }\n\n    private fun loadHardcodedDefaults() {\n        // Last resort: safe defaults\n        val defaultSnapshot = FlagConfigurations.createProductionConfig()\n        Flags.load(defaultSnapshot)\n        logger.warn(\"Loaded hardcoded defaults\")\n    }\n\n    companion object {\n        private val logger = LoggerFactory.getLogger(FlagLoader::class.java)\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#integrate-with-application","title":"Integrate with Application","text":"MyApplication.kt<pre><code>package com.yourapp\n\nimport android.app.Application\nimport com.yourapp.flags.FlagLoader\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\n\nclass MyApplication : Application() {\n    private val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n\n    override fun onCreate() {\n        super.onCreate()\n\n        // Load flags\n        applicationScope.launch {\n            val loader = FlagLoader(\n                context = this@MyApplication,\n                environment = BuildConfig.ENVIRONMENT\n            )\n            loader.initialize()\n        }\n\n        // Continue with other initialization...\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#use-flags-in-ui","title":"Use Flags in UI","text":"MainActivity.kt<pre><code>package com.yourapp\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.yourapp.flags.FeatureFlags\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Context\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Version\nimport io.amichne.konditional.core.SingletonFlagRegistry\nimport io.amichne.konditional.core.StableId\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Create user context\n        val userContext = createUserContext()\n\n        // Evaluate flags\n        with(Flags) {\n            val darkMode = userContext.evaluate(FeatureFlags.DARK_MODE)\n            val newOnboarding = userContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n            val compactCards = userContext.evaluate(FeatureFlags.COMPACT_CARDS)\n\n            // Apply flags\n            if (darkMode) {\n                setTheme(R.style.DarkTheme)\n            }\n\n            if (compactCards) {\n                setContentView(R.layout.activity_main_compact)\n            } else {\n                setContentView(R.layout.activity_main)\n            }\n\n            if (newOnboarding &amp;&amp; isFirstLaunch()) {\n                showOnboarding()\n            }\n        }\n    }\n\n    private fun createUserContext(): Context {\n        return Context(\n            locale = getCurrentLocale(),\n            platform = Platform.ANDROID,\n            appVersion = Version.of(\n                BuildConfig.VERSION_MAJOR,\n                BuildConfig.VERSION_MINOR,\n                BuildConfig.VERSION_PATCH\n            ),\n            stableId = StableId.of(getUserId())\n        )\n    }\n\n    private fun getCurrentLocale(): AppLocale {\n        return when (resources.configuration.locales[0].language) {\n            \"en\" -&gt; AppLocale.EN_US\n            \"es\" -&gt; AppLocale.ES_US\n            else -&gt; AppLocale.EN_US\n        }\n    }\n\n    private fun getUserId(): String {\n        // Get stable user ID from your auth system\n        return authManager.getUserId()\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#part-4-testing","title":"Part 4: Testing","text":""},{"location":"serialization/runthrough/#unit-tests","title":"Unit Tests","text":"FlagSerializationTest.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Context\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Version\nimport io.amichne.konditional.core.SingletonFlagRegistry\nimport io.amichne.konditional.core.StableId\nimport io.amichne.konditional.serialization.ConditionalRegistry\nimport io.amichne.konditional.serialization.SnapshotSerializer\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.assertNotNull\n\nclass FlagSerializationTest {\n    private val serializer = SnapshotSerializer.default\n\n    @BeforeEach\n    fun setUp() {\n        FlagRegistration.registerAll()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        FlagRegistration.clearForTesting()\n    }\n\n    @Test\n    fun `round-trip serialization preserves behavior`() {\n        val original = FlagConfigurations.createProductionConfig()\n        val json = serializer.serialize(original)\n        val restored = serializer.deserialize(json)\n\n        assertNotNull(json)\n\n        val context = createTestContext()\n\n        with(Flags) {\n            Flags.load(original)\n            val originalValues = context.evaluate()\n\n            Flags.load(restored)\n            val restoredValues = context.evaluate()\n\n            assertEquals(originalValues.size, restoredValues.size)\n            originalValues.forEach { (key, value) -&gt;\n                assertEquals(value, restoredValues[key])\n            }\n        }\n    }\n\n    @Test\n    fun `all environments are valid`() {\n        val configs = mapOf(\n            \"development\" to FlagConfigurations.createDevelopmentConfig(),\n            \"staging\" to FlagConfigurations.createStagingConfig(),\n            \"production\" to FlagConfigurations.createProductionConfig()\n        )\n\n        configs.forEach { (env, konfig) -&gt;\n            val json = serializer.serialize(konfig)\n            val restored = serializer.deserialize(json)\n\n            assertNotNull(restored, \"$env config should be valid\")\n        }\n    }\n\n    private fun createTestContext() = Context(\n        AppLocale.EN_US,\n        Platform.ANDROID,\n        Version.of(2, 0, 0),\n        StableId.of(\"test-user-12345678\")\n    )\n}\n</code></pre>"},{"location":"serialization/runthrough/#integration-tests","title":"Integration Tests","text":"FlagLoadingIntegrationTest.kt<pre><code>package com.yourapp.flags\n\nimport android.content.Context\nimport androidx.test.core.app.ApplicationProvider\nimport androidx.test.ext.junit.runners.AndroidJUnit4\nimport com.yourapp.flags.FeatureFlags\nimport io.amichne.konditional.core.SingletonFlagRegistry\nimport kotlinx.coroutines.runBlocking\nimport org.junit.Before\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport kotlin.test.assertTrue\n\n@RunWith(AndroidJUnit4::class)\nclass FlagLoadingIntegrationTest {\n\n    private lateinit var context: Context\n\n    @Before\n    fun setup() {\n        context = ApplicationProvider.getApplicationContext()\n    }\n\n    @Test\n    fun flagsLoadSuccessfully() = runBlocking {\n        val loader = FlagLoader(context, \"production\")\n        loader.initialize()\n\n        // Verify flags are accessible\n        val testContext = createTestContext()\n        with(Flags) {\n            val darkMode = testContext.evaluate(FeatureFlags.DARK_MODE)\n            assertNotNull(darkMode)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#part-5-cicd-setup","title":"Part 5: CI/CD Setup","text":""},{"location":"serialization/runthrough/#github-actions-workflow","title":"GitHub Actions Workflow","text":".github/workflows/deploy-flags.yml<pre><code>name: Deploy Feature Flags\n\non:\n  push:\n    paths:\n      - 'config/*.json'\n    branches:\n      - main\n\njobs:\n  validate-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      - name: Validate configurations\n        run: ./gradlew test --tests '*FlagSerializationTest*'\n\n      - name: Deploy to S3\n        run: |\n          aws s3 cp config/production-flags.json \\\n            s3://${{ secrets.S3_BUCKET }}/flags-production.json \\\n            --cache-control \"max-age=300\"\n\n      - name: Invalidate CloudFront\n        run: |\n          aws cloudfront create-invalidation \\\n            --distribution-id ${{ secrets.CLOUDFRONT_DIST_ID }} \\\n            --paths \"/flags-production.json\"\n</code></pre>"},{"location":"serialization/runthrough/#part-6-monitoring","title":"Part 6: Monitoring","text":""},{"location":"serialization/runthrough/#add-logging","title":"Add Logging","text":"FlagLogger.kt<pre><code>package com.yourapp.flags\n\nimport org.slf4j.LoggerFactory\n\nobject FlagLogger {\n    private val logger = LoggerFactory.getLogger(\"FeatureFlags\")\n\n    fun logLoad(numFlags: Int, source: String) {\n        logger.info(\"Loaded $numFlags flags from $source\")\n    }\n\n    fun logEvaluation(flag: String, value: Any, userId: String) {\n        logger.debug(\"Flag $flag evaluated to $value for user ${userId.take(8)}\")\n    }\n\n    fun logError(operation: String, error: Exception) {\n        logger.error(\"Flag operation failed: $operation\", error)\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#add-metrics","title":"Add Metrics","text":"FlagMetrics.kt<pre><code>package com.yourapp.flags\n\nclass FlagMetrics(private val metricsClient: MetricsClient) {\n\n    fun recordLoad(success: Boolean, source: String) {\n        metricsClient.increment(\"flags.load\", mapOf(\n            \"success\" to success.toString(),\n            \"source\" to source\n        ))\n    }\n\n    fun recordEvaluation(flag: String, value: String) {\n        metricsClient.increment(\"flags.evaluation\", mapOf(\n            \"flag\" to flag,\n            \"value\" to value\n        ))\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#conclusion","title":"Conclusion","text":"<p>You now have a complete, production-ready serialization integration! Your application can:</p> <p>\u2705 Load feature flags from JSON \u2705 Support multiple environments \u2705 Handle errors gracefully with fallbacks \u2705 Dynamically update flags from remote sources \u2705 Monitor flag usage \u2705 Test configurations thoroughly</p>"},{"location":"serialization/runthrough/#next-steps","title":"Next Steps","text":"<ul> <li>Explore advanced features: Patch Updates</li> <li>API reference: Complete API Documentation</li> <li>Migration guide: Migrating Existing Systems</li> </ul> <p>::: tip For questions or issues, check the GitHub repository or file an issue. :::</p>"},{"location":"serialization/steps/step-01-dependencies/","title":"Step 1: Add Dependencies","text":""},{"location":"serialization/steps/step-01-dependencies/#overview","title":"Overview","text":"<p>The first step in integrating Konditional serialization is adding the Moshi JSON library to your project. Moshi provides the serialization infrastructure that Konditional uses.</p> <p>::: tip Time estimate: 5 minutes</p> <p>Prerequisites: Gradle-based Kotlin project with Konditional already added :::</p>"},{"location":"serialization/steps/step-01-dependencies/#add-moshi-to-buildgradlekts","title":"Add Moshi to build.gradle.kts","text":"<p>Open your <code>build.gradle.kts</code> file and add the Moshi dependencies:</p> <p>```kotlin title=\"build.gradle.kts\" ins={2-4} dependencies {     // Moshi for JSON serialization     implementation(\"com.squareup.moshi:moshi:1.15.0\")     implementation(\"com.squareup.moshi:moshi-kotlin:1.15.0\")     implementation(\"com.squareup.moshi:moshi-adapters:1.15.0\")</p> <pre><code>// Your existing dependencies\nimplementation(\"io.amichne:konditional:1.0.0\")\n// ...\n</code></pre> <p>} ``` </p>"},{"location":"serialization/steps/step-01-dependencies/#why-these-dependencies","title":"Why These Dependencies?","text":"Dependency Purpose <code>moshi</code> Core JSON parsing and serialization <code>moshi-kotlin</code> Kotlin-specific adapters (data classes, default values) <code>moshi-adapters</code> Standard adapters for common types ::: note The Konditional serialization package already includes adapters for all Konditional types. You don't need to write custom adapters. ::: ## Sync Your Project After adding the dependencies, sync your Gradle project: ```bash ./gradlew build ```"},{"location":"serialization/steps/step-01-dependencies/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test to verify Moshi is working:</p> src/test/kotlin/VerifyMoshiTest.kt<pre><code>import com.squareup.moshi.Moshi\nimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass VerifyMoshiTest {\n    @Test\n    fun `moshi can serialize simple objects`() {\n        val moshi = Moshi.Builder()\n            .add(KotlinJsonAdapterFactory())\n            .build()\n\n        data class Person(val name: String, val age: Int)\n\n        val adapter = moshi.adapter(Person::class.java)\n        val person = Person(\"Alice\", 30)\n\n        val json = adapter.toJson(person)\n        val restored = adapter.fromJson(json)\n\n        assertEquals(person, restored)\n    }\n}\n</code></pre> <p>Run the test:</p> <pre><code>./gradlew test --tests VerifyMoshiTest\n</code></pre> <p>If the test passes, Moshi is correctly installed!</p>"},{"location":"serialization/steps/step-01-dependencies/#project-structure","title":"Project Structure","text":"<p>Your project should now look like this:</p> <pre><code>- build.gradle.kts\n- src/\n  - main/kotlin/\n    - your/package/\n      - FeatureFlags.kt (your existing flags)\n  - test/kotlin/\n    - VerifyMoshiTest.kt\n</code></pre>"},{"location":"serialization/steps/step-01-dependencies/#whats-next","title":"What's Next?","text":"<p>Now that Moshi is installed, you need to register your feature flags so they can be deserialized.</p> Next: Step 2 - Register Flags \u2192"},{"location":"serialization/steps/step-01-dependencies/#troubleshooting","title":"Troubleshooting","text":""},{"location":"serialization/steps/step-01-dependencies/#build-fails-with-could-not-resolve-dependency","title":"Build Fails with \"Could not resolve dependency\"","text":"<p>Problem: Gradle can't download Moshi</p> <p>Solution: Check your repository configuration:</p> build.gradle.kts<pre><code>repositories {\n    mavenCentral() // Moshi is on Maven Central\n}\n</code></pre>"},{"location":"serialization/steps/step-01-dependencies/#unresolved-reference-moshi","title":"\"Unresolved reference: Moshi\"","text":"<p>Problem: IDE hasn't picked up the new dependency</p> <p>Solution: 1. Click \"Sync Project with Gradle Files\" in your IDE 2. Or run <code>./gradlew --refresh-dependencies</code></p>"},{"location":"serialization/steps/step-01-dependencies/#version-conflicts","title":"Version Conflicts","text":"<p>Problem: Multiple versions of Moshi in the dependency tree</p> <p>Solution: Force a specific version:</p> build.gradle.kts<pre><code>configurations.all {\n    resolutionStrategy {\n        force(\"com.squareup.moshi:moshi:1.15.0\")\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/","title":"Step 2: Register Your Flags","text":""},{"location":"serialization/steps/step-02-register/#overview","title":"Overview","text":"<p>Before deserializing JSON, you must register all your <code>Conditional</code> instances with the <code>ConditionalRegistry</code>. This mapping allows the deserializer to convert string keys back into typed <code>Conditional</code> references.</p> <p>::: tip Time estimate: 10 minutes</p> <p>Why? The registry solves the problem of mapping string keys in JSON to strongly-typed Kotlin objects. :::</p>"},{"location":"serialization/steps/step-02-register/#understanding-the-registry","title":"Understanding the Registry","text":"<p>When you serialize a flag, it becomes a string key in JSON:</p> <pre><code>// In Kotlin\nenum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// In JSON\n{\n  \"key\": \"dark_mode\",  // Just a string!\n  ...\n}\n</code></pre> <p>When deserializing, we need to map <code>\"dark_mode\"</code> back to <code>FeatureFlags.DARK_MODE</code>. The registry handles this mapping.</p>"},{"location":"serialization/steps/step-02-register/#registration-methods","title":"Registration Methods","text":""},{"location":"serialization/steps/step-02-register/#method-1-register-an-entire-enum-recommended","title":"Method 1: Register an Entire Enum (Recommended)","text":"<p>If your flags are defined as an enum (the typical pattern), register the whole enum at once:</p> <pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\n\n// Register all flags in the enum\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n</code></pre> <p>This registers every enum constant automatically.</p>"},{"location":"serialization/steps/step-02-register/#method-2-register-individual-flags","title":"Method 2: Register Individual Flags","text":"<p>For non-enum flags or selective registration:</p> <pre><code>// Register specific flags\nConditionalRegistry.register(FeatureFlags.DARK_MODE)\nConditionalRegistry.register(FeatureFlags.NEW_ONBOARDING)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#method-3-register-multiple-enums","title":"Method 3: Register Multiple Enums","text":"<p>For projects with multiple flag enums:</p> <pre><code>// Register all your flag enums\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\nConditionalRegistry.registerEnum&lt;DebugFlags&gt;()\n</code></pre>"},{"location":"serialization/steps/step-02-register/#when-to-register","title":"When to Register","text":"<p>::: caution Critical: Register flags before calling <code>deserialize()</code>. Registration after deserialization will fail. :::</p>"},{"location":"serialization/steps/step-02-register/#application-startup-recommended","title":"Application Startup (Recommended)","text":"<p>Register flags as early as possible in your application lifecycle:</p> TabAndroidSpring BootKtorMain Function MyApplication.kt<pre><code>import android.app.Application\nimport io.amichne.konditional.serialization.ConditionalRegistry\n\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Register flags first thing\n        registerFeatureFlags()\n\n        // Then load configuration\n        loadFlagConfiguration()\n\n        // Rest of initialization...\n    }\n\n    private fun registerFeatureFlags() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n    }\n}\n</code></pre> FlagConfiguration.kt<pre><code>import org.springframework.context.annotation.Configuration\nimport javax.annotation.PostConstruct\n\n@Configuration\nclass FlagConfiguration {\n\n    @PostConstruct\n    fun registerFlags() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n    }\n}\n</code></pre> Application.kt<pre><code>import io.ktor.server.application.*\n\nfun Application.module() {\n    // Register flags before anything else\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    // Configure routes, etc.\n    configureRouting()\n}\n</code></pre> Main.kt<pre><code>fun main() {\n    // Register before doing anything with flags\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    // Load configuration\n    val config = loadConfiguration()\n\n    // Start application\n    runApplication(config)\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#create-a-registration-helper","title":"Create a Registration Helper","text":"<p>For larger projects, create a dedicated registration class:</p> FlagRegistration.kt<pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\n\n/**\n * Centralized registration of all feature flags.\n * Call [registerAll] once during application startup.\n */\nobject FlagRegistration {\n\n    private var registered = false\n\n    /**\n     * Registers all feature flags with the ConditionalRegistry.\n     * Safe to call multiple times - will only register once.\n     */\n    fun registerAll() {\n        if (registered) {\n            return\n        }\n\n        // Register all flag enums\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;DebugFlags&gt;()\n\n        registered = true\n    }\n\n    /**\n     * Clears all registrations. Only for testing!\n     */\n    fun clearForTesting() {\n        if (isTestEnvironment()) {\n            ConditionalRegistry.clear()\n            registered = false\n        }\n    }\n\n    private fun isTestEnvironment(): Boolean {\n        return try {\n            Class.forName(\"org.junit.jupiter.api.Test\")\n            true\n        } catch (e: ClassNotFoundException) {\n            false\n        }\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        FlagRegistration.registerAll()\n        // ...\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#testing-with-the-registry","title":"Testing with the Registry","text":"<p>In tests, you need to register and clean up properly:</p> FlagSerializationTest.kt<pre><code>import org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\n\nclass FlagSerializationTest {\n\n    @BeforeEach\n    fun setUp() {\n        // Register flags before each test\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        // Clean up after each test to avoid pollution\n        ConditionalRegistry.clear()\n    }\n\n    @Test\n    fun `test flag serialization`() {\n        // Test code here - flags are registered\n        val konfig = createTestSnapshot()\n        val json = SnapshotSerializer.default.serialize(konfig)\n\n        // This will work because flags are registered\n        val deserialized = SnapshotSerializer.default.deserialize(json)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#verification","title":"Verification","text":"<p>Verify your registration is working:</p> <pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\n\nfun verifyRegistration() {\n    // Register\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    // Check if specific keys are registered\n    val isDarkModeRegistered = ConditionalRegistry.contains(\"dark_mode\")\n    val isNewOnboardingRegistered = ConditionalRegistry.contains(\"new_onboarding\")\n\n    println(\"Dark mode registered: $isDarkModeRegistered\")\n    println(\"New onboarding registered: $isNewOnboardingRegistered\")\n\n    // You can also retrieve a flag\n    val darkMode: Conditional&lt;Boolean, Context&gt; = ConditionalRegistry.get(\"dark_mode\")\n    println(\"Retrieved flag: ${darkMode.key}\")\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#common-mistakes","title":"Common Mistakes","text":""},{"location":"serialization/steps/step-02-register/#deserializing-before-registering","title":"\u274c Deserializing Before Registering","text":"<pre><code>// This will crash!\nval konfig = SnapshotSerializer.default.deserialize(json)\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n// IllegalArgumentException: Conditional with key 'dark_mode' not found\n</code></pre>"},{"location":"serialization/steps/step-02-register/#correct-order","title":"\u2705 Correct Order","text":"<pre><code>// Register first\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n// Then deserialize\nval konfig = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#forgetting-some-flags","title":"\u274c Forgetting Some Flags","text":"<pre><code>// Only registered FeatureFlags\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n// JSON contains ExperimentFlags - will crash!\nval json = \"\"\"{\"flags\": [{\"key\": \"experiment_new_ui\", ...}]}\"\"\"\nval konfig = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#register-all-used-flags","title":"\u2705 Register All Used Flags","text":"<pre><code>// Register all flag types you use\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n\n// Now both types can be deserialized\nval konfig = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#whats-next","title":"What's Next?","text":"<p>With flags registered, you can now create your first serializable configuration.</p> \u2190 Previous: Step 1 - Dependencies Next: Step 3 - Create Configuration \u2192"},{"location":"serialization/steps/step-03-configuration/","title":"Step 3: Create Configuration","text":""},{"location":"serialization/steps/step-03-configuration/#overview","title":"Overview","text":"<p>In this step, you'll create a flag configuration using <code>ConfigBuilder</code>. This configuration will define your feature flags with their default values and targeting rules.</p> <p>::: tip Time estimate: 15-20 minutes</p> <p>Goal: Create a <code>Flags.Snapshot</code> that can be serialized to JSON :::</p>"},{"location":"serialization/steps/step-03-configuration/#your-first-configuration","title":"Your First Configuration","text":"<p>Let's assume you have these feature flags defined:</p> FeatureFlags.kt<pre><code>enum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_ONBOARDING(\"new_onboarding\"),\n    COMPACT_CARDS(\"compact_cards\"),\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#simple-configuration","title":"Simple Configuration","text":"<p>Start with a basic configuration using default values only:</p> <pre><code>import io.amichne.konditional.builders.ConfigBuilder\n\nval konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(false)\n    }\n\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n    }\n\n    FeatureFlags.COMPACT_CARDS with {\n        default(true)\n    }\n}\n</code></pre> <p>This creates a konfig where: - <code>DARK_MODE</code> defaults to <code>false</code> - <code>NEW_ONBOARDING</code> defaults to <code>false</code> - <code>COMPACT_CARDS</code> defaults to <code>true</code></p> <p>No targeting rules yet - all users see the same values.</p>"},{"location":"serialization/steps/step-03-configuration/#adding-targeting-rules","title":"Adding Targeting Rules","text":"<p>Now let's add rules to target specific users:</p>"},{"location":"serialization/steps/step-03-configuration/#example-1-platform-based-targeting","title":"Example 1: Platform-Based Targeting","text":"<p>Enable dark mode only on iOS:</p> <pre><code>import io.amichne.konditional.context.Platform\n\nval konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#example-2-locale-based-targeting","title":"Example 2: Locale-Based Targeting","text":"<p>Enable new onboarding for US users:</p> <pre><code>import io.amichne.konditional.context.AppLocale\n\nval konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n\n        rule {\n            locales(AppLocale.EN_US, AppLocale.ES_US)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#example-3-gradual-rollout","title":"Example 3: Gradual Rollout","text":"<p>Roll out to 25% of users using rollout:</p> <pre><code>import io.amichne.konditional.context.Rollout\n\nval konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.COMPACT_CARDS with {\n        default(false)\n\n        rule {\n            rollout = Rollout.of(25.0) // 25% of users\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#example-4-version-based-targeting","title":"Example 4: Version-Based Targeting","text":"<p>Enable for users on version 2.0.0 or higher:</p> <pre><code>val konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(false)\n\n        rule {\n            versions {\n                min(2, 0, 0)\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#combining-criteria","title":"Combining Criteria","text":"<p>Rules can combine multiple targeting criteria:</p> <pre><code>val konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n\n        // Rule 1: 50% rollout for US iOS users on v2.0+\n        rule {\n            rollout = Rollout.of(50.0)\n            locales(AppLocale.EN_US)\n            platforms(Platform.IOS)\n            versions {\n                min(2, 0, 0)\n            }\n        }.implies(true)\n\n        // Rule 2: 100% for all Android users on v2.1+\n        rule {\n            platforms(Platform.ANDROID)\n            versions {\n                min(2, 1, 0)\n            }\n        }.implies(true)\n    }\n}\n</code></pre> <p>::: note Rules are evaluated in order of specificity (most specific first). More specific rules override less specific ones. :::</p>"},{"location":"serialization/steps/step-03-configuration/#real-world-configuration","title":"Real-World Configuration","text":"<p>Here's a complete example for a production app:</p> createProductionConfig.kt<pre><code>import io.amichne.konditional.builders.ConfigBuilder\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Rollout\n\nfun createProductionConfig(): Flags.Snapshot {\n    return ConfigBuilder.buildSnapshot {\n        // Dark Mode: Enabled for everyone\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        // New Onboarding: Gradual rollout\n        FeatureFlags.NEW_ONBOARDING with {\n            default(false)\n\n            // 10% rollout for US users\n            rule {\n                rollout = Rollout.of(10.0)\n                locales(AppLocale.EN_US)\n            }.implies(true)\n\n            // 5% rollout for other English locales\n            rule {\n                rollout = Rollout.of(5.0)\n                locales(AppLocale.EN_CA)\n            }.implies(true)\n        }\n\n        // Compact Cards: Platform-specific\n        FeatureFlags.COMPACT_CARDS with {\n            default(false)\n\n            // Enable for all mobile platforms\n            rule {\n                platforms(Platform.IOS, Platform.ANDROID)\n            }.implies(true)\n\n            // But disable for old versions\n            rule {\n                versions {\n                    max(1, 9, 9)\n                }\n            }.implies(false)\n        }\n\n        // Premium Feature: Version and platform gated\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(false)\n\n            rule {\n                platforms(Platform.IOS)\n                versions {\n                    min(2, 0, 0)\n                }\n            }.implies(true)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>Create different configs for different environments:</p> TabDevelopmentStagingProduction <pre><code>  title=\"developmentConfig.kt\"\nfun createDevelopmentConfig() = ConfigBuilder.buildSnapshot {\n    // Everything enabled for development\n    FeatureFlags.DARK_MODE with { default(true) }\n    FeatureFlags.NEW_ONBOARDING with { default(true) }\n    FeatureFlags.COMPACT_CARDS with { default(true) }\n    FeatureFlags.DEBUG_MENU with { default(true) }\n}\n</code></pre> stagingConfig.kt<pre><code>fun createStagingConfig() = ConfigBuilder.buildSnapshot {\n    // Production-like with some overrides\n    FeatureFlags.DARK_MODE with { default(true) }\n\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n        rule {\n            rollout = Rollout.of(50.0) // Higher rollout for testing\n        }.implies(true)\n    }\n\n    FeatureFlags.COMPACT_CARDS with { default(true) }\n    FeatureFlags.DEBUG_MENU with { default(true) } // Debug tools available\n}\n</code></pre> productionConfig.kt<pre><code>fun createProductionConfig() = ConfigBuilder.buildSnapshot {\n    // Conservative rollouts\n    FeatureFlags.DARK_MODE with { default(true) }\n\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n        rule {\n            rollout = Rollout.of(10.0) // Careful rollout\n            locales(AppLocale.EN_US)\n        }.implies(true)\n    }\n\n    FeatureFlags.COMPACT_CARDS with { default(false) }\n    FeatureFlags.DEBUG_MENU with { default(false) } // Disabled\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"serialization/steps/step-03-configuration/#1-document-your-rules","title":"1. Document Your Rules","text":"<p>Use the <code>note</code> field to explain why a rule exists:</p> <pre><code>rule {\n    rollout = Rollout.of(50.0)\n    locales(AppLocale.EN_US)\n    platforms(Platform.IOS)\n    note = \"JIRA-123: Gradual rollout for US iOS users to test performance\"\n}.implies(true)\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#2-use-salt-for-experiment-rebucketing","title":"2. Use Salt for Experiment Rebucketing","text":"<p>Change the salt when you want to rebucket users:</p> <pre><code>FeatureFlags.NEW_EXPERIMENT with {\n    default(false)\n    salt = \"v2\" // Changed from \"v1\" to rebucket users\n\n    rule {\n        rollout = Rollout.of(50.0)\n    }.implies(true)\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#3-keep-defaults-conservative","title":"3. Keep Defaults Conservative","text":"<p>Default to <code>false</code> for new features:</p> <pre><code>FeatureFlags.RISKY_NEW_FEATURE with {\n    default(false) // Safe default\n    // Add rules to selectively enable\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#4-test-your-configuration","title":"4. Test Your Configuration","text":"<p>Before serializing, test that it behaves as expected:</p> <pre><code>fun testConfiguration() {\n    val konfig = createProductionConfig()\n    Flags.load(konfig)\n\n    // Test various contexts\n    val usIosContext = Context(\n        AppLocale.EN_US,\n        Platform.IOS,\n        Version.of(2, 0, 0),\n        StableId.of(\"test-user-1\")\n    )\n\n    with(Flags) {\n        val darkMode = usIosContext.evaluate(FeatureFlags.DARK_MODE)\n        val onboarding = usIosContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n\n        println(\"Dark mode: $darkMode\")\n        println(\"New onboarding: $onboarding\")\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#whats-next","title":"What's Next?","text":"<p>Now that you have a configuration, you'll serialize it to JSON in the next step.</p> \u2190 Previous: Step 2 - Register Flags Next: Step 4 - Serialize \u2192"},{"location":"serialization/steps/step-04-serialize/","title":"Step 4: Serialize to JSON","text":""},{"location":"serialization/steps/step-04-serialize/#overview","title":"Overview","text":"<p>With a <code>Flags.Snapshot</code> created, you can now serialize it to JSON. This JSON can be committed to version control, deployed to a CDN, or stored in a configuration service.</p> <p>::: tip Time estimate: 10 minutes</p> <p>Output: A JSON file containing your complete flag configuration :::</p>"},{"location":"serialization/steps/step-04-serialize/#basic-serialization","title":"Basic Serialization","text":"<p>The <code>SnapshotSerializer</code> provides a simple API for serialization:</p> <pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\n\n// Create your configuration\nval konfig = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(true)\n    }\n}\n\n// Serialize to JSON\nval serializer = SnapshotSerializer.default\nval json = serializer.serialize(konfig)\n\nprintln(json)\n</code></pre> <p>Output:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"type\": \"BOOLEAN\",\n      \"defaultValue\": true,\n      \"default\": {\n        \"value\": true,\n        \"type\": \"BOOLEAN\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": []\n    }\n  ]\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#saving-to-a-file","title":"Saving to a File","text":"<p>Write the JSON to a file:</p> <pre><code>import java.io.File\n\nfun saveConfiguration(konfig: Flags.Snapshot, outputPath: String) {\n    val json = SnapshotSerializer.default.serialize(konfig)\n    File(outputPath).writeText(json)\n    println(\"Configuration saved to $outputPath\")\n}\n\n// Usage\nval konfig = createProductionConfig()\nsaveConfiguration(konfig, \"config/production-flags.json\")\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#pretty-printing","title":"Pretty Printing","text":"<p>The serializer automatically formats JSON with indentation for readability:</p> <pre><code>val json = SnapshotSerializer.default.serialize(konfig)\n// Already pretty-printed with 2-space indentation!\n</code></pre> <p>If you need custom formatting:</p> <pre><code>import com.squareup.moshi.Moshi\nimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\n\n// Create a custom serializer with 4-space indentation\nval customMoshi = Moshi.Builder()\n    .add(KotlinJsonAdapterFactory())\n    .build()\n\nval customSerializer = SnapshotSerializer(customMoshi)\nval adapter = customMoshi.adapter(SerializableSnapshot::class.java).indent(\"    \")\n\nval konfig = createConfig()\nval serializableSnapshot = konfig.toSerializable()\nval json = adapter.toJson(serializableSnapshot)\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#serializing-complex-configurations","title":"Serializing Complex Configurations","text":"<p>For the production config from Step 3:</p> <pre><code>fun serializeProductionConfig() {\n    val konfig = createProductionConfig()\n    val json = SnapshotSerializer.default.serialize(konfig)\n\n    File(\"config/production-flags.json\").writeText(json)\n}\n</code></pre> <p>The resulting JSON will look like:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"type\": \"BOOLEAN\",\n      \"defaultValue\": true,\n      \"default\": {\n        \"value\": true,\n        \"type\": \"BOOLEAN\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": []\n    },\n    {\n      \"key\": \"new_onboarding\",\n      \"type\": \"BOOLEAN\",\n      \"defaultValue\": false,\n      \"default\": {\n        \"value\": false,\n        \"type\": \"BOOLEAN\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"value\": true,\n            \"type\": \"BOOLEAN\"\n          },\n          \"rollout\": 10.0,\n          \"note\": null,\n          \"locales\": [\"EN_US\"],\n          \"platforms\": [],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#environment-specific-serialization","title":"Environment-Specific Serialization","text":"<p>Create separate JSON files for each environment:</p> <pre><code>fun serializeAllEnvironments() {\n    // Development\n    val devSnapshot = createDevelopmentConfig()\n    File(\"config/dev-flags.json\").writeText(\n        SnapshotSerializer.default.serialize(devSnapshot)\n    )\n\n    // Staging\n    val stagingSnapshot = createStagingConfig()\n    File(\"config/staging-flags.json\").writeText(\n        SnapshotSerializer.default.serialize(stagingSnapshot)\n    )\n\n    // Production\n    val prodSnapshot = createProductionConfig()\n    File(\"config/production-flags.json\").writeText(\n        SnapshotSerializer.default.serialize(prodSnapshot)\n    )\n\n    println(\"All configurations serialized successfully\")\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#automating-serialization","title":"Automating Serialization","text":""},{"location":"serialization/steps/step-04-serialize/#gradle-task","title":"Gradle Task","text":"<p>Create a Gradle task to generate configuration files:</p> build.gradle.kts<pre><code>tasks.register(\"generateFlagConfigs\") {\n    doLast {\n        // Use reflection or source generation to run your config builder\n        exec {\n            mainClass.set(\"com.yourapp.ConfigGeneratorKt\")\n            classpath = sourceSets[\"main\"].runtimeClasspath\n        }\n    }\n}\n</code></pre> <p>Then create the generator:</p> ConfigGenerator.kt<pre><code>package com.yourapp\n\nfun main() {\n    println(\"Generating flag configurations...\")\n\n    val environments = mapOf(\n        \"development\" to createDevelopmentConfig(),\n        \"staging\" to createStagingConfig(),\n        \"production\" to createProductionConfig()\n    )\n\n    environments.forEach { (env, konfig) -&gt;\n        val outputFile = File(\"config/$env-flags.json\")\n        outputFile.parentFile.mkdirs()\n\n        val json = SnapshotSerializer.default.serialize(konfig)\n        outputFile.writeText(json)\n\n        println(\"\u2713 Generated $env configuration (${outputFile.absolutePath})\")\n    }\n\n    println(\"Done!\")\n}\n</code></pre> <p>Run it:</p> <pre><code>./gradlew generateFlagConfigs\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#validation","title":"Validation","text":"<p>Before committing JSON to version control, validate it:</p> <pre><code>fun validateSerializedConfig(jsonPath: String): Boolean {\n    return try {\n        val json = File(jsonPath).readText()\n\n        // Attempt to deserialize\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        val konfig = SnapshotSerializer.default.deserialize(json)\n\n        // Check basic properties\n        require(konfig.flags.isNotEmpty()) {\n            \"Configuration must contain at least one flag\"\n        }\n\n        // Optionally: test some evaluations\n        testConfiguration(konfig)\n\n        println(\"\u2713 Configuration is valid\")\n        true\n    } catch (e: Exception) {\n        println(\"\u2717 Validation failed: ${e.message}\")\n        e.printStackTrace()\n        false\n    }\n}\n\nfun testConfiguration(konfig: Flags.Snapshot) {\n    Flags.load(konfig)\n\n    val testContext = Context(\n        AppLocale.EN_US,\n        Platform.IOS,\n        Version.of(2, 0, 0),\n        StableId.of(\"test-user\")\n    )\n\n    with(Flags) {\n        // Verify critical flags evaluate without error\n        testContext.evaluate(FeatureFlags.DARK_MODE)\n        testContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#version-control","title":"Version Control","text":"<p>Add generated JSON to version control:</p> .gitignore<pre><code># Don't ignore configuration files!\n# config/*.json\n</code></pre> <p>Commit your configurations:</p> <pre><code>git add config/production-flags.json\ngit add config/staging-flags.json\ngit commit -m \"Update feature flag configuration\"\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#cicd-integration","title":"CI/CD Integration","text":"<p>In your CI pipeline, validate configurations:</p> .github/workflows/validate-flags.yml<pre><code>name: Validate Flag Configurations\n\non: [push, pull_request]\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n\n      - name: Validate configurations\n        run: ./gradlew test --tests FlagValidationTest\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#whats-next","title":"What's Next?","text":"<p>Now you have JSON files ready to be deserialized. In the next step, you'll learn how to load them back into your application.</p> \u2190 Previous: Step 3 - Create Configuration Next: Step 5 - Deserialize \u2192"},{"location":"serialization/steps/step-05-deserialize/","title":"Step 5: Deserialize JSON","text":""},{"location":"serialization/steps/step-05-deserialize/#overview","title":"Overview","text":"<p>Deserialization converts JSON back into a <code>Flags.Snapshot</code> that can be loaded into the runtime. This is typically done during application startup or when updating configurations.</p> <p>::: tip Time estimate: 15 minutes</p> <p>Goal: Load your JSON configuration into a usable <code>Flags.Snapshot</code> :::</p>"},{"location":"serialization/steps/step-05-deserialize/#basic-deserialization","title":"Basic Deserialization","text":"<pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\nimport java.io.File\n\n// 1. Register your flags (critical!)\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n// 2. Read JSON from file\nval json = File(\"config/production-flags.json\").readText()\n\n// 3. Deserialize\nval konfig = SnapshotSerializer.default.deserialize(json)\n\nprintln(\"Loaded ${konfig.flags.size} flags\")\n</code></pre> <p>::: caution Always register flags before deserializing, or you'll get an <code>IllegalArgumentException</code>. :::</p>"},{"location":"serialization/steps/step-05-deserialize/#loading-from-different-sources","title":"Loading from Different Sources","text":""},{"location":"serialization/steps/step-05-deserialize/#from-resources-embedded-in-apkjar","title":"From Resources (Embedded in APK/JAR)","text":"<pre><code>fun loadEmbeddedConfiguration(): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = javaClass.getResourceAsStream(\"/flags.json\")\n        ?.bufferedReader()\n        ?.use { it.readText() }\n        ?: throw IllegalStateException(\"flags.json not found in resources\")\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#from-assets-android","title":"From Assets (Android)","text":"<pre><code>import android.content.Context as AndroidContext\n\nfun loadFromAssets(context: AndroidContext): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = context.assets.open(\"flags.json\")\n        .bufferedReader()\n        .use { it.readText() }\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#from-remote-url","title":"From Remote URL","text":"<pre><code>import java.net.URL\n\nsuspend fun loadRemoteConfiguration(url: String): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = withContext(Dispatchers.IO) {\n        URL(url).readText()\n    }\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n\n// Usage\nlifecycleScope.launch {\n    val konfig = loadRemoteConfiguration(\"https://cdn.example.com/flags.json\")\n    Flags.load(konfig)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#from-network-with-okhttp","title":"From Network with OkHttp","text":"<pre><code>import okhttp3.OkHttpClient\nimport okhttp3.Request\n\nsuspend fun loadFromCDN(client: OkHttpClient, url: String): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = withContext(Dispatchers.IO) {\n        val request = Request.Builder()\n            .url(url)\n            .build()\n\n        client.newCall(request).execute().use { response -&gt;\n            response.body?.string()\n                ?: throw IOException(\"Empty response body\")\n        }\n    }\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#error-handling","title":"Error Handling","text":"<p>Production code must handle deserialization errors gracefully:</p>"},{"location":"serialization/steps/step-05-deserialize/#pattern-1-fallback-to-embedded-config","title":"Pattern 1: Fallback to Embedded Config","text":"<pre><code>fun loadConfigWithFallback(context: AndroidContext): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    return try {\n        // Try to load from cache/remote\n        loadCachedConfiguration()\n    } catch (e: Exception) {\n        logger.warn(\"Failed to load cached config, using embedded\", e)\n        try {\n            loadEmbeddedConfiguration(context)\n        } catch (e: Exception) {\n            logger.error(\"Failed to load embedded config, using hardcoded\", e)\n            createDefaultSnapshot()\n        }\n    }\n}\n\nfun createDefaultSnapshot(): Flags.Snapshot {\n    // Last resort: hardcoded defaults\n    return ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with { default(false) }\n        FeatureFlags.NEW_ONBOARDING with { default(false) }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#pattern-2-result-type","title":"Pattern 2: Result Type","text":"<pre><code>sealed class ConfigLoadResult {\n    data class Success(val konfig: Flags.Snapshot) : ConfigLoadResult()\n    data class Error(val error: Exception, val fallback: Flags.Snapshot) : ConfigLoadResult()\n}\n\nfun loadConfiguration(json: String): ConfigLoadResult {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    return try {\n        val konfig = SnapshotSerializer.default.deserialize(json)\n        ConfigLoadResult.Success(konfig)\n    } catch (e: Exception) {\n        logger.error(\"Deserialization failed\", e)\n        val fallback = createDefaultSnapshot()\n        ConfigLoadResult.Error(e, fallback)\n    }\n}\n\n// Usage\nwhen (val result = loadConfiguration(json)) {\n    is ConfigLoadResult.Success -&gt; {\n        Flags.load(result.konfig)\n        showToast(\"Configuration loaded\")\n    }\n    is ConfigLoadResult.Error -&gt; {\n        Flags.load(result.fallback)\n        showToast(\"Using default configuration\")\n        logError(result.error)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#validation-after-deserialization","title":"Validation After Deserialization","text":"<p>Validate the deserialized konfig before using it:</p> <pre><code>fun loadAndValidate(json: String): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val konfig = SnapshotSerializer.default.deserialize(json)\n\n    // Validate\n    require(konfig.flags.isNotEmpty()) {\n        \"Snapshot must contain at least one flag\"\n    }\n\n    // Check required flags exist\n    val requiredFlags = setOf(\"dark_mode\", \"new_onboarding\")\n    val actualFlags = konfig.flags.keys.map { it.key }.toSet()\n\n    require(requiredFlags.all { it in actualFlags }) {\n        \"Missing required flags: ${requiredFlags - actualFlags}\"\n    }\n\n    // Test evaluation works\n    val testContext = createTestContext()\n    Flags.load(konfig)\n\n    with(Flags) {\n        testContext.evaluate(FeatureFlags.DARK_MODE)\n        testContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n    }\n\n    return konfig\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#caching-deserialized-snapshots","title":"Caching Deserialized Snapshots","text":"<p>Don't deserialize repeatedly - cache the result:</p> <pre><code>object FlagCache {\n    private var cached: Flags.Snapshot? = null\n    private var lastLoadTime: Long = 0\n\n    fun getSnapshot(forceRefresh: Boolean = false): Flags.Snapshot {\n        val cacheAge = System.currentTimeMillis() - lastLoadTime\n\n        if (!forceRefresh &amp;&amp; cached != null &amp;&amp; cacheAge &lt; CACHE_TTL) {\n            return cached!!\n        }\n\n        // Load fresh\n        val konfig = loadConfiguration()\n        cached = konfig\n        lastLoadTime = System.currentTimeMillis()\n\n        return konfig\n    }\n\n    fun clear() {\n        cached = null\n        lastLoadTime = 0\n    }\n\n    private companion object {\n        const val CACHE_TTL = 5 * 60 * 1000L // 5 minutes\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#background-loading","title":"Background Loading","text":"<p>Load configurations in the background to avoid blocking the UI:</p> <pre><code>class FlagLoader(private val context: AndroidContext) {\n\n    suspend fun loadInBackground(): Flags.Snapshot = withContext(Dispatchers.IO) {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        try {\n            // Try remote first\n            loadFromRemote()\n        } catch (e: IOException) {\n            logger.warn(\"Remote load failed, trying cache\", e)\n            try {\n                loadFromCache()\n            } catch (e: Exception) {\n                logger.warn(\"Cache load failed, using embedded\", e)\n                loadEmbedded()\n            }\n        }\n    }\n\n    private fun loadFromRemote(): Flags.Snapshot {\n        val url = getConfigUrl()\n        val json = URL(url).readText()\n\n        // Cache for next time\n        cacheJson(json)\n\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun loadFromCache(): Flags.Snapshot {\n        val cacheFile = File(context.cacheDir, \"flags.json\")\n        val json = cacheFile.readText()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun loadEmbedded(): Flags.Snapshot {\n        val json = context.assets.open(\"default-flags.json\")\n            .bufferedReader()\n            .use { it.readText() }\n\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun cacheJson(json: String) {\n        File(context.cacheDir, \"flags.json\").writeText(json)\n    }\n\n    private fun getConfigUrl(): String {\n        val environment = BuildConfig.ENVIRONMENT\n        return \"https://cdn.example.com/flags-$environment.json\"\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#testing-deserialization","title":"Testing Deserialization","text":"<p>Test your deserialization logic:</p> <pre><code>class DeserializationTest {\n\n    @BeforeEach\n    fun setUp() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        ConditionalRegistry.clear()\n    }\n\n    @Test\n    fun `deserialize valid JSON successfully`() {\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"dark_mode\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        val konfig = SnapshotSerializer.default.deserialize(json)\n\n        assertEquals(1, konfig.flags.size)\n    }\n\n    @Test\n    fun `deserialization fails gracefully with invalid JSON`() {\n        val invalidJson = \"not valid json\"\n\n        assertThrows&lt;JsonDataException&gt; {\n            SnapshotSerializer.default.deserialize(invalidJson)\n        }\n    }\n\n    @Test\n    fun `deserialization fails if flag not registered`() {\n        ConditionalRegistry.clear() // Clear registration\n\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"unknown_flag\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        assertThrows&lt;IllegalArgumentException&gt; {\n            SnapshotSerializer.default.deserialize(json)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#whats-next","title":"What's Next?","text":"<p>With deserialization working, you'll learn how to load the konfig into the runtime.</p> \u2190 Previous: Step 4 - Serialize Next: Step 6 - Load into Runtime \u2192"},{"location":"serialization/steps/step-06-load/","title":"Step 6: Load into Runtime","text":""},{"location":"serialization/steps/step-06-load/#overview","title":"Overview","text":"<p>After deserializing JSON into a <code>Snapshot</code>, you need to load it into the <code>SingletonFlagRegistry</code> so your application can evaluate feature flags.</p> <p>::: tip Time estimate: 5 minutes</p> <p>Goal: Make flags available for evaluation throughout your application :::</p>"},{"location":"serialization/steps/step-06-load/#loading-the-snapshot","title":"Loading the Snapshot","text":"<p>The <code>SingletonFlagRegistry.load()</code> method loads a konfig into the singleton registry:</p> <pre><code>import io.amichne.konditional.core.SingletonFlagRegistry\nimport io.amichne.konditional.serialization.SnapshotSerializer\n\n// After deserializing\nval konfig = SnapshotSerializer.default.deserialize(json)\n\n// Load into runtime\nSingletonFlagRegistry.load(konfig)\n\n// Now flags are ready to use!\n</code></pre> <p>That's it! Once loaded, you can evaluate flags from anywhere in your application.</p>"},{"location":"serialization/steps/step-06-load/#when-to-load","title":"When to Load","text":""},{"location":"serialization/steps/step-06-load/#application-startup-recommended","title":"Application Startup (Recommended)","text":"<p>Load flags as early as possible:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Register flags\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        // Load configuration\n        loadFeatureFlags()\n\n        // Continue initialization...\n    }\n\n    private fun loadFeatureFlags() {\n        val json = loadConfigJson() // From assets, network, etc.\n        val konfig = SnapshotSerializer.default.deserialize(json)\n        SingletonFlagRegistry.load(konfig)\n\n        logger.info(\"Feature flags loaded: ${konfig.flags.size} flags\")\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#lazy-loading","title":"Lazy Loading","text":"<p>If you need to defer loading:</p> <pre><code>object FlagManager {\n    private var initialized = false\n\n    fun ensureLoaded(context: Context) {\n        if (initialized) return\n\n        synchronized(this) {\n            if (initialized) return\n\n            ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n            val json = context.assets.open(\"flags.json\")\n                .bufferedReader()\n                .use { it.readText() }\n\n            val konfig = SnapshotSerializer.default.deserialize(json)\n            SingletonFlagRegistry.load(konfig)\n\n            initialized = true\n        }\n    }\n}\n\n// Call before using flags\nFlagManager.ensureLoaded(context)\n</code></pre>"},{"location":"serialization/steps/step-06-load/#evaluating-flags","title":"Evaluating Flags","text":"<p>Once loaded, evaluate flags using a <code>Context</code>:</p> <pre><code>import io.amichne.konditional.context.Context\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Version\nimport io.amichne.konditional.core.StableId\n\n// Create a context for the current user\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.of(2, 1, 0),\n    stableId = StableId.of(getUserId())\n)\n\n// Evaluate flags\nval isDarkModeEnabled = context.evaluate(FeatureFlags.DARK_MODE)\nval showNewOnboarding = context.evaluate(FeatureFlags.NEW_ONBOARDING)\n\nif (isDarkModeEnabled) {\n    enableDarkMode()\n}\n\nif (showNewOnboarding) {\n    showOnboardingScreen()\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#reloading-flags","title":"Reloading Flags","text":"<p>You can reload flags at runtime by calling <code>load()</code> again:</p> <pre><code>fun reloadFlags() {\n    // Download new configuration\n    val json = downloadLatestConfig()\n\n    // Deserialize\n    val konfig = SnapshotSerializer.default.deserialize(json)\n\n    // Reload (replaces current configuration)\n    SingletonFlagRegistry.load(konfig)\n\n    logger.info(\"Flags reloaded successfully\")\n\n    // Notify listeners if needed\n    notifyFlagChangeListeners()\n}\n</code></pre> <p>::: note Reloading flags is thread-safe. The <code>SingletonFlagRegistry</code> uses atomic operations to ensure consistency. :::</p>"},{"location":"serialization/steps/step-06-load/#thread-safety","title":"Thread Safety","text":"<p>The <code>SingletonFlagRegistry</code> is thread-safe and can be accessed from multiple threads:</p> <pre><code>// Thread 1: Loading\nCoroutineScope(Dispatchers.IO).launch {\n    val konfig = loadRemoteConfiguration()\n    SingletonFlagRegistry.load(konfig)\n}\n\n// Thread 2: Evaluating (safe even during reload)\nCoroutineScope(Dispatchers.Main).launch {\n    val value = context.evaluate(FeatureFlags.DARK_MODE)\n    updateUI(value)\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#complete-integration-example","title":"Complete Integration Example","text":"<p>Here's a complete example integrating loading and evaluation:</p> <pre><code>class MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Ensure flags are loaded\n        ensureFlagsLoaded()\n\n        // Use flags to control UI\n        setupUI()\n    }\n\n    private fun ensureFlagsLoaded() {\n        if (!FlagManager.isLoaded) {\n            FlagManager.load(this)\n        }\n    }\n\n    private fun setupUI() {\n        val context = createUserContext()\n\n        // Check dark mode flag\n        if (context.evaluate(FeatureFlags.DARK_MODE)) {\n            setTheme(R.style.DarkTheme)\n        }\n\n        // Check UI variant flags\n        if (context.evaluate(FeatureFlags.COMPACT_CARDS)) {\n            setContentView(R.layout.activity_main_compact)\n        } else {\n            setContentView(R.layout.activity_main_standard)\n        }\n\n        // Check feature availability\n        if (context.evaluate(FeatureFlags.NEW_FEATURE)) {\n            showNewFeatureBadge()\n        }\n    }\n\n    private fun createUserContext(): Context {\n        return Context(\n            locale = getCurrentLocale(),\n            platform = Platform.ANDROID,\n            appVersion = Version.of(BuildConfig.VERSION_CODE),\n            stableId = StableId.of(getUserId())\n        )\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#observing-flag-changes","title":"Observing Flag Changes","text":"<p>If you need to react to flag changes, implement an observer pattern:</p> <pre><code>object FlagObserver {\n    private val listeners = mutableSetOf&lt;() -&gt; Unit&gt;()\n\n    fun addListener(listener: () -&gt; Unit) {\n        listeners.add(listener)\n    }\n\n    fun removeListener(listener: () -&gt; Unit) {\n        listeners.remove(listener)\n    }\n\n    fun notifyChange() {\n        listeners.forEach { it() }\n    }\n}\n\n// When reloading flags\nfun reloadFlags() {\n    val konfig = loadNewConfiguration()\n    SingletonFlagRegistry.load(konfig)\n\n    // Notify observers\n    FlagObserver.notifyChange()\n}\n\n// In your UI\nclass MyFragment : Fragment() {\n    private val flagChangeListener = {\n        refreshUI()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        FlagObserver.addListener(flagChangeListener)\n    }\n\n    override fun onPause() {\n        super.onPause()\n        FlagObserver.removeListener(flagChangeListener)\n    }\n\n    private fun refreshUI() {\n        val context = createUserContext()\n        updateDarkMode(context.evaluate(FeatureFlags.DARK_MODE))\n        updateCompactMode(context.evaluate(FeatureFlags.COMPACT_CARDS))\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#best-practices","title":"Best Practices","text":""},{"location":"serialization/steps/step-06-load/#1-load-early","title":"1. Load Early","text":"<p>Load flags as early as possible to avoid race conditions:</p> <pre><code>// \u2705 Good: Load in Application.onCreate()\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        loadFlags() // First thing\n        initializeLibraries() // After flags\n    }\n}\n\n// \u274c Bad: Load lazily when first needed\nfun someActivity() {\n    loadFlagsIfNeeded() // Too late, might miss flags\n    if (isDarkModeEnabled()) { ... }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#2-handle-missing-flags-gracefully","title":"2. Handle Missing Flags Gracefully","text":"<p>Always provide defaults:</p> <pre><code>fun isDarkModeEnabled(context: Context): Boolean {\n    return try {\n        context.evaluate(FeatureFlags.DARK_MODE)\n    } catch (e: IllegalStateException) {\n        // Flag not found - return safe default\n        logger.warn(\"Dark mode flag not found, defaulting to false\", e)\n        false\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#3-cache-user-context","title":"3. Cache User Context","text":"<p>Don't create contexts repeatedly:</p> <pre><code>// \u2705 Good: Create once, reuse\nclass UserSession {\n    val flagContext by lazy {\n        Context(\n            locale = getUserLocale(),\n            platform = Platform.ANDROID,\n            appVersion = Version.of(BuildConfig.VERSION_CODE),\n            stableId = StableId.of(getUserId())\n        )\n    }\n}\n\n// \u274c Bad: Create every time\nfun checkFlag(): Boolean {\n    val context = Context(...) // Recreated unnecessarily\n    return context.evaluate(flag)\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#whats-next","title":"What's Next?","text":"<p>With flags loaded and working, you should add tests to ensure everything works correctly.</p> \u2190 Previous: Step 5 - Deserialize Next: Step 7 - Testing \u2192"},{"location":"serialization/steps/step-07-testing/","title":"Step 7: Testing","text":""},{"location":"serialization/steps/step-07-testing/#overview","title":"Overview","text":"<p>Thorough testing ensures your serialization implementation works correctly and prevents regressions. This step covers unit tests, integration tests, and property-based tests.</p> <p>::: tip Time estimate: 30 minutes</p> <p>Goal: Comprehensive test coverage for serialization workflows :::</p>"},{"location":"serialization/steps/step-07-testing/#test-setup","title":"Test Setup","text":"<p>Create a base test class with proper setup/teardown:</p> BaseSerializationTest.kt<pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\n\nabstract class BaseSerializationTest {\n\n    @BeforeEach\n    fun setUp() {\n        // Register flags before each test\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        // Clean up registry to avoid test pollution\n        ConditionalRegistry.clear()\n    }\n\n    protected fun createTestContext() = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version.of(2, 0, 0),\n        stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n    )\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#unit-tests","title":"Unit Tests","text":""},{"location":"serialization/steps/step-07-testing/#test-1-basic-serialization","title":"Test 1: Basic Serialization","text":"<pre><code>class BasicSerializationTest : BaseSerializationTest() {\n\n    @Test\n    fun `serialize simple flag configuration`() {\n        val konfig = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with {\n                default(true)\n            }\n        }\n\n        val json = SnapshotSerializer.default.serialize(konfig)\n\n        assertNotNull(json)\n        assertTrue(json.contains(\"dark_mode\"))\n        assertTrue(json.contains(\"BOOLEAN\"))\n        assertTrue(json.contains(\"\\\"defaultValue\\\": true\"))\n    }\n\n    @Test\n    fun `deserialize simple flag configuration`() {\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"dark_mode\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"salt\": \"v1\",\n                  \"isActive\": true,\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        val konfig = SnapshotSerializer.default.deserialize(json)\n\n        assertEquals(1, konfig.flags.size)\n        assertTrue(konfig.flags.containsKey(FeatureFlags.DARK_MODE))\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#test-2-round-trip-equality","title":"Test 2: Round-Trip Equality","text":"<pre><code>class RoundTripTest : BaseSerializationTest() {\n\n    @Test\n    fun `round-trip preserves simple configuration`() {\n        val original = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n            FeatureFlags.NEW_ONBOARDING with { default(false) }\n        }\n\n        val json = SnapshotSerializer.default.serialize(original)\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        assertSnapshotsEqual(original, restored)\n    }\n\n    @Test\n    fun `round-trip preserves complex rules`() {\n        val original = ConfigBuilder.buildSnapshot {\n            FeatureFlags.NEW_ONBOARDING with {\n                default(false)\n                rule {\n                    rollout = Rollout.of(50.0)\n                    locales(AppLocale.EN_US, AppLocale.EN_CA)\n                    platforms(Platform.IOS)\n                    note = \"50% rollout for US/CA iOS\"\n                }.implies(true)\n            }\n        }\n\n        val json = SnapshotSerializer.default.serialize(original)\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        assertSnapshotsEqual(original, restored)\n    }\n\n    private fun assertSnapshotsEqual(\n        expected: Flags.Snapshot,\n        actual: Flags.Snapshot\n    ) {\n        val context = createTestContext()\n\n        with(Flags) {\n            Flags.load(expected)\n            val expectedValues = context.evaluate()\n\n            Flags.load(actual)\n            val actualValues = context.evaluate()\n\n            assertEquals(expectedValues.size, actualValues.size)\n\n            expectedValues.forEach { (key, value) -&gt;\n                assertEquals(\n                    value,\n                    actualValues[key],\n                    \"Flag ${(key as Conditional&lt;*, *&gt;).key} values should match\"\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#test-3-error-handling","title":"Test 3: Error Handling","text":"<pre><code>class ErrorHandlingTest : BaseSerializationTest() {\n\n    @Test\n    fun `deserialization fails on invalid JSON`() {\n        val invalidJson = \"not valid json at all\"\n\n        assertThrows&lt;JsonDataException&gt; {\n            SnapshotSerializer.default.deserialize(invalidJson)\n        }\n    }\n\n    @Test\n    fun `deserialization fails on unregistered flag`() {\n        ConditionalRegistry.clear() // Clear all registrations\n\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"unknown_flag\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        val exception = assertThrows&lt;IllegalArgumentException&gt; {\n            SnapshotSerializer.default.deserialize(json)\n        }\n\n        assertTrue(exception.message!!.contains(\"unknown_flag\"))\n        assertTrue(exception.message!!.contains(\"not found in registry\"))\n    }\n\n    @Test\n    fun `deserialization fails on type mismatch`() {\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"dark_mode\",\n                  \"type\": \"STRING\",\n                  \"defaultValue\": \"not a boolean\",\n                  \"default\": {\"value\": \"not a boolean\", \"type\": \"STRING\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        // This should fail because FeatureFlags.DARK_MODE expects Boolean\n        assertThrows&lt;ClassCastException&gt; {\n            val konfig = SnapshotSerializer.default.deserialize(json)\n            Flags.load(konfig)\n\n            with(Flags) {\n                createTestContext().evaluate(FeatureFlags.DARK_MODE)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#integration-tests","title":"Integration Tests","text":""},{"location":"serialization/steps/step-07-testing/#test-loading-workflow","title":"Test Loading Workflow","text":"<pre><code>class LoadingWorkflowTest : BaseSerializationTest() {\n\n    @Test\n    fun `full workflow from config to evaluation`() {\n        // 1. Create configuration\n        val konfig = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with {\n                default(false)\n                rule {\n                    platforms(Platform.IOS)\n                }.implies(true)\n            }\n        }\n\n        // 2. Serialize\n        val json = SnapshotSerializer.default.serialize(konfig)\n        assertNotNull(json)\n\n        // 3. Deserialize\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        // 4. Load\n        Flags.load(restored)\n\n        // 5. Evaluate\n        val iosContext = Context(\n            AppLocale.EN_US,\n            Platform.IOS,\n            Version.of(1, 0, 0),\n            StableId.of(\"test-user-ios\")\n        )\n\n        val androidContext = Context(\n            AppLocale.EN_US,\n            Platform.ANDROID,\n            Version.of(1, 0, 0),\n            StableId.of(\"test-user-android\")\n        )\n\n        with(Flags) {\n            assertTrue(iosContext.evaluate(FeatureFlags.DARK_MODE))\n            assertFalse(androidContext.evaluate(FeatureFlags.DARK_MODE))\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#test-patch-updates","title":"Test Patch Updates","text":"<pre><code>class PatchUpdateTest : BaseSerializationTest() {\n\n    @Test\n    fun `patch adds new flag`() {\n        val initial = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n        }\n\n        val patch = SerializablePatch(\n            flags = listOf(\n                SerializableFlag(\n                    key = \"new_onboarding\",\n                    type = ValueType.BOOLEAN,\n                    defaultValue = false\n                )\n            )\n        )\n\n        val updated = SnapshotSerializer.default.applyPatch(initial, patch)\n\n        assertEquals(2, updated.flags.size)\n        assertTrue(updated.flags.containsKey(FeatureFlags.DARK_MODE))\n        assertTrue(updated.flags.containsKey(FeatureFlags.NEW_ONBOARDING))\n    }\n\n    @Test\n    fun `patch updates existing flag`() {\n        val initial = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(false) }\n        }\n\n        val patch = SerializablePatch(\n            flags = listOf(\n                SerializableFlag(\n                    key = \"dark_mode\",\n                    type = ValueType.BOOLEAN,\n                    defaultValue = true // Changed\n                )\n            )\n        )\n\n        val updated = SnapshotSerializer.default.applyPatch(initial, patch)\n\n        Flags.load(updated)\n        val context = createTestContext()\n\n        with(Flags) {\n            assertTrue(context.evaluate(FeatureFlags.DARK_MODE))\n        }\n    }\n\n    @Test\n    fun `patch removes flag`() {\n        val initial = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n            FeatureFlags.NEW_ONBOARDING with { default(false) }\n        }\n\n        val patch = SerializablePatch(\n            flags = emptyList(),\n            removeKeys = listOf(\"new_onboarding\")\n        )\n\n        val updated = SnapshotSerializer.default.applyPatch(initial, patch)\n\n        assertEquals(1, updated.flags.size)\n        assertTrue(updated.flags.containsKey(FeatureFlags.DARK_MODE))\n        assertFalse(updated.flags.containsKey(FeatureFlags.NEW_ONBOARDING))\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#property-based-tests","title":"Property-Based Tests","text":"<p>Test properties that should always hold true:</p> <pre><code>class PropertyBasedTest : BaseSerializationTest() {\n\n    @Test\n    fun `serialization is deterministic`() {\n        val konfig = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n            FeatureFlags.NEW_ONBOARDING with { default(false) }\n        }\n\n        val json1 = SnapshotSerializer.default.serialize(konfig)\n        val json2 = SnapshotSerializer.default.serialize(konfig)\n\n        assertEquals(json1, json2, \"Serialization should be deterministic\")\n    }\n\n    @Test\n    fun `evaluation is consistent across reload`() {\n        val konfig = ConfigBuilder.buildSnapshot {\n            FeatureFlags.NEW_ONBOARDING with {\n                default(false)\n                rule {\n                    rollout = Rollout.of(50.0)\n                }.implies(true)\n            }\n        }\n\n        val context = createTestContext()\n\n        // Evaluate before reload\n        Flags.load(konfig)\n        val valueBefore = with(Flags) {\n            context.evaluate(FeatureFlags.NEW_ONBOARDING)\n        }\n\n        // Reload same configuration\n        Flags.load(konfig)\n        val valueAfter = with(Flags) {\n            context.evaluate(FeatureFlags.NEW_ONBOARDING)\n        }\n\n        assertEquals(valueBefore, valueAfter, \"Values should be consistent\")\n    }\n\n    @Test\n    fun `all registered flags can be serialized and deserialized`() {\n        // Create config with all flags\n        val konfig = ConfigBuilder.buildSnapshot {\n            FeatureFlags.values().forEach { flag -&gt;\n                flag with { default(false) }\n            }\n        }\n\n        // Serialize\n        val json = SnapshotSerializer.default.serialize(konfig)\n\n        // Deserialize\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        // All flags should be present\n        assertEquals(FeatureFlags.values().size, restored.flags.size)\n\n        FeatureFlags.values().forEach { flag -&gt;\n            assertTrue(\n                restored.flags.containsKey(flag),\n                \"Flag ${flag.key} should be present after round-trip\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"serialization/steps/step-07-testing/#1-test-json-samples","title":"1. Test JSON Samples","text":"<p>Keep real JSON samples for regression testing:</p> <pre><code>@Test\nfun `deserialize production JSON sample`() {\n    val json = File(\"src/test/resources/production-flags.json\").readText()\n    val konfig = SnapshotSerializer.default.deserialize(json)\n\n    assertNotNull(konfig)\n    assertTrue(konfig.flags.isNotEmpty())\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#2-parameterized-tests","title":"2. Parameterized Tests","text":"<p>Test multiple scenarios with one test:</p> <pre><code>@ParameterizedTest\n@MethodSource(\"flagScenarios\")\nfun `test various flag configurations`(scenario: FlagScenario) {\n    val konfig = scenario.createSnapshot()\n    val json = SnapshotSerializer.default.serialize(konfig)\n    val restored = SnapshotSerializer.default.deserialize(json)\n\n    assertSnapshotsEqual(konfig, restored)\n}\n\ncompanion object {\n    @JvmStatic\n    fun flagScenarios() = listOf(\n        FlagScenario(\"simple default\", { FeatureFlags.DARK_MODE with { default(true) } }),\n        FlagScenario(\"with rules\", { FeatureFlags.DARK_MODE with {\n            default(false)\n            rule { platforms(Platform.IOS) }.implies(true)\n        }}),\n        // More scenarios...\n    )\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#whats-next","title":"What's Next?","text":"<p>With comprehensive tests in place, you're ready to deploy to production!</p> \u2190 Previous: Step 6 - Load into Runtime Next: Step 8 - Production Setup \u2192"},{"location":"serialization/steps/step-08-production/","title":"Step 8: Production Setup","text":""},{"location":"serialization/steps/step-08-production/#overview","title":"Overview","text":"<p>The final step is setting up serialization for production use. This includes deployment strategies, monitoring, rollback procedures, and operational best practices.</p> <p>::: tip Time estimate: 45 minutes</p> <p>Goal: Production-ready serialization infrastructure :::</p>"},{"location":"serialization/steps/step-08-production/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"serialization/steps/step-08-production/#strategy-1-embedded-configuration-simple","title":"Strategy 1: Embedded Configuration (Simple)","text":"<p>Bundle JSON with your application:</p> <pre><code>// Place JSON in resources\nsrc/main/resources/\n  \u2514\u2500\u2500 flags.json\n\n// Load at startup\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        loadEmbeddedFlags()\n    }\n\n    private fun loadEmbeddedFlags() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        val json = javaClass.getResourceAsStream(\"/flags.json\")\n            ?.bufferedReader()\n            ?.use { it.readText() }\n            ?: throw IllegalStateException(\"flags.json not found\")\n\n        val konfig = SnapshotSerializer.default.deserialize(json)\n        Flags.load(konfig)\n    }\n}\n</code></pre> <p>Pros: Simple, no network dependency, guaranteed availability</p> <p>Cons: Requires rebuild to change, larger APK/JAR</p>"},{"location":"serialization/steps/step-08-production/#strategy-2-remote-configuration-dynamic","title":"Strategy 2: Remote Configuration (Dynamic)","text":"<p>Load from a CDN or configuration service:</p> <pre><code>class FlagLoader(\n    private val cdnUrl: String,\n    private val cacheDir: File\n) {\n    suspend fun loadFlags(): Result&lt;Flags.Snapshot&gt; = withContext(Dispatchers.IO) {\n        try {\n            // Try remote first\n            val remoteSnapshot = downloadRemoteFlags()\n            cacheSnapshot(remoteSnapshot)\n            Result.success(remoteSnapshot)\n        } catch (e: IOException) {\n            // Fallback to cache\n            logger.warn(\"Remote load failed, using cache\", e)\n            try {\n                val cachedSnapshot = loadCachedFlags()\n                Result.success(cachedSnapshot)\n            } catch (e: Exception) {\n                // Last resort: embedded\n                logger.error(\"Cache failed, using embedded\", e)\n                Result.success(loadEmbeddedFlags())\n            }\n        }\n    }\n\n    private fun downloadRemoteFlags(): Flags.Snapshot {\n        val url = \"$cdnUrl/flags-${BuildConfig.ENVIRONMENT}.json\"\n        val json = URL(url).readText()\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun cacheSnapshot(konfig: Flags.Snapshot) {\n        val json = SnapshotSerializer.default.serialize(konfig)\n        File(cacheDir, \"flags.json\").writeText(json)\n    }\n\n    private fun loadCachedFlags(): Flags.Snapshot {\n        val json = File(cacheDir, \"flags.json\").readText()\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun loadEmbeddedFlags(): Flags.Snapshot {\n        val json = javaClass.getResourceAsStream(\"/default-flags.json\")\n            ?.bufferedReader()\n            ?.use { it.readText() }\n            ?: throw IllegalStateException(\"Embedded flags not found\")\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n}\n</code></pre> <p>Pros: Update without rebuild, environment-specific configs, A/B testing</p> <p>Cons: Network dependency, requires caching, complex error handling</p>"},{"location":"serialization/steps/step-08-production/#strategy-3-hybrid-recommended","title":"Strategy 3: Hybrid (Recommended)","text":"<p>Combine both approaches for resilience:</p> <pre><code>class ProductionFlagLoader(\n    private val context: Context,\n    private val remoteUrl: String\n) {\n    suspend fun initialize() {\n        // Load embedded flags immediately\n        loadEmbeddedFlags()\n\n        // Update from remote in background\n        updateFromRemote()\n    }\n\n    private fun loadEmbeddedFlags() {\n        val json = context.assets.open(\"flags.json\")\n            .bufferedReader()\n            .use { it.readText() }\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        val konfig = SnapshotSerializer.default.deserialize(json)\n        Flags.load(konfig)\n\n        logger.info(\"Embedded flags loaded\")\n    }\n\n    private suspend fun updateFromRemote() = withContext(Dispatchers.IO) {\n        try {\n            val json = downloadWithRetry(remoteUrl, maxRetries = 3)\n\n            val konfig = SnapshotSerializer.default.deserialize(json)\n\n            // Validate before loading\n            validateSnapshot(konfig)\n\n            Flags.load(konfig)\n\n            // Cache for next launch\n            cacheJson(json)\n\n            logger.info(\"Remote flags loaded successfully\")\n        } catch (e: Exception) {\n            logger.warn(\"Remote update failed, keeping embedded config\", e)\n            // App continues with embedded config\n        }\n    }\n\n    private fun validateSnapshot(konfig: Flags.Snapshot) {\n        require(konfig.flags.isNotEmpty()) {\n            \"Snapshot must contain flags\"\n        }\n\n        // Add custom validation\n        val requiredFlags = setOf(\"dark_mode\", \"critical_feature\")\n        val actualFlags = konfig.flags.keys.map { it.key }.toSet()\n\n        require(requiredFlags.all { it in actualFlags }) {\n            \"Missing required flags\"\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"serialization/steps/step-08-production/#github-actions-example","title":"GitHub Actions Example","text":".github/workflows/deploy-flags.yml<pre><code>name: Deploy Feature Flags\n\non:\n  push:\n    paths:\n      - 'config/production-flags.json'\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n\n      - name: Validate configuration\n        run: ./gradlew test --tests FlagValidationTest\n\n      - name: Deploy to CDN\n        run: |\n          aws s3 cp config/production-flags.json \\\n            s3://${{ secrets.CDN_BUCKET }}/flags-production.json \\\n            --cache-control \"max-age=300\"\n\n      - name: Invalidate CDN cache\n        run: |\n          aws cloudfront create-invalidation \\\n            --distribution-id ${{ secrets.CDN_DISTRIBUTION_ID }} \\\n            --paths \"/flags-production.json\"\n</code></pre>"},{"location":"serialization/steps/step-08-production/#validation-in-ci","title":"Validation in CI","text":"FlagValidationTest.kt<pre><code>class FlagValidationTest {\n\n    @Test\n    fun `production configuration is valid`() {\n        val json = File(\"config/production-flags.json\").readText()\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        // Should deserialize without errors\n        val konfig = SnapshotSerializer.default.deserialize(json)\n\n        // Validate structure\n        assertTrue(konfig.flags.isNotEmpty())\n\n        // Test evaluation doesn't crash\n        testEvaluation(konfig)\n    }\n\n    @Test\n    fun `all environments have valid configs`() {\n        val environments = listOf(\"development\", \"staging\", \"production\")\n\n        environments.forEach { env -&gt;\n            val json = File(\"config/$env-flags.json\").readText()\n\n            ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n            val konfig = SnapshotSerializer.default.deserialize(json)\n\n            assertNotNull(konfig, \"$env configuration should be valid\")\n\n            // Environment-specific assertions\n            when (env) {\n                \"production\" -&gt; assertProductionSafe(konfig)\n                \"development\" -&gt; assertDevelopmentComplete(konfig)\n            }\n\n            ConditionalRegistry.clear()\n        }\n    }\n\n    private fun assertProductionSafe(konfig: Flags.Snapshot) {\n        // No debug flags enabled\n        Flags.load(konfig)\n        val context = createTestContext()\n\n        with(Flags) {\n            assertFalse(\n                context.evaluate(FeatureFlags.DEBUG_MENU),\n                \"Debug menu must be disabled in production\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#monitoring","title":"Monitoring","text":""},{"location":"serialization/steps/step-08-production/#application-metrics","title":"Application Metrics","text":"<pre><code>class FlagMetrics(private val metricsClient: MetricsClient) {\n\n    fun recordFlagLoad(success: Boolean, source: String, durationMs: Long) {\n        metricsClient.count(\"flag.load\", 1, mapOf(\n            \"success\" to success.toString(),\n            \"source\" to source\n        ))\n\n        if (success) {\n            metricsClient.histogram(\"flag.load.duration_ms\", durationMs)\n        }\n    }\n\n    fun recordFlagEvaluation(flagKey: String, value: Any) {\n        metricsClient.count(\"flag.evaluation\", 1, mapOf(\n            \"flag\" to flagKey,\n            \"value\" to value.toString()\n        ))\n    }\n\n    fun recordError(operation: String, error: Exception) {\n        metricsClient.count(\"flag.error\", 1, mapOf(\n            \"operation\" to operation,\n            \"error_type\" to error::class.simpleName.orEmpty()\n        ))\n    }\n}\n\n// Usage\nclass InstrumentedFlagLoader(\n    private val flagLoader: FlagLoader,\n    private val metrics: FlagMetrics\n) {\n    suspend fun loadFlags(): Result&lt;Flags.Snapshot&gt; {\n        val startTime = System.currentTimeMillis()\n\n        return try {\n            val result = flagLoader.loadFlags()\n            val duration = System.currentTimeMillis() - startTime\n\n            metrics.recordFlagLoad(\n                success = result.isSuccess,\n                source = \"remote\",\n                durationMs = duration\n            )\n\n            result\n        } catch (e: Exception) {\n            metrics.recordError(\"load\", e)\n            throw e\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#logging","title":"Logging","text":"<pre><code>class FlagLogger {\n    private val logger = LoggerFactory.getLogger(FlagLogger::class.java)\n\n    fun logLoad(konfig: Flags.Snapshot, source: String) {\n        logger.info(\n            \"Loaded {} flags from {}\",\n            konfig.flags.size,\n            source\n        )\n\n        if (logger.isDebugEnabled) {\n            konfig.flags.keys.forEach { flag -&gt;\n                logger.debug(\"Flag loaded: {}\", (flag as Conditional&lt;*, *&gt;).key)\n            }\n        }\n    }\n\n    fun logEvaluation(context: Context, flag: Conditional&lt;*, *&gt;, value: Any) {\n        logger.debug(\n            \"Evaluated flag {} for user {} (platform: {}, version: {}): {}\",\n            flag.key,\n            context.stableId.id.take(8),\n            context.platform,\n            context.appVersion,\n            value\n        )\n    }\n\n    fun logError(operation: String, error: Exception) {\n        logger.error(\"Flag operation failed: {}\", operation, error)\n    }\n\n    fun logReload(oldSize: Int, newSize: Int) {\n        logger.info(\n            \"Reloaded flags: {} -&gt; {} flags ({} change)\",\n            oldSize,\n            newSize,\n            if (newSize &gt; oldSize) \"+${newSize - oldSize}\" else \"${newSize - oldSize}\"\n        )\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#rollback-procedures","title":"Rollback Procedures","text":""},{"location":"serialization/steps/step-08-production/#version-your-configurations","title":"Version Your Configurations","text":"<pre><code>data class VersionedConfiguration(\n    val version: String,\n    val timestamp: Long,\n    val konfig: Flags.Snapshot\n)\n\nclass ConfigurationVersionManager(private val cacheDir: File) {\n\n    fun save(konfig: Flags.Snapshot) {\n        val version = generateVersion()\n        val versioned = VersionedConfiguration(\n            version = version,\n            timestamp = System.currentTimeMillis(),\n            konfig = konfig\n        )\n\n        // Save current version\n        saveVersion(versioned, \"current\")\n\n        // Archive for rollback\n        saveVersion(versioned, version)\n\n        // Clean old versions (keep last 10)\n        cleanOldVersions()\n    }\n\n    fun rollback(toVersion: String? = null): Flags.Snapshot {\n        return if (toVersion != null) {\n            loadVersion(toVersion).konfig\n        } else {\n            loadPreviousVersion().konfig\n        }\n    }\n\n    private fun generateVersion(): String {\n        val timestamp = System.currentTimeMillis()\n        return \"v$timestamp\"\n    }\n\n    private fun saveVersion(config: VersionedConfiguration, name: String) {\n        val json = SnapshotSerializer.default.serialize(config.konfig)\n        val metadata = \"\"\"\n            {\n              \"version\": \"${config.version}\",\n              \"timestamp\": ${config.timestamp}\n            }\n        \"\"\".trimIndent()\n\n        File(cacheDir, \"$name.json\").writeText(json)\n        File(cacheDir, \"$name.meta.json\").writeText(metadata)\n    }\n\n    private fun loadPreviousVersion(): VersionedConfiguration {\n        // Implementation to find previous version\n        val versions = listVersions().sortedByDescending { it.timestamp }\n        return versions[1] // Get second most recent (current is first)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#emergency-rollback","title":"Emergency Rollback","text":"<pre><code>object EmergencyFlagControl {\n\n    fun rollbackToDefault() {\n        logger.warn(\"Emergency rollback initiated\")\n\n        val defaultSnapshot = ConfigBuilder.buildSnapshot {\n            // Safe defaults for all flags\n            FeatureFlags.values().forEach { flag -&gt;\n                flag with { default(false) }\n            }\n        }\n\n        Flags.load(defaultSnapshot)\n\n        logger.info(\"Rolled back to safe defaults\")\n    }\n\n    fun disableFlag(flag: Conditional&lt;*, *&gt;) {\n        logger.warn(\"Emergency disable: ${flag.key}\")\n\n        // Create patch to disable\n        val patch = SerializablePatch(\n            flags = listOf(\n                SerializableFlag(\n                    key = flag.key,\n                    type = ValueType.BOOLEAN,\n                    defaultValue = false\n                )\n            )\n        )\n\n        val current = getCurrentSnapshot()\n        val updated = SnapshotSerializer.default.applyPatch(current, patch)\n        Flags.load(updated)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#security-considerations","title":"Security Considerations","text":""},{"location":"serialization/steps/step-08-production/#validate-json-source","title":"Validate JSON Source","text":"<pre><code>fun loadFlagsSecurely(url: String) {\n    // Only load from trusted domains\n    require(url.startsWith(\"https://cdn.yourcompany.com/\")) {\n        \"Untrusted source: $url\"\n    }\n\n    // Verify SSL certificate\n    val json = downloadWithCertificatePin(url)\n\n    // Validate signature\n    verifySignature(json)\n\n    // Load\n    val konfig = SnapshotSerializer.default.deserialize(json)\n    Flags.load(konfig)\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#prevent-injection","title":"Prevent Injection","text":"<pre><code>fun sanitizeConfiguration(konfig: Flags.Snapshot): Flags.Snapshot {\n    // Ensure no malicious values\n    konfig.flags.forEach { (key, entry) -&gt;\n        validateFlagEntry(key, entry)\n    }\n\n    return konfig\n}\n\nprivate fun validateFlagEntry(key: Conditional&lt;*, *&gt;, entry: Flags.FlagEntry&lt;*, *&gt;) {\n    // Implement validation logic\n    // - Check for suspicious patterns\n    // - Validate value ranges\n    // - Ensure rules are reasonable\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#congratulations","title":"Congratulations!","text":"<p>You've completed the integration! Your serialization system is now production-ready.</p> \u2190 Previous: Step 7 - Testing View Full Runthrough \u2192"},{"location":"serialization/steps/step-08-production/#quick-links","title":"Quick Links","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Patch Updates - Advanced patch techniques</li> <li>Migration Guide - Migrating existing systems</li> </ul>"},{"location":"venv/lib/python3.14/site-packages/backrefs-5.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/idna-3.11.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/markdown-3.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip-25.2.dist-info/licenses/src/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}