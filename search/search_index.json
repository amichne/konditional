{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Konditional","text":"<p>Type-safe, deterministic feature flags for Kotlin</p> <p>Get Started View on GitHub</p>"},{"location":"#features","title":"Features","text":"<p>Type-Safe: Leverage Kotlin's type system for compile-time safety</p> <p>Deterministic: Predictable flag evaluation based on clear rules</p> <p>Serializable: Export and import flag configurations with built-in serialization support</p> <p>Flexible: Support for version ranges, custom types, and complex conditions</p>"},{"location":"advanced/architecture/","title":"Architecture Overview","text":"<p>This document describes the high-level architecture of Konditional and how its core components work together to provide type-safe, deterministic feature flag evaluation.</p>"},{"location":"advanced/architecture/#core-concepts","title":"Core Concepts","text":""},{"location":"advanced/architecture/#1-conditional","title":"1. Conditional <p><code>Conditional&lt;S : Any, C : Context&gt;</code> is the central abstraction representing a feature flag or configuration value.</p> <ul> <li>S: The value type returned when evaluating this conditional (e.g., <code>Boolean</code>, <code>String</code>, custom types)</li> <li>C: The context type used for evaluation (e.g., <code>Context</code>, <code>EnterpriseContext</code>)</li> </ul> <pre><code>interface Conditional&lt;S : Any, C : Context&gt; {\n    val key: String\n    fun with(build: FlagBuilder&lt;S, C&gt;.() -&gt; Unit)\n    fun update(condition: FlagDefinition&lt;S, C&gt;)\n}\n</code></pre> <p>Typically implemented as an enum for convenience:</p> <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_UI(\"new_ui\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Boolean, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n</code></pre>","text":""},{"location":"advanced/architecture/#2-context","title":"2. Context <p><code>Context</code> defines what information is available for rule evaluation. The base interface provides:</p> <ul> <li><code>locale</code>: Application locale</li> <li><code>platform</code>: Platform (iOS, Android, Web)</li> <li><code>appVersion</code>: Semantic version</li> <li><code>stableId</code>: Unique identifier for deterministic bucketing</li> </ul> <p>You can extend this interface with your own fields:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n) : Context\n</code></pre>","text":""},{"location":"advanced/architecture/#3-flagdefinition","title":"3. FlagDefinition <p><code>FlagDefinition&lt;S : Any, C : Context&gt;</code> contains the evaluation logic for a conditional:</p> <ul> <li>key: Reference to the <code>Conditional&lt;S, C&gt;</code> this condition evaluates</li> <li>bounds: List of <code>TargetedValue&lt;S, C&gt;</code> (rule \u2192 value mappings)</li> <li>defaultValue: Value returned when no rules match</li> <li>fallbackValue: Reserved for future use</li> <li>salt: String used in hash function for bucketing independence</li> </ul> <pre><code>data class FlagDefinition&lt;S : Any, C : Context&gt;(\n    val key: Conditional&lt;S, C&gt;,\n    val bounds: List&lt;TargetedValue&lt;S, C&gt;&gt;,\n    val defaultValue: S,\n    val fallbackValue: S,\n    val salt: String = \"v1\",\n)\n</code></pre> <p>Evaluation Logic: 1. Sort surjections by rule specificity (descending) 2. Find first rule that matches the context 3. Check if user is in the eligible bucket for that rule's ramp-up percentage 4. Return the associated value, or default if no match</p>","text":""},{"location":"advanced/architecture/#4-evaluable-base-abstraction","title":"4. Evaluable (Base Abstraction) <p><code>Evaluable&lt;C : Context&gt;</code> is the foundation for composable rule evaluation:</p> <pre><code>abstract class Evaluable&lt;C : Context&gt; {\n    internal open fun matches(context: C): Boolean = true\n    internal open fun specificity(): Int = 0\n}\n</code></pre> <p>Purpose: Provides a composable abstraction for rule evaluation logic that can be combined and extended.</p> <p>Key Features: - Composability: Multiple Evaluables can be composed together - Default behavior: Returns true (matches all) with 0 specificity - Extension point: Subclasses override to add custom matching logic</p>","text":""},{"location":"advanced/architecture/#5-userclientevaluator","title":"5. UserClientEvaluator <p><code>UserClientEvaluator&lt;C : Context&gt;</code> encapsulates standard client targeting logic:</p> <pre><code>data class UserClientEvaluator&lt;C : Context&gt;(\n    val locales: Set&lt;AppLocale&gt; = emptySet(),\n    val platforms: Set&lt;Platform&gt; = emptySet(),\n    val versionRange: VersionRange = Unbounded,\n) : Evaluable&lt;C&gt;()\n</code></pre> <p>Matching: A rule matches if ALL specified constraints are satisfied: - If <code>locales</code> is empty, any locale matches; otherwise context.locale must be in the set - If <code>platforms</code> is empty, any platform matches; otherwise context.platform must be in the set - If <code>versionRange</code> is unbounded, any version matches; otherwise context.appVersion must be in range</p> <p>Specificity: Calculated as: <pre><code>(if (locales.isNotEmpty()) 1 else 0) +\n(if (platforms.isNotEmpty()) 1 else 0) +\n(if (versionRange.hasBounds()) 1 else 0)\n</code></pre></p> <p>Ranges from 0 (no constraints) to 3 (all constraints specified).</p>","text":""},{"location":"advanced/architecture/#6-rule-composable-implementation","title":"6. Rule (Composable Implementation) <p><code>Rule&lt;C : Context&gt;</code> composes standard targeting with extensible evaluation:</p> <pre><code>data class Rule&lt;C : Context&gt;(\n    val rollout: Rollout = Rollout.of(100.0),\n    val note: String? = null,\n    val userClientEvaluator: UserClientEvaluator&lt;C&gt; = UserClientEvaluator(),\n    val extension: Evaluable&lt;C&gt; = object : Evaluable&lt;C&gt;() {},\n) : Evaluable&lt;C&gt;()\n</code></pre> <p>Composition Architecture: - userClientEvaluator: Handles standard locale, platform, and version targeting - extension: Allows custom domain-specific evaluation logic - Both must match for the rule to match: <code>userClientEvaluator.matches(context) &amp;&amp; extension.matches(context)</code> - Total specificity is the sum: <code>userClientEvaluator.specificity() + extension.specificity()</code></p> <p>Convenience Constructor: For backward compatibility, there's a secondary constructor that accepts individual parameters: <pre><code>Rule(\n    rollout = Rollout.of(50.0),\n    locales = setOf(AppLocale.EN_US),\n    platforms = setOf(Platform.IOS),\n    versionRange = LeftBound(Version(2, 0, 0))\n)\n</code></pre></p> <p>This creates a <code>UserClientEvaluator</code> internally with the specified constraints.</p>","text":""},{"location":"advanced/architecture/#7-targetedvalue","title":"7. TargetedValue <p><code>TargetedValue&lt;S : Any, C : Context&gt;</code> maps a rule to its output value:</p> <pre><code>data class TargetedValue&lt;S : Any, C : Context&gt;(\n    val rule: Rule&lt;C&gt;,\n    val value: S\n)\n</code></pre> <p>Created using the <code>implies</code> infix operator in the DSL:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(50.0)\n} implies true\n</code></pre>","text":""},{"location":"advanced/architecture/#8-flags-singleton","title":"8. Flags Singleton <p><code>Flags</code> is the central registry holding all configured conditions:</p> <pre><code>object Flags {\n    class FlagEntry&lt;S : Any, C : Context&gt;(\n        val condition: FlagDefinition&lt;S, C&gt;\n    )\n\n    data class Snapshot internal constructor(\n        val flags: Map&lt;Conditional&lt;*, *&gt;, FlagEntry&lt;*, *&gt;&gt;\n    )\n\n    fun load(config: Snapshot)\n    fun &lt;S : Any, C : Context&gt; update(condition: FlagDefinition&lt;S, C&gt;)\n    fun &lt;S : Any, C : Context&gt; C.evaluate(key: Conditional&lt;S, C&gt;): S\n    fun &lt;C : Context&gt; C.evaluate(): Map&lt;Conditional&lt;*, *&gt;, Any?&gt;\n}\n</code></pre> <p>Key features: - Atomic updates: <code>Snapshot</code> is replaced atomically using <code>AtomicReference</code> - Lock-free reads: Evaluation reads from a stable snapshot - FlagEntry wrapper: Maintains type safety between <code>Conditional&lt;S, C&gt;</code> and <code>FlagDefinition&lt;S, C&gt;</code></p>","text":""},{"location":"advanced/architecture/#evaluation-flow","title":"Evaluation Flow","text":"<pre><code>1. Application calls: context.evaluate(Features.DARK_MODE)\n                                    \u2193\n2. Flags retrieves FlagEntry for Features.DARK_MODE from current snapshot\n                                    \u2193\n3. FlagEntry.condition.evaluate(context) is called\n                                    \u2193\n4. Condition sorts surjections by rule specificity (most specific first)\n                                    \u2193\n5. For each surjection (in order):\n   a. Check if surjection.rule.matches(context)\n   b. If matches, check if user is in eligible bucket\n   c. If eligible, return surjection.value\n                                    \u2193\n6. If no surjection matches, return defaultValue\n</code></pre>"},{"location":"advanced/architecture/#deterministic-bucketing","title":"Deterministic Bucketing","text":"<p>Each surjection has a <code>rollout</code> percentage (0-100%). To determine if a user is eligible:</p> <ol> <li>Compute <code>bucket = SHA-256(\"$salt:$flagKey:$stableId\") mod 10000</code></li> <li>User is eligible if <code>bucket &lt; (rollout * 100)</code></li> </ol> <p>Properties: - Deterministic: Same <code>stableId</code> + <code>flagKey</code> + <code>salt</code> always produces same bucket - Independent: Different <code>flagKey</code> values produce independent buckets (no correlation) - Granular: 10,000 buckets allows 0.01% precision in ramp-up percentages</p>"},{"location":"advanced/architecture/#composable-architecture","title":"Composable Architecture","text":"<p>Konditional's architecture is built on composition rather than inheritance. The key abstraction is <code>Evaluable&lt;C&gt;</code>, which provides two core operations:</p> <ul> <li>matches(context: C): Determines if a context satisfies the criteria</li> <li>specificity(): Returns a numeric value for precedence ordering</li> </ul> <p>This simple interface enables powerful composition patterns:</p>"},{"location":"advanced/architecture/#composition-in-rule","title":"Composition in Rule <p>The <code>Rule&lt;C&gt;</code> class demonstrates composition by combining two Evaluables:</p> <pre><code>data class Rule&lt;C : Context&gt;(\n    val userClientEvaluator: UserClientEvaluator&lt;C&gt;,\n    val extension: Evaluable&lt;C&gt;\n) : Evaluable&lt;C&gt;() {\n    override fun matches(context: C): Boolean =\n        userClientEvaluator.matches(context) &amp;&amp; extension.matches(context)\n\n    override fun specificity(): Int =\n        userClientEvaluator.specificity() + extension.specificity()\n}\n</code></pre> <p>This design provides: - Separation of concerns: Standard targeting is separate from custom logic - Reusability: Custom Evaluables can be reused across multiple rules - Predictable precedence: Specificity values compose additively - Extension without modification: Add custom logic without changing Rule class</p>","text":""},{"location":"advanced/architecture/#benefits-of-composable-design","title":"Benefits of Composable Design <ol> <li>Testability: Each Evaluable can be tested independently</li> <li>Flexibility: Mix and match different evaluation strategies</li> <li>Type safety: Composition preserves type parameters throughout</li> <li>Clear semantics: AND composition for matching, SUM composition for specificity</li> </ol>","text":""},{"location":"advanced/architecture/#type-safety-architecture","title":"Type Safety Architecture","text":"<p>The generic type parameters <code>&lt;S : Any, C : Context&gt;</code> flow through the entire system:</p> <pre><code>Conditional&lt;S, C&gt;\n    \u2193\nFlagDefinition&lt;S, C&gt;\n    \u2193\nTargetedValue&lt;S, C&gt;\n    \u2193\nRule&lt;C&gt; extends Evaluable&lt;C&gt;\n    \u2193\nUserClientEvaluator&lt;C&gt; + extension: Evaluable&lt;C&gt;\n\nFlagEntry&lt;S, C&gt; wraps FlagDefinition&lt;S, C&gt;\n    \u2193\nMap&lt;Conditional&lt;*, *&gt;, FlagEntry&lt;*, *&gt;&gt; stores all flags\n    \u2193\nRetrieval casts FlagEntry&lt;*, *&gt; to FlagEntry&lt;S, C&gt;\n    \u2193\nFlagEntry.evaluate(context: C): S maintains type safety\n</code></pre> <p>The <code>FlagEntry</code> wrapper is crucial: it ensures that when we retrieve a flag by key, the associated condition has matching type parameters. While an unchecked cast is still needed (due to type erasure), the wrapper makes it structurally safe - the types are guaranteed to match if the key matches.</p>"},{"location":"advanced/architecture/#thread-safety","title":"Thread Safety","text":"<p>Reads (evaluation): - Lock-free: read from <code>AtomicReference&lt;Snapshot&gt;</code> - Snapshot is immutable once created - Multiple threads can evaluate concurrently</p> <p>Writes (configuration updates): - <code>AtomicReference.set()</code> provides atomic snapshot replacement - Writers never block readers - Later writes win if concurrent</p>"},{"location":"advanced/architecture/#dsl-architecture","title":"DSL Architecture","text":"<p>The configuration DSL is built with type-safe builders:</p> <pre><code>ConfigBuilder\n    \u2193 creates\nFlagBuilder&lt;S, C&gt;\n    \u2193 creates\nRuleBuilder&lt;C&gt;\n    \u2193 creates\nRule&lt;C&gt;\n\nFlagBuilder combines:\n- TargetedValue&lt;S, C&gt; instances (from rule { } implies value)\n- Default value\n- Fallback value\n    \u2193 builds\nFlagDefinition&lt;S, C&gt;\n    \u2193 wrapped in\nFlagEntry&lt;S, C&gt;\n    \u2193 added to\nSnapshot\n</code></pre> <p>The DSL ensures: - Type parameters match throughout construction - Required fields (default value) are provided - Rules and values have compatible types</p>"},{"location":"advanced/architecture/#extension-points","title":"Extension Points","text":"<p>Konditional is designed for extension through its composable architecture:</p> <ol> <li>Custom Contexts: Implement <code>Context</code> interface with your fields</li> <li>Custom Value Types: Use any <code>S : Any</code> type in <code>Conditional&lt;S, C&gt;</code></li> <li>Custom Evaluables: Extend <code>Evaluable&lt;C&gt;</code> to create reusable evaluation logic</li> <li>Rule Extensions: Use the <code>extension</code> parameter in <code>Rule&lt;C&gt;</code> to add custom logic</li> <li>Custom Builders: Extend builders to add domain-specific DSL methods</li> </ol>"},{"location":"advanced/architecture/#example-custom-evaluable","title":"Example: Custom Evaluable <pre><code>class SubscriptionTierEvaluator&lt;C : EnterpriseContext&gt;(\n    val requiredTier: SubscriptionTier\n) : Evaluable&lt;C&gt;() {\n    override fun matches(context: C): Boolean =\n        context.subscriptionTier &gt;= requiredTier\n\n    override fun specificity(): Int = 1\n}\n</code></pre>","text":""},{"location":"advanced/architecture/#example-using-custom-evaluable-in-rules","title":"Example: Using Custom Evaluable in Rules <pre><code>// Compose custom evaluable with standard targeting\nRule(\n    rollout = Rollout.of(100.0),\n    locales = setOf(AppLocale.EN_US),\n    platforms = setOf(Platform.IOS),\n    extension = SubscriptionTierEvaluator(SubscriptionTier.ENTERPRISE)\n)\n\n// Or create more complex compositions\nRule(\n    rollout = Rollout.of(50.0),\n    extension = object : Evaluable&lt;EnterpriseContext&gt;() {\n        override fun matches(context: EnterpriseContext): Boolean {\n            return context.subscriptionTier &gt;= SubscriptionTier.PREMIUM &amp;&amp;\n                   context.userRole in setOf(UserRole.ADMIN, UserRole.OWNER)\n        }\n        override fun specificity(): Int = 2\n    }\n)\n</code></pre> <p>This composable design allows you to build reusable evaluation logic that can be mixed and matched across different rules.</p>","text":""},{"location":"advanced/architecture/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Evaluation: O(n) where n = number of surjections for a flag</li> <li>Typically very small (1-10 rules per flag)</li> <li>Sorted once when condition is created</li> <li> <p>First match wins (early exit)</p> </li> <li> <p>Memory: O(f \u00d7 r) where f = number of flags, r = average rules per flag</p> </li> <li>Snapshots are immutable and shared</li> <li> <p>No per-request allocation</p> </li> <li> <p>Bucketing: O(1) hash computation</p> </li> <li>SHA-256 with small input</li> <li>No synchronization required</li> </ul>"},{"location":"advanced/architecture/#summary","title":"Summary","text":"<p>Konditional's architecture prioritizes: - Type safety: Generics flow through the entire system - Composability: <code>Evaluable&lt;C&gt;</code> abstraction enables flexible composition of evaluation logic - Determinism: SHA-256 based bucketing with same inputs \u2192 same outputs - Thread safety: Lock-free reads with atomic updates - Extensibility: Generic parameters allow custom contexts, value types, and evaluation strategies - Separation of concerns: Standard targeting separated from custom logic through composition - Performance: Simple evaluation with no synchronization on read path</p>"},{"location":"advanced/conditional-types/","title":"Conditional Value Types","text":"<p>Konditional supports any non-nullable type as a flag value. This document explores the different types you can use and when each is appropriate.</p>"},{"location":"advanced/conditional-types/#the-type-parameter","title":"The Type Parameter","text":"<p><code>Conditional&lt;S : Any, C : Context&gt;</code> uses <code>S</code> to represent the value type:</p> <ul> <li><code>S : Any</code> means any non-nullable type</li> <li>Primitives, collections, data classes, enums - all supported</li> <li>Type safety is maintained end-to-end</li> </ul>"},{"location":"advanced/conditional-types/#boolean-flags","title":"Boolean Flags","text":"<p>The most common type - simple on/off switches.</p> <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ANALYTICS_ENABLED(\"analytics_enabled\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Boolean, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    Features.DARK_MODE with {\n        default(false)\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n        } implies true\n    }\n}\n\n// Usage\nif (context.evaluate(Features.DARK_MODE)) {\n    applyDarkTheme()\n}\n</code></pre> <p>When to use: Simple enable/disable decisions.</p>"},{"location":"advanced/conditional-types/#string-flags","title":"String Flags","text":"<p>Useful for configuration values, endpoints, and variants.</p> <pre><code>enum class Config(override val key: String) : Conditional&lt;String, Context&gt; {\n    API_ENDPOINT(\"api_endpoint\"),\n    THEME_NAME(\"theme_name\"),\n    LOG_LEVEL(\"log_level\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;String, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    Config.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n        rule {\n            platforms(Platform.WEB)\n        } implies \"https://api.staging.example.com\"\n    }\n\n    Config.THEME_NAME with {\n        default(\"light\")\n        rule {\n            locales(AppLocale.EN_US)\n        } implies \"dark\"\n        rule {\n            locales(AppLocale.HI_IN)\n        } implies \"vibrant\"\n    }\n}\n\n// Usage\nval endpoint = context.evaluate(Config.API_ENDPOINT)\napiClient.configure(baseUrl = endpoint)\n</code></pre> <p>When to use: - Configuration values that vary by environment - A/B test variants - URLs, keys, or other string configuration</p>"},{"location":"advanced/conditional-types/#integer-flags","title":"Integer Flags","text":"<p>For numeric configuration like timeouts, limits, or sizes.</p> <pre><code>enum class Limits(override val key: String) : Conditional&lt;Int, Context&gt; {\n    MAX_CONNECTIONS(\"max_connections\"),\n    TIMEOUT_SECONDS(\"timeout_seconds\"),\n    CACHE_SIZE_MB(\"cache_size_mb\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Int, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    Limits.MAX_CONNECTIONS with {\n        default(10)\n        rule {\n            platforms(Platform.WEB)\n        } implies 50\n        rule {\n            platforms(Platform.WEB)\n            versions {\n                min(3, 0)\n            }\n        } implies 100\n    }\n\n    Limits.TIMEOUT_SECONDS with {\n        default(30)\n        rule {\n            platforms(Platform.ANDROID)\n            versions {\n                max(5, 0, 0)  // Legacy devices\n            }\n        } implies 60  // More generous timeout\n    }\n}\n\n// Usage\nval maxConnections = context.evaluate(Limits.MAX_CONNECTIONS)\nconnectionPool.setMaxSize(maxConnections)\n</code></pre> <p>When to use: - Numeric limits or thresholds - Timeouts and intervals - Buffer sizes and limits - Retry counts</p>"},{"location":"advanced/conditional-types/#enum-flags","title":"Enum Flags","text":"<p>Type-safe multi-variant flags.</p> <pre><code>enum class LogLevel {\n    DEBUG, INFO, WARN, ERROR, NONE\n}\n\nenum class LogConfig(override val key: String) : Conditional&lt;LogLevel, Context&gt; {\n    APP_LOG_LEVEL(\"app_log_level\"),\n    NETWORK_LOG_LEVEL(\"network_log_level\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;LogLevel, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    LogConfig.APP_LOG_LEVEL with {\n        default(LogLevel.INFO)\n        rule {\n            platforms(Platform.WEB)\n        } implies LogLevel.DEBUG\n        rule {\n            versions {\n                max(1, 0)  // Old versions\n            }\n        } implies LogLevel.ERROR\n    }\n}\n\n// Usage\nval logLevel = context.evaluate(LogConfig.APP_LOG_LEVEL)\nlogger.setLevel(logLevel)\n</code></pre> <p>When to use: - Multiple exclusive options (log levels, modes, strategies) - Type-safe variants in A/B tests - Enums provide exhaustive when expressions</p>"},{"location":"advanced/conditional-types/#data-class-flags","title":"Data Class Flags","text":"<p>Complex configuration objects.</p> <pre><code>data class ApiConfig(\n    val baseUrl: String,\n    val timeout: Int,\n    val retries: Int,\n    val useHttps: Boolean,\n)\n\nenum class NetworkConfig(override val key: String) : Conditional&lt;ApiConfig, Context&gt; {\n    PRIMARY_API(\"primary_api\"),\n    BACKUP_API(\"backup_api\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;ApiConfig, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    NetworkConfig.PRIMARY_API with {\n        default(ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30,\n            retries = 3,\n            useHttps = true,\n        ))\n        rule {\n            platforms(Platform.WEB)\n        } implies ApiConfig(\n            baseUrl = \"http://api.dev.example.com\",\n            timeout = 60,\n            retries = 1,\n            useHttps = false,\n        )\n    }\n}\n\n// Usage\nval apiConfig = context.evaluate(NetworkConfig.PRIMARY_API)\napiClient.configure(\n    baseUrl = apiConfig.baseUrl,\n    timeout = apiConfig.timeout,\n    retries = apiConfig.retries,\n)\n</code></pre> <p>When to use: - Related configuration values that should change together - Complex objects with multiple fields - Configuration that varies as a unit</p>"},{"location":"advanced/conditional-types/#list-flags","title":"List Flags","text":"<p>Collections of values.</p> <pre><code>enum class ModuleConfig(override val key: String) : Conditional&lt;List&lt;String&gt;, Context&gt; {\n    ENABLED_FEATURES(\"enabled_features\"),\n    BETA_MODULES(\"beta_modules\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;List&lt;String&gt;, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    ModuleConfig.ENABLED_FEATURES with {\n        default(listOf(\"core\", \"basic\"))\n        rule {\n            versions {\n                min(2, 0)\n            }\n        } implies listOf(\"core\", \"basic\", \"advanced\", \"analytics\")\n    }\n}\n\n// Usage\nval enabledFeatures = context.evaluate(ModuleConfig.ENABLED_FEATURES)\nfor (feature in enabledFeatures) {\n    moduleRegistry.enable(feature)\n}\n</code></pre> <p>When to use: - Variable sets of enabled modules - Lists of allowed values - Configuration arrays</p>"},{"location":"advanced/conditional-types/#map-flags","title":"Map Flags","text":"<p>Key-value configuration.</p> <pre><code>enum class FeatureToggles(override val key: String) : Conditional&lt;Map&lt;String, String&gt;, Context&gt; {\n    TOGGLES(\"feature_toggles\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Map&lt;String, String&gt;, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    FeatureToggles.TOGGLES with {\n        default(mapOf(\n            \"feature1\" to \"off\",\n            \"feature2\" to \"off\",\n        ))\n        rule {\n            locales(AppLocale.EN_US, AppLocale.EN_CA)\n        } implies mapOf(\n            \"feature1\" to \"on\",\n            \"feature2\" to \"on\",\n            \"feature3\" to \"beta\",\n        )\n    }\n}\n\n// Usage\nval toggles = context.evaluate(FeatureToggles.TOGGLES)\nval feature1Status = toggles[\"feature1\"] ?: \"off\"\n</code></pre> <p>When to use: - Flexible key-value configuration - Dynamic sets of toggles - Configuration dictionaries</p>"},{"location":"advanced/conditional-types/#nested-data-structures","title":"Nested Data Structures","text":"<p>Combine types for complex configuration:</p> <pre><code>data class ThemeConfig(\n    val primaryColor: String,\n    val secondaryColor: String,\n    val fontSizes: Map&lt;String, Int&gt;,\n    val enabledFeatures: List&lt;String&gt;,\n)\n\nenum class AppConfig(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    THEME(\"app_theme\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;ThemeConfig, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    AppConfig.THEME with {\n        default(ThemeConfig(\n            primaryColor = \"#FFFFFF\",\n            secondaryColor = \"#F0F0F0\",\n            fontSizes = mapOf(\n                \"body\" to 14,\n                \"heading\" to 20,\n            ),\n            enabledFeatures = listOf(\"animations\"),\n        ))\n        rule {\n            locales(AppLocale.EN_US)\n        } implies ThemeConfig(\n            primaryColor = \"#1E1E1E\",\n            secondaryColor = \"#2D2D2D\",\n            fontSizes = mapOf(\n                \"body\" to 16,\n                \"heading\" to 24,\n            ),\n            enabledFeatures = listOf(\"animations\", \"dark-mode\", \"high-contrast\"),\n        )\n    }\n}\n</code></pre>"},{"location":"advanced/conditional-types/#sealed-classes","title":"Sealed Classes","text":"<p>Use sealed classes for type-safe variants:</p> <pre><code>sealed class PaymentMethod {\n    data class CreditCard(val last4: String) : PaymentMethod()\n    data class PayPal(val email: String) : PaymentMethod()\n    data class BankTransfer(val accountNumber: String) : PaymentMethod()\n}\n\nenum class PaymentConfig(override val key: String) : Conditional&lt;PaymentMethod, Context&gt; {\n    DEFAULT_METHOD(\"default_payment_method\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;PaymentMethod, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    PaymentConfig.DEFAULT_METHOD with {\n        default(PaymentMethod.CreditCard(\"****\"))\n        rule {\n            locales(AppLocale.EN_US)\n        } implies PaymentMethod.PayPal(\"default@example.com\")\n    }\n}\n\n// Usage\nwhen (val method = context.evaluate(PaymentConfig.DEFAULT_METHOD)) {\n    is PaymentMethod.CreditCard -&gt; processCreditCard(method.last4)\n    is PaymentMethod.PayPal -&gt; processPayPal(method.email)\n    is PaymentMethod.BankTransfer -&gt; processBankTransfer(method.accountNumber)\n}\n</code></pre>"},{"location":"advanced/conditional-types/#type-safety-benefits","title":"Type Safety Benefits","text":""},{"location":"advanced/conditional-types/#compile-time-verification","title":"Compile-Time Verification","text":"<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    FEATURE_A(\"feature_a\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Boolean, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    Features.FEATURE_A with {\n        default(false)\n        rule {\n        } implies true  // \u2713 Type matches (Boolean)\n        // } implies \"invalid\"  // \u2717 Compile error: type mismatch\n    }\n}\n\n// Evaluation is type-safe\nval result: Boolean = context.evaluate(Features.FEATURE_A)  // \u2713 Correct type\n// val result: String = context.evaluate(Features.FEATURE_A)  // \u2717 Compile error\n</code></pre>"},{"location":"advanced/conditional-types/#ide-support","title":"IDE Support","text":"<ul> <li>Auto-completion for all flag names</li> <li>Type inference for evaluation results</li> <li>Refactoring support (rename, extract, etc.)</li> <li>Inline documentation</li> </ul>"},{"location":"advanced/conditional-types/#best-practices","title":"Best Practices","text":""},{"location":"advanced/conditional-types/#1-use-the-right-type-for-the-job","title":"1. Use the Right Type for the Job","text":"<pre><code>// Good: Boolean for on/off decisions\nenum class Features(...) : Conditional&lt;Boolean, Context&gt;\n\n// Good: Enum for multiple options\nenum class LogLevel { DEBUG, INFO, WARN }\nenum class Config(...) : Conditional&lt;LogLevel, Context&gt;\n\n// Bad: String when enum would be better\n// enum class Config(...) : Conditional&lt;String, Context&gt;  // \"debug\", \"info\" prone to typos\n</code></pre>"},{"location":"advanced/conditional-types/#2-keep-value-types-simple","title":"2. Keep Value Types Simple","text":"<pre><code>// Good: Simple data class\ndata class ApiConfig(\n    val url: String,\n    val timeout: Int,\n)\n\n// Bad: Includes behavior or mutable state\ndata class ApiConfig(\n    val url: String,\n    var timeout: Int,  // Mutable\n    val client: HttpClient,  // Heavy object\n)\n</code></pre>"},{"location":"advanced/conditional-types/#3-use-data-classes-for-immutability","title":"3. Use Data Classes for Immutability","text":"<pre><code>// Good: Immutable data class\ndata class Config(val value: String)\n\n// Bad: Mutable class\nclass Config {\n    var value: String = \"\"\n}\n</code></pre>"},{"location":"advanced/conditional-types/#4-document-complex-types","title":"4. Document Complex Types","text":"<pre><code>/**\n * Configuration for the analytics system.\n * @property endpoint The analytics endpoint URL\n * @property batchSize Number of events to batch before sending\n * @property enabled Whether analytics is enabled at all\n */\ndata class AnalyticsConfig(\n    val endpoint: String,\n    val batchSize: Int,\n    val enabled: Boolean,\n)\n</code></pre>"},{"location":"advanced/conditional-types/#5-consider-sealed-classes-for-variants","title":"5. Consider Sealed Classes for Variants","text":"<p>When you have multiple mutually exclusive options with different data, sealed classes are better than enums:</p> <pre><code>// Good: Sealed class with associated data\nsealed class CacheStrategy {\n    data class InMemory(val maxSize: Int) : CacheStrategy()\n    data class OnDisk(val path: String, val maxSize: Long) : CacheStrategy()\n    object None : CacheStrategy()\n}\n\n// Less ideal: Separate flags for each option\n// enum class CacheType : Conditional&lt;String, Context&gt;  // \"inmemory\", \"disk\", \"none\"\n// enum class CacheSize : Conditional&lt;Int, Context&gt;  // Only relevant for some types\n</code></pre>"},{"location":"advanced/conditional-types/#summary","title":"Summary","text":"<p>Konditional's support for arbitrary value types allows you to:</p> <ul> <li>Use the right type for each use case</li> <li>Maintain type safety throughout your codebase</li> <li>Get compile-time errors instead of runtime failures</li> <li>Leverage IDE features like auto-completion and refactoring</li> <li>Express complex configuration with nested data structures</li> </ul> <p>Choose types that accurately model your domain and let Konditional's type system ensure correctness.</p>"},{"location":"advanced/context-polymorphism/","title":"Context Polymorphism","text":"<p>One of Konditional's most powerful features is context polymorphism - the ability to define custom context types tailored to your domain, while maintaining full type safety throughout the system.</p>"},{"location":"advanced/context-polymorphism/#why-custom-contexts","title":"Why Custom Contexts?","text":"<p>The base <code>Context</code> interface provides common properties like <code>locale</code>, <code>platform</code>, <code>appVersion</code>, and <code>stableId</code>. However, your application may need to make decisions based on:</p> <ul> <li>Organization/Tenant ID for multi-tenant applications</li> <li>User roles or permissions for enterprise features</li> <li>Subscription tier for freemium models</li> <li>Experiment groups for A/B testing</li> <li>Device capabilities for hardware-specific features</li> <li>Session attributes for personalization</li> <li>Any domain-specific data your application needs</li> </ul>"},{"location":"advanced/context-polymorphism/#the-context-interface","title":"The Context Interface","text":"<pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n</code></pre> <p>This interface is intentionally minimal - it defines only what's needed for the base rule system. You extend it with your own properties.</p>"},{"location":"advanced/context-polymorphism/#creating-a-custom-context","title":"Creating a Custom Context","text":""},{"location":"advanced/context-polymorphism/#example-enterprise-context","title":"Example: Enterprise Context","text":"<pre><code>data class EnterpriseContext(\n    // Required: Base Context properties\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    // Custom: Enterprise-specific properties\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val userRole: UserRole,\n    val featuresEnabled: Set&lt;String&gt;,\n) : Context\n\nenum class SubscriptionTier {\n    FREE, BASIC, PREMIUM, ENTERPRISE\n}\n\nenum class UserRole {\n    VIEWER, EDITOR, ADMIN, OWNER\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#example-experiment-context","title":"Example: Experiment Context","text":"<pre><code>data class ExperimentContext(\n    // Required: Base Context properties\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    // Custom: Experiment-specific properties\n    val experimentGroups: Set&lt;String&gt;,\n    val sessionId: String,\n    val cohortId: String,\n    val firstSeen: Instant,\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#using-custom-contexts-with-flags","title":"Using Custom Contexts with Flags","text":"<p>Once you have a custom context, you use it as the type parameter in your <code>Conditional</code> definitions:</p> <pre><code>enum class EnterpriseFeatures(\n    override val key: String\n) : Conditional&lt;Boolean, EnterpriseContext&gt; {  // Note: EnterpriseContext, not Context\n    ADVANCED_ANALYTICS(\"advanced_analytics\"),\n    BULK_EXPORT(\"bulk_export\"),\n    API_ACCESS(\"api_access\"),\n    CUSTOM_BRANDING(\"custom_branding\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Boolean, EnterpriseContext&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#configuration","title":"Configuration","text":"<p>Configure rules using base Context properties (the custom context implements them):</p> <pre><code>config {\n    EnterpriseFeatures.ADVANCED_ANALYTICS with {\n        default(false)\n\n        // Base properties work fine\n        rule {\n            platforms(Platform.WEB)\n            versions {\n                min(2, 0)\n            }\n        } implies true\n    }\n\n    EnterpriseFeatures.API_ACCESS with {\n        default(false)\n\n        // Full rollout for web users on v2.0+\n        rule {\n            platforms(Platform.WEB)\n            versions {\n                min(2, 0)\n            }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#evaluation","title":"Evaluation","text":"<p>Evaluate with your custom context:</p> <pre><code>val enterpriseCtx = EnterpriseContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.WEB,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\"),\n    organizationId = \"org-456\",\n    subscriptionTier = SubscriptionTier.ENTERPRISE,\n    userRole = UserRole.ADMIN,\n    featuresEnabled = setOf(\"beta-features\"),\n)\n\n// Type-safe: returns Boolean\nval hasAnalytics = enterpriseCtx.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)\n</code></pre>"},{"location":"advanced/context-polymorphism/#extending-rules-for-custom-contexts","title":"Extending Rules for Custom Contexts","text":"<p>While the base <code>Rule&lt;C&gt;</code> works with any context type, you can create custom rule types that leverage your context's specific properties:</p> <pre><code>data class EnterpriseRule(\n    val Rule: Rule&lt;EnterpriseContext&gt;,\n    val minSubscriptionTier: SubscriptionTier? = null,\n    val requiredRole: UserRole? = null,\n    val requiredFeatures: Set&lt;String&gt; = emptySet(),\n) {\n    fun matches(context: EnterpriseContext): Boolean {\n        // First check base rule (platform, locale, version)\n        if (!Rule.matches(context)) return false\n\n        // Then check enterprise-specific requirements\n        if (minSubscriptionTier != null &amp;&amp; context.subscriptionTier.ordinal &lt; minSubscriptionTier.ordinal) {\n            return false\n        }\n\n        if (requiredRole != null &amp;&amp; context.userRole.ordinal &lt; requiredRole.ordinal) {\n            return false\n        }\n\n        if (requiredFeatures.isNotEmpty() &amp;&amp; !context.featuresEnabled.containsAll(requiredFeatures)) {\n            return false\n        }\n\n        return true\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>val enterpriseOnlyRule = EnterpriseRule(\n    Rule = Rule(\n        rollout = Rollout.MAX,\n        locales = emptySet(),\n        platforms = setOf(Platform.WEB),\n        versionRange = Unbounded,\n    ),\n    minSubscriptionTier = SubscriptionTier.ENTERPRISE,\n    requiredRole = UserRole.ADMIN,\n)\n\nif (enterpriseOnlyRule.matches(enterpriseCtx)) {\n    // User meets all criteria\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#multiple-context-types-in-the-same-application","title":"Multiple Context Types in the Same Application","text":"<p>You can use multiple context types for different purposes:</p> <pre><code>// Standard features use base Context\nenum class StandardFeatures(\n    override val key: String\n) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_UI(\"new_ui\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Boolean, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\n// Enterprise features use EnterpriseContext\nenum class EnterpriseFeatures(\n    override val key: String\n) : Conditional&lt;Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"advanced_analytics\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Boolean, EnterpriseContext&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\n// Experiment features use ExperimentContext\nenum class ExperimentFeatures(\n    override val key: String\n) : Conditional&lt;String, ExperimentContext&gt; {  // Note: String value type\n    HOMEPAGE_VARIANT(\"homepage_variant\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;String, ExperimentContext&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n</code></pre> <p>Each set of flags operates independently with its own context type.</p>"},{"location":"advanced/context-polymorphism/#context-creation-patterns","title":"Context Creation Patterns","text":""},{"location":"advanced/context-polymorphism/#from-user-session","title":"From User Session","text":"<pre><code>fun createEnterpriseContext(session: UserSession): EnterpriseContext {\n    return EnterpriseContext(\n        locale = session.user.preferredLocale,\n        platform = session.deviceInfo.platform,\n        appVersion = session.appVersion,\n        stableId = StableId.of(session.user.id),\n        organizationId = session.organization.id,\n        subscriptionTier = session.organization.subscriptionTier,\n        userRole = session.user.roleIn(session.organization),\n        featuresEnabled = session.organization.enabledFeatures,\n    )\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#from-api-request","title":"From API Request","text":"<pre><code>fun createContextFromRequest(request: HttpServletRequest): EnterpriseContext {\n    val user = authenticateUser(request)\n    val org = user.organization\n\n    return EnterpriseContext(\n        locale = parseLocale(request.getHeader(\"Accept-Language\")),\n        platform = parsePlatform(request.getHeader(\"User-Agent\")),\n        appVersion = parseVersion(request.getHeader(\"X-App-Version\")),\n        stableId = StableId.of(user.id),\n        organizationId = org.id,\n        subscriptionTier = org.tier,\n        userRole = user.role,\n        featuresEnabled = org.features,\n    )\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#from-graphql-context","title":"From GraphQL Context","text":"<pre><code>data class GraphQLContext(\n    val user: User,\n    val organization: Organization,\n    // ... other GraphQL context fields\n) {\n    fun toEnterpriseContext(): EnterpriseContext {\n        return EnterpriseContext(\n            locale = user.locale,\n            platform = user.lastSeenPlatform,\n            appVersion = user.lastSeenAppVersion,\n            stableId = StableId.of(user.id),\n            organizationId = organization.id,\n            subscriptionTier = organization.tier,\n            userRole = user.role,\n            featuresEnabled = organization.features,\n        )\n    }\n}\n\n// In GraphQL resolver:\nval enterpriseCtx = graphQLContext.toEnterpriseContext()\nval hasAccess = enterpriseCtx.evaluate(EnterpriseFeatures.API_ACCESS)\n</code></pre>"},{"location":"advanced/context-polymorphism/#inheritance-and-context-hierarchies","title":"Inheritance and Context Hierarchies","text":"<p>You can create context hierarchies:</p> <pre><code>// Base authenticated context\ninterface AuthenticatedContext : Context {\n    val userId: String\n    val sessionId: String\n}\n\n// Enterprise adds organization info\ndata class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    override val userId: String,\n    override val sessionId: String,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n) : AuthenticatedContext\n\n// Free user doesn't have organization\ndata class FreeUserContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    override val userId: String,\n    override val sessionId: String,\n) : AuthenticatedContext\n</code></pre>"},{"location":"advanced/context-polymorphism/#best-practices","title":"Best Practices","text":""},{"location":"advanced/context-polymorphism/#1-keep-contexts-immutable","title":"1. Keep Contexts Immutable","text":"<p>Use <code>data class</code> and <code>val</code> properties:</p> <pre><code>data class MyContext(\n    override val locale: AppLocale,  // val, not var\n    val customField: String,\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#2-use-stable-ids-correctly","title":"2. Use Stable IDs Correctly","text":"<p>The <code>stableId</code> should be: - Consistent for the same user across sessions - Unique per user - Non-PII if possible (hashed user ID, device ID, etc.)</p> <pre><code>// Good: Stable, unique identifier\nstableId = StableId.of(user.hashedId)\n\n// Bad: Session ID changes every session\nstableId = StableId.of(session.id)\n\n// Bad: Not unique per user\nstableId = StableId.of(user.organization.id)\n</code></pre>"},{"location":"advanced/context-polymorphism/#3-keep-contexts-lightweight","title":"3. Keep Contexts Lightweight","text":"<p>Don't include heavy objects or computed values:</p> <pre><code>// Good: Only data needed for evaluation\ndata class MyContext(\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    // ...\n) : Context\n\n// Bad: Includes heavy objects\ndata class MyContext(\n    override val stableId: StableId,\n    val user: User,  // May contain lots of data\n    val organization: Organization,  // May trigger database queries\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#4-document-custom-fields","title":"4. Document Custom Fields","text":"<p>Add KDoc to explain the purpose of custom fields:</p> <pre><code>data class EnterpriseContext(\n    // Base Context properties\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    /**\n     * Unique identifier for the user's organization.\n     * Used for organization-specific feature rollouts.\n     */\n    val organizationId: String,\n\n    /**\n     * Current subscription tier of the organization.\n     * Used to gate premium features.\n     */\n    val subscriptionTier: SubscriptionTier,\n) : Context\n</code></pre>"},{"location":"advanced/context-polymorphism/#5-test-with-multiple-context-types","title":"5. Test with Multiple Context Types","text":"<p>Write tests that verify flags work correctly with your custom contexts:</p> <pre><code>@Test\nfun `enterprise features evaluate correctly with EnterpriseContext`() {\n    config {\n        EnterpriseFeatures.ADVANCED_ANALYTICS with {\n            default(false)\n            rule {\n                platforms(Platform.WEB)\n            } implies true\n        }\n    }\n\n    val ctx = EnterpriseContext(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"test-user\"),\n        organizationId = \"org-123\",\n        subscriptionTier = SubscriptionTier.ENTERPRISE,\n        userRole = UserRole.ADMIN,\n        featuresEnabled = emptySet(),\n    )\n\n    assertTrue(ctx.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS))\n}\n</code></pre>"},{"location":"advanced/context-polymorphism/#summary","title":"Summary","text":"<p>Context polymorphism in Konditional allows you to:</p> <ul> <li>Extend the base Context with domain-specific fields</li> <li>Maintain type safety throughout the system</li> <li>Create custom rules that leverage your context's properties</li> <li>Use multiple context types in the same application</li> <li>Adapt to your domain without modifying the framework</li> </ul> <p>This makes Konditional flexible enough to handle any use case while keeping the type safety guarantees that make it powerful.</p>"},{"location":"advanced/custom-types/","title":"Custom Types","text":"<p>While Konditional provides built-in support for common types (Boolean, String, Int, Double), you can also use custom types for your feature flags. This enables:</p> <ul> <li>Complex configurations: Use rich domain objects as flag values</li> <li>Type safety: Leverage Kotlin's type system for your custom types</li> <li>Serialization: Integrate custom types with Konditional's serialization system</li> </ul>"},{"location":"advanced/custom-types/#defining-custom-types","title":"Defining Custom Types","text":""},{"location":"advanced/custom-types/#simple-custom-type","title":"Simple Custom Type","text":"<pre><code>data class ThemeConfig(\n    val primaryColor: String,\n    val secondaryColor: String,\n    val darkMode: Boolean\n)\n\nval themeFlag = Flag(\n    id = \"app-theme\",\n    defaultValue = ThemeConfig(\n        primaryColor = \"#007AFF\",\n        secondaryColor = \"#5856D6\",\n        darkMode = false\n    )\n)\n</code></pre>"},{"location":"advanced/custom-types/#using-the-flag","title":"Using the Flag","text":"<pre><code>val theme = themeFlag.evaluate(context)\nprintln(\"Primary color: ${theme.primaryColor}\")\n</code></pre>"},{"location":"advanced/custom-types/#serialization-support","title":"Serialization Support","text":"<p>To use custom types with serialization, register a <code>ValueType</code> converter:</p>"},{"location":"advanced/custom-types/#step-1-define-your-type","title":"Step 1: Define Your Type","text":"<pre><code>data class FeatureConfig(\n    val maxUsers: Int,\n    val allowedRegions: List&lt;String&gt;,\n    val experimentalFeatures: Set&lt;String&gt;\n)\n</code></pre>"},{"location":"advanced/custom-types/#step-2-create-a-valuetype","title":"Step 2: Create a ValueType","text":"<pre><code>import io.amichne.konditional.core.ValueType\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.json.Json\n\n@Serializable\ndata class SerializableFeatureConfig(\n    val maxUsers: Int,\n    val allowedRegions: List&lt;String&gt;,\n    val experimentalFeatures: Set&lt;String&gt;\n)\n\nobject FeatureConfigType : ValueType&lt;FeatureConfig&gt; {\n    override val name = \"FeatureConfig\"\n\n    override fun serialize(value: FeatureConfig): String {\n        val serializable = SerializableFeatureConfig(\n            maxUsers = value.maxUsers,\n            allowedRegions = value.allowedRegions,\n            experimentalFeatures = value.experimentalFeatures\n        )\n        return Json.encodeToString(\n            SerializableFeatureConfig.serializer(),\n            serializable\n        )\n    }\n\n    override fun deserialize(value: String): FeatureConfig {\n        val serializable = Json.decodeFromString(\n            SerializableFeatureConfig.serializer(),\n            value\n        )\n        return FeatureConfig(\n            maxUsers = serializable.maxUsers,\n            allowedRegions = serializable.allowedRegions,\n            experimentalFeatures = serializable.experimentalFeatures\n        )\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#step-3-register-the-type","title":"Step 3: Register the Type","text":"<pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\n\nval serializer = SnapshotSerializer(\n    customTypes = mapOf(\n        \"FeatureConfig\" to FeatureConfigType\n    )\n)\n</code></pre>"},{"location":"advanced/custom-types/#step-4-use-with-flags","title":"Step 4: Use with Flags","text":"<pre><code>val featureFlag = Flag(\n    id = \"feature-config\",\n    defaultValue = FeatureConfig(\n        maxUsers = 1000,\n        allowedRegions = listOf(\"US\", \"EU\"),\n        experimentalFeatures = setOf()\n    )\n)\n\n// Register flag\nserializer.register(featureFlag)\n\n// Serialize\nval snapshot = serializer.serialize()\n\n// Deserialize\nval loaded = serializer.deserialize(snapshot)\n</code></pre>"},{"location":"advanced/custom-types/#enum-types","title":"Enum Types","text":"<p>Enums work naturally with Konditional:</p> <pre><code>enum class LogLevel {\n    DEBUG, INFO, WARN, ERROR\n}\n\nval logLevelFlag = Flag(\n    id = \"log-level\",\n    defaultValue = LogLevel.INFO\n)\n\n// With rules\nval logLevelWithRules = Flag(\n    id = \"log-level\",\n    defaultValue = LogLevel.INFO,\n    rules = listOf(\n        Rule(\n            condition = EnvironmentCondition(\"development\"),\n            value = LogLevel.DEBUG\n        ),\n        Rule(\n            condition = EnvironmentCondition(\"production\"),\n            value = LogLevel.WARN\n        )\n    )\n)\n</code></pre>"},{"location":"advanced/custom-types/#enum-serialization","title":"Enum Serialization","text":"<pre><code>object LogLevelType : ValueType&lt;LogLevel&gt; {\n    override val name = \"LogLevel\"\n\n    override fun serialize(value: LogLevel): String = value.name\n\n    override fun deserialize(value: String): LogLevel =\n        LogLevel.valueOf(value)\n}\n</code></pre>"},{"location":"advanced/custom-types/#sealed-classes","title":"Sealed Classes","text":"<p>Sealed classes provide type-safe polymorphism:</p> <pre><code>sealed class PaymentMethod {\n    data class CreditCard(val last4: String) : PaymentMethod()\n    data class PayPal(val email: String) : PaymentMethod()\n    object Cash : PaymentMethod()\n}\n\nval paymentFlag = Flag(\n    id = \"default-payment-method\",\n    defaultValue = PaymentMethod.Cash as PaymentMethod\n)\n</code></pre>"},{"location":"advanced/custom-types/#sealed-class-serialization","title":"Sealed Class Serialization","text":"<pre><code>import kotlinx.serialization.json.*\n\nobject PaymentMethodType : ValueType&lt;PaymentMethod&gt; {\n    override val name = \"PaymentMethod\"\n\n    override fun serialize(value: PaymentMethod): String {\n        val json = when (value) {\n            is PaymentMethod.CreditCard -&gt; buildJsonObject {\n                put(\"type\", \"CreditCard\")\n                put(\"last4\", value.last4)\n            }\n            is PaymentMethod.PayPal -&gt; buildJsonObject {\n                put(\"type\", \"PayPal\")\n                put(\"email\", value.email)\n            }\n            PaymentMethod.Cash -&gt; buildJsonObject {\n                put(\"type\", \"Cash\")\n            }\n        }\n        return json.toString()\n    }\n\n    override fun deserialize(value: String): PaymentMethod {\n        val json = Json.parseToJsonElement(value).jsonObject\n        return when (json[\"type\"]?.jsonPrimitive?.content) {\n            \"CreditCard\" -&gt; PaymentMethod.CreditCard(\n                json[\"last4\"]!!.jsonPrimitive.content\n            )\n            \"PayPal\" -&gt; PaymentMethod.PayPal(\n                json[\"email\"]!!.jsonPrimitive.content\n            )\n            \"Cash\" -&gt; PaymentMethod.Cash\n            else -&gt; throw IllegalArgumentException(\"Unknown payment method\")\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#collections","title":"Collections","text":"<p>Use collections as flag values:</p> <pre><code>// List of strings\nval allowedCountriesFlag = Flag(\n    id = \"allowed-countries\",\n    defaultValue = listOf(\"US\", \"CA\", \"UK\")\n)\n\n// Map\nval featureLimitsFlag = Flag(\n    id = \"feature-limits\",\n    defaultValue = mapOf(\n        \"free\" to 10,\n        \"premium\" to 100,\n        \"enterprise\" to -1\n    )\n)\n\n// Set\nval enabledFeaturesFlag = Flag(\n    id = \"enabled-features\",\n    defaultValue = setOf(\"feature-a\", \"feature-b\")\n)\n</code></pre>"},{"location":"advanced/custom-types/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-types/#keep-types-simple","title":"Keep Types Simple","text":"<p>Prefer simple, serializable types:</p> <pre><code>// Good\ndata class Config(\n    val enabled: Boolean,\n    val timeout: Int,\n    val endpoints: List&lt;String&gt;\n)\n\n// Avoid complex hierarchies\ndata class OverlyComplex(\n    val nested: Level1,\n    val callbacks: List&lt;() -&gt; Unit&gt;, // Not serializable\n    val state: MutableState&lt;Int&gt; // Mutable state\n)\n</code></pre>"},{"location":"advanced/custom-types/#use-immutable-types","title":"Use Immutable Types","text":"<pre><code>// Good - immutable\ndata class FeatureSettings(\n    val maxRetries: Int,\n    val timeout: Duration\n)\n\n// Avoid - mutable\ndata class MutableSettings(\n    var maxRetries: Int,\n    var timeout: Duration\n)\n</code></pre>"},{"location":"advanced/custom-types/#document-type-contracts","title":"Document Type Contracts","text":"<pre><code>/**\n * Configuration for the recommendation engine.\n *\n * @property algorithm The algorithm to use (\"collaborative\", \"content\", \"hybrid\")\n * @property maxResults Maximum number of results to return (1-100)\n * @property minScore Minimum confidence score (0.0-1.0)\n */\ndata class RecommendationConfig(\n    val algorithm: String,\n    val maxResults: Int,\n    val minScore: Double\n) {\n    init {\n        require(algorithm in setOf(\"collaborative\", \"content\", \"hybrid\"))\n        require(maxResults in 1..100)\n        require(minScore in 0.0..1.0)\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#version-your-types","title":"Version Your Types","text":"<p>When types evolve, handle versioning:</p> <pre><code>sealed class ConfigVersion {\n    data class V1(val timeout: Int) : ConfigVersion()\n    data class V2(\n        val timeout: Int,\n        val retries: Int\n    ) : ConfigVersion()\n}\n\nobject ConfigVersionType : ValueType&lt;ConfigVersion&gt; {\n    override fun deserialize(value: String): ConfigVersion {\n        val json = Json.parseToJsonElement(value).jsonObject\n        return when (json[\"version\"]?.jsonPrimitive?.int) {\n            1 -&gt; ConfigVersion.V1(\n                timeout = json[\"timeout\"]!!.jsonPrimitive.int\n            )\n            2 -&gt; ConfigVersion.V2(\n                timeout = json[\"timeout\"]!!.jsonPrimitive.int,\n                retries = json[\"retries\"]!!.jsonPrimitive.int\n            )\n            else -&gt; throw IllegalArgumentException(\"Unknown version\")\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/custom-types/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Migration strategies for evolving flag configurations</li> <li>Explore Patch Updates for dynamic configuration changes</li> <li>Review the Serialization API for complete details</li> </ul>"},{"location":"advanced/migration/","title":"Migration Strategies","text":"<p>As your application evolves, you'll need to migrate feature flag configurations. This guide covers strategies for:</p> <ul> <li>Updating flag schemas</li> <li>Migrating between versions</li> <li>Deprecating old flags</li> <li>Evolving configuration structures</li> </ul>"},{"location":"advanced/migration/#schema-evolution","title":"Schema Evolution","text":""},{"location":"advanced/migration/#adding-new-flags","title":"Adding New Flags","text":"<p>New flags can be added without breaking existing configurations:</p> <pre><code>// Original configuration\nval originalFlags = listOf(\n    Flag(\"feature-a\", defaultValue = true),\n    Flag(\"feature-b\", defaultValue = false)\n)\n\n// Add new flag\nval updatedFlags = originalFlags + Flag(\n    \"feature-c\",\n    defaultValue = true\n)\n</code></pre> <p>When deserializing old configurations, new flags use their default values:</p> <pre><code>val serializer = SnapshotSerializer()\n\n// Register all flags (including new ones)\nupdatedFlags.forEach { serializer.register(it) }\n\n// Load old configuration\nval oldSnapshot = loadFromStorage()\nserializer.deserialize(oldSnapshot) // feature-c uses default value\n</code></pre>"},{"location":"advanced/migration/#removing-flags","title":"Removing Flags","text":"<p>To remove a flag safely:</p> <ol> <li>Mark as deprecated (optional documentation step)</li> <li>Stop using in code</li> <li>Remove after grace period</li> </ol> <pre><code>// Step 1: Mark as deprecated\n@Deprecated(\"Use feature-c instead\", ReplaceWith(\"feature-c\"))\nval deprecatedFlag = Flag(\"old-feature\", defaultValue = false)\n\n// Step 2: Migration period - both flags exist\nval currentFlags = listOf(\n    deprecatedFlag,\n    Flag(\"new-feature\", defaultValue = false)\n)\n\n// Step 3: Remove old flag (after users have migrated)\nval cleanFlags = listOf(\n    Flag(\"new-feature\", defaultValue = false)\n)\n</code></pre>"},{"location":"advanced/migration/#renaming-flags","title":"Renaming Flags","text":"<p>Create a migration function to rename flags in stored configurations:</p> <pre><code>fun migrateRenamedFlag(\n    snapshot: SerializableSnapshot,\n    oldName: String,\n    newName: String\n): SerializableSnapshot {\n    val updatedFlags = snapshot.flags.map { flag -&gt;\n        if (flag.id == oldName) {\n            flag.copy(id = newName)\n        } else {\n            flag\n        }\n    }\n    return snapshot.copy(flags = updatedFlags)\n}\n\n// Usage\nval oldSnapshot = loadFromStorage()\nval migratedSnapshot = migrateRenamedFlag(\n    oldSnapshot,\n    oldName = \"oldFeatureName\",\n    newName = \"newFeatureName\"\n)\nserializer.deserialize(migratedSnapshot)\n</code></pre>"},{"location":"advanced/migration/#type-migrations","title":"Type Migrations","text":""},{"location":"advanced/migration/#changing-value-types","title":"Changing Value Types","text":"<p>When changing a flag's value type, provide a conversion function:</p> <pre><code>// Original: Boolean flag\nval oldFlag = Flag(\"max-connections\", defaultValue = false)\n\n// New: Int flag\nval newFlag = Flag(\"max-connections\", defaultValue = 10)\n\nfun migrateBooleanToInt(snapshot: SerializableSnapshot): SerializableSnapshot {\n    val updatedFlags = snapshot.flags.map { flag -&gt;\n        if (flag.id == \"max-connections\" &amp;&amp; flag.type == \"Boolean\") {\n            flag.copy(\n                type = \"Int\",\n                value = if (flag.value.toBoolean()) \"100\" else \"10\"\n            )\n        } else {\n            flag\n        }\n    }\n    return snapshot.copy(flags = updatedFlags)\n}\n</code></pre>"},{"location":"advanced/migration/#complex-type-evolution","title":"Complex Type Evolution","text":"<p>For custom types, handle versioning in your ValueType implementation:</p> <pre><code>// Version 1\ndata class ConfigV1(val timeout: Int)\n\n// Version 2 - added retries\ndata class ConfigV2(val timeout: Int, val retries: Int)\n\nobject ConfigType : ValueType&lt;ConfigV2&gt; {\n    override val name = \"Config\"\n\n    override fun deserialize(value: String): ConfigV2 {\n        val json = Json.parseToJsonElement(value).jsonObject\n\n        // Check version\n        return when (json[\"version\"]?.jsonPrimitive?.int) {\n            1 -&gt; {\n                // Migrate from V1\n                ConfigV2(\n                    timeout = json[\"timeout\"]!!.jsonPrimitive.int,\n                    retries = 3 // Default value for new field\n                )\n            }\n            2, null -&gt; {\n                // V2 or assume current version if no version field\n                ConfigV2(\n                    timeout = json[\"timeout\"]!!.jsonPrimitive.int,\n                    retries = json[\"retries\"]?.jsonPrimitive?.int ?: 3\n                )\n            }\n            else -&gt; throw IllegalArgumentException(\"Unknown version\")\n        }\n    }\n\n    override fun serialize(value: ConfigV2): String {\n        val json = buildJsonObject {\n            put(\"version\", 2)\n            put(\"timeout\", value.timeout)\n            put(\"retries\", value.retries)\n        }\n        return json.toString()\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#version-based-migrations","title":"Version-Based Migrations","text":""},{"location":"advanced/migration/#migration-manager","title":"Migration Manager","text":"<p>Create a migration manager to handle version transitions:</p> <pre><code>class MigrationManager {\n    private val migrations = mutableMapOf&lt;String, (SerializableSnapshot) -&gt; SerializableSnapshot&gt;()\n\n    fun register(version: String, migration: (SerializableSnapshot) -&gt; SerializableSnapshot) {\n        migrations[version] = migration\n    }\n\n    fun migrate(snapshot: SerializableSnapshot, targetVersion: String): SerializableSnapshot {\n        var current = snapshot\n        val currentVersion = parseVersion(snapshot.version.value)\n        val target = parseVersion(targetVersion)\n\n        migrations\n            .filter { (version, _) -&gt;\n                val v = parseVersion(version)\n                v &gt; currentVersion &amp;&amp; v &lt;= target\n            }\n            .toSortedMap()\n            .forEach { (_, migration) -&gt;\n                current = migration(current)\n            }\n\n        return current.copy(version = SerializableVersion(targetVersion))\n    }\n\n    private fun parseVersion(version: String): Int {\n        return version.replace(\".\", \"\").toIntOrNull() ?: 0\n    }\n}\n\n// Usage\nval migrationManager = MigrationManager()\n\nmigrationManager.register(\"1.1.0\") { snapshot -&gt;\n    // Migration for 1.1.0\n    migrateRenamedFlag(snapshot, \"old-name\", \"new-name\")\n}\n\nmigrationManager.register(\"1.2.0\") { snapshot -&gt;\n    // Migration for 1.2.0\n    migrateBooleanToInt(snapshot)\n}\n\n// Apply migrations\nval oldSnapshot = loadFromStorage()\nval migratedSnapshot = migrationManager.migrate(oldSnapshot, \"1.2.0\")\n</code></pre>"},{"location":"advanced/migration/#backward-compatibility","title":"Backward Compatibility","text":""},{"location":"advanced/migration/#maintain-old-flag-ids","title":"Maintain Old Flag IDs","text":"<p>Keep a mapping of old to new flag IDs:</p> <pre><code>class FlagRegistry {\n    private val flags = mutableMapOf&lt;String, Flag&lt;*&gt;&gt;()\n    private val aliases = mutableMapOf&lt;String, String&gt;()\n\n    fun register(flag: Flag&lt;*&gt;, vararg aliasIds: String) {\n        flags[flag.id] = flag\n        aliasIds.forEach { alias -&gt;\n            aliases[alias] = flag.id\n        }\n    }\n\n    fun get(id: String): Flag&lt;*&gt;? {\n        val actualId = aliases[id] ?: id\n        return flags[actualId]\n    }\n}\n\n// Usage\nval registry = FlagRegistry()\nregistry.register(\n    Flag(\"new-feature-name\", defaultValue = true),\n    \"old-feature-name\", // Alias for backward compatibility\n    \"legacy-name\"       // Another alias\n)\n</code></pre>"},{"location":"advanced/migration/#graceful-degradation","title":"Graceful Degradation","text":"<p>Handle missing or invalid flags gracefully:</p> <pre><code>fun &lt;T&gt; safeEvaluate(\n    flagId: String,\n    defaultValue: T,\n    context: EvaluationContext = EvaluationContext()\n): T {\n    return try {\n        val flag = registry.get(flagId) as? Flag&lt;T&gt;\n        flag?.evaluate(context) ?: defaultValue\n    } catch (e: Exception) {\n        logger.warn(\"Failed to evaluate flag $flagId: ${e.message}\")\n        defaultValue\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#rolling-migrations","title":"Rolling Migrations","text":"<p>For large deployments, use rolling migrations:</p>"},{"location":"advanced/migration/#phase-1-dual-write","title":"Phase 1: Dual Write","text":"<p>Write to both old and new flags:</p> <pre><code>fun updateFeatureFlag(enabled: Boolean) {\n    // Update old flag\n    oldFlag.setValue(enabled)\n\n    // Update new flag\n    newFlag.setValue(enabled)\n\n    // Persist both\n    persistFlags()\n}\n</code></pre>"},{"location":"advanced/migration/#phase-2-dual-read","title":"Phase 2: Dual Read","text":"<p>Read from new flag, fall back to old:</p> <pre><code>fun isFeatureEnabled(): Boolean {\n    return try {\n        newFlag.evaluate()\n    } catch (e: Exception) {\n        logger.warn(\"Failed to read new flag, falling back to old\")\n        oldFlag.evaluate()\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#phase-3-deprecate-old","title":"Phase 3: Deprecate Old","text":"<p>After all instances are updated:</p> <pre><code>fun isFeatureEnabled(): Boolean {\n    return newFlag.evaluate()\n}\n</code></pre>"},{"location":"advanced/migration/#phase-4-remove-old","title":"Phase 4: Remove Old","text":"<p>Clean up old flag completely.</p>"},{"location":"advanced/migration/#testing-migrations","title":"Testing Migrations","text":""},{"location":"advanced/migration/#unit-tests","title":"Unit Tests","text":"<pre><code>@Test\nfun `test flag rename migration`() {\n    val oldSnapshot = SerializableSnapshot(\n        version = SerializableVersion(\"1.0.0\"),\n        flags = listOf(\n            SerializableFlag(\n                id = \"old-name\",\n                type = \"Boolean\",\n                value = \"true\"\n            )\n        )\n    )\n\n    val migrated = migrateRenamedFlag(oldSnapshot, \"old-name\", \"new-name\")\n\n    assertEquals(\"new-name\", migrated.flags.first().id)\n    assertEquals(\"true\", migrated.flags.first().value)\n}\n</code></pre>"},{"location":"advanced/migration/#integration-tests","title":"Integration Tests","text":"<pre><code>@Test\nfun `test full migration pipeline`() {\n    val serializer = SnapshotSerializer()\n    val migrationManager = MigrationManager()\n\n    // Setup migrations\n    setupMigrations(migrationManager)\n\n    // Load old config\n    val oldConfig = loadTestConfig(\"v1.0.0\")\n\n    // Migrate\n    val migrated = migrationManager.migrate(oldConfig, \"2.0.0\")\n\n    // Deserialize and verify\n    serializer.deserialize(migrated)\n\n    // Verify all flags work correctly\n    assertTrue(featureFlag.evaluate())\n}\n</code></pre>"},{"location":"advanced/migration/#best-practices","title":"Best Practices","text":""},{"location":"advanced/migration/#document-migrations","title":"Document Migrations","text":"<pre><code>/**\n * Migration 1.5.0 -&gt; 1.6.0\n *\n * Changes:\n * - Renamed `maxConnections` to `connectionLimit`\n * - Changed `enableCache` from Boolean to CacheConfig\n * - Removed deprecated `oldFeature` flag\n *\n * Backward compatibility: Maintains aliases for old flag names\n */\nfun migrateToV1_6_0(snapshot: SerializableSnapshot): SerializableSnapshot {\n    // Migration implementation\n}\n</code></pre>"},{"location":"advanced/migration/#version-everything","title":"Version Everything","text":"<pre><code>data class SerializableSnapshot(\n    val version: SerializableVersion,\n    val schemaVersion: Int = CURRENT_SCHEMA_VERSION,\n    val flags: List&lt;SerializableFlag&gt;\n) {\n    companion object {\n        const val CURRENT_SCHEMA_VERSION = 3\n    }\n}\n</code></pre>"},{"location":"advanced/migration/#test-migrations-thoroughly","title":"Test Migrations Thoroughly","text":"<ul> <li>Test migration from every previous version</li> <li>Test with missing fields</li> <li>Test with invalid data</li> <li>Test rollback scenarios</li> </ul>"},{"location":"advanced/migration/#provide-migration-tools","title":"Provide Migration Tools","text":"<pre><code>// CLI tool for offline migration\nfun main(args: Array&lt;String&gt;) {\n    val inputFile = args[0]\n    val outputFile = args[1]\n    val targetVersion = args[2]\n\n    val snapshot = loadSnapshot(inputFile)\n    val migrated = migrationManager.migrate(snapshot, targetVersion)\n    saveSnapshot(outputFile, migrated)\n\n    println(\"Migrated from ${snapshot.version} to $targetVersion\")\n}\n</code></pre>"},{"location":"advanced/migration/#next-steps","title":"Next Steps","text":"<ul> <li>Review Patch Updates for incremental configuration changes</li> <li>Learn about Custom Types for complex flag values</li> <li>Explore the Serialization API for complete details</li> </ul>"},{"location":"advanced/patch-updates/","title":"Patch Updates","text":"<p>Patch updates allow you to modify feature flag configurations dynamically without replacing the entire configuration. This is useful for:</p> <ul> <li>Incremental updates: Apply small changes without re-deploying entire configurations</li> <li>Real-time adjustments: Update specific flags in production</li> <li>Efficient syncing: Minimize bandwidth by sending only changes</li> <li>Version control: Track configuration changes over time</li> </ul>"},{"location":"advanced/patch-updates/#what-is-a-patch","title":"What is a Patch?","text":"<p>A patch is a set of targeted changes to your flag configuration. Instead of sending a complete snapshot, you send only the differences:</p> <pre><code>import io.amichne.konditional.serialization.models.*\n\nval patch = SerializablePatch(\n    version = SerializableVersion(\"1.2.0\"),\n    changes = listOf(\n        FlagChange.Update(\n            flagId = \"my-feature\",\n            newValue = true\n        ),\n        FlagChange.AddRule(\n            flagId = \"beta-feature\",\n            rule = SerializableRule(\n                condition = /* ... */,\n                value = true\n            )\n        )\n    )\n)\n</code></pre>"},{"location":"advanced/patch-updates/#types-of-changes","title":"Types of Changes","text":""},{"location":"advanced/patch-updates/#update-flag-value","title":"Update Flag Value","text":"<p>Change a flag's default value:</p> <pre><code>FlagChange.Update(\n    flagId = \"max-items\",\n    newValue = 20\n)\n</code></pre>"},{"location":"advanced/patch-updates/#add-rule","title":"Add Rule","text":"<p>Add a new rule to a flag:</p> <pre><code>FlagChange.AddRule(\n    flagId = \"premium-feature\",\n    rule = SerializableRule(\n        condition = VersionCondition(\n            range = VersionRange.from(\"2.0.0\")\n        ),\n        value = true\n    )\n)\n</code></pre>"},{"location":"advanced/patch-updates/#remove-rule","title":"Remove Rule","text":"<p>Remove a specific rule:</p> <pre><code>FlagChange.RemoveRule(\n    flagId = \"old-feature\",\n    ruleIndex = 0\n)\n</code></pre>"},{"location":"advanced/patch-updates/#toggle-flag","title":"Toggle Flag","text":"<p>Enable or disable a flag:</p> <pre><code>FlagChange.Toggle(\n    flagId = \"maintenance-mode\",\n    enabled = true\n)\n</code></pre>"},{"location":"advanced/patch-updates/#applying-patches","title":"Applying Patches","text":""},{"location":"advanced/patch-updates/#using-snapshotserializer","title":"Using SnapshotSerializer","text":"<pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\n\nval serializer = SnapshotSerializer()\n\n// Get current snapshot\nval currentSnapshot = serializer.serialize()\n\n// Apply patch\nval updatedSnapshot = serializer.applyPatch(currentSnapshot, patch)\n\n// Load back into runtime\nserializer.deserialize(updatedSnapshot)\n</code></pre>"},{"location":"advanced/patch-updates/#patch-validation","title":"Patch Validation","text":"<p>Patches are validated before being applied:</p> <pre><code>try {\n    serializer.applyPatch(snapshot, patch)\n} catch (e: PatchValidationException) {\n    println(\"Invalid patch: ${e.message}\")\n    // Handle validation error\n}\n</code></pre>"},{"location":"advanced/patch-updates/#best-practices","title":"Best Practices","text":""},{"location":"advanced/patch-updates/#version-your-patches","title":"Version Your Patches","text":"<p>Always include version information:</p> <pre><code>val patch = SerializablePatch(\n    version = SerializableVersion(\"1.3.0\"),\n    previousVersion = SerializableVersion(\"1.2.0\"),\n    changes = changes\n)\n</code></pre>"},{"location":"advanced/patch-updates/#test-patches-locally","title":"Test Patches Locally","text":"<p>Before applying patches in production, test them locally:</p> <pre><code>// Clone current configuration\nval testSnapshot = currentSnapshot.copy()\n\n// Apply patch to test snapshot\nval result = serializer.applyPatch(testSnapshot, patch)\n\n// Validate result\nassert(result.isValid())\n</code></pre>"},{"location":"advanced/patch-updates/#atomic-application","title":"Atomic Application","text":"<p>Apply patches atomically to avoid partial states:</p> <pre><code>// Use transactions or locks\nsynchronized(configLock) {\n    val newSnapshot = serializer.applyPatch(currentSnapshot, patch)\n    updateConfiguration(newSnapshot)\n}\n</code></pre>"},{"location":"advanced/patch-updates/#keep-patch-history","title":"Keep Patch History","text":"<p>Maintain a history of patches for rollback and auditing:</p> <pre><code>data class PatchHistory(\n    val patches: List&lt;SerializablePatch&gt;,\n    val timestamps: List&lt;Instant&gt;\n)\n\nfun applyWithHistory(patch: SerializablePatch) {\n    history.add(patch, Instant.now())\n    serializer.applyPatch(currentSnapshot, patch)\n}\n</code></pre>"},{"location":"advanced/patch-updates/#example-remote-configuration-updates","title":"Example: Remote Configuration Updates","text":"<pre><code>class RemoteConfigManager(\n    private val serializer: SnapshotSerializer,\n    private val httpClient: HttpClient\n) {\n    suspend fun checkForUpdates() {\n        val currentVersion = getCurrentVersion()\n        val patch = httpClient.fetchPatch(currentVersion)\n\n        if (patch != null) {\n            try {\n                val snapshot = serializer.getCurrentSnapshot()\n                val updated = serializer.applyPatch(snapshot, patch)\n                serializer.load(updated)\n\n                println(\"Applied patch: ${patch.version}\")\n            } catch (e: Exception) {\n                println(\"Failed to apply patch: ${e.message}\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/patch-updates/#common-use-cases","title":"Common Use Cases","text":""},{"location":"advanced/patch-updates/#ab-test-updates","title":"A/B Test Updates","text":"<pre><code>// Start A/B test\nval startPatch = SerializablePatch(\n    changes = listOf(\n        FlagChange.AddRule(\n            flagId = \"experiment-feature\",\n            rule = SerializableRule(\n                condition = UserBucketCondition(bucket = \"A\"),\n                value = \"variant-a\"\n            )\n        )\n    )\n)\n\n// Adjust test based on results\nval adjustPatch = SerializablePatch(\n    changes = listOf(\n        FlagChange.Update(\n            flagId = \"experiment-feature\",\n            newValue = \"variant-b\"\n        )\n    )\n)\n</code></pre>"},{"location":"advanced/patch-updates/#emergency-disable","title":"Emergency Disable","text":"<pre><code>val emergencyPatch = SerializablePatch(\n    version = SerializableVersion(\"hotfix-1\"),\n    changes = listOf(\n        FlagChange.Toggle(\n            flagId = \"problematic-feature\",\n            enabled = false\n        )\n    )\n)\n</code></pre>"},{"location":"advanced/patch-updates/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Custom Types for advanced flag values</li> <li>Explore Migration strategies for evolving configurations</li> <li>Review the Serialization API for complete details</li> </ul>"},{"location":"getting-started/introduction/","title":"Introduction to Konditional","text":"<p>Konditional is a type-safe, deterministic feature flag library for Kotlin that provides compile-time safety and runtime flexibility for managing feature flags in your applications.</p>"},{"location":"getting-started/introduction/#what-are-feature-flags","title":"What are Feature Flags?","text":"<p>Feature flags (also known as feature toggles) are a software development technique that allows you to enable or disable features without deploying new code. This enables:</p> <ul> <li>Progressive rollouts: Deploy features to a subset of users</li> <li>A/B testing: Test different implementations with different user groups</li> <li>Emergency kill switches: Quickly disable problematic features</li> <li>Development flexibility: Work on features behind flags before they're ready</li> </ul>"},{"location":"getting-started/introduction/#why-konditional","title":"Why Konditional?","text":""},{"location":"getting-started/introduction/#type-safe","title":"Type-Safe","text":"<p>Konditional leverages Kotlin's powerful type system to provide compile-time safety. Your feature flags are strongly typed, preventing runtime type errors.</p>"},{"location":"getting-started/introduction/#deterministic","title":"Deterministic","text":"<p>Flag evaluation is predictable and based on clear, testable rules. No surprises in production.</p>"},{"location":"getting-started/introduction/#serializable","title":"Serializable","text":"<p>Export and import flag configurations using built-in serialization support. Perfect for: - Remote configuration management - A/B testing platforms - Configuration as code</p>"},{"location":"getting-started/introduction/#flexible","title":"Flexible","text":"<p>Support for: - Version ranges - Custom value types - Complex conditional logic - Rule composition</p>"},{"location":"getting-started/introduction/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/introduction/#flags","title":"Flags","text":"<p>A flag is a typed configuration value that can change based on conditions. Each flag has: - A unique identifier - A value type (Boolean, String, Int, etc.) - A default value - Optional rules for conditional evaluation</p>"},{"location":"getting-started/introduction/#rules","title":"Rules","text":"<p>Rules define when and how flag values should change. Rules can be based on: - Application version - User attributes - Custom conditions - Time-based criteria</p>"},{"location":"getting-started/introduction/#conditions","title":"Conditions","text":"<p>Conditions are the building blocks of rules. They evaluate to true or false based on runtime context.</p>"},{"location":"getting-started/introduction/#next-steps","title":"Next Steps","text":"<p>Continue to the Quick Start guide to begin using Konditional in your project.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Konditional in your Kotlin project.</p>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<p>Add the Konditional dependency to your project:</p>"},{"location":"getting-started/quick-start/#gradle-kotlin-dsl","title":"Gradle (Kotlin DSL)","text":"<pre><code>dependencies {\n    implementation(\"io.amichne:konditional-core:VERSION\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#gradle-groovy","title":"Gradle (Groovy)","text":"<pre><code>dependencies {\n    implementation 'io.amichne:konditional-core:VERSION'\n}\n</code></pre>"},{"location":"getting-started/quick-start/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.amichne&lt;/groupId&gt;\n    &lt;artifactId&gt;konditional-core&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quick-start/#1-define-your-feature-flags","title":"1. Define Your Feature Flags","text":"<p>Create an enum implementing <code>Conditional&lt;S, C&gt;</code> where <code>S</code> is the value type and <code>C</code> is the context type:</p> <pre><code>import io.amichne.konditional.core.Conditional\nimport io.amichne.konditional.builders.FlagBuilder\nimport io.amichne.konditional.context.Context\n\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ANALYTICS(\"analytics\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Boolean, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n</code></pre>"},{"location":"getting-started/quick-start/#2-configure-your-flags","title":"2. Configure Your Flags","text":"<p>Use the DSL to configure flag behavior:</p> <pre><code>import io.amichne.konditional.builders.ConfigBuilder.Companion.config\nimport io.amichne.konditional.context.Platform\n\nconfig {\n    Features.DARK_MODE with {\n        default(false)  // Default value when no rules match\n\n        // Enable for iOS users\n        rule {\n            platforms(Platform.IOS)\n        } implies true\n    }\n\n    Features.NEW_CHECKOUT with {\n        default(false)\n\n        // Enable for version 2.0+\n        rule {\n            versions {\n                min(2, 0)\n            }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#3-create-a-context-and-evaluate","title":"3. Create a Context and Evaluate","text":"<p>Create an evaluation context and check flag values:</p> <pre><code>import io.amichne.konditional.core.Flags.evaluate\nimport io.amichne.konditional.context.*\nimport io.amichne.konditional.core.StableId\n\n// Create a context with user/app information\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 1, 0),\n    stableId = StableId.of(\"user-123\")\n)\n\n// Evaluate flags\nval isDarkModeEnabled = context.evaluate(Features.DARK_MODE)  // true (iOS)\nval isNewCheckout = context.evaluate(Features.NEW_CHECKOUT)   // true (v2.0+)\n\nif (isDarkModeEnabled) {\n    applyDarkTheme()\n}\n</code></pre>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#string-based-flags","title":"String-Based Flags","text":"<p>For configuration values like API endpoints or theme names:</p> <pre><code>enum class Config(override val key: String) : Conditional&lt;String, Context&gt; {\n    API_ENDPOINT(\"api_endpoint\"),\n    THEME_NAME(\"theme_name\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;String, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    Config.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n\n        rule {\n            platforms(Platform.WEB)\n        } implies \"https://api.staging.example.com\"\n    }\n}\n\nval endpoint = context.evaluate(Config.API_ENDPOINT)\n</code></pre>"},{"location":"getting-started/quick-start/#integer-based-flags","title":"Integer-Based Flags","text":"<p>For numeric limits and thresholds:</p> <pre><code>enum class Limits(override val key: String) : Conditional&lt;Int, Context&gt; {\n    MAX_CONNECTIONS(\"max_connections\"),\n    TIMEOUT_SECONDS(\"timeout_seconds\"),\n    ;\n\n    override fun with(build: FlagBuilder&lt;Int, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n\nconfig {\n    Limits.MAX_CONNECTIONS with {\n        default(10)\n\n        rule {\n            platforms(Platform.WEB)\n        } implies 50\n    }\n}\n\nval maxConnections = context.evaluate(Limits.MAX_CONNECTIONS)\n</code></pre>"},{"location":"getting-started/quick-start/#gradual-rollouts","title":"Gradual Rollouts","text":"<p>Use rollout percentages for gradual feature releases:</p> <pre><code>import io.amichne.konditional.context.Rollout\n\nconfig {\n    Features.NEW_CHECKOUT with {\n        default(false)\n\n        // 25% rollout to iOS users\n        rule {\n            platforms(Platform.IOS)\n            rollout = Rollout.of(25.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#complex-targeting","title":"Complex Targeting","text":"<p>Combine multiple criteria:</p> <pre><code>config {\n    Features.ANALYTICS with {\n        default(false)\n\n        // Enable for US iOS users on v2.0+ with 50% rollout\n        rule {\n            locales(AppLocale.EN_US)\n            platforms(Platform.IOS)\n            versions {\n                min(2, 0)\n            }\n            rollout = Rollout.of(50.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Architecture to understand how Konditional works</li> <li>Explore Conditional Types for using different value types</li> <li>Read about Context Polymorphism to create custom contexts</li> <li>Learn about Serialization to manage flags remotely</li> </ul>"},{"location":"getting-started/quick-start/#example-project","title":"Example Project","text":"<p>For complete working examples, check out the test suite in the GitHub repository.</p>"},{"location":"serialization/api/","title":"API Reference","text":""},{"location":"serialization/api/#overview","title":"Overview","text":"<p>This page documents all public APIs in the Konditional serialization package.</p>"},{"location":"serialization/api/#snapshotserializer","title":"SnapshotSerializer","text":"<p>Main interface for serialization operations.</p>"},{"location":"serialization/api/#class-definition","title":"Class Definition","text":"<pre><code>class SnapshotSerializer(\n    moshi: Moshi = defaultMoshi()\n)\n</code></pre>"},{"location":"serialization/api/#methods","title":"Methods","text":""},{"location":"serialization/api/#serialize","title":"serialize()","text":"<p>Serializes a <code>Flags.Snapshot</code> to JSON string.</p> <pre><code>fun serialize(snapshot: Flags.Snapshot): String\n</code></pre> <p>Parameters: - <code>snapshot</code> - The snapshot to serialize</p> <p>Returns: Pretty-printed JSON string</p> <p>Example: <pre><code>val serializer = SnapshotSerializer.default\nval json = serializer.serialize(snapshot)\n</code></pre></p>"},{"location":"serialization/api/#deserialize","title":"deserialize()","text":"<p>Deserializes JSON string to <code>Flags.Snapshot</code>.</p> <pre><code>fun deserialize(json: String): Flags.Snapshot\n</code></pre> <p>Parameters: - <code>json</code> - JSON string to deserialize</p> <p>Returns: Deserialized <code>Flags.Snapshot</code></p> <p>Throws: - <code>JsonDataException</code> - If JSON is malformed - <code>IllegalArgumentException</code> - If flag keys are not registered</p> <p>Example: <pre><code>val snapshot = serializer.deserialize(json)\n</code></pre></p>"},{"location":"serialization/api/#serializepatch","title":"serializePatch()","text":"<p>Serializes a patch to JSON.</p> <pre><code>fun serializePatch(patch: SerializablePatch): String\n</code></pre> <p>Parameters: - <code>patch</code> - The patch to serialize</p> <p>Returns: JSON string</p> <p>Example: <pre><code>val patch = SerializablePatch(...)\nval json = serializer.serializePatch(patch)\n</code></pre></p>"},{"location":"serialization/api/#deserializepatch","title":"deserializePatch()","text":"<p>Deserializes JSON to a patch.</p> <pre><code>fun deserializePatch(json: String): SerializablePatch\n</code></pre> <p>Parameters: - <code>json</code> - JSON string containing patch</p> <p>Returns: Deserialized patch</p> <p>Throws: - <code>JsonDataException</code> - If JSON is malformed</p> <p>Example: <pre><code>val patch = serializer.deserializePatch(patchJson)\n</code></pre></p>"},{"location":"serialization/api/#applypatch","title":"applyPatch()","text":"<p>Applies a patch to an existing snapshot.</p> <pre><code>fun applyPatch(\n    currentSnapshot: Flags.Snapshot,\n    patch: SerializablePatch\n): Flags.Snapshot\n</code></pre> <p>Parameters: - <code>currentSnapshot</code> - Snapshot to patch - <code>patch</code> - Patch to apply</p> <p>Returns: New snapshot with patch applied</p> <p>Example: <pre><code>val updated = serializer.applyPatch(current, patch)\n</code></pre></p>"},{"location":"serialization/api/#applypatchjson","title":"applyPatchJson()","text":"<p>Applies a patch from JSON to a snapshot.</p> <pre><code>fun applyPatchJson(\n    currentSnapshot: Flags.Snapshot,\n    patchJson: String\n): Flags.Snapshot\n</code></pre> <p>Parameters: - <code>currentSnapshot</code> - Snapshot to patch - <code>patchJson</code> - JSON string containing patch</p> <p>Returns: New snapshot with patch applied</p> <p>Example: <pre><code>val updated = serializer.applyPatchJson(current, patchJson)\n</code></pre></p>"},{"location":"serialization/api/#companion-object","title":"Companion Object","text":""},{"location":"serialization/api/#defaultmoshi","title":"defaultMoshi()","text":"<p>Creates the default Moshi instance.</p> <pre><code>fun defaultMoshi(): Moshi\n</code></pre> <p>Returns: Configured Moshi instance</p>"},{"location":"serialization/api/#default","title":"default","text":"<p>Default serializer instance.</p> <pre><code>val default: SnapshotSerializer\n</code></pre> <p>Example: <pre><code>val serializer = SnapshotSerializer.default\n</code></pre></p>"},{"location":"serialization/api/#conditionalregistry","title":"ConditionalRegistry","text":"<p>Registry for mapping flag keys to <code>Conditional</code> instances.</p>"},{"location":"serialization/api/#methods_1","title":"Methods","text":""},{"location":"serialization/api/#register","title":"register()","text":"<p>Registers a single conditional.</p> <pre><code>fun &lt;S : Any, C : Context&gt; register(conditional: Conditional&lt;S, C&gt;)\n</code></pre> <p>Parameters: - <code>conditional</code> - The conditional to register</p> <p>Example: <pre><code>ConditionalRegistry.register(FeatureFlags.DARK_MODE)\n</code></pre></p>"},{"location":"serialization/api/#registerenum","title":"registerEnum()","text":"<p>Registers all conditionals from an enum.</p> <pre><code>inline fun &lt;reified T&gt; registerEnum()\n    where T : Enum&lt;T&gt;, T : Conditional&lt;*, *&gt;\n</code></pre> <p>Type Parameters: - <code>T</code> - Enum type implementing <code>Conditional</code></p> <p>Example: <pre><code>ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n</code></pre></p>"},{"location":"serialization/api/#get","title":"get()","text":"<p>Retrieves a conditional by key.</p> <pre><code>fun &lt;S : Any, C : Context&gt; get(key: String): Conditional&lt;S, C&gt;\n</code></pre> <p>Parameters: - <code>key</code> - String key to look up</p> <p>Returns: Conditional instance</p> <p>Throws: - <code>IllegalArgumentException</code> - If key not found</p> <p>Example: <pre><code>val flag = ConditionalRegistry.get&lt;Boolean, Context&gt;(\"dark_mode\")\n</code></pre></p>"},{"location":"serialization/api/#contains","title":"contains()","text":"<p>Checks if a key is registered.</p> <pre><code>fun contains(key: String): Boolean\n</code></pre> <p>Parameters: - <code>key</code> - String key to check</p> <p>Returns: <code>true</code> if registered, <code>false</code> otherwise</p> <p>Example: <pre><code>if (ConditionalRegistry.contains(\"dark_mode\")) {\n    // Key is registered\n}\n</code></pre></p>"},{"location":"serialization/api/#clear","title":"clear()","text":"<p>Clears all registrations. For testing only!</p> <pre><code>fun clear()\n</code></pre> <p>Example: <pre><code>@AfterEach\nfun tearDown() {\n    ConditionalRegistry.clear()\n}\n</code></pre></p>"},{"location":"serialization/api/#serializablesnapshot","title":"SerializableSnapshot","text":"<p>Top-level serializable representation.</p>"},{"location":"serialization/api/#data-class","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableSnapshot(\n    val flags: List&lt;SerializableFlag&gt;\n)\n</code></pre>"},{"location":"serialization/api/#fields","title":"Fields","text":"Field Type Description <code>flags</code> <code>List&lt;SerializableFlag&gt;</code> List of flag configurations"},{"location":"serialization/api/#serializableflag","title":"SerializableFlag","text":"<p>Serializable flag configuration.</p>"},{"location":"serialization/api/#data-class_1","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableFlag(\n    val key: String,\n    val type: ValueType,\n    val defaultValue: Any,\n    val default: SerializableRule.SerializableValue,\n    val salt: String = \"v1\",\n    val isActive: Boolean = true,\n    val rules: List&lt;SerializableRule&gt; = emptyList()\n)\n</code></pre>"},{"location":"serialization/api/#fields_1","title":"Fields","text":"Field Type Required Default Description <code>key</code> <code>String</code> Yes - Unique identifier <code>type</code> <code>ValueType</code> Yes - Value type <code>defaultValue</code> <code>Any</code> Yes - Default value (primitive) <code>default</code> <code>SerializableValue</code> Yes - Typed default wrapper <code>salt</code> <code>String</code> No <code>\"v1\"</code> Bucketing salt <code>isActive</code> <code>Boolean</code> No <code>true</code> Active flag <code>rules</code> <code>List&lt;SerializableRule&gt;</code> No <code>[]</code> Targeting rules"},{"location":"serialization/api/#serializablerule","title":"SerializableRule","text":"<p>Serializable targeting rule.</p>"},{"location":"serialization/api/#data-class_2","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableRule(\n    val value: SerializableValue,\n    val rollout: Double = 100.0,\n    val note: String? = null,\n    val locales: Set&lt;String&gt; = emptySet(),\n    val platforms: Set&lt;String&gt; = emptySet(),\n    val versionRange: SerializableVersionRange? = null\n)\n</code></pre>"},{"location":"serialization/api/#fields_2","title":"Fields","text":"Field Type Required Default Description <code>value</code> <code>SerializableValue</code> Yes - Typed value wrapper <code>rollout</code> <code>Double</code> No <code>100.0</code> Percentage 0-100 <code>note</code> <code>String?</code> No <code>null</code> Description <code>locales</code> <code>Set&lt;String&gt;</code> No <code>[]</code> Locale set (empty = all) <code>platforms</code> <code>Set&lt;String&gt;</code> No <code>[]</code> Platform set (empty = all) <code>versionRange</code> <code>SerializableVersionRange?</code> No <code>null</code> Version constraints"},{"location":"serialization/api/#nested-class-serializablevalue","title":"Nested Class: SerializableValue","text":"<pre><code>data class SerializableValue(\n    val value: Any,\n    val type: ValueType\n)\n</code></pre> <p>Wraps a value with its type for type safety.</p>"},{"location":"serialization/api/#serializableversionrange","title":"SerializableVersionRange","text":"<p>Serializable version range.</p>"},{"location":"serialization/api/#data-class_3","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableVersionRange(\n    val type: VersionRangeType,\n    val min: SerializableVersion? = null,\n    val max: SerializableVersion? = null\n)\n</code></pre>"},{"location":"serialization/api/#fields_3","title":"Fields","text":"Field Type Required Description <code>type</code> <code>VersionRangeType</code> Yes Range type <code>min</code> <code>SerializableVersion?</code> Conditional Min version (required for MIN_BOUND, MIN_AND_MAX_BOUND) <code>max</code> <code>SerializableVersion?</code> Conditional Max version (required for MAX_BOUND, MIN_AND_MAX_BOUND)"},{"location":"serialization/api/#serializableversion","title":"SerializableVersion","text":"<p>Serializable version.</p>"},{"location":"serialization/api/#data-class_4","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableVersion(\n    val major: Int,\n    val minor: Int,\n    val patch: Int\n)\n</code></pre>"},{"location":"serialization/api/#fields_4","title":"Fields","text":"Field Type Description <code>major</code> <code>Int</code> Major version <code>minor</code> <code>Int</code> Minor version <code>patch</code> <code>Int</code> Patch version"},{"location":"serialization/api/#serializablepatch","title":"SerializablePatch","text":"<p>Patch update configuration.</p>"},{"location":"serialization/api/#data-class_5","title":"Data Class","text":"<pre><code>@JsonClass(generateAdapter = true)\ndata class SerializablePatch(\n    val flags: List&lt;SerializableFlag&gt;,\n    val removeKeys: List&lt;String&gt; = emptyList()\n)\n</code></pre>"},{"location":"serialization/api/#fields_5","title":"Fields","text":"Field Type Default Description <code>flags</code> <code>List&lt;SerializableFlag&gt;</code> - Flags to add/update <code>removeKeys</code> <code>List&lt;String&gt;</code> <code>[]</code> Flag keys to remove"},{"location":"serialization/api/#enums","title":"Enums","text":""},{"location":"serialization/api/#valuetype","title":"ValueType","text":"<p>Supported value types.</p> <pre><code>enum class ValueType {\n    BOOLEAN,\n    STRING,\n    INT,\n    LONG,\n    DOUBLE\n}\n</code></pre>"},{"location":"serialization/api/#versionrangetype","title":"VersionRangeType","text":"<p>Version range types.</p> <pre><code>enum class VersionRangeType {\n    UNBOUNDED,\n    MIN_BOUND,\n    MAX_BOUND,\n    MIN_AND_MAX_BOUND\n}\n</code></pre>"},{"location":"serialization/api/#extension-functions","title":"Extension Functions","text":""},{"location":"serialization/api/#flagssnapshottojson","title":"Flags.Snapshot.toJson()","text":"<p>Convenience method to serialize directly.</p> <pre><code>fun Flags.Snapshot.toJson(\n    serializer: SnapshotSerializer = SnapshotSerializer.default\n): String\n</code></pre> <p>Example: <pre><code>val json = snapshot.toJson()\n</code></pre></p>"},{"location":"serialization/api/#snapshotjsonparserfromjson","title":"SnapshotJsonParser.fromJson()","text":"<p>Convenience method to deserialize.</p> <pre><code>object SnapshotJsonParser {\n    fun fromJson(\n        json: String,\n        serializer: SnapshotSerializer = SnapshotSerializer.default\n    ): Flags.Snapshot\n}\n</code></pre> <p>Example: <pre><code>val snapshot = SnapshotJsonParser.fromJson(json)\n</code></pre></p>"},{"location":"serialization/api/#conversion-utilities","title":"Conversion Utilities","text":""},{"location":"serialization/api/#flagssnapshottoserializable","title":"Flags.Snapshot.toSerializable()","text":"<p>Converts snapshot to serializable form.</p> <pre><code>fun Flags.Snapshot.toSerializable(): SerializableSnapshot\n</code></pre> <p>Internal use - Called by <code>SnapshotSerializer.serialize()</code></p>"},{"location":"serialization/api/#serializablesnapshottosnapshot","title":"SerializableSnapshot.toSnapshot()","text":"<p>Converts serializable form to snapshot.</p> <pre><code>fun SerializableSnapshot.toSnapshot(): Flags.Snapshot\n</code></pre> <p>Internal use - Called by <code>SnapshotSerializer.deserialize()</code></p>"},{"location":"serialization/api/#usage-examples","title":"Usage Examples","text":""},{"location":"serialization/api/#complete-example","title":"Complete Example","text":"<pre><code>import io.amichne.konditional.serialization.*\n\n// Register flags\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n// Create config\nval snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with { default(true) }\n}\n\n// Serialize\nval serializer = SnapshotSerializer.default\nval json = serializer.serialize(snapshot)\n\n// Save to file\nFile(\"flags.json\").writeText(json)\n\n// Load from file\nval loadedJson = File(\"flags.json\").readText()\n\n// Deserialize\nval loadedSnapshot = serializer.deserialize(loadedJson)\n\n// Load into runtime\nFlags.load(loadedSnapshot)\n\n// Use flags\nval context = createContext()\nwith(Flags) {\n    val darkMode = context.evaluate(FeatureFlags.DARK_MODE)\n}\n</code></pre>"},{"location":"serialization/api/#best-practices","title":"Best Practices","text":""},{"location":"serialization/api/#1-always-register-before-deserializing","title":"1. Always Register Before Deserializing","text":"<pre><code>// \u2705 Correct\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nval snapshot = serializer.deserialize(json)\n\n// \u274c Wrong\nval snapshot = serializer.deserialize(json)\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;() // Too late!\n</code></pre>"},{"location":"serialization/api/#2-use-default-serializer","title":"2. Use Default Serializer","text":"<pre><code>// \u2705 Preferred\nval serializer = SnapshotSerializer.default\n\n// \u26a0\ufe0f Only if you need custom Moshi config\nval customMoshi = Moshi.Builder()...build()\nval serializer = SnapshotSerializer(customMoshi)\n</code></pre>"},{"location":"serialization/api/#3-handle-errors","title":"3. Handle Errors","text":"<pre><code>try {\n    val snapshot = serializer.deserialize(json)\n    Flags.load(snapshot)\n} catch (e: JsonDataException) {\n    logger.error(\"Invalid JSON\", e)\n    // Load fallback\n} catch (e: IllegalArgumentException) {\n    logger.error(\"Unregistered flag\", e)\n    // Load fallback\n}\n</code></pre>"},{"location":"serialization/api/#see-also","title":"See Also","text":"<ul> <li>Integration Guide</li> <li>Step-by-Step Tutorial</li> <li>Full Runthrough</li> </ul>"},{"location":"serialization/integration/","title":"Integration Guide","text":""},{"location":"serialization/integration/#integration-overview","title":"Integration Overview","text":"<p>This guide walks you through integrating the Konditional serialization system into an existing application. We'll cover both greenfield (starting fresh) and brownfield (existing codebase) scenarios.</p> <p>::: note This guide assumes you already have Konditional set up and are using <code>Conditional</code> instances for feature flags. If not, see the Quick Start guide first. :::</p>"},{"location":"serialization/integration/#prerequisites","title":"Prerequisites","text":"<p>Before integrating serialization, ensure you have:</p> <ol> <li>Konditional library added to your project</li> <li>Feature flags defined as <code>Conditional</code> instances (typically enums)</li> <li>Moshi dependencies added to your <code>build.gradle.kts</code></li> <li>Understanding of your deployment strategy (where JSON will be stored/loaded)</li> </ol>"},{"location":"serialization/integration/#integration-patterns","title":"Integration Patterns","text":"<p>Choose the pattern that best fits your architecture:</p>"},{"location":"serialization/integration/#pattern-1-build-time-configuration","title":"Pattern 1: Build-Time Configuration","text":"<p>Best for: Small apps, monoliths, infrequent flag changes</p> <pre><code>Developer \u2192 ConfigBuilder \u2192 JSON \u2192 Git \u2192 Build \u2192 Embed in APK/JAR\n</code></pre> <ul> <li>Configuration is committed to source control</li> <li>Flags are baked into the application at build time</li> <li>Changes require a new build and deployment</li> </ul>"},{"location":"serialization/integration/#pattern-2-runtime-configuration","title":"Pattern 2: Runtime Configuration","text":"<p>Best for: Large apps, microservices, frequent flag changes</p> <pre><code>Developer \u2192 ConfigBuilder \u2192 JSON \u2192 Upload to S3/CDN \u2192 App downloads on launch\n</code></pre> <ul> <li>Configuration is external to the application</li> <li>Flags can be updated without redeploying</li> <li>Requires network access and error handling</li> </ul>"},{"location":"serialization/integration/#pattern-3-hybrid-approach","title":"Pattern 3: Hybrid Approach","text":"<p>Best for: Production apps needing flexibility</p> <pre><code>Developer \u2192 ConfigBuilder \u2192 Default JSON (embedded) + Remote JSON (downloaded)\n                                \u2193                              \u2193\n                          Fallback config              Production overrides\n</code></pre> <ul> <li>Embedded default configuration as fallback</li> <li>Remote configuration overrides defaults</li> <li>Graceful degradation if network fails</li> </ul>"},{"location":"serialization/integration/#architecture-decisions","title":"Architecture Decisions","text":""},{"location":"serialization/integration/#where-to-store-json","title":"Where to Store JSON?","text":"TabEmbedded ResourcesLocal File SystemRemote Server/CDNConfiguration Service <p>Pros: - No network dependency - Guaranteed availability - Fast loading</p> <p>Cons: - Requires rebuild to change - Larger APK/JAR size - No runtime flexibility</p> <pre><code>val json = javaClass.getResourceAsStream(\"/flags.json\")\n    .bufferedReader()\n    .use { it.readText() }\n</code></pre> <p>Pros: - Easy to update locally - No network needed - Fast loading</p> <p>Cons: - Requires file system access - Platform-specific paths - Not suitable for mobile</p> <pre><code>val json = File(\"/etc/myapp/flags.json\").readText()\n</code></pre> <p>Pros: - Update without deploying - Environment-specific configs - A/B testing support</p> <p>Cons: - Network dependency - Requires caching - Potential latency</p> <pre><code>val json = httpClient.get(\"https://cdn.example.com/flags.json\")\n</code></pre> <p>Pros: - Centralized management - Access control - Audit logs</p> <p>Cons: - Added complexity - Service dependency - Requires infrastructure</p> <pre><code>val json = configService.getFlags(environment, version)\n</code></pre>"},{"location":"serialization/integration/#when-to-load-flags","title":"When to Load Flags?","text":"<p>Consider the trade-offs of different loading strategies:</p>"},{"location":"serialization/integration/#application-startup-recommended","title":"Application Startup (Recommended)","text":"<pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Load flags before anything else\n        loadFeatureFlags()\n\n        // Rest of initialization...\n    }\n\n    private fun loadFeatureFlags() {\n        val json = loadFlagsJson() // From wherever you store them\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n        Flags.load(snapshot)\n    }\n}\n</code></pre> <p>Pros: Flags available immediately, simple error handling Cons: Increases startup time, blocks initialization</p>"},{"location":"serialization/integration/#lazy-loading","title":"Lazy Loading","text":"<pre><code>object FlagManager {\n    private var initialized = false\n\n    fun ensureLoaded() {\n        if (!initialized) {\n            loadFlags()\n            initialized = true\n        }\n    }\n}\n</code></pre> <p>Pros: Faster startup, load only when needed Cons: First access is slower, race conditions possible</p>"},{"location":"serialization/integration/#background-loading","title":"Background Loading","text":"<pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Load with defaults first\n        loadDefaultFlags()\n\n        // Update from remote in background\n        CoroutineScope(Dispatchers.IO).launch {\n            updateFlagsFromRemote()\n        }\n    }\n}\n</code></pre> <p>Pros: Fast startup, eventually consistent Cons: Complex state management, temporary inconsistency</p>"},{"location":"serialization/integration/#registering-conditionals","title":"Registering Conditionals","text":"<p>The registry maps string keys to <code>Conditional</code> instances. Register all flags before deserialization:</p>"},{"location":"serialization/integration/#for-enum-based-flags","title":"For Enum-Based Flags","text":"<pre><code>// Register an entire enum at once\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n</code></pre>"},{"location":"serialization/integration/#for-mixed-flag-types","title":"For Mixed Flag Types","text":"<pre><code>// Register multiple enums\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\nConditionalRegistry.registerEnum&lt;DebugFlags&gt;()\n\n// Or register individually\nConditionalRegistry.register(FeatureFlags.DARK_MODE)\nConditionalRegistry.register(ExperimentFlags.NEW_ONBOARDING)\n</code></pre>"},{"location":"serialization/integration/#registration-timing","title":"Registration Timing","text":"<p>::: caution Critical: Register all flags before calling <code>deserialize()</code>. Missing registrations will cause runtime errors. :::</p> <pre><code>// \u2705 Good: Register first\nfun initializeFlags() {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    val snapshot = SnapshotSerializer.default.deserialize(json)\n    Flags.load(snapshot)\n}\n\n// \u274c Bad: Deserialize before registering\nfun initializeFlags() {\n    val snapshot = SnapshotSerializer.default.deserialize(json) // Error!\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n}\n</code></pre>"},{"location":"serialization/integration/#error-handling","title":"Error Handling","text":"<p>Production applications must handle serialization errors gracefully:</p>"},{"location":"serialization/integration/#strategy-1-fallback-to-defaults","title":"Strategy 1: Fallback to Defaults","text":"<pre><code>fun loadFlags(): Flags.Snapshot {\n    return try {\n        val json = downloadRemoteConfig()\n        SnapshotSerializer.default.deserialize(json)\n    } catch (e: IOException) {\n        logger.warn(\"Failed to load remote config, using defaults\", e)\n        loadDefaultSnapshot()\n    } catch (e: JsonDataException) {\n        logger.error(\"Invalid JSON format, using defaults\", e)\n        loadDefaultSnapshot()\n    }\n}\n\nprivate fun loadDefaultSnapshot(): Flags.Snapshot {\n    val defaultJson = resources.openRawResource(R.raw.default_flags)\n        .bufferedReader()\n        .use { it.readText() }\n    return SnapshotSerializer.default.deserialize(defaultJson)\n}\n</code></pre>"},{"location":"serialization/integration/#strategy-2-partial-updates","title":"Strategy 2: Partial Updates","text":"<pre><code>fun updateFlags() {\n    try {\n        val patchJson = downloadPatch()\n        val currentSnapshot = getCurrentSnapshot()\n        val updated = SnapshotSerializer.default.applyPatchJson(\n            currentSnapshot,\n            patchJson\n        )\n        Flags.load(updated)\n        logger.info(\"Successfully applied patch update\")\n    } catch (e: Exception) {\n        logger.error(\"Patch update failed, keeping current config\", e)\n        // Don't change anything - keep working configuration\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#strategy-3-validation-before-loading","title":"Strategy 3: Validation Before Loading","text":"<pre><code>fun loadFlags(json: String): Result&lt;Flags.Snapshot&gt; {\n    return try {\n        // Deserialize\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n\n        // Validate before loading\n        validateSnapshot(snapshot)\n\n        // Load if valid\n        Flags.load(snapshot)\n        Result.success(snapshot)\n    } catch (e: Exception) {\n        logger.error(\"Flag loading failed\", e)\n        Result.failure(e)\n    }\n}\n\nprivate fun validateSnapshot(snapshot: Flags.Snapshot) {\n    require(snapshot.flags.isNotEmpty()) {\n        \"Snapshot cannot be empty\"\n    }\n\n    // Validate against schema\n    val requiredFlags = setOf(\"feature_x\", \"feature_y\")\n    val actualFlags = snapshot.flags.keys.map { it.key }.toSet()\n\n    require(requiredFlags.all { it in actualFlags }) {\n        \"Missing required flags: ${requiredFlags - actualFlags}\"\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#testing-integration","title":"Testing Integration","text":""},{"location":"serialization/integration/#unit-tests","title":"Unit Tests","text":"<p>Test serialization/deserialization in isolation:</p> <pre><code>class FlagSerializationTest {\n    @BeforeEach\n    fun setup() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        ConditionalRegistry.clear()\n    }\n\n    @Test\n    fun `serialization round-trip preserves behavior`() {\n        val original = createTestSnapshot()\n        val json = SnapshotSerializer.default.serialize(original)\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        val context = createTestContext()\n\n        with(Flags) {\n            Flags.load(original)\n            val originalValue = context.evaluate(FeatureFlags.MY_FLAG)\n\n            Flags.load(restored)\n            val restoredValue = context.evaluate(FeatureFlags.MY_FLAG)\n\n            assertEquals(originalValue, restoredValue)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#integration-tests","title":"Integration Tests","text":"<p>Test the full loading workflow:</p> <pre><code>@Test\nfun `application loads flags on startup`() {\n    // Prepare test JSON\n    val testJson = \"\"\"\n        {\n          \"flags\": [\n            {\n              \"key\": \"my_feature\",\n              \"type\": \"BOOLEAN\",\n              \"defaultValue\": true,\n              \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n              \"rules\": []\n            }\n          ]\n        }\n    \"\"\".trimIndent()\n\n    // Save to test location\n    File(testFlagsPath).writeText(testJson)\n\n    // Initialize app\n    val app = TestApplication()\n    app.onCreate()\n\n    // Verify flags are loaded\n    val context = createTestContext()\n    with(Flags) {\n        val value = context.evaluate(FeatureFlags.MY_FEATURE)\n        assertTrue(value)\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#performance-considerations","title":"Performance Considerations","text":""},{"location":"serialization/integration/#deserialization-performance","title":"Deserialization Performance","text":"<p>For large configurations (100+ flags):</p> <pre><code>// \u2705 Good: Deserialize once, reuse\nval snapshot = SnapshotSerializer.default.deserialize(json)\nFlags.load(snapshot)\n\n// \u274c Bad: Deserialize repeatedly\nrepeat(100) {\n    val snapshot = SnapshotSerializer.default.deserialize(json)\n    // This is very slow!\n}\n</code></pre>"},{"location":"serialization/integration/#memory-usage","title":"Memory Usage","text":"<p>Snapshots are immutable and can be shared:</p> <pre><code>// \u2705 Good: Share snapshot across components\nval snapshot = loadSnapshot()\ncomponentA.useSnapshot(snapshot)\ncomponentB.useSnapshot(snapshot)\n\n// \u26a0\ufe0f Consider: Snapshot size in memory\n// For apps with 1000+ flags, monitor memory usage\n</code></pre>"},{"location":"serialization/integration/#caching","title":"Caching","text":"<p>Implement caching for remote configurations:</p> <pre><code>class FlagCache(private val cacheDir: File) {\n    fun getCachedOrFetch(url: String): String {\n        val cacheFile = File(cacheDir, \"flags.json\")\n\n        // Use cached if recent\n        if (cacheFile.exists() &amp;&amp; cacheFile.isRecent()) {\n            return cacheFile.readText()\n        }\n\n        // Fetch new version\n        val json = httpClient.get(url)\n        cacheFile.writeText(json)\n        return json\n    }\n\n    private fun File.isRecent(): Boolean {\n        val age = System.currentTimeMillis() - lastModified()\n        return age &lt; TimeUnit.HOURS.toMillis(1)\n    }\n}\n</code></pre>"},{"location":"serialization/integration/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"serialization/integration/#pitfall-1-forgetting-to-register","title":"Pitfall 1: Forgetting to Register","text":"<pre><code>// \u274c This will crash at runtime\nval snapshot = SnapshotSerializer.default.deserialize(json)\n// IllegalArgumentException: Conditional with key 'my_flag' not found\n\n// \u2705 Always register first\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nval snapshot = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/integration/#pitfall-2-type-mismatches","title":"Pitfall 2: Type Mismatches","text":"<pre><code>// JSON says INT but code expects BOOLEAN\n{\n  \"key\": \"my_flag\",\n  \"type\": \"INT\",  // Wrong!\n  \"defaultValue\": 42\n}\n\n// \u2705 Ensure JSON matches your Conditional definition\nenum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    MY_FLAG(\"my_flag\")  // Expects Boolean, not Int!\n}\n</code></pre>"},{"location":"serialization/integration/#pitfall-3-missing-default-field","title":"Pitfall 3: Missing Default Field","text":"<pre><code>// \u274c Old format without 'default' field\n{\n  \"key\": \"my_flag\",\n  \"type\": \"BOOLEAN\",\n  \"defaultValue\": true\n  // Missing: \"default\": {\"value\": true, \"type\": \"BOOLEAN\"}\n}\n\n// \u2705 Always include the default wrapper\n{\n  \"key\": \"my_flag\",\n  \"type\": \"BOOLEAN\",\n  \"defaultValue\": true,\n  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"}\n}\n</code></pre>"},{"location":"serialization/integration/#next-steps","title":"Next Steps","text":"<p>Now that you understand the integration concepts, proceed to the step-by-step guide:</p> <p>Step 1: Dependencies \u2192</p> <p>Or jump straight to a complete example:</p> <p>Full Runthrough \u2192</p>"},{"location":"serialization/overview/","title":"Serialization Overview","text":""},{"location":"serialization/overview/#what-is-serialization","title":"What is Serialization?","text":"<p>The Konditional serialization system enables you to externalize your feature flag configurations as JSON files. This allows you to:</p> <ul> <li>Separate configuration from code - Update flags without recompiling</li> <li>Version control configurations - Track flag changes over time</li> <li>Environment-specific settings - Different configs for dev/staging/prod</li> <li>Remote configuration - Load flags from a server or CDN</li> <li>Dynamic updates - Apply changes without app restarts</li> </ul>"},{"location":"serialization/overview/#type-safe","title":"Type-Safe","text":"<pre><code>All values are wrapped with their type information, preventing runtime type mismatches\n</code></pre>"},{"location":"serialization/overview/#round-trip-guaranteed","title":"Round-Trip Guaranteed","text":"<pre><code>Serialized configurations behave identically to programmatic ones\n</code></pre>"},{"location":"serialization/overview/#patch-updates","title":"Patch Updates","text":"<pre><code>Apply incremental changes without replacing entire configurations\n</code></pre>"},{"location":"serialization/overview/#production-ready","title":"Production Ready","text":"<pre><code>Comprehensive test coverage with real-world examples\n</code></pre>"},{"location":"serialization/overview/#architecture","title":"Architecture","text":"<p>The serialization system consists of three main components:</p>"},{"location":"serialization/overview/#1-serializable-models-serializablepatchkt","title":"1. Serializable Models (<code>SerializablePatch.kt</code>)","text":"<p>Type-safe DTOs that represent your configuration in JSON:</p> <pre><code>@JsonClass(generateAdapter = true)\ndata class SerializableSnapshot(\n    val flags: List&lt;SerializableFlag&gt;\n)\n\n@JsonClass(generateAdapter = true)\ndata class SerializableFlag(\n    val key: String,\n    val type: ValueType,\n    val defaultValue: Any,\n    val default: SerializableRule.SerializableValue,\n    val salt: String = \"v1\",\n    val isActive: Boolean = true,\n    val rules: List&lt;SerializableRule&gt; = emptyList()\n)\n</code></pre>"},{"location":"serialization/overview/#2-conversion-utilities-conversionutilskt","title":"2. Conversion Utilities (<code>ConversionUtils.kt</code>)","text":"<p>Bidirectional conversion between runtime types and JSON:</p> <ul> <li>ConditionalRegistry - Maps flag keys to runtime instances</li> <li>Extension functions - Convert between <code>Flags.Snapshot</code> and <code>SerializableSnapshot</code></li> <li>Type casting - Safe conversion with validation</li> </ul>"},{"location":"serialization/overview/#3-serialization-api-snapshotserializerkt","title":"3. Serialization API (<code>SnapshotSerializer.kt</code>)","text":"<p>Main interface for serialization operations:</p> <pre><code>val serializer = SnapshotSerializer.default\n\n// Serialize\nval json = serializer.serialize(snapshot)\n\n// Deserialize\nval loaded = serializer.deserialize(json)\n\n// Apply patches\nval updated = serializer.applyPatch(current, patch)\n</code></pre>"},{"location":"serialization/overview/#key-concepts","title":"Key Concepts","text":""},{"location":"serialization/overview/#type-safety-with-serializablevalue","title":"Type Safety with SerializableValue","text":"<p>All values are wrapped with their type information to guarantee type safety:</p> <pre><code>{\n  \"value\": {\n    \"value\": true,\n    \"type\": \"BOOLEAN\"\n  }\n}\n</code></pre> <p>This prevents type mismatches and makes the JSON self-describing.</p>"},{"location":"serialization/overview/#the-registry-pattern","title":"The Registry Pattern","text":"<p>Before deserialization, you must register all your <code>Conditional</code> instances:</p> <pre><code>// Register an enum of flags\nConditionalRegistry.registerEnum&lt;MyFeatureFlags&gt;()\n\n// Or register individual flags\nConditionalRegistry.register(MyFlags.SOME_FLAG)\n</code></pre> <p>This allows the deserializer to map string keys back to typed <code>Conditional</code> instances.</p>"},{"location":"serialization/overview/#round-trip-equality","title":"Round-Trip Equality","text":"<p>A core guarantee of the system is that serialized configurations behave identically to the originals:</p> <pre><code>val original = createConfiguration()\nval json = serializer.serialize(original)\nval restored = serializer.deserialize(json)\n\n// These produce identical results\noriginal.evaluate(context) == restored.evaluate(context) // true\n</code></pre>"},{"location":"serialization/overview/#json-structure","title":"JSON Structure","text":""},{"location":"serialization/overview/#complete-example","title":"Complete Example","text":"<pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"enable_compact_cards\",\n      \"type\": \"BOOLEAN\",\n      \"defaultValue\": false,\n      \"default\": {\n        \"value\": false,\n        \"type\": \"BOOLEAN\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"value\": true,\n            \"type\": \"BOOLEAN\"\n          },\n          \"rollout\": 50.0,\n          \"note\": \"US iOS 50% rollout\",\n          \"locales\": [\"EN_US\"],\n          \"platforms\": [\"IOS\"],\n          \"versionRange\": {\n            \"type\": \"MIN_BOUND\",\n            \"min\": {\n              \"major\": 7,\n              \"minor\": 10,\n              \"patch\": 0\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"serialization/overview/#field-reference","title":"Field Reference","text":""},{"location":"serialization/overview/#flag-level","title":"Flag Level","text":"Field Type Required Description <code>key</code> String Yes Unique identifier matching <code>Conditional.key</code> <code>type</code> ValueType Yes Value type: BOOLEAN, STRING, INT, LONG, DOUBLE <code>defaultValue</code> Any Yes Default value when no rules match <code>default</code> SerializableValue Yes Typed wrapper for default value <code>salt</code> String No Salt for bucketing (default: \"v1\") <code>isActive</code> Boolean No Whether flag is active (default: true) <code>rules</code> Array No List of targeting rules"},{"location":"serialization/overview/#rule-level","title":"Rule Level","text":"Field Type Required Description <code>value</code> SerializableValue Yes Typed value to return if rule matches <code>rollout</code> Number No Percentage 0-100 (default: 100) <code>note</code> String No Description of the rule <code>locales</code> Array No Set of locales (empty = all) <code>platforms</code> Array No Set of platforms (empty = all) <code>versionRange</code> Object No Version constraints"},{"location":"serialization/overview/#version-range-types","title":"Version Range Types","text":"<ul> <li>UNBOUNDED - No version constraints</li> <li>MIN_BOUND - <code>version &gt;= min</code></li> <li>MAX_BOUND - <code>version &lt;= max</code></li> <li>MIN_AND_MAX_BOUND - <code>min &lt;= version &lt;= max</code></li> </ul>"},{"location":"serialization/overview/#use-cases","title":"Use Cases","text":""},{"location":"serialization/overview/#1-development-workflow","title":"1. Development Workflow","text":"<pre><code>Developer \u2192 ConfigBuilder \u2192 Snapshot \u2192 Serialize \u2192 JSON file\n                                                        \u2193\n                                                   Git commit\n</code></pre>"},{"location":"serialization/overview/#2-cicd-pipeline","title":"2. CI/CD Pipeline","text":"<pre><code>Git \u2192 Build \u2192 Validate JSON \u2192 Deploy to S3/CDN \u2192 App downloads \u2192 Deserialize\n</code></pre>"},{"location":"serialization/overview/#3-remote-configuration","title":"3. Remote Configuration","text":"<pre><code>Server API \u2192 Patch JSON \u2192 Client downloads \u2192 Apply patch \u2192 Updated flags\n</code></pre>"},{"location":"serialization/overview/#4-ab-testing","title":"4. A/B Testing","text":"<pre><code>JSON config \u2192 Multiple rules with rollout \u2192 Stable bucketing \u2192 Consistent experience\n</code></pre>"},{"location":"serialization/overview/#next-steps","title":"Next Steps","text":""},{"location":"serialization/overview/#integration-guide","title":"Integration Guide","text":"<pre><code>Learn how to integrate serialization into your existing codebase\n\n[Read the guide \u2192](/serialization/integration/)\n</code></pre>"},{"location":"serialization/overview/#step-by-step-tutorial","title":"Step-by-Step Tutorial","text":"<pre><code>Follow detailed steps to implement serialization from scratch\n\n[Start tutorial \u2192](/serialization/steps/step-01-dependencies/)\n</code></pre>"},{"location":"serialization/overview/#full-runthrough","title":"Full Runthrough","text":"<pre><code>See the complete integration in one place\n\n[View runthrough \u2192](/serialization/runthrough/)\n</code></pre> <p>::: tip The serialization system is production-ready with comprehensive test coverage. All 11 serialization tests pass, verifying round-trip equality and patch functionality. :::</p>"},{"location":"serialization/runthrough/","title":"Complete Integration Runthrough","text":""},{"location":"serialization/runthrough/#introduction","title":"Introduction","text":"<p>This page provides a complete, end-to-end integration guide for Konditional serialization. Follow these instructions from start to finish to integrate serialization into your application.</p> <p>::: tip Estimated time: 2-3 hours for full integration</p> <p>Prerequisites: - Existing Kotlin project with Gradle - Konditional library already integrated - Feature flags defined as <code>Conditional</code> instances :::</p>"},{"location":"serialization/runthrough/#part-1-project-setup","title":"Part 1: Project Setup","text":""},{"location":"serialization/runthrough/#add-dependencies","title":"Add Dependencies","text":"<p>First, add Moshi to your <code>build.gradle.kts</code>:</p> <p>```kotlin title=\"build.gradle.kts\" {14-16} repositories {     mavenCentral() }</p> <p>dependencies {     // Konditional     implementation(\"io.amichne:konditional:1.0.0\")</p> <pre><code>// Moshi for JSON serialization\nimplementation(\"com.squareup.moshi:moshi:1.15.0\")\nimplementation(\"com.squareup.moshi:moshi-kotlin:1.15.0\")\nimplementation(\"com.squareup.moshi:moshi-adapters:1.15.0\")\n\n// Testing\ntestImplementation(kotlin(\"test\"))\ntestImplementation(\"org.junit.jupiter:junit-jupiter:5.10.3\")\n</code></pre> <p>} <code>Sync your project:</code>bash ./gradlew build ```</p>"},{"location":"serialization/runthrough/#create-flag-registration-helper","title":"Create Flag Registration Helper","text":"<p>Create a centralized registration class:</p> FlagRegistration.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.serialization.ConditionalRegistry\n\nobject FlagRegistration {\n    private var registered = false\n\n    fun registerAll() {\n        if (registered) return\n\n        synchronized(this) {\n            if (registered) return\n\n            // Register all your flag enums\n            ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n            ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n            // Add more as needed\n\n            registered = true\n        }\n    }\n\n    fun clearForTesting() {\n        ConditionalRegistry.clear()\n        registered = false\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#part-2-configuration-creation","title":"Part 2: Configuration Creation","text":""},{"location":"serialization/runthrough/#define-your-flags","title":"Define Your Flags","text":"<p>Example flag enum:</p> FeatureFlags.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.context.Context\nimport io.amichne.konditional.core.Conditional\nimport io.amichne.konditional.builders.FlagBuilder\n\nenum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_ONBOARDING(\"new_onboarding\"),\n    COMPACT_CARDS(\"compact_cards\"),\n    PREMIUM_FEATURE(\"premium_feature\");\n\n    override fun with(build: FlagBuilder&lt;Boolean, Context&gt;.() -&gt; Unit) =\n        update(FlagBuilder(this).apply(build).build())\n}\n</code></pre>"},{"location":"serialization/runthrough/#create-configuration-builder","title":"Create Configuration Builder","text":"<p>Create environment-specific configurations:</p> FlagConfigurations.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.builders.ConfigBuilder\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Rollout\nimport io.amichne.konditional.core.Flags\n\nobject FlagConfigurations {\n\n    fun createDevelopmentConfig() = ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        FeatureFlags.NEW_ONBOARDING with {\n            default(true)\n        }\n\n        FeatureFlags.COMPACT_CARDS with {\n            default(true)\n        }\n\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(true)\n        }\n    }\n\n    fun createStagingConfig() = ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        FeatureFlags.NEW_ONBOARDING with {\n            default(false)\n            rule {\n                rollout = Rollout.of(50.0)\n                locales(AppLocale.EN_US)\n            }.implies(true)\n        }\n\n        FeatureFlags.COMPACT_CARDS with {\n            default(true)\n        }\n\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(false)\n            rule {\n                platforms(Platform.IOS, Platform.ANDROID)\n            }.implies(true)\n        }\n    }\n\n    fun createProductionConfig() = ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        FeatureFlags.NEW_ONBOARDING with {\n            default(false)\n            rule {\n                rollout = Rollout.of(10.0)\n                locales(AppLocale.EN_US)\n                note = \"JIRA-456: Gradual rollout for US users\"\n            }.implies(true)\n        }\n\n        FeatureFlags.COMPACT_CARDS with {\n            default(false)\n            rule {\n                platforms(Platform.IOS, Platform.ANDROID)\n                versions {\n                    min(2, 0, 0)\n                }\n            }.implies(true)\n        }\n\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(false)\n            rule {\n                platforms(Platform.IOS)\n                versions {\n                    min(2, 1, 0)\n                }\n            }.implies(true)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#generate-json-files","title":"Generate JSON Files","text":"<p>Create a configuration generator:</p> ConfigGenerator.kt<pre><code>package com.yourapp.tools\n\nimport com.yourapp.flags.FlagConfigurations\nimport com.yourapp.flags.FlagRegistration\nimport io.amichne.konditional.serialization.SnapshotSerializer\nimport java.io.File\n\nfun main() {\n    println(\"Generating feature flag configurations...\")\n\n    // Register flags\n    FlagRegistration.registerAll()\n\n    val serializer = SnapshotSerializer.default\n\n    // Create config directory\n    val configDir = File(\"config\")\n    configDir.mkdirs()\n\n    // Generate development config\n    val devSnapshot = FlagConfigurations.createDevelopmentConfig()\n    val devJson = serializer.serialize(devSnapshot)\n    File(configDir, \"development-flags.json\").writeText(devJson)\n    println(\"\u2713 Generated development configuration\")\n\n    // Generate staging config\n    val stagingSnapshot = FlagConfigurations.createStagingConfig()\n    val stagingJson = serializer.serialize(stagingSnapshot)\n    File(configDir, \"staging-flags.json\").writeText(stagingJson)\n    println(\"\u2713 Generated staging configuration\")\n\n    // Generate production config\n    val productionSnapshot = FlagConfigurations.createProductionConfig()\n    val productionJson = serializer.serialize(productionSnapshot)\n    File(configDir, \"production-flags.json\").writeText(productionJson)\n    println(\"\u2713 Generated production configuration\")\n\n    println(\"\\nAll configurations generated successfully!\")\n}\n</code></pre> <p>Add a Gradle task:</p> build.gradle.kts<pre><code>tasks.register&lt;JavaExec&gt;(\"generateFlagConfigs\") {\n    group = \"flags\"\n    description = \"Generate feature flag configuration files\"\n    mainClass.set(\"com.yourapp.tools.ConfigGeneratorKt\")\n    classpath = sourceSets[\"main\"].runtimeClasspath\n}\n</code></pre> <p>Run it:</p> <pre><code>./gradlew generateFlagConfigs\n</code></pre>"},{"location":"serialization/runthrough/#part-3-application-integration","title":"Part 3: Application Integration","text":""},{"location":"serialization/runthrough/#create-flag-loader","title":"Create Flag Loader","text":"<p>Build a robust flag loader with fallback:</p> FlagLoader.kt<pre><code>package com.yourapp.flags\n\nimport android.content.Context\nimport io.amichne.konditional.core.Flags\nimport io.amichne.konditional.serialization.SnapshotSerializer\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport java.io.File\nimport java.net.URL\n\nclass FlagLoader(\n    private val context: Context,\n    private val environment: String\n) {\n    private val serializer = SnapshotSerializer.default\n\n    suspend fun initialize() {\n        // Register flags first\n        FlagRegistration.registerAll()\n\n        // Load embedded flags immediately (fast)\n        loadEmbeddedFlags()\n\n        // Update from remote in background (slow)\n        updateFromRemote()\n    }\n\n    private fun loadEmbeddedFlags() {\n        try {\n            val json = context.assets.open(\"flags.json\")\n                .bufferedReader()\n                .use { it.readText() }\n\n            val snapshot = serializer.deserialize(json)\n            Flags.load(snapshot)\n\n            logger.info(\"Loaded embedded flags\")\n        } catch (e: Exception) {\n            logger.error(\"Failed to load embedded flags\", e)\n            loadHardcodedDefaults()\n        }\n    }\n\n    private suspend fun updateFromRemote() = withContext(Dispatchers.IO) {\n        try {\n            val url = \"https://cdn.yourcompany.com/flags-$environment.json\"\n            val json = URL(url).readText()\n\n            // Cache for offline use\n            cacheJson(json)\n\n            val snapshot = serializer.deserialize(json)\n            Flags.load(snapshot)\n\n            logger.info(\"Updated from remote configuration\")\n        } catch (e: Exception) {\n            logger.warn(\"Remote update failed, using embedded config\", e)\n            // App continues with embedded config\n        }\n    }\n\n    private fun cacheJson(json: String) {\n        File(context.cacheDir, \"flags.json\").writeText(json)\n    }\n\n    private fun loadHardcodedDefaults() {\n        // Last resort: safe defaults\n        val defaultSnapshot = FlagConfigurations.createProductionConfig()\n        Flags.load(defaultSnapshot)\n        logger.warn(\"Loaded hardcoded defaults\")\n    }\n\n    companion object {\n        private val logger = LoggerFactory.getLogger(FlagLoader::class.java)\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#integrate-with-application","title":"Integrate with Application","text":"MyApplication.kt<pre><code>package com.yourapp\n\nimport android.app.Application\nimport com.yourapp.flags.FlagLoader\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\n\nclass MyApplication : Application() {\n    private val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n\n    override fun onCreate() {\n        super.onCreate()\n\n        // Load flags\n        applicationScope.launch {\n            val loader = FlagLoader(\n                context = this@MyApplication,\n                environment = BuildConfig.ENVIRONMENT\n            )\n            loader.initialize()\n        }\n\n        // Continue with other initialization...\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#use-flags-in-ui","title":"Use Flags in UI","text":"MainActivity.kt<pre><code>package com.yourapp\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.yourapp.flags.FeatureFlags\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Context\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Version\nimport io.amichne.konditional.core.Flags\nimport io.amichne.konditional.core.StableId\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Create user context\n        val userContext = createUserContext()\n\n        // Evaluate flags\n        with(Flags) {\n            val darkMode = userContext.evaluate(FeatureFlags.DARK_MODE)\n            val newOnboarding = userContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n            val compactCards = userContext.evaluate(FeatureFlags.COMPACT_CARDS)\n\n            // Apply flags\n            if (darkMode) {\n                setTheme(R.style.DarkTheme)\n            }\n\n            if (compactCards) {\n                setContentView(R.layout.activity_main_compact)\n            } else {\n                setContentView(R.layout.activity_main)\n            }\n\n            if (newOnboarding &amp;&amp; isFirstLaunch()) {\n                showOnboarding()\n            }\n        }\n    }\n\n    private fun createUserContext(): Context {\n        return Context(\n            locale = getCurrentLocale(),\n            platform = Platform.ANDROID,\n            appVersion = Version.of(\n                BuildConfig.VERSION_MAJOR,\n                BuildConfig.VERSION_MINOR,\n                BuildConfig.VERSION_PATCH\n            ),\n            stableId = StableId.of(getUserId())\n        )\n    }\n\n    private fun getCurrentLocale(): AppLocale {\n        return when (resources.configuration.locales[0].language) {\n            \"en\" -&gt; AppLocale.EN_US\n            \"es\" -&gt; AppLocale.ES_US\n            else -&gt; AppLocale.EN_US\n        }\n    }\n\n    private fun getUserId(): String {\n        // Get stable user ID from your auth system\n        return authManager.getUserId()\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#part-4-testing","title":"Part 4: Testing","text":""},{"location":"serialization/runthrough/#unit-tests","title":"Unit Tests","text":"FlagSerializationTest.kt<pre><code>package com.yourapp.flags\n\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Context\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Version\nimport io.amichne.konditional.core.Flags\nimport io.amichne.konditional.core.StableId\nimport io.amichne.konditional.serialization.ConditionalRegistry\nimport io.amichne.konditional.serialization.SnapshotSerializer\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.assertNotNull\n\nclass FlagSerializationTest {\n    private val serializer = SnapshotSerializer.default\n\n    @BeforeEach\n    fun setUp() {\n        FlagRegistration.registerAll()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        FlagRegistration.clearForTesting()\n    }\n\n    @Test\n    fun `round-trip serialization preserves behavior`() {\n        val original = FlagConfigurations.createProductionConfig()\n        val json = serializer.serialize(original)\n        val restored = serializer.deserialize(json)\n\n        assertNotNull(json)\n\n        val context = createTestContext()\n\n        with(Flags) {\n            Flags.load(original)\n            val originalValues = context.evaluate()\n\n            Flags.load(restored)\n            val restoredValues = context.evaluate()\n\n            assertEquals(originalValues.size, restoredValues.size)\n            originalValues.forEach { (key, value) -&gt;\n                assertEquals(value, restoredValues[key])\n            }\n        }\n    }\n\n    @Test\n    fun `all environments are valid`() {\n        val configs = mapOf(\n            \"development\" to FlagConfigurations.createDevelopmentConfig(),\n            \"staging\" to FlagConfigurations.createStagingConfig(),\n            \"production\" to FlagConfigurations.createProductionConfig()\n        )\n\n        configs.forEach { (env, snapshot) -&gt;\n            val json = serializer.serialize(snapshot)\n            val restored = serializer.deserialize(json)\n\n            assertNotNull(restored, \"$env config should be valid\")\n        }\n    }\n\n    private fun createTestContext() = Context(\n        AppLocale.EN_US,\n        Platform.ANDROID,\n        Version.of(2, 0, 0),\n        StableId.of(\"test-user-12345678\")\n    )\n}\n</code></pre>"},{"location":"serialization/runthrough/#integration-tests","title":"Integration Tests","text":"FlagLoadingIntegrationTest.kt<pre><code>package com.yourapp.flags\n\nimport android.content.Context\nimport androidx.test.core.app.ApplicationProvider\nimport androidx.test.ext.junit.runners.AndroidJUnit4\nimport com.yourapp.flags.FeatureFlags\nimport io.amichne.konditional.core.Flags\nimport kotlinx.coroutines.runBlocking\nimport org.junit.Before\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport kotlin.test.assertTrue\n\n@RunWith(AndroidJUnit4::class)\nclass FlagLoadingIntegrationTest {\n\n    private lateinit var context: Context\n\n    @Before\n    fun setup() {\n        context = ApplicationProvider.getApplicationContext()\n    }\n\n    @Test\n    fun flagsLoadSuccessfully() = runBlocking {\n        val loader = FlagLoader(context, \"production\")\n        loader.initialize()\n\n        // Verify flags are accessible\n        val testContext = createTestContext()\n        with(Flags) {\n            val darkMode = testContext.evaluate(FeatureFlags.DARK_MODE)\n            assertNotNull(darkMode)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#part-5-cicd-setup","title":"Part 5: CI/CD Setup","text":""},{"location":"serialization/runthrough/#github-actions-workflow","title":"GitHub Actions Workflow","text":".github/workflows/deploy-flags.yml<pre><code>name: Deploy Feature Flags\n\non:\n  push:\n    paths:\n      - 'config/*.json'\n    branches:\n      - main\n\njobs:\n  validate-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      - name: Validate configurations\n        run: ./gradlew test --tests '*FlagSerializationTest*'\n\n      - name: Deploy to S3\n        run: |\n          aws s3 cp config/production-flags.json \\\n            s3://${{ secrets.S3_BUCKET }}/flags-production.json \\\n            --cache-control \"max-age=300\"\n\n      - name: Invalidate CloudFront\n        run: |\n          aws cloudfront create-invalidation \\\n            --distribution-id ${{ secrets.CLOUDFRONT_DIST_ID }} \\\n            --paths \"/flags-production.json\"\n</code></pre>"},{"location":"serialization/runthrough/#part-6-monitoring","title":"Part 6: Monitoring","text":""},{"location":"serialization/runthrough/#add-logging","title":"Add Logging","text":"FlagLogger.kt<pre><code>package com.yourapp.flags\n\nimport org.slf4j.LoggerFactory\n\nobject FlagLogger {\n    private val logger = LoggerFactory.getLogger(\"FeatureFlags\")\n\n    fun logLoad(numFlags: Int, source: String) {\n        logger.info(\"Loaded $numFlags flags from $source\")\n    }\n\n    fun logEvaluation(flag: String, value: Any, userId: String) {\n        logger.debug(\"Flag $flag evaluated to $value for user ${userId.take(8)}\")\n    }\n\n    fun logError(operation: String, error: Exception) {\n        logger.error(\"Flag operation failed: $operation\", error)\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#add-metrics","title":"Add Metrics","text":"FlagMetrics.kt<pre><code>package com.yourapp.flags\n\nclass FlagMetrics(private val metricsClient: MetricsClient) {\n\n    fun recordLoad(success: Boolean, source: String) {\n        metricsClient.increment(\"flags.load\", mapOf(\n            \"success\" to success.toString(),\n            \"source\" to source\n        ))\n    }\n\n    fun recordEvaluation(flag: String, value: String) {\n        metricsClient.increment(\"flags.evaluation\", mapOf(\n            \"flag\" to flag,\n            \"value\" to value\n        ))\n    }\n}\n</code></pre>"},{"location":"serialization/runthrough/#conclusion","title":"Conclusion","text":"<p>You now have a complete, production-ready serialization integration! Your application can:</p> <p>\u2705 Load feature flags from JSON \u2705 Support multiple environments \u2705 Handle errors gracefully with fallbacks \u2705 Dynamically update flags from remote sources \u2705 Monitor flag usage \u2705 Test configurations thoroughly</p>"},{"location":"serialization/runthrough/#next-steps","title":"Next Steps","text":"<ul> <li>Explore advanced features: Patch Updates</li> <li>API reference: Complete API Documentation</li> <li>Migration guide: Migrating Existing Systems</li> </ul> <p>::: tip For questions or issues, check the GitHub repository or file an issue. :::</p>"},{"location":"serialization/steps/step-01-dependencies/","title":"Step 1: Add Dependencies","text":""},{"location":"serialization/steps/step-01-dependencies/#overview","title":"Overview","text":"<p>The first step in integrating Konditional serialization is adding the Moshi JSON library to your project. Moshi provides the serialization infrastructure that Konditional uses.</p> <p>::: tip Time estimate: 5 minutes</p> <p>Prerequisites: Gradle-based Kotlin project with Konditional already added :::</p>"},{"location":"serialization/steps/step-01-dependencies/#add-moshi-to-buildgradlekts","title":"Add Moshi to build.gradle.kts","text":"<p>Open your <code>build.gradle.kts</code> file and add the Moshi dependencies:</p> <p>```kotlin title=\"build.gradle.kts\" ins={2-4} dependencies {     // Moshi for JSON serialization     implementation(\"com.squareup.moshi:moshi:1.15.0\")     implementation(\"com.squareup.moshi:moshi-kotlin:1.15.0\")     implementation(\"com.squareup.moshi:moshi-adapters:1.15.0\")</p> <pre><code>// Your existing dependencies\nimplementation(\"io.amichne:konditional:1.0.0\")\n// ...\n</code></pre> <p>} ``` </p>"},{"location":"serialization/steps/step-01-dependencies/#why-these-dependencies","title":"Why These Dependencies?","text":"Dependency Purpose <code>moshi</code> Core JSON parsing and serialization <code>moshi-kotlin</code> Kotlin-specific adapters (data classes, default values) <code>moshi-adapters</code> Standard adapters for common types ::: note The Konditional serialization package already includes adapters for all Konditional types. You don't need to write custom adapters. ::: ## Sync Your Project After adding the dependencies, sync your Gradle project: ```bash ./gradlew build ```"},{"location":"serialization/steps/step-01-dependencies/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test to verify Moshi is working:</p> src/test/kotlin/VerifyMoshiTest.kt<pre><code>import com.squareup.moshi.Moshi\nimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass VerifyMoshiTest {\n    @Test\n    fun `moshi can serialize simple objects`() {\n        val moshi = Moshi.Builder()\n            .add(KotlinJsonAdapterFactory())\n            .build()\n\n        data class Person(val name: String, val age: Int)\n\n        val adapter = moshi.adapter(Person::class.java)\n        val person = Person(\"Alice\", 30)\n\n        val json = adapter.toJson(person)\n        val restored = adapter.fromJson(json)\n\n        assertEquals(person, restored)\n    }\n}\n</code></pre> <p>Run the test:</p> <pre><code>./gradlew test --tests VerifyMoshiTest\n</code></pre> <p>If the test passes, Moshi is correctly installed!</p>"},{"location":"serialization/steps/step-01-dependencies/#project-structure","title":"Project Structure","text":"<p>Your project should now look like this:</p> <pre><code>- build.gradle.kts\n- src/\n  - main/kotlin/\n    - your/package/\n      - FeatureFlags.kt (your existing flags)\n  - test/kotlin/\n    - VerifyMoshiTest.kt\n</code></pre>"},{"location":"serialization/steps/step-01-dependencies/#whats-next","title":"What's Next?","text":"<p>Now that Moshi is installed, you need to register your feature flags so they can be deserialized.</p> Next: Step 2 - Register Flags \u2192"},{"location":"serialization/steps/step-01-dependencies/#troubleshooting","title":"Troubleshooting","text":""},{"location":"serialization/steps/step-01-dependencies/#build-fails-with-could-not-resolve-dependency","title":"Build Fails with \"Could not resolve dependency\"","text":"<p>Problem: Gradle can't download Moshi</p> <p>Solution: Check your repository configuration:</p> build.gradle.kts<pre><code>repositories {\n    mavenCentral() // Moshi is on Maven Central\n}\n</code></pre>"},{"location":"serialization/steps/step-01-dependencies/#unresolved-reference-moshi","title":"\"Unresolved reference: Moshi\"","text":"<p>Problem: IDE hasn't picked up the new dependency</p> <p>Solution: 1. Click \"Sync Project with Gradle Files\" in your IDE 2. Or run <code>./gradlew --refresh-dependencies</code></p>"},{"location":"serialization/steps/step-01-dependencies/#version-conflicts","title":"Version Conflicts","text":"<p>Problem: Multiple versions of Moshi in the dependency tree</p> <p>Solution: Force a specific version:</p> build.gradle.kts<pre><code>configurations.all {\n    resolutionStrategy {\n        force(\"com.squareup.moshi:moshi:1.15.0\")\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/","title":"Step 2: Register Your Flags","text":""},{"location":"serialization/steps/step-02-register/#overview","title":"Overview","text":"<p>Before deserializing JSON, you must register all your <code>Conditional</code> instances with the <code>ConditionalRegistry</code>. This mapping allows the deserializer to convert string keys back into typed <code>Conditional</code> references.</p> <p>::: tip Time estimate: 10 minutes</p> <p>Why? The registry solves the problem of mapping string keys in JSON to strongly-typed Kotlin objects. :::</p>"},{"location":"serialization/steps/step-02-register/#understanding-the-registry","title":"Understanding the Registry","text":"<p>When you serialize a flag, it becomes a string key in JSON:</p> <pre><code>// In Kotlin\nenum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// In JSON\n{\n  \"key\": \"dark_mode\",  // Just a string!\n  ...\n}\n</code></pre> <p>When deserializing, we need to map <code>\"dark_mode\"</code> back to <code>FeatureFlags.DARK_MODE</code>. The registry handles this mapping.</p>"},{"location":"serialization/steps/step-02-register/#registration-methods","title":"Registration Methods","text":""},{"location":"serialization/steps/step-02-register/#method-1-register-an-entire-enum-recommended","title":"Method 1: Register an Entire Enum (Recommended)","text":"<p>If your flags are defined as an enum (the typical pattern), register the whole enum at once:</p> <pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\n\n// Register all flags in the enum\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n</code></pre> <p>This registers every enum constant automatically.</p>"},{"location":"serialization/steps/step-02-register/#method-2-register-individual-flags","title":"Method 2: Register Individual Flags","text":"<p>For non-enum flags or selective registration:</p> <pre><code>// Register specific flags\nConditionalRegistry.register(FeatureFlags.DARK_MODE)\nConditionalRegistry.register(FeatureFlags.NEW_ONBOARDING)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#method-3-register-multiple-enums","title":"Method 3: Register Multiple Enums","text":"<p>For projects with multiple flag enums:</p> <pre><code>// Register all your flag enums\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\nConditionalRegistry.registerEnum&lt;DebugFlags&gt;()\n</code></pre>"},{"location":"serialization/steps/step-02-register/#when-to-register","title":"When to Register","text":"<p>::: caution Critical: Register flags before calling <code>deserialize()</code>. Registration after deserialization will fail. :::</p>"},{"location":"serialization/steps/step-02-register/#application-startup-recommended","title":"Application Startup (Recommended)","text":"<p>Register flags as early as possible in your application lifecycle:</p> TabAndroidSpring BootKtorMain Function MyApplication.kt<pre><code>import android.app.Application\nimport io.amichne.konditional.serialization.ConditionalRegistry\n\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Register flags first thing\n        registerFeatureFlags()\n\n        // Then load configuration\n        loadFlagConfiguration()\n\n        // Rest of initialization...\n    }\n\n    private fun registerFeatureFlags() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n    }\n}\n</code></pre> FlagConfiguration.kt<pre><code>import org.springframework.context.annotation.Configuration\nimport javax.annotation.PostConstruct\n\n@Configuration\nclass FlagConfiguration {\n\n    @PostConstruct\n    fun registerFlags() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n    }\n}\n</code></pre> Application.kt<pre><code>import io.ktor.server.application.*\n\nfun Application.module() {\n    // Register flags before anything else\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    // Configure routes, etc.\n    configureRouting()\n}\n</code></pre> Main.kt<pre><code>fun main() {\n    // Register before doing anything with flags\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    // Load configuration\n    val config = loadConfiguration()\n\n    // Start application\n    runApplication(config)\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#create-a-registration-helper","title":"Create a Registration Helper","text":"<p>For larger projects, create a dedicated registration class:</p> FlagRegistration.kt<pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\n\n/**\n * Centralized registration of all feature flags.\n * Call [registerAll] once during application startup.\n */\nobject FlagRegistration {\n\n    private var registered = false\n\n    /**\n     * Registers all feature flags with the ConditionalRegistry.\n     * Safe to call multiple times - will only register once.\n     */\n    fun registerAll() {\n        if (registered) {\n            return\n        }\n\n        // Register all flag enums\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n        ConditionalRegistry.registerEnum&lt;DebugFlags&gt;()\n\n        registered = true\n    }\n\n    /**\n     * Clears all registrations. Only for testing!\n     */\n    fun clearForTesting() {\n        if (isTestEnvironment()) {\n            ConditionalRegistry.clear()\n            registered = false\n        }\n    }\n\n    private fun isTestEnvironment(): Boolean {\n        return try {\n            Class.forName(\"org.junit.jupiter.api.Test\")\n            true\n        } catch (e: ClassNotFoundException) {\n            false\n        }\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        FlagRegistration.registerAll()\n        // ...\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#testing-with-the-registry","title":"Testing with the Registry","text":"<p>In tests, you need to register and clean up properly:</p> FlagSerializationTest.kt<pre><code>import org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\n\nclass FlagSerializationTest {\n\n    @BeforeEach\n    fun setUp() {\n        // Register flags before each test\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        // Clean up after each test to avoid pollution\n        ConditionalRegistry.clear()\n    }\n\n    @Test\n    fun `test flag serialization`() {\n        // Test code here - flags are registered\n        val snapshot = createTestSnapshot()\n        val json = SnapshotSerializer.default.serialize(snapshot)\n\n        // This will work because flags are registered\n        val deserialized = SnapshotSerializer.default.deserialize(json)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#verification","title":"Verification","text":"<p>Verify your registration is working:</p> <pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\n\nfun verifyRegistration() {\n    // Register\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    // Check if specific keys are registered\n    val isDarkModeRegistered = ConditionalRegistry.contains(\"dark_mode\")\n    val isNewOnboardingRegistered = ConditionalRegistry.contains(\"new_onboarding\")\n\n    println(\"Dark mode registered: $isDarkModeRegistered\")\n    println(\"New onboarding registered: $isNewOnboardingRegistered\")\n\n    // You can also retrieve a flag\n    val darkMode: Conditional&lt;Boolean, Context&gt; = ConditionalRegistry.get(\"dark_mode\")\n    println(\"Retrieved flag: ${darkMode.key}\")\n}\n</code></pre>"},{"location":"serialization/steps/step-02-register/#common-mistakes","title":"Common Mistakes","text":""},{"location":"serialization/steps/step-02-register/#deserializing-before-registering","title":"\u274c Deserializing Before Registering","text":"<pre><code>// This will crash!\nval snapshot = SnapshotSerializer.default.deserialize(json)\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n// IllegalArgumentException: Conditional with key 'dark_mode' not found\n</code></pre>"},{"location":"serialization/steps/step-02-register/#correct-order","title":"\u2705 Correct Order","text":"<pre><code>// Register first\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n// Then deserialize\nval snapshot = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#forgetting-some-flags","title":"\u274c Forgetting Some Flags","text":"<pre><code>// Only registered FeatureFlags\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n// JSON contains ExperimentFlags - will crash!\nval json = \"\"\"{\"flags\": [{\"key\": \"experiment_new_ui\", ...}]}\"\"\"\nval snapshot = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#register-all-used-flags","title":"\u2705 Register All Used Flags","text":"<pre><code>// Register all flag types you use\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\nConditionalRegistry.registerEnum&lt;ExperimentFlags&gt;()\n\n// Now both types can be deserialized\nval snapshot = SnapshotSerializer.default.deserialize(json)\n</code></pre>"},{"location":"serialization/steps/step-02-register/#whats-next","title":"What's Next?","text":"<p>With flags registered, you can now create your first serializable configuration.</p> \u2190 Previous: Step 1 - Dependencies Next: Step 3 - Create Configuration \u2192"},{"location":"serialization/steps/step-03-configuration/","title":"Step 3: Create Configuration","text":""},{"location":"serialization/steps/step-03-configuration/#overview","title":"Overview","text":"<p>In this step, you'll create a flag configuration using <code>ConfigBuilder</code>. This configuration will define your feature flags with their default values and targeting rules.</p> <p>::: tip Time estimate: 15-20 minutes</p> <p>Goal: Create a <code>Flags.Snapshot</code> that can be serialized to JSON :::</p>"},{"location":"serialization/steps/step-03-configuration/#your-first-configuration","title":"Your First Configuration","text":"<p>Let's assume you have these feature flags defined:</p> FeatureFlags.kt<pre><code>enum class FeatureFlags(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_ONBOARDING(\"new_onboarding\"),\n    COMPACT_CARDS(\"compact_cards\"),\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#simple-configuration","title":"Simple Configuration","text":"<p>Start with a basic configuration using default values only:</p> <pre><code>import io.amichne.konditional.builders.ConfigBuilder\n\nval snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(false)\n    }\n\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n    }\n\n    FeatureFlags.COMPACT_CARDS with {\n        default(true)\n    }\n}\n</code></pre> <p>This creates a snapshot where: - <code>DARK_MODE</code> defaults to <code>false</code> - <code>NEW_ONBOARDING</code> defaults to <code>false</code> - <code>COMPACT_CARDS</code> defaults to <code>true</code></p> <p>No targeting rules yet - all users see the same values.</p>"},{"location":"serialization/steps/step-03-configuration/#adding-targeting-rules","title":"Adding Targeting Rules","text":"<p>Now let's add rules to target specific users:</p>"},{"location":"serialization/steps/step-03-configuration/#example-1-platform-based-targeting","title":"Example 1: Platform-Based Targeting","text":"<p>Enable dark mode only on iOS:</p> <pre><code>import io.amichne.konditional.context.Platform\n\nval snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#example-2-locale-based-targeting","title":"Example 2: Locale-Based Targeting","text":"<p>Enable new onboarding for US users:</p> <pre><code>import io.amichne.konditional.context.AppLocale\n\nval snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n\n        rule {\n            locales(AppLocale.EN_US, AppLocale.ES_US)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#example-3-gradual-rollout","title":"Example 3: Gradual Rollout","text":"<p>Roll out to 25% of users using rollout:</p> <pre><code>import io.amichne.konditional.context.Rollout\n\nval snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.COMPACT_CARDS with {\n        default(false)\n\n        rule {\n            rollout = Rollout.of(25.0) // 25% of users\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#example-4-version-based-targeting","title":"Example 4: Version-Based Targeting","text":"<p>Enable for users on version 2.0.0 or higher:</p> <pre><code>val snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(false)\n\n        rule {\n            versions {\n                min(2, 0, 0)\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#combining-criteria","title":"Combining Criteria","text":"<p>Rules can combine multiple targeting criteria:</p> <pre><code>val snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n\n        // Rule 1: 50% rollout for US iOS users on v2.0+\n        rule {\n            rollout = Rollout.of(50.0)\n            locales(AppLocale.EN_US)\n            platforms(Platform.IOS)\n            versions {\n                min(2, 0, 0)\n            }\n        }.implies(true)\n\n        // Rule 2: 100% for all Android users on v2.1+\n        rule {\n            platforms(Platform.ANDROID)\n            versions {\n                min(2, 1, 0)\n            }\n        }.implies(true)\n    }\n}\n</code></pre> <p>::: note Rules are evaluated in order of specificity (most specific first). More specific rules override less specific ones. :::</p>"},{"location":"serialization/steps/step-03-configuration/#real-world-configuration","title":"Real-World Configuration","text":"<p>Here's a complete example for a production app:</p> createProductionConfig.kt<pre><code>import io.amichne.konditional.builders.ConfigBuilder\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Rollout\n\nfun createProductionConfig(): Flags.Snapshot {\n    return ConfigBuilder.buildSnapshot {\n        // Dark Mode: Enabled for everyone\n        FeatureFlags.DARK_MODE with {\n            default(true)\n        }\n\n        // New Onboarding: Gradual rollout\n        FeatureFlags.NEW_ONBOARDING with {\n            default(false)\n\n            // 10% rollout for US users\n            rule {\n                rollout = Rollout.of(10.0)\n                locales(AppLocale.EN_US)\n            }.implies(true)\n\n            // 5% rollout for other English locales\n            rule {\n                rollout = Rollout.of(5.0)\n                locales(AppLocale.EN_CA)\n            }.implies(true)\n        }\n\n        // Compact Cards: Platform-specific\n        FeatureFlags.COMPACT_CARDS with {\n            default(false)\n\n            // Enable for all mobile platforms\n            rule {\n                platforms(Platform.IOS, Platform.ANDROID)\n            }.implies(true)\n\n            // But disable for old versions\n            rule {\n                versions {\n                    max(1, 9, 9)\n                }\n            }.implies(false)\n        }\n\n        // Premium Feature: Version and platform gated\n        FeatureFlags.PREMIUM_FEATURE with {\n            default(false)\n\n            rule {\n                platforms(Platform.IOS)\n                versions {\n                    min(2, 0, 0)\n                }\n            }.implies(true)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>Create different configs for different environments:</p> TabDevelopmentStagingProduction <pre><code>  title=\"developmentConfig.kt\"\nfun createDevelopmentConfig() = ConfigBuilder.buildSnapshot {\n    // Everything enabled for development\n    FeatureFlags.DARK_MODE with { default(true) }\n    FeatureFlags.NEW_ONBOARDING with { default(true) }\n    FeatureFlags.COMPACT_CARDS with { default(true) }\n    FeatureFlags.DEBUG_MENU with { default(true) }\n}\n</code></pre> stagingConfig.kt<pre><code>fun createStagingConfig() = ConfigBuilder.buildSnapshot {\n    // Production-like with some overrides\n    FeatureFlags.DARK_MODE with { default(true) }\n\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n        rule {\n            rollout = Rollout.of(50.0) // Higher rollout for testing\n        }.implies(true)\n    }\n\n    FeatureFlags.COMPACT_CARDS with { default(true) }\n    FeatureFlags.DEBUG_MENU with { default(true) } // Debug tools available\n}\n</code></pre> productionConfig.kt<pre><code>fun createProductionConfig() = ConfigBuilder.buildSnapshot {\n    // Conservative rollouts\n    FeatureFlags.DARK_MODE with { default(true) }\n\n    FeatureFlags.NEW_ONBOARDING with {\n        default(false)\n        rule {\n            rollout = Rollout.of(10.0) // Careful rollout\n            locales(AppLocale.EN_US)\n        }.implies(true)\n    }\n\n    FeatureFlags.COMPACT_CARDS with { default(false) }\n    FeatureFlags.DEBUG_MENU with { default(false) } // Disabled\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"serialization/steps/step-03-configuration/#1-document-your-rules","title":"1. Document Your Rules","text":"<p>Use the <code>note</code> field to explain why a rule exists:</p> <pre><code>rule {\n    rollout = Rollout.of(50.0)\n    locales(AppLocale.EN_US)\n    platforms(Platform.IOS)\n    note = \"JIRA-123: Gradual rollout for US iOS users to test performance\"\n}.implies(true)\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#2-use-salt-for-experiment-rebucketing","title":"2. Use Salt for Experiment Rebucketing","text":"<p>Change the salt when you want to rebucket users:</p> <pre><code>FeatureFlags.NEW_EXPERIMENT with {\n    default(false)\n    salt = \"v2\" // Changed from \"v1\" to rebucket users\n\n    rule {\n        rollout = Rollout.of(50.0)\n    }.implies(true)\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#3-keep-defaults-conservative","title":"3. Keep Defaults Conservative","text":"<p>Default to <code>false</code> for new features:</p> <pre><code>FeatureFlags.RISKY_NEW_FEATURE with {\n    default(false) // Safe default\n    // Add rules to selectively enable\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#4-test-your-configuration","title":"4. Test Your Configuration","text":"<p>Before serializing, test that it behaves as expected:</p> <pre><code>fun testConfiguration() {\n    val snapshot = createProductionConfig()\n    Flags.load(snapshot)\n\n    // Test various contexts\n    val usIosContext = Context(\n        AppLocale.EN_US,\n        Platform.IOS,\n        Version.of(2, 0, 0),\n        StableId.of(\"test-user-1\")\n    )\n\n    with(Flags) {\n        val darkMode = usIosContext.evaluate(FeatureFlags.DARK_MODE)\n        val onboarding = usIosContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n\n        println(\"Dark mode: $darkMode\")\n        println(\"New onboarding: $onboarding\")\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-03-configuration/#whats-next","title":"What's Next?","text":"<p>Now that you have a configuration, you'll serialize it to JSON in the next step.</p> \u2190 Previous: Step 2 - Register Flags Next: Step 4 - Serialize \u2192"},{"location":"serialization/steps/step-04-serialize/","title":"Step 4: Serialize to JSON","text":""},{"location":"serialization/steps/step-04-serialize/#overview","title":"Overview","text":"<p>With a <code>Flags.Snapshot</code> created, you can now serialize it to JSON. This JSON can be committed to version control, deployed to a CDN, or stored in a configuration service.</p> <p>::: tip Time estimate: 10 minutes</p> <p>Output: A JSON file containing your complete flag configuration :::</p>"},{"location":"serialization/steps/step-04-serialize/#basic-serialization","title":"Basic Serialization","text":"<p>The <code>SnapshotSerializer</code> provides a simple API for serialization:</p> <pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\n\n// Create your configuration\nval snapshot = ConfigBuilder.buildSnapshot {\n    FeatureFlags.DARK_MODE with {\n        default(true)\n    }\n}\n\n// Serialize to JSON\nval serializer = SnapshotSerializer.default\nval json = serializer.serialize(snapshot)\n\nprintln(json)\n</code></pre> <p>Output:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"type\": \"BOOLEAN\",\n      \"defaultValue\": true,\n      \"default\": {\n        \"value\": true,\n        \"type\": \"BOOLEAN\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": []\n    }\n  ]\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#saving-to-a-file","title":"Saving to a File","text":"<p>Write the JSON to a file:</p> <pre><code>import java.io.File\n\nfun saveConfiguration(snapshot: Flags.Snapshot, outputPath: String) {\n    val json = SnapshotSerializer.default.serialize(snapshot)\n    File(outputPath).writeText(json)\n    println(\"Configuration saved to $outputPath\")\n}\n\n// Usage\nval snapshot = createProductionConfig()\nsaveConfiguration(snapshot, \"config/production-flags.json\")\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#pretty-printing","title":"Pretty Printing","text":"<p>The serializer automatically formats JSON with indentation for readability:</p> <pre><code>val json = SnapshotSerializer.default.serialize(snapshot)\n// Already pretty-printed with 2-space indentation!\n</code></pre> <p>If you need custom formatting:</p> <pre><code>import com.squareup.moshi.Moshi\nimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\n\n// Create a custom serializer with 4-space indentation\nval customMoshi = Moshi.Builder()\n    .add(KotlinJsonAdapterFactory())\n    .build()\n\nval customSerializer = SnapshotSerializer(customMoshi)\nval adapter = customMoshi.adapter(SerializableSnapshot::class.java).indent(\"    \")\n\nval snapshot = createConfig()\nval serializableSnapshot = snapshot.toSerializable()\nval json = adapter.toJson(serializableSnapshot)\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#serializing-complex-configurations","title":"Serializing Complex Configurations","text":"<p>For the production config from Step 3:</p> <pre><code>fun serializeProductionConfig() {\n    val snapshot = createProductionConfig()\n    val json = SnapshotSerializer.default.serialize(snapshot)\n\n    File(\"config/production-flags.json\").writeText(json)\n}\n</code></pre> <p>The resulting JSON will look like:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"type\": \"BOOLEAN\",\n      \"defaultValue\": true,\n      \"default\": {\n        \"value\": true,\n        \"type\": \"BOOLEAN\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": []\n    },\n    {\n      \"key\": \"new_onboarding\",\n      \"type\": \"BOOLEAN\",\n      \"defaultValue\": false,\n      \"default\": {\n        \"value\": false,\n        \"type\": \"BOOLEAN\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"value\": true,\n            \"type\": \"BOOLEAN\"\n          },\n          \"rollout\": 10.0,\n          \"note\": null,\n          \"locales\": [\"EN_US\"],\n          \"platforms\": [],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#environment-specific-serialization","title":"Environment-Specific Serialization","text":"<p>Create separate JSON files for each environment:</p> <pre><code>fun serializeAllEnvironments() {\n    // Development\n    val devSnapshot = createDevelopmentConfig()\n    File(\"config/dev-flags.json\").writeText(\n        SnapshotSerializer.default.serialize(devSnapshot)\n    )\n\n    // Staging\n    val stagingSnapshot = createStagingConfig()\n    File(\"config/staging-flags.json\").writeText(\n        SnapshotSerializer.default.serialize(stagingSnapshot)\n    )\n\n    // Production\n    val prodSnapshot = createProductionConfig()\n    File(\"config/production-flags.json\").writeText(\n        SnapshotSerializer.default.serialize(prodSnapshot)\n    )\n\n    println(\"All configurations serialized successfully\")\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#automating-serialization","title":"Automating Serialization","text":""},{"location":"serialization/steps/step-04-serialize/#gradle-task","title":"Gradle Task","text":"<p>Create a Gradle task to generate configuration files:</p> build.gradle.kts<pre><code>tasks.register(\"generateFlagConfigs\") {\n    doLast {\n        // Use reflection or source generation to run your config builder\n        exec {\n            mainClass.set(\"com.yourapp.ConfigGeneratorKt\")\n            classpath = sourceSets[\"main\"].runtimeClasspath\n        }\n    }\n}\n</code></pre> <p>Then create the generator:</p> ConfigGenerator.kt<pre><code>package com.yourapp\n\nfun main() {\n    println(\"Generating flag configurations...\")\n\n    val environments = mapOf(\n        \"development\" to createDevelopmentConfig(),\n        \"staging\" to createStagingConfig(),\n        \"production\" to createProductionConfig()\n    )\n\n    environments.forEach { (env, snapshot) -&gt;\n        val outputFile = File(\"config/$env-flags.json\")\n        outputFile.parentFile.mkdirs()\n\n        val json = SnapshotSerializer.default.serialize(snapshot)\n        outputFile.writeText(json)\n\n        println(\"\u2713 Generated $env configuration (${outputFile.absolutePath})\")\n    }\n\n    println(\"Done!\")\n}\n</code></pre> <p>Run it:</p> <pre><code>./gradlew generateFlagConfigs\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#validation","title":"Validation","text":"<p>Before committing JSON to version control, validate it:</p> <pre><code>fun validateSerializedConfig(jsonPath: String): Boolean {\n    return try {\n        val json = File(jsonPath).readText()\n\n        // Attempt to deserialize\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n\n        // Check basic properties\n        require(snapshot.flags.isNotEmpty()) {\n            \"Configuration must contain at least one flag\"\n        }\n\n        // Optionally: test some evaluations\n        testConfiguration(snapshot)\n\n        println(\"\u2713 Configuration is valid\")\n        true\n    } catch (e: Exception) {\n        println(\"\u2717 Validation failed: ${e.message}\")\n        e.printStackTrace()\n        false\n    }\n}\n\nfun testConfiguration(snapshot: Flags.Snapshot) {\n    Flags.load(snapshot)\n\n    val testContext = Context(\n        AppLocale.EN_US,\n        Platform.IOS,\n        Version.of(2, 0, 0),\n        StableId.of(\"test-user\")\n    )\n\n    with(Flags) {\n        // Verify critical flags evaluate without error\n        testContext.evaluate(FeatureFlags.DARK_MODE)\n        testContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#version-control","title":"Version Control","text":"<p>Add generated JSON to version control:</p> .gitignore<pre><code># Don't ignore configuration files!\n# config/*.json\n</code></pre> <p>Commit your configurations:</p> <pre><code>git add config/production-flags.json\ngit add config/staging-flags.json\ngit commit -m \"Update feature flag configuration\"\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#cicd-integration","title":"CI/CD Integration","text":"<p>In your CI pipeline, validate configurations:</p> .github/workflows/validate-flags.yml<pre><code>name: Validate Flag Configurations\n\non: [push, pull_request]\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n\n      - name: Validate configurations\n        run: ./gradlew test --tests FlagValidationTest\n</code></pre>"},{"location":"serialization/steps/step-04-serialize/#whats-next","title":"What's Next?","text":"<p>Now you have JSON files ready to be deserialized. In the next step, you'll learn how to load them back into your application.</p> \u2190 Previous: Step 3 - Create Configuration Next: Step 5 - Deserialize \u2192"},{"location":"serialization/steps/step-05-deserialize/","title":"Step 5: Deserialize JSON","text":""},{"location":"serialization/steps/step-05-deserialize/#overview","title":"Overview","text":"<p>Deserialization converts JSON back into a <code>Flags.Snapshot</code> that can be loaded into the runtime. This is typically done during application startup or when updating configurations.</p> <p>::: tip Time estimate: 15 minutes</p> <p>Goal: Load your JSON configuration into a usable <code>Flags.Snapshot</code> :::</p>"},{"location":"serialization/steps/step-05-deserialize/#basic-deserialization","title":"Basic Deserialization","text":"<pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\nimport java.io.File\n\n// 1. Register your flags (critical!)\nConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n// 2. Read JSON from file\nval json = File(\"config/production-flags.json\").readText()\n\n// 3. Deserialize\nval snapshot = SnapshotSerializer.default.deserialize(json)\n\nprintln(\"Loaded ${snapshot.flags.size} flags\")\n</code></pre> <p>::: caution Always register flags before deserializing, or you'll get an <code>IllegalArgumentException</code>. :::</p>"},{"location":"serialization/steps/step-05-deserialize/#loading-from-different-sources","title":"Loading from Different Sources","text":""},{"location":"serialization/steps/step-05-deserialize/#from-resources-embedded-in-apkjar","title":"From Resources (Embedded in APK/JAR)","text":"<pre><code>fun loadEmbeddedConfiguration(): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = javaClass.getResourceAsStream(\"/flags.json\")\n        ?.bufferedReader()\n        ?.use { it.readText() }\n        ?: throw IllegalStateException(\"flags.json not found in resources\")\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#from-assets-android","title":"From Assets (Android)","text":"<pre><code>import android.content.Context as AndroidContext\n\nfun loadFromAssets(context: AndroidContext): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = context.assets.open(\"flags.json\")\n        .bufferedReader()\n        .use { it.readText() }\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#from-remote-url","title":"From Remote URL","text":"<pre><code>import java.net.URL\n\nsuspend fun loadRemoteConfiguration(url: String): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = withContext(Dispatchers.IO) {\n        URL(url).readText()\n    }\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n\n// Usage\nlifecycleScope.launch {\n    val snapshot = loadRemoteConfiguration(\"https://cdn.example.com/flags.json\")\n    Flags.load(snapshot)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#from-network-with-okhttp","title":"From Network with OkHttp","text":"<pre><code>import okhttp3.OkHttpClient\nimport okhttp3.Request\n\nsuspend fun loadFromCDN(client: OkHttpClient, url: String): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val json = withContext(Dispatchers.IO) {\n        val request = Request.Builder()\n            .url(url)\n            .build()\n\n        client.newCall(request).execute().use { response -&gt;\n            response.body?.string()\n                ?: throw IOException(\"Empty response body\")\n        }\n    }\n\n    return SnapshotSerializer.default.deserialize(json)\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#error-handling","title":"Error Handling","text":"<p>Production code must handle deserialization errors gracefully:</p>"},{"location":"serialization/steps/step-05-deserialize/#pattern-1-fallback-to-embedded-config","title":"Pattern 1: Fallback to Embedded Config","text":"<pre><code>fun loadConfigWithFallback(context: AndroidContext): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    return try {\n        // Try to load from cache/remote\n        loadCachedConfiguration()\n    } catch (e: Exception) {\n        logger.warn(\"Failed to load cached config, using embedded\", e)\n        try {\n            loadEmbeddedConfiguration(context)\n        } catch (e: Exception) {\n            logger.error(\"Failed to load embedded config, using hardcoded\", e)\n            createDefaultSnapshot()\n        }\n    }\n}\n\nfun createDefaultSnapshot(): Flags.Snapshot {\n    // Last resort: hardcoded defaults\n    return ConfigBuilder.buildSnapshot {\n        FeatureFlags.DARK_MODE with { default(false) }\n        FeatureFlags.NEW_ONBOARDING with { default(false) }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#pattern-2-result-type","title":"Pattern 2: Result Type","text":"<pre><code>sealed class ConfigLoadResult {\n    data class Success(val snapshot: Flags.Snapshot) : ConfigLoadResult()\n    data class Error(val error: Exception, val fallback: Flags.Snapshot) : ConfigLoadResult()\n}\n\nfun loadConfiguration(json: String): ConfigLoadResult {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    return try {\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n        ConfigLoadResult.Success(snapshot)\n    } catch (e: Exception) {\n        logger.error(\"Deserialization failed\", e)\n        val fallback = createDefaultSnapshot()\n        ConfigLoadResult.Error(e, fallback)\n    }\n}\n\n// Usage\nwhen (val result = loadConfiguration(json)) {\n    is ConfigLoadResult.Success -&gt; {\n        Flags.load(result.snapshot)\n        showToast(\"Configuration loaded\")\n    }\n    is ConfigLoadResult.Error -&gt; {\n        Flags.load(result.fallback)\n        showToast(\"Using default configuration\")\n        logError(result.error)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#validation-after-deserialization","title":"Validation After Deserialization","text":"<p>Validate the deserialized snapshot before using it:</p> <pre><code>fun loadAndValidate(json: String): Flags.Snapshot {\n    ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n    val snapshot = SnapshotSerializer.default.deserialize(json)\n\n    // Validate\n    require(snapshot.flags.isNotEmpty()) {\n        \"Snapshot must contain at least one flag\"\n    }\n\n    // Check required flags exist\n    val requiredFlags = setOf(\"dark_mode\", \"new_onboarding\")\n    val actualFlags = snapshot.flags.keys.map { it.key }.toSet()\n\n    require(requiredFlags.all { it in actualFlags }) {\n        \"Missing required flags: ${requiredFlags - actualFlags}\"\n    }\n\n    // Test evaluation works\n    val testContext = createTestContext()\n    Flags.load(snapshot)\n\n    with(Flags) {\n        testContext.evaluate(FeatureFlags.DARK_MODE)\n        testContext.evaluate(FeatureFlags.NEW_ONBOARDING)\n    }\n\n    return snapshot\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#caching-deserialized-snapshots","title":"Caching Deserialized Snapshots","text":"<p>Don't deserialize repeatedly - cache the result:</p> <pre><code>object FlagCache {\n    private var cached: Flags.Snapshot? = null\n    private var lastLoadTime: Long = 0\n\n    fun getSnapshot(forceRefresh: Boolean = false): Flags.Snapshot {\n        val cacheAge = System.currentTimeMillis() - lastLoadTime\n\n        if (!forceRefresh &amp;&amp; cached != null &amp;&amp; cacheAge &lt; CACHE_TTL) {\n            return cached!!\n        }\n\n        // Load fresh\n        val snapshot = loadConfiguration()\n        cached = snapshot\n        lastLoadTime = System.currentTimeMillis()\n\n        return snapshot\n    }\n\n    fun clear() {\n        cached = null\n        lastLoadTime = 0\n    }\n\n    private companion object {\n        const val CACHE_TTL = 5 * 60 * 1000L // 5 minutes\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#background-loading","title":"Background Loading","text":"<p>Load configurations in the background to avoid blocking the UI:</p> <pre><code>class FlagLoader(private val context: AndroidContext) {\n\n    suspend fun loadInBackground(): Flags.Snapshot = withContext(Dispatchers.IO) {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        try {\n            // Try remote first\n            loadFromRemote()\n        } catch (e: IOException) {\n            logger.warn(\"Remote load failed, trying cache\", e)\n            try {\n                loadFromCache()\n            } catch (e: Exception) {\n                logger.warn(\"Cache load failed, using embedded\", e)\n                loadEmbedded()\n            }\n        }\n    }\n\n    private fun loadFromRemote(): Flags.Snapshot {\n        val url = getConfigUrl()\n        val json = URL(url).readText()\n\n        // Cache for next time\n        cacheJson(json)\n\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun loadFromCache(): Flags.Snapshot {\n        val cacheFile = File(context.cacheDir, \"flags.json\")\n        val json = cacheFile.readText()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun loadEmbedded(): Flags.Snapshot {\n        val json = context.assets.open(\"default-flags.json\")\n            .bufferedReader()\n            .use { it.readText() }\n\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun cacheJson(json: String) {\n        File(context.cacheDir, \"flags.json\").writeText(json)\n    }\n\n    private fun getConfigUrl(): String {\n        val environment = BuildConfig.ENVIRONMENT\n        return \"https://cdn.example.com/flags-$environment.json\"\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#testing-deserialization","title":"Testing Deserialization","text":"<p>Test your deserialization logic:</p> <pre><code>class DeserializationTest {\n\n    @BeforeEach\n    fun setUp() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        ConditionalRegistry.clear()\n    }\n\n    @Test\n    fun `deserialize valid JSON successfully`() {\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"dark_mode\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n\n        assertEquals(1, snapshot.flags.size)\n    }\n\n    @Test\n    fun `deserialization fails gracefully with invalid JSON`() {\n        val invalidJson = \"not valid json\"\n\n        assertThrows&lt;JsonDataException&gt; {\n            SnapshotSerializer.default.deserialize(invalidJson)\n        }\n    }\n\n    @Test\n    fun `deserialization fails if flag not registered`() {\n        ConditionalRegistry.clear() // Clear registration\n\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"unknown_flag\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        assertThrows&lt;IllegalArgumentException&gt; {\n            SnapshotSerializer.default.deserialize(json)\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-05-deserialize/#whats-next","title":"What's Next?","text":"<p>With deserialization working, you'll learn how to load the snapshot into the runtime.</p> \u2190 Previous: Step 4 - Serialize Next: Step 6 - Load into Runtime \u2192"},{"location":"serialization/steps/step-06-load/","title":"Step 6: Load into Runtime","text":""},{"location":"serialization/steps/step-06-load/#overview","title":"Overview","text":"<p>After deserializing JSON into a <code>Flags.Snapshot</code>, you need to load it into the <code>Flags</code> singleton so your application can evaluate feature flags.</p> <p>::: tip Time estimate: 5 minutes</p> <p>Goal: Make flags available for evaluation throughout your application :::</p>"},{"location":"serialization/steps/step-06-load/#loading-the-snapshot","title":"Loading the Snapshot","text":"<p>The <code>Flags.load()</code> method loads a snapshot into the global state:</p> <pre><code>import io.amichne.konditional.core.Flags\n\n// After deserializing\nval snapshot = SnapshotSerializer.default.deserialize(json)\n\n// Load into runtime\nFlags.load(snapshot)\n\n// Now flags are ready to use!\n</code></pre> <p>That's it! Once loaded, you can evaluate flags from anywhere in your application.</p>"},{"location":"serialization/steps/step-06-load/#when-to-load","title":"When to Load","text":""},{"location":"serialization/steps/step-06-load/#application-startup-recommended","title":"Application Startup (Recommended)","text":"<p>Load flags as early as possible:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Register flags\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        // Load configuration\n        loadFeatureFlags()\n\n        // Continue initialization...\n    }\n\n    private fun loadFeatureFlags() {\n        val json = loadConfigJson() // From assets, network, etc.\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n        Flags.load(snapshot)\n\n        logger.info(\"Feature flags loaded: ${snapshot.flags.size} flags\")\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#lazy-loading","title":"Lazy Loading","text":"<p>If you need to defer loading:</p> <pre><code>object FlagManager {\n    private var initialized = false\n\n    fun ensureLoaded(context: Context) {\n        if (initialized) return\n\n        synchronized(this) {\n            if (initialized) return\n\n            ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n            val json = context.assets.open(\"flags.json\")\n                .bufferedReader()\n                .use { it.readText() }\n\n            val snapshot = SnapshotSerializer.default.deserialize(json)\n            Flags.load(snapshot)\n\n            initialized = true\n        }\n    }\n}\n\n// Call before using flags\nFlagManager.ensureLoaded(context)\n</code></pre>"},{"location":"serialization/steps/step-06-load/#evaluating-flags","title":"Evaluating Flags","text":"<p>Once loaded, evaluate flags using a <code>Context</code>:</p> <pre><code>import io.amichne.konditional.context.Context\nimport io.amichne.konditional.context.AppLocale\nimport io.amichne.konditional.context.Platform\nimport io.amichne.konditional.context.Version\nimport io.amichne.konditional.core.StableId\n\n// Create a context for the current user\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.of(2, 1, 0),\n    stableId = StableId.of(getUserId())\n)\n\n// Evaluate flags\nwith(Flags) {\n    val isDarkModeEnabled = context.evaluate(FeatureFlags.DARK_MODE)\n    val showNewOnboarding = context.evaluate(FeatureFlags.NEW_ONBOARDING)\n\n    if (isDarkModeEnabled) {\n        enableDarkMode()\n    }\n\n    if (showNewOnboarding) {\n        showOnboardingScreen()\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#reloading-flags","title":"Reloading Flags","text":"<p>You can reload flags at runtime by calling <code>load()</code> again:</p> <pre><code>fun reloadFlags() {\n    // Download new configuration\n    val json = downloadLatestConfig()\n\n    // Deserialize\n    val snapshot = SnapshotSerializer.default.deserialize(json)\n\n    // Reload (replaces current configuration)\n    Flags.load(snapshot)\n\n    logger.info(\"Flags reloaded successfully\")\n\n    // Notify listeners if needed\n    notifyFlagChangeListeners()\n}\n</code></pre> <p>::: note Reloading flags is thread-safe. The <code>Flags</code> singleton uses atomic operations to ensure consistency. :::</p>"},{"location":"serialization/steps/step-06-load/#thread-safety","title":"Thread Safety","text":"<p>The <code>Flags</code> singleton is thread-safe and can be accessed from multiple threads:</p> <pre><code>// Thread 1: Loading\nCoroutineScope(Dispatchers.IO).launch {\n    val snapshot = loadRemoteConfiguration()\n    Flags.load(snapshot)\n}\n\n// Thread 2: Evaluating (safe even during reload)\nCoroutineScope(Dispatchers.Main).launch {\n    with(Flags) {\n        val value = context.evaluate(FeatureFlags.DARK_MODE)\n        updateUI(value)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#complete-integration-example","title":"Complete Integration Example","text":"<p>Here's a complete example integrating loading and evaluation:</p> <pre><code>class MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Ensure flags are loaded\n        ensureFlagsLoaded()\n\n        // Use flags to control UI\n        setupUI()\n    }\n\n    private fun ensureFlagsLoaded() {\n        if (!FlagManager.isLoaded) {\n            FlagManager.load(this)\n        }\n    }\n\n    private fun setupUI() {\n        val context = createUserContext()\n\n        with(Flags) {\n            // Check dark mode flag\n            if (context.evaluate(FeatureFlags.DARK_MODE)) {\n                setTheme(R.style.DarkTheme)\n            }\n\n            // Check UI variant flags\n            if (context.evaluate(FeatureFlags.COMPACT_CARDS)) {\n                setContentView(R.layout.activity_main_compact)\n            } else {\n                setContentView(R.layout.activity_main_standard)\n            }\n\n            // Check feature availability\n            if (context.evaluate(FeatureFlags.NEW_FEATURE)) {\n                showNewFeatureBadge()\n            }\n        }\n    }\n\n    private fun createUserContext(): Context {\n        return Context(\n            locale = getCurrentLocale(),\n            platform = Platform.ANDROID,\n            appVersion = Version.of(BuildConfig.VERSION_CODE),\n            stableId = StableId.of(getUserId())\n        )\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#observing-flag-changes","title":"Observing Flag Changes","text":"<p>If you need to react to flag changes, implement an observer pattern:</p> <pre><code>object FlagObserver {\n    private val listeners = mutableSetOf&lt;() -&gt; Unit&gt;()\n\n    fun addListener(listener: () -&gt; Unit) {\n        listeners.add(listener)\n    }\n\n    fun removeListener(listener: () -&gt; Unit) {\n        listeners.remove(listener)\n    }\n\n    fun notifyChange() {\n        listeners.forEach { it() }\n    }\n}\n\n// When reloading flags\nfun reloadFlags() {\n    val snapshot = loadNewConfiguration()\n    Flags.load(snapshot)\n\n    // Notify observers\n    FlagObserver.notifyChange()\n}\n\n// In your UI\nclass MyFragment : Fragment() {\n    private val flagChangeListener = {\n        refreshUI()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        FlagObserver.addListener(flagChangeListener)\n    }\n\n    override fun onPause() {\n        super.onPause()\n        FlagObserver.removeListener(flagChangeListener)\n    }\n\n    private fun refreshUI() {\n        val context = createUserContext()\n        with (Flags) {\n            updateDarkMode(context.evaluate(FeatureFlags.DARK_MODE))\n            updateCompactMode(context.evaluate(FeatureFlags.COMPACT_CARDS))\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#best-practices","title":"Best Practices","text":""},{"location":"serialization/steps/step-06-load/#1-load-early","title":"1. Load Early","text":"<p>Load flags as early as possible to avoid race conditions:</p> <pre><code>// \u2705 Good: Load in Application.onCreate()\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        loadFlags() // First thing\n        initializeLibraries() // After flags\n    }\n}\n\n// \u274c Bad: Load lazily when first needed\nfun someActivity() {\n    loadFlagsIfNeeded() // Too late, might miss flags\n    if (isDarkModeEnabled()) { ... }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#2-handle-missing-flags-gracefully","title":"2. Handle Missing Flags Gracefully","text":"<p>Always provide defaults:</p> <pre><code>fun isDarkModeEnabled(context: Context): Boolean {\n    return try {\n        with(Flags) {\n            context.evaluate(FeatureFlags.DARK_MODE)\n        }\n    } catch (e: IllegalStateException) {\n        // Flag not found - return safe default\n        logger.warn(\"Dark mode flag not found, defaulting to false\", e)\n        false\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#3-cache-user-context","title":"3. Cache User Context","text":"<p>Don't create contexts repeatedly:</p> <pre><code>// \u2705 Good: Create once, reuse\nclass UserSession {\n    val flagContext by lazy {\n        Context(\n            locale = getUserLocale(),\n            platform = Platform.ANDROID,\n            appVersion = Version.of(BuildConfig.VERSION_CODE),\n            stableId = StableId.of(getUserId())\n        )\n    }\n}\n\n// \u274c Bad: Create every time\nfun checkFlag(): Boolean {\n    val context = Context(...) // Recreated unnecessarily\n    return with(Flags) { context.evaluate(flag) }\n}\n</code></pre>"},{"location":"serialization/steps/step-06-load/#whats-next","title":"What's Next?","text":"<p>With flags loaded and working, you should add tests to ensure everything works correctly.</p> \u2190 Previous: Step 5 - Deserialize Next: Step 7 - Testing \u2192"},{"location":"serialization/steps/step-07-testing/","title":"Step 7: Testing","text":""},{"location":"serialization/steps/step-07-testing/#overview","title":"Overview","text":"<p>Thorough testing ensures your serialization implementation works correctly and prevents regressions. This step covers unit tests, integration tests, and property-based tests.</p> <p>::: tip Time estimate: 30 minutes</p> <p>Goal: Comprehensive test coverage for serialization workflows :::</p>"},{"location":"serialization/steps/step-07-testing/#test-setup","title":"Test Setup","text":"<p>Create a base test class with proper setup/teardown:</p> BaseSerializationTest.kt<pre><code>import io.amichne.konditional.serialization.ConditionalRegistry\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.BeforeEach\n\nabstract class BaseSerializationTest {\n\n    @BeforeEach\n    fun setUp() {\n        // Register flags before each test\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n    }\n\n    @AfterEach\n    fun tearDown() {\n        // Clean up registry to avoid test pollution\n        ConditionalRegistry.clear()\n    }\n\n    protected fun createTestContext() = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version.of(2, 0, 0),\n        stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n    )\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#unit-tests","title":"Unit Tests","text":""},{"location":"serialization/steps/step-07-testing/#test-1-basic-serialization","title":"Test 1: Basic Serialization","text":"<pre><code>class BasicSerializationTest : BaseSerializationTest() {\n\n    @Test\n    fun `serialize simple flag configuration`() {\n        val snapshot = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with {\n                default(true)\n            }\n        }\n\n        val json = SnapshotSerializer.default.serialize(snapshot)\n\n        assertNotNull(json)\n        assertTrue(json.contains(\"dark_mode\"))\n        assertTrue(json.contains(\"BOOLEAN\"))\n        assertTrue(json.contains(\"\\\"defaultValue\\\": true\"))\n    }\n\n    @Test\n    fun `deserialize simple flag configuration`() {\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"dark_mode\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"salt\": \"v1\",\n                  \"isActive\": true,\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n\n        assertEquals(1, snapshot.flags.size)\n        assertTrue(snapshot.flags.containsKey(FeatureFlags.DARK_MODE))\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#test-2-round-trip-equality","title":"Test 2: Round-Trip Equality","text":"<pre><code>class RoundTripTest : BaseSerializationTest() {\n\n    @Test\n    fun `round-trip preserves simple configuration`() {\n        val original = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n            FeatureFlags.NEW_ONBOARDING with { default(false) }\n        }\n\n        val json = SnapshotSerializer.default.serialize(original)\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        assertSnapshotsEqual(original, restored)\n    }\n\n    @Test\n    fun `round-trip preserves complex rules`() {\n        val original = ConfigBuilder.buildSnapshot {\n            FeatureFlags.NEW_ONBOARDING with {\n                default(false)\n                rule {\n                    rollout = Rollout.of(50.0)\n                    locales(AppLocale.EN_US, AppLocale.EN_CA)\n                    platforms(Platform.IOS)\n                    note = \"50% rollout for US/CA iOS\"\n                }.implies(true)\n            }\n        }\n\n        val json = SnapshotSerializer.default.serialize(original)\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        assertSnapshotsEqual(original, restored)\n    }\n\n    private fun assertSnapshotsEqual(\n        expected: Flags.Snapshot,\n        actual: Flags.Snapshot\n    ) {\n        val context = createTestContext()\n\n        with(Flags) {\n            Flags.load(expected)\n            val expectedValues = context.evaluate()\n\n            Flags.load(actual)\n            val actualValues = context.evaluate()\n\n            assertEquals(expectedValues.size, actualValues.size)\n\n            expectedValues.forEach { (key, value) -&gt;\n                assertEquals(\n                    value,\n                    actualValues[key],\n                    \"Flag ${(key as Conditional&lt;*, *&gt;).key} values should match\"\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#test-3-error-handling","title":"Test 3: Error Handling","text":"<pre><code>class ErrorHandlingTest : BaseSerializationTest() {\n\n    @Test\n    fun `deserialization fails on invalid JSON`() {\n        val invalidJson = \"not valid json at all\"\n\n        assertThrows&lt;JsonDataException&gt; {\n            SnapshotSerializer.default.deserialize(invalidJson)\n        }\n    }\n\n    @Test\n    fun `deserialization fails on unregistered flag`() {\n        ConditionalRegistry.clear() // Clear all registrations\n\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"unknown_flag\",\n                  \"type\": \"BOOLEAN\",\n                  \"defaultValue\": true,\n                  \"default\": {\"value\": true, \"type\": \"BOOLEAN\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        val exception = assertThrows&lt;IllegalArgumentException&gt; {\n            SnapshotSerializer.default.deserialize(json)\n        }\n\n        assertTrue(exception.message!!.contains(\"unknown_flag\"))\n        assertTrue(exception.message!!.contains(\"not found in registry\"))\n    }\n\n    @Test\n    fun `deserialization fails on type mismatch`() {\n        val json = \"\"\"\n            {\n              \"flags\": [\n                {\n                  \"key\": \"dark_mode\",\n                  \"type\": \"STRING\",\n                  \"defaultValue\": \"not a boolean\",\n                  \"default\": {\"value\": \"not a boolean\", \"type\": \"STRING\"},\n                  \"rules\": []\n                }\n              ]\n            }\n        \"\"\".trimIndent()\n\n        // This should fail because FeatureFlags.DARK_MODE expects Boolean\n        assertThrows&lt;ClassCastException&gt; {\n            val snapshot = SnapshotSerializer.default.deserialize(json)\n            Flags.load(snapshot)\n\n            with(Flags) {\n                createTestContext().evaluate(FeatureFlags.DARK_MODE)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#integration-tests","title":"Integration Tests","text":""},{"location":"serialization/steps/step-07-testing/#test-loading-workflow","title":"Test Loading Workflow","text":"<pre><code>class LoadingWorkflowTest : BaseSerializationTest() {\n\n    @Test\n    fun `full workflow from config to evaluation`() {\n        // 1. Create configuration\n        val snapshot = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with {\n                default(false)\n                rule {\n                    platforms(Platform.IOS)\n                }.implies(true)\n            }\n        }\n\n        // 2. Serialize\n        val json = SnapshotSerializer.default.serialize(snapshot)\n        assertNotNull(json)\n\n        // 3. Deserialize\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        // 4. Load\n        Flags.load(restored)\n\n        // 5. Evaluate\n        val iosContext = Context(\n            AppLocale.EN_US,\n            Platform.IOS,\n            Version.of(1, 0, 0),\n            StableId.of(\"test-user-ios\")\n        )\n\n        val androidContext = Context(\n            AppLocale.EN_US,\n            Platform.ANDROID,\n            Version.of(1, 0, 0),\n            StableId.of(\"test-user-android\")\n        )\n\n        with(Flags) {\n            assertTrue(iosContext.evaluate(FeatureFlags.DARK_MODE))\n            assertFalse(androidContext.evaluate(FeatureFlags.DARK_MODE))\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#test-patch-updates","title":"Test Patch Updates","text":"<pre><code>class PatchUpdateTest : BaseSerializationTest() {\n\n    @Test\n    fun `patch adds new flag`() {\n        val initial = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n        }\n\n        val patch = SerializablePatch(\n            flags = listOf(\n                SerializableFlag(\n                    key = \"new_onboarding\",\n                    type = ValueType.BOOLEAN,\n                    defaultValue = false\n                )\n            )\n        )\n\n        val updated = SnapshotSerializer.default.applyPatch(initial, patch)\n\n        assertEquals(2, updated.flags.size)\n        assertTrue(updated.flags.containsKey(FeatureFlags.DARK_MODE))\n        assertTrue(updated.flags.containsKey(FeatureFlags.NEW_ONBOARDING))\n    }\n\n    @Test\n    fun `patch updates existing flag`() {\n        val initial = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(false) }\n        }\n\n        val patch = SerializablePatch(\n            flags = listOf(\n                SerializableFlag(\n                    key = \"dark_mode\",\n                    type = ValueType.BOOLEAN,\n                    defaultValue = true // Changed\n                )\n            )\n        )\n\n        val updated = SnapshotSerializer.default.applyPatch(initial, patch)\n\n        Flags.load(updated)\n        val context = createTestContext()\n\n        with(Flags) {\n            assertTrue(context.evaluate(FeatureFlags.DARK_MODE))\n        }\n    }\n\n    @Test\n    fun `patch removes flag`() {\n        val initial = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n            FeatureFlags.NEW_ONBOARDING with { default(false) }\n        }\n\n        val patch = SerializablePatch(\n            flags = emptyList(),\n            removeKeys = listOf(\"new_onboarding\")\n        )\n\n        val updated = SnapshotSerializer.default.applyPatch(initial, patch)\n\n        assertEquals(1, updated.flags.size)\n        assertTrue(updated.flags.containsKey(FeatureFlags.DARK_MODE))\n        assertFalse(updated.flags.containsKey(FeatureFlags.NEW_ONBOARDING))\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#property-based-tests","title":"Property-Based Tests","text":"<p>Test properties that should always hold true:</p> <pre><code>class PropertyBasedTest : BaseSerializationTest() {\n\n    @Test\n    fun `serialization is deterministic`() {\n        val snapshot = ConfigBuilder.buildSnapshot {\n            FeatureFlags.DARK_MODE with { default(true) }\n            FeatureFlags.NEW_ONBOARDING with { default(false) }\n        }\n\n        val json1 = SnapshotSerializer.default.serialize(snapshot)\n        val json2 = SnapshotSerializer.default.serialize(snapshot)\n\n        assertEquals(json1, json2, \"Serialization should be deterministic\")\n    }\n\n    @Test\n    fun `evaluation is consistent across reload`() {\n        val snapshot = ConfigBuilder.buildSnapshot {\n            FeatureFlags.NEW_ONBOARDING with {\n                default(false)\n                rule {\n                    rollout = Rollout.of(50.0)\n                }.implies(true)\n            }\n        }\n\n        val context = createTestContext()\n\n        // Evaluate before reload\n        Flags.load(snapshot)\n        val valueBefore = with(Flags) {\n            context.evaluate(FeatureFlags.NEW_ONBOARDING)\n        }\n\n        // Reload same configuration\n        Flags.load(snapshot)\n        val valueAfter = with(Flags) {\n            context.evaluate(FeatureFlags.NEW_ONBOARDING)\n        }\n\n        assertEquals(valueBefore, valueAfter, \"Values should be consistent\")\n    }\n\n    @Test\n    fun `all registered flags can be serialized and deserialized`() {\n        // Create config with all flags\n        val snapshot = ConfigBuilder.buildSnapshot {\n            FeatureFlags.values().forEach { flag -&gt;\n                flag with { default(false) }\n            }\n        }\n\n        // Serialize\n        val json = SnapshotSerializer.default.serialize(snapshot)\n\n        // Deserialize\n        val restored = SnapshotSerializer.default.deserialize(json)\n\n        // All flags should be present\n        assertEquals(FeatureFlags.values().size, restored.flags.size)\n\n        FeatureFlags.values().forEach { flag -&gt;\n            assertTrue(\n                restored.flags.containsKey(flag),\n                \"Flag ${flag.key} should be present after round-trip\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"serialization/steps/step-07-testing/#1-test-json-samples","title":"1. Test JSON Samples","text":"<p>Keep real JSON samples for regression testing:</p> <pre><code>@Test\nfun `deserialize production JSON sample`() {\n    val json = File(\"src/test/resources/production-flags.json\").readText()\n    val snapshot = SnapshotSerializer.default.deserialize(json)\n\n    assertNotNull(snapshot)\n    assertTrue(snapshot.flags.isNotEmpty())\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#2-parameterized-tests","title":"2. Parameterized Tests","text":"<p>Test multiple scenarios with one test:</p> <pre><code>@ParameterizedTest\n@MethodSource(\"flagScenarios\")\nfun `test various flag configurations`(scenario: FlagScenario) {\n    val snapshot = scenario.createSnapshot()\n    val json = SnapshotSerializer.default.serialize(snapshot)\n    val restored = SnapshotSerializer.default.deserialize(json)\n\n    assertSnapshotsEqual(snapshot, restored)\n}\n\ncompanion object {\n    @JvmStatic\n    fun flagScenarios() = listOf(\n        FlagScenario(\"simple default\", { FeatureFlags.DARK_MODE with { default(true) } }),\n        FlagScenario(\"with rules\", { FeatureFlags.DARK_MODE with {\n            default(false)\n            rule { platforms(Platform.IOS) }.implies(true)\n        }}),\n        // More scenarios...\n    )\n}\n</code></pre>"},{"location":"serialization/steps/step-07-testing/#whats-next","title":"What's Next?","text":"<p>With comprehensive tests in place, you're ready to deploy to production!</p> \u2190 Previous: Step 6 - Load into Runtime Next: Step 8 - Production Setup \u2192"},{"location":"serialization/steps/step-08-production/","title":"Step 8: Production Setup","text":""},{"location":"serialization/steps/step-08-production/#overview","title":"Overview","text":"<p>The final step is setting up serialization for production use. This includes deployment strategies, monitoring, rollback procedures, and operational best practices.</p> <p>::: tip Time estimate: 45 minutes</p> <p>Goal: Production-ready serialization infrastructure :::</p>"},{"location":"serialization/steps/step-08-production/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"serialization/steps/step-08-production/#strategy-1-embedded-configuration-simple","title":"Strategy 1: Embedded Configuration (Simple)","text":"<p>Bundle JSON with your application:</p> <pre><code>// Place JSON in resources\nsrc/main/resources/\n  \u2514\u2500\u2500 flags.json\n\n// Load at startup\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        loadEmbeddedFlags()\n    }\n\n    private fun loadEmbeddedFlags() {\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        val json = javaClass.getResourceAsStream(\"/flags.json\")\n            ?.bufferedReader()\n            ?.use { it.readText() }\n            ?: throw IllegalStateException(\"flags.json not found\")\n\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n        Flags.load(snapshot)\n    }\n}\n</code></pre> <p>Pros: Simple, no network dependency, guaranteed availability</p> <p>Cons: Requires rebuild to change, larger APK/JAR</p>"},{"location":"serialization/steps/step-08-production/#strategy-2-remote-configuration-dynamic","title":"Strategy 2: Remote Configuration (Dynamic)","text":"<p>Load from a CDN or configuration service:</p> <pre><code>class FlagLoader(\n    private val cdnUrl: String,\n    private val cacheDir: File\n) {\n    suspend fun loadFlags(): Result&lt;Flags.Snapshot&gt; = withContext(Dispatchers.IO) {\n        try {\n            // Try remote first\n            val remoteSnapshot = downloadRemoteFlags()\n            cacheSnapshot(remoteSnapshot)\n            Result.success(remoteSnapshot)\n        } catch (e: IOException) {\n            // Fallback to cache\n            logger.warn(\"Remote load failed, using cache\", e)\n            try {\n                val cachedSnapshot = loadCachedFlags()\n                Result.success(cachedSnapshot)\n            } catch (e: Exception) {\n                // Last resort: embedded\n                logger.error(\"Cache failed, using embedded\", e)\n                Result.success(loadEmbeddedFlags())\n            }\n        }\n    }\n\n    private fun downloadRemoteFlags(): Flags.Snapshot {\n        val url = \"$cdnUrl/flags-${BuildConfig.ENVIRONMENT}.json\"\n        val json = URL(url).readText()\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun cacheSnapshot(snapshot: Flags.Snapshot) {\n        val json = SnapshotSerializer.default.serialize(snapshot)\n        File(cacheDir, \"flags.json\").writeText(json)\n    }\n\n    private fun loadCachedFlags(): Flags.Snapshot {\n        val json = File(cacheDir, \"flags.json\").readText()\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n\n    private fun loadEmbeddedFlags(): Flags.Snapshot {\n        val json = javaClass.getResourceAsStream(\"/default-flags.json\")\n            ?.bufferedReader()\n            ?.use { it.readText() }\n            ?: throw IllegalStateException(\"Embedded flags not found\")\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n        return SnapshotSerializer.default.deserialize(json)\n    }\n}\n</code></pre> <p>Pros: Update without rebuild, environment-specific configs, A/B testing</p> <p>Cons: Network dependency, requires caching, complex error handling</p>"},{"location":"serialization/steps/step-08-production/#strategy-3-hybrid-recommended","title":"Strategy 3: Hybrid (Recommended)","text":"<p>Combine both approaches for resilience:</p> <pre><code>class ProductionFlagLoader(\n    private val context: Context,\n    private val remoteUrl: String\n) {\n    suspend fun initialize() {\n        // Load embedded flags immediately\n        loadEmbeddedFlags()\n\n        // Update from remote in background\n        updateFromRemote()\n    }\n\n    private fun loadEmbeddedFlags() {\n        val json = context.assets.open(\"flags.json\")\n            .bufferedReader()\n            .use { it.readText() }\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n        Flags.load(snapshot)\n\n        logger.info(\"Embedded flags loaded\")\n    }\n\n    private suspend fun updateFromRemote() = withContext(Dispatchers.IO) {\n        try {\n            val json = downloadWithRetry(remoteUrl, maxRetries = 3)\n\n            val snapshot = SnapshotSerializer.default.deserialize(json)\n\n            // Validate before loading\n            validateSnapshot(snapshot)\n\n            Flags.load(snapshot)\n\n            // Cache for next launch\n            cacheJson(json)\n\n            logger.info(\"Remote flags loaded successfully\")\n        } catch (e: Exception) {\n            logger.warn(\"Remote update failed, keeping embedded config\", e)\n            // App continues with embedded config\n        }\n    }\n\n    private fun validateSnapshot(snapshot: Flags.Snapshot) {\n        require(snapshot.flags.isNotEmpty()) {\n            \"Snapshot must contain flags\"\n        }\n\n        // Add custom validation\n        val requiredFlags = setOf(\"dark_mode\", \"critical_feature\")\n        val actualFlags = snapshot.flags.keys.map { it.key }.toSet()\n\n        require(requiredFlags.all { it in actualFlags }) {\n            \"Missing required flags\"\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"serialization/steps/step-08-production/#github-actions-example","title":"GitHub Actions Example","text":".github/workflows/deploy-flags.yml<pre><code>name: Deploy Feature Flags\n\non:\n  push:\n    paths:\n      - 'config/production-flags.json'\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n\n      - name: Validate configuration\n        run: ./gradlew test --tests FlagValidationTest\n\n      - name: Deploy to CDN\n        run: |\n          aws s3 cp config/production-flags.json \\\n            s3://${{ secrets.CDN_BUCKET }}/flags-production.json \\\n            --cache-control \"max-age=300\"\n\n      - name: Invalidate CDN cache\n        run: |\n          aws cloudfront create-invalidation \\\n            --distribution-id ${{ secrets.CDN_DISTRIBUTION_ID }} \\\n            --paths \"/flags-production.json\"\n</code></pre>"},{"location":"serialization/steps/step-08-production/#validation-in-ci","title":"Validation in CI","text":"FlagValidationTest.kt<pre><code>class FlagValidationTest {\n\n    @Test\n    fun `production configuration is valid`() {\n        val json = File(\"config/production-flags.json\").readText()\n\n        ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n        // Should deserialize without errors\n        val snapshot = SnapshotSerializer.default.deserialize(json)\n\n        // Validate structure\n        assertTrue(snapshot.flags.isNotEmpty())\n\n        // Test evaluation doesn't crash\n        testEvaluation(snapshot)\n    }\n\n    @Test\n    fun `all environments have valid configs`() {\n        val environments = listOf(\"development\", \"staging\", \"production\")\n\n        environments.forEach { env -&gt;\n            val json = File(\"config/$env-flags.json\").readText()\n\n            ConditionalRegistry.registerEnum&lt;FeatureFlags&gt;()\n\n            val snapshot = SnapshotSerializer.default.deserialize(json)\n\n            assertNotNull(snapshot, \"$env configuration should be valid\")\n\n            // Environment-specific assertions\n            when (env) {\n                \"production\" -&gt; assertProductionSafe(snapshot)\n                \"development\" -&gt; assertDevelopmentComplete(snapshot)\n            }\n\n            ConditionalRegistry.clear()\n        }\n    }\n\n    private fun assertProductionSafe(snapshot: Flags.Snapshot) {\n        // No debug flags enabled\n        Flags.load(snapshot)\n        val context = createTestContext()\n\n        with(Flags) {\n            assertFalse(\n                context.evaluate(FeatureFlags.DEBUG_MENU),\n                \"Debug menu must be disabled in production\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#monitoring","title":"Monitoring","text":""},{"location":"serialization/steps/step-08-production/#application-metrics","title":"Application Metrics","text":"<pre><code>class FlagMetrics(private val metricsClient: MetricsClient) {\n\n    fun recordFlagLoad(success: Boolean, source: String, durationMs: Long) {\n        metricsClient.count(\"flag.load\", 1, mapOf(\n            \"success\" to success.toString(),\n            \"source\" to source\n        ))\n\n        if (success) {\n            metricsClient.histogram(\"flag.load.duration_ms\", durationMs)\n        }\n    }\n\n    fun recordFlagEvaluation(flagKey: String, value: Any) {\n        metricsClient.count(\"flag.evaluation\", 1, mapOf(\n            \"flag\" to flagKey,\n            \"value\" to value.toString()\n        ))\n    }\n\n    fun recordError(operation: String, error: Exception) {\n        metricsClient.count(\"flag.error\", 1, mapOf(\n            \"operation\" to operation,\n            \"error_type\" to error::class.simpleName.orEmpty()\n        ))\n    }\n}\n\n// Usage\nclass InstrumentedFlagLoader(\n    private val flagLoader: FlagLoader,\n    private val metrics: FlagMetrics\n) {\n    suspend fun loadFlags(): Result&lt;Flags.Snapshot&gt; {\n        val startTime = System.currentTimeMillis()\n\n        return try {\n            val result = flagLoader.loadFlags()\n            val duration = System.currentTimeMillis() - startTime\n\n            metrics.recordFlagLoad(\n                success = result.isSuccess,\n                source = \"remote\",\n                durationMs = duration\n            )\n\n            result\n        } catch (e: Exception) {\n            metrics.recordError(\"load\", e)\n            throw e\n        }\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#logging","title":"Logging","text":"<pre><code>class FlagLogger {\n    private val logger = LoggerFactory.getLogger(FlagLogger::class.java)\n\n    fun logLoad(snapshot: Flags.Snapshot, source: String) {\n        logger.info(\n            \"Loaded {} flags from {}\",\n            snapshot.flags.size,\n            source\n        )\n\n        if (logger.isDebugEnabled) {\n            snapshot.flags.keys.forEach { flag -&gt;\n                logger.debug(\"Flag loaded: {}\", (flag as Conditional&lt;*, *&gt;).key)\n            }\n        }\n    }\n\n    fun logEvaluation(context: Context, flag: Conditional&lt;*, *&gt;, value: Any) {\n        logger.debug(\n            \"Evaluated flag {} for user {} (platform: {}, version: {}): {}\",\n            flag.key,\n            context.stableId.id.take(8),\n            context.platform,\n            context.appVersion,\n            value\n        )\n    }\n\n    fun logError(operation: String, error: Exception) {\n        logger.error(\"Flag operation failed: {}\", operation, error)\n    }\n\n    fun logReload(oldSize: Int, newSize: Int) {\n        logger.info(\n            \"Reloaded flags: {} -&gt; {} flags ({} change)\",\n            oldSize,\n            newSize,\n            if (newSize &gt; oldSize) \"+${newSize - oldSize}\" else \"${newSize - oldSize}\"\n        )\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#rollback-procedures","title":"Rollback Procedures","text":""},{"location":"serialization/steps/step-08-production/#version-your-configurations","title":"Version Your Configurations","text":"<pre><code>data class VersionedConfiguration(\n    val version: String,\n    val timestamp: Long,\n    val snapshot: Flags.Snapshot\n)\n\nclass ConfigurationVersionManager(private val cacheDir: File) {\n\n    fun save(snapshot: Flags.Snapshot) {\n        val version = generateVersion()\n        val versioned = VersionedConfiguration(\n            version = version,\n            timestamp = System.currentTimeMillis(),\n            snapshot = snapshot\n        )\n\n        // Save current version\n        saveVersion(versioned, \"current\")\n\n        // Archive for rollback\n        saveVersion(versioned, version)\n\n        // Clean old versions (keep last 10)\n        cleanOldVersions()\n    }\n\n    fun rollback(toVersion: String? = null): Flags.Snapshot {\n        return if (toVersion != null) {\n            loadVersion(toVersion).snapshot\n        } else {\n            loadPreviousVersion().snapshot\n        }\n    }\n\n    private fun generateVersion(): String {\n        val timestamp = System.currentTimeMillis()\n        return \"v$timestamp\"\n    }\n\n    private fun saveVersion(config: VersionedConfiguration, name: String) {\n        val json = SnapshotSerializer.default.serialize(config.snapshot)\n        val metadata = \"\"\"\n            {\n              \"version\": \"${config.version}\",\n              \"timestamp\": ${config.timestamp}\n            }\n        \"\"\".trimIndent()\n\n        File(cacheDir, \"$name.json\").writeText(json)\n        File(cacheDir, \"$name.meta.json\").writeText(metadata)\n    }\n\n    private fun loadPreviousVersion(): VersionedConfiguration {\n        // Implementation to find previous version\n        val versions = listVersions().sortedByDescending { it.timestamp }\n        return versions[1] // Get second most recent (current is first)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#emergency-rollback","title":"Emergency Rollback","text":"<pre><code>object EmergencyFlagControl {\n\n    fun rollbackToDefault() {\n        logger.warn(\"Emergency rollback initiated\")\n\n        val defaultSnapshot = ConfigBuilder.buildSnapshot {\n            // Safe defaults for all flags\n            FeatureFlags.values().forEach { flag -&gt;\n                flag with { default(false) }\n            }\n        }\n\n        Flags.load(defaultSnapshot)\n\n        logger.info(\"Rolled back to safe defaults\")\n    }\n\n    fun disableFlag(flag: Conditional&lt;*, *&gt;) {\n        logger.warn(\"Emergency disable: ${flag.key}\")\n\n        // Create patch to disable\n        val patch = SerializablePatch(\n            flags = listOf(\n                SerializableFlag(\n                    key = flag.key,\n                    type = ValueType.BOOLEAN,\n                    defaultValue = false\n                )\n            )\n        )\n\n        val current = getCurrentSnapshot()\n        val updated = SnapshotSerializer.default.applyPatch(current, patch)\n        Flags.load(updated)\n    }\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#security-considerations","title":"Security Considerations","text":""},{"location":"serialization/steps/step-08-production/#validate-json-source","title":"Validate JSON Source","text":"<pre><code>fun loadFlagsSecurely(url: String) {\n    // Only load from trusted domains\n    require(url.startsWith(\"https://cdn.yourcompany.com/\")) {\n        \"Untrusted source: $url\"\n    }\n\n    // Verify SSL certificate\n    val json = downloadWithCertificatePin(url)\n\n    // Validate signature\n    verifySignature(json)\n\n    // Load\n    val snapshot = SnapshotSerializer.default.deserialize(json)\n    Flags.load(snapshot)\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#prevent-injection","title":"Prevent Injection","text":"<pre><code>fun sanitizeConfiguration(snapshot: Flags.Snapshot): Flags.Snapshot {\n    // Ensure no malicious values\n    snapshot.flags.forEach { (key, entry) -&gt;\n        validateFlagEntry(key, entry)\n    }\n\n    return snapshot\n}\n\nprivate fun validateFlagEntry(key: Conditional&lt;*, *&gt;, entry: Flags.FlagEntry&lt;*, *&gt;) {\n    // Implement validation logic\n    // - Check for suspicious patterns\n    // - Validate value ranges\n    // - Ensure rules are reasonable\n}\n</code></pre>"},{"location":"serialization/steps/step-08-production/#congratulations","title":"Congratulations!","text":"<p>You've completed the integration! Your serialization system is now production-ready.</p> \u2190 Previous: Step 7 - Testing View Full Runthrough \u2192"},{"location":"serialization/steps/step-08-production/#quick-links","title":"Quick Links","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Patch Updates - Advanced patch techniques</li> <li>Migration Guide - Migrating existing systems</li> </ul>"}]}