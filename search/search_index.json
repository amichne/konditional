{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Konditional","text":"<p>Type-safe feature flags for Kotlin that won't break in production.</p> <p>Konditional prevents the entire class of runtime errors that come from stringly-typed feature flag systems: typos that ship to production, type coercion failures, inconsistent rollout logic, and configuration drift.</p> <pre><code>object AppFlags : FeatureContainer() {\n    val checkoutVersion by string(default = \"classic\") {\n        rule { platforms(Platform.MOBILE) } returns \"optimized\"\n        rule { rollout { 50.0 } } returns \"experimental\"\n    }\n}\n\n// Typos don't compile. Types are guaranteed. Rollouts are deterministic.\nval version: String = AppFlags.checkoutVersion.evaluate(ctx)\n</code></pre>"},{"location":"#why-konditional","title":"Why Konditional?","text":"<p>Traditional feature flag SDKs use string keys:</p> <pre><code>val enabled = flagClient.getBool(\"new_onboaring_flow\", false)  // typo ships to production\n</code></pre> <p>This compiles. It deploys. Your experiment silently fails. You discover it weeks later.</p> <p>Konditional makes flags compile-time correct:</p> <pre><code>val enabled = AppFlags.newOnboardingFlow.evaluate(ctx)  // typos are compile errors\n</code></pre> <p>Beyond typo safety, Konditional gives you:</p> <ul> <li>Typed values \u2014 not just booleans, but strings, ints, doubles, enums, and custom types</li> <li>Deterministic rollouts \u2014 SHA-256 bucketing ensures same user \u2192 same bucket, always</li> <li>Unified evaluation \u2014 one rule DSL across your entire codebase, not per-domain evaluators</li> <li>Explicit boundaries \u2014 parse JSON configuration with validation; reject invalid updates before they affect production</li> </ul> <p>Read the full argument: Why Konditional Exists</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(\"io.github.amichne:konditional:0.0.1\")\n}\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#define-flags-as-properties","title":"Define flags as properties","text":"<pre><code>object AppFeatures : FeatureContainer() {\n    val darkMode by boolean(default = false) {\n        rule { platforms(Platform.IOS) } returns true\n        rule { rollout { 50.0 } } returns true\n    }\n\n    val apiEndpoint by string(default = \"https://api.example.com\") {\n        rule { platforms(Platform.WEB) } returns \"https://api-web.example.com\"\n    }\n\n    val maxRetries by int(default = 3) {\n        rule { versions { min(2, 0, 0) } } returns 5\n    }\n}\n</code></pre>"},{"location":"#evaluate-with-context","title":"Evaluate with context","text":"<pre><code>val ctx = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.of(2, 1, 0),\n    stableId = StableId.of(\"user-123\")\n)\n\nval enabled: Boolean = AppFeatures.darkMode.evaluate(ctx)\nval endpoint: String = AppFeatures.apiEndpoint.evaluate(ctx)\nval retries: Int = AppFeatures.maxRetries.evaluate(ctx)\n</code></pre> <p>Evaluation is total: if no rule matches, the default is returned. No nulls, no exceptions.</p>"},{"location":"#beyond-booleans-typed-values","title":"Beyond Booleans: Typed Values","text":""},{"location":"#stop-encoding-variants-as-multiple-booleans","title":"Stop encoding variants as multiple booleans","text":"<p>Before (boolean explosion): <pre><code>if (isEnabled(CHECKOUT_V1) &amp;&amp; !isEnabled(CHECKOUT_V2)) {\n    // v1 logic\n} else if (isEnabled(CHECKOUT_V2) &amp;&amp; !isEnabled(CHECKOUT_FAST_PATH)) {\n    // v2 without fast path\n} else if (isEnabled(CHECKOUT_V3) || isEnabled(CHECKOUT_FAST_PATH)) {\n    // which logic wins?\n}\n</code></pre></p> <p>After (typed values): <pre><code>val checkoutVersion by string(default = \"v1\") {\n    rule { rollout { 33.0 } } returns \"v2\"\n    rule { rollout { 66.0 } } returns \"v3\"\n}\n\nwhen (AppFlags.checkoutVersion.evaluate(ctx)) {\n    \"v1\" -&gt; v1Checkout()\n    \"v2\" -&gt; v2Checkout()\n    \"v3\" -&gt; v3Checkout()\n}\n</code></pre></p>"},{"location":"#enums","title":"Enums","text":"<pre><code>enum class Theme { LIGHT, DARK, AUTO }\n\nval theme by enum(default = Theme.LIGHT) {\n    rule { platforms(Platform.IOS) } returns Theme.DARK\n}\n</code></pre>"},{"location":"#custom-structured-values","title":"Custom structured values","text":"<pre><code>@ConfigDataClass\ndata class RetryPolicy(\n    val maxAttempts: Int = 3,\n    val backoffMs: Double = 1000.0,\n    val enabled: Boolean = true\n) : KotlinEncodeable&lt;ObjectSchema&gt; {\n    override val schema = schemaRoot {\n        ::maxAttempts of { minimum = 1.0 }\n        ::backoffMs of { minimum = 0.0 }\n        ::enabled of {}\n    }\n}\n\nval retryPolicy by custom(default = RetryPolicy()) {\n    rule { platforms(Platform.WEB) } returns RetryPolicy(maxAttempts = 5, backoffMs = 2000.0)\n}\n</code></pre>"},{"location":"#deterministic-rollouts","title":"Deterministic Rollouts","text":"<p>Rollouts use SHA-256 bucketing for consistent, reproducible results:</p> <pre><code>val newFeature by boolean(default = false) {\n    rule { rollout { 25.0 } } returns true\n}\n</code></pre> <p>Guarantees: - Same user + same flag + same percentage \u2192 same bucket - Changing 10% \u2192 20% doesn't reshuffle existing users - Rollout decisions are reproducible from logs (<code>stableId</code> + flag key \u2192 deterministic bucket)</p> <p>No random number generators. No modulo edge cases. No per-team rollout implementations with subtle differences.</p>"},{"location":"#remote-configuration","title":"Remote Configuration","text":""},{"location":"#load-configuration-from-json","title":"Load configuration from JSON","text":"<pre><code>val json = fetchRemoteConfig()\n\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; {\n        // Invalid JSON rejected, last-known-good remains active\n        logError(\"Config parse failed: ${result.error.message}\")\n    }\n}\n</code></pre> <p>The boundary is explicit: Parse failures don't crash your app or silently corrupt evaluation. Bad config is rejected; the previous working config stays active.</p>"},{"location":"#serialize-current-configuration","title":"Serialize current configuration","text":"<pre><code>val snapshot = SnapshotSerializer.serialize(Namespace.Global.configuration)\npersistToStorage(snapshot)\n</code></pre>"},{"location":"#incremental-updates-patches","title":"Incremental updates (patches)","text":"<pre><code>val patchJson = fetchPatch()\n\nwhen (val result = SnapshotSerializer.applyPatchJson(currentConfig, patchJson)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Patch failed: ${result.error.message}\")\n}\n</code></pre> <p>See 06-remote-config.md and 08-persistence-format.md for details.</p>"},{"location":"#thread-safety","title":"Thread Safety","text":"<ul> <li>Atomic updates: <code>Namespace.load()</code> swaps configuration atomically</li> <li>Lock-free reads: Evaluation reads a snapshot without blocking writers</li> <li>No races: Multiple threads can evaluate flags concurrently while configuration updates happen in the background</li> </ul>"},{"location":"#namespaces-optional-isolation","title":"Namespaces (Optional Isolation)","text":"<p>By default, all flags live in <code>Namespace.Global</code>. If you need isolated registries (e.g., per-team, per-domain), define your own:</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Account : AppDomain(\"account\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AccountFlags : FeatureContainer&lt;AppDomain.Account&gt;(AppDomain.Account) {\n    val creditCheck by boolean(default = false)\n}\n\nobject PaymentFlags : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val stripeEnabled by boolean(default = true)\n}\n</code></pre> <p>Each namespace has independent configuration lifecycle, registry, and serialization.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Namespace: Isolation boundary with its own registry and configuration lifecycle</li> <li>FeatureContainer: Declares flags as delegated properties bound to a namespace</li> <li>Context: Runtime inputs for evaluation (<code>locale</code>, <code>platform</code>, <code>appVersion</code>, <code>stableId</code>)</li> <li>Rules: Typed criteria-to-value mappings (<code>platforms/locales/versions/rollout/extension</code>)</li> <li>Snapshot/Patch: JSON formats for persistence and incremental updates</li> <li>Total evaluation: No nulls\u2014every flag returns its default if no rule matches</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Getting started: - Quick Start Guide - Core Concepts</p> <p>Features: - Targeting &amp; Rollouts - Evaluation Semantics - Remote Configuration - Persistence Format</p> <p>Why Konditional: - Why Konditional Exists \u2014 The compelling argument</p>"},{"location":"#what-konditional-prevents","title":"What Konditional Prevents","text":"<p>Typos that ship to production: <pre><code>flagClient.getBool(\"new_onboaring_flow\", false)  // compiles, deploys, fails silently\nAppFlags.newOnboaringFlow                        // compile error\n</code></pre></p> <p>Type coercion incidents: <pre><code>// JSON: {\"max_retries\": \"disabled\"}\nflagClient.getInt(\"max_retries\", 3)  // returns 0, service fails immediately\nAppFlags.maxRetries                  // parse fails at boundary, last-known-good stays active\n</code></pre></p> <p>Boolean explosion: <pre><code>// Before: 5 boolean flags \u2192 2^5 = 32 test cases, most undefined\n// After: 1 typed enum flag \u2192 5 explicit variants, all defined\n</code></pre></p> <p>Inconsistent rollout logic: <pre><code>// Before: Account team uses modulo, Payments team uses random(), different bucketing\n// After: All flags use SHA-256 bucketing, same user \u2192 same bucket across all flags\n</code></pre></p> <p>Read more: Real Problems Konditional Prevents</p>"},{"location":"#when-to-use-konditional","title":"When to Use Konditional","text":"<p>Choose Konditional when: - You want compile-time correctness for flag definitions and callsites - You need typed values beyond booleans (variants, thresholds, structured config) - You run experiments and need deterministic, reproducible rollouts - You value consistency over bespoke per-domain solutions - You have remote configuration and want explicit validation boundaries</p> <p>Konditional might not fit if: - You need vendor-hosted dashboards more than compile-time safety - Your flags are fully dynamic with zero static definitions - You're okay with process/tooling to prevent string key drift</p>"},{"location":"#license","title":"License","text":"<p>MIT. See LICENSE.</p>"},{"location":"01-getting-started/","title":"Getting Started","text":"<p>Konditional is a Kotlin feature-flag DSL designed to make configuration typed, deterministic, and non-null. The core claim is precise: statically-defined flags have compile-time type correctness, and evaluation is total (you always get a value back).</p>"},{"location":"01-getting-started/#why-konditional-and-what-it-actually-guarantees","title":"Why Konditional (and what it actually guarantees)","text":"<p>Most flag systems are stringly-typed: a string key selects a value and the caller chooses a \u201ctyped getter\u201d. That architecture creates three failure modes that are syntactically valid but semantically wrong at runtime: key typos, type mismatches, and null propagation.</p> <p>Konditional changes the failure surface by binding identity and type at definition time via Kotlin properties:</p> <ul> <li>No string keys at call sites: flags are accessed as properties (typos become compile errors).</li> <li>No casts at call sites: the return type flows from the flag definition (mismatched types become compile errors).</li> <li>No nulls from evaluation: defaults are required, so evaluation has a total return path.</li> </ul> <pre><code>flowchart LR\n  Def[\"Flag defined as a property\"] --&gt; Bound[\"Key + type bound at compile-time\"]\n  Bound --&gt; Eval[\"Evaluation\"]\n  Eval --&gt;|Rule matches| Value[\"Rule value\"]\n  Eval --&gt;|No match| Default[\"Declared default\"]\n  style Bound fill:#e1f5ff\n  style Default fill:#fff3cd\n  style Value fill:#c8e6c9</code></pre>"},{"location":"01-getting-started/#installation","title":"Installation","text":"<pre><code>// build.gradle.kts\ndependencies {\n    implementation(\"io.amichne:konditional:0.0.1\")\n}\n</code></pre>"},{"location":"01-getting-started/#your-first-flag","title":"Your first flag","text":"<p>Define a flag as a delegated property in a <code>FeatureContainer</code> bound to a <code>Namespace</code>:</p> <pre><code>import io.amichne.konditional.core.Namespace\nimport io.amichne.konditional.core.features.FeatureContainer\nimport io.amichne.konditional.context.*\n\nobject AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            rollout { 50.0 }\n        } returns true\n    }\n}\n\nval context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n\nval enabled: Boolean = feature { AppFeatures.DARK_MODE }\n</code></pre> <p>Notes: - Konditional models evaluation as context-dependent; examples assume you are evaluating within a context-aware scope. - <code>feature { ... }</code> returns the flag\u2019s declared Kotlin type and never returns null.</p>"},{"location":"01-getting-started/#a-small-api-surface-intentionally","title":"A small API surface, intentionally","text":"<p>Supported value types (out of the box):</p> Type DSL Method Kotlin Type Example Default Boolean <code>boolean()</code> <code>Boolean</code> <code>false</code> String <code>string()</code> <code>String</code> <code>\"production\"</code> Integer <code>int()</code> <code>Int</code> <code>42</code> Decimal <code>double()</code> <code>Double</code> <code>3.14</code> Enum <code>enum&lt;E&gt;()</code> <code>E : Enum&lt;E&gt;</code> <code>LogLevel.INFO</code>"},{"location":"01-getting-started/#common-patterns","title":"Common patterns","text":""},{"location":"01-getting-started/#gradual-rollout-deterministic","title":"Gradual rollout (deterministic)","text":"<pre><code>val NEW_CHECKOUT by boolean(default = false) {\n    rule {\n        platforms(Platform.ANDROID)\n        rollout { 10.0 }\n    } returns true\n}\n</code></pre> <p>Konditional\u2019s rollouts are deterministic: the same <code>(stableId, flagKey, salt)</code> yields the same bucket assignment.</p>"},{"location":"01-getting-started/#platform-specific-configuration","title":"Platform-specific configuration","text":"<pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n    rule { platforms(Platform.WEB) } returns \"https://api-web.example.com\"\n}\n</code></pre>"},{"location":"01-getting-started/#variants-via-enums-not-strings","title":"Variants via enums (not strings)","text":"<pre><code>enum class Theme { LIGHT, DARK }\n\nval THEME by enum&lt;Theme, Context&gt;(default = Theme.LIGHT)\n</code></pre>"},{"location":"01-getting-started/#namespaces-scale-ownership-not-prefixes","title":"Namespaces scale ownership, not prefixes","text":"<p>Konditional provides <code>Namespace.Global</code>. If you need isolation boundaries beyond global, define your own namespaces in your codebase (consumer-defined), then bind <code>FeatureContainer</code>s to them.</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val APPLE_PAY by boolean(default = false)\n}\n</code></pre>"},{"location":"01-getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Learn the building blocks: \"Core Concepts\"</li> <li>Write targeting rules and understand rollouts: \"Targeting &amp; Rollouts\"</li> <li>Understand evaluation order and determinism: \"Evaluation\"</li> <li>Add runtime-validated JSON configuration: \"Remote Configuration\"</li> <li>Understand the exact trust boundary: \"Theory\"</li> </ul>"},{"location":"02-migration/","title":"Migration Guide","text":"<p>This guide maps the conceptual shift from string-based flags to Konditional\u2019s typed, property-based model. It focuses on what changes at the definition site, at the call site, and at the trust boundary (runtime JSON).</p>"},{"location":"02-migration/#the-core-mapping","title":"The core mapping","text":"<p>String-based flag systems typically have: - a string key (<code>\"dark-mode\"</code>) - a typed getter chosen by the caller (<code>getBoolean</code>, <code>getString</code>, \u2026) - an untyped context (often string keys and <code>Any</code> values)</p> <p>Konditional replaces those with: - a property (the property name becomes the key) - a declared type (from the delegate: <code>boolean</code>, <code>string</code>, <code>int</code>, <code>double</code>, <code>enum</code>) - a typed <code>Context</code> (and optionally domain-specific context data classes)</p> <pre><code>flowchart LR\n  A[\"String key\"] --&gt; B[\"Property name\"]\n  C[\"Typed getter\"] --&gt; D[\"Type flows from definition\"]\n  E[\"Untyped context map\"] --&gt; F[\"Typed Context data\"]</code></pre>"},{"location":"02-migration/#step-by-step-adoption-incremental","title":"Step-by-step adoption (incremental)","text":""},{"location":"02-migration/#0-start-with-one-container","title":"0. Start with one container","text":"<pre><code>object Features : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n}\n</code></pre>"},{"location":"02-migration/#1-replace-call-sites-first-value-safety","title":"1. Replace call sites first (value safety)","text":"<pre><code>val enabled: Boolean = feature { Features.DARK_MODE }\n</code></pre> <p>What you gain immediately: - key typos are eliminated at the call site (there is no string key) - return type is concrete (no cast; <code>Boolean</code> is enforced) - evaluation is non-null (default is required)</p>"},{"location":"02-migration/#2-introduce-typed-context-targeting-rollouts","title":"2. Introduce typed context (targeting + rollouts)","text":"<pre><code>val context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n</code></pre> <p><code>stableId</code> is the stable input used for deterministic rollout bucketing (see \"Targeting &amp; Rollouts\").</p>"},{"location":"02-migration/#3-add-rules-after-defaults-exist-behavior-safety","title":"3. Add rules after defaults exist (behavior safety)","text":"<pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n}\n</code></pre>"},{"location":"02-migration/#migrating-context-maps-to-typed-contexts","title":"Migrating \u201ccontext maps\u201d to typed contexts","text":"<p>If your current system uses string keys (<code>\"tier\"</code>, <code>\"role\"</code>, \u2026), move that information into a custom context:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val employeeCount: Int\n) : Context\n\nenum class SubscriptionTier { FREE, PRO, ENTERPRISE }\n\nval ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                    ctx.employeeCount &gt; 100\n            }\n        }\n    } returns true\n}\n</code></pre> <p>Result: business targeting logic becomes type-checked and refactor-safe.</p>"},{"location":"02-migration/#namespaces-replace-prefixes","title":"Namespaces replace prefixes","text":"<p>Instead of <code>\"auth.dark-mode\"</code> / <code>\"payments.dark-mode\"</code> style prefixes, use namespace isolation:</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val APPLE_PAY by boolean(default = false)\n}\n</code></pre> <p>Each namespace has its own registry and independent configuration lifecycle.</p>"},{"location":"02-migration/#when-you-need-runtime-configuration-remote-json","title":"When you need runtime configuration (remote JSON)","text":"<p>Konditional supports JSON configuration as a validated boundary:</p> <pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Parse failed: ${result.error}\")\n}\n</code></pre> <p>The guarantee is intentionally qualified: JSON is not \u201calways safe\u201d; instead, invalid JSON is rejected before it can affect evaluation.</p>"},{"location":"02-migration/#shadow-evaluation-parallel-migration","title":"Shadow evaluation (parallel migration)","text":"<p>For gradual migrations, you can evaluate against a baseline registry and shadow-evaluate against a candidate:</p> <pre><code>val value = Features.DARK_MODE.evaluateWithShadow(\n    context = context,\n    candidateRegistry = candidateRegistry,\n    onMismatch = { mismatch -&gt;\n        log.warn(\"Mismatch: ${mismatch.kinds} baseline=${mismatch.baseline.value} candidate=${mismatch.candidate.value}\")\n    }\n)\n</code></pre> <p>This keeps behavior pinned to the baseline value while generating comparison telemetry for the candidate path.</p>"},{"location":"02-migration/#next-steps","title":"Next steps","text":"<ul> <li>Learn the primitives: \"Core Concepts\"</li> <li>Understand rule evaluation and determinism: \"Evaluation\"</li> <li>Operate remote config safely: \"Remote Configuration\"</li> </ul>"},{"location":"03-core-concepts/","title":"Core Concepts","text":"<p>Konditional\u2019s public surface is intentionally small. Understanding three primitives\u2014Features, Context, and Namespaces\u2014is enough to reason about correctness, organization, and runtime behavior.</p> <pre><code>flowchart TD\n  N[\"Namespace\"] --&gt; R[\"Registry\"]\n  C[\"FeatureContainer\"] --&gt; R\n  C --&gt; F[\"Feature (typed)\"]\n  F --&gt; D[\"Default (required)\"]\n  F --&gt; Rules[\"Rules\"]\n  Rules --&gt; Rule[\"rule { ... } returns value\"]\n  Rule --&gt; Criteria[\"platforms/locales/versions/rollout/extension\"]\n  X[\"Context\"] --&gt; Rule</code></pre>"},{"location":"03-core-concepts/#features","title":"Features","text":"<p>A feature is a typed configuration value with an optional rule set. You define features as delegated properties in a <code>FeatureContainer</code>:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.example.com\")\n    val MAX_RETRIES by int(default = 3)\n    val TIMEOUT by double(default = 30.0)\n}\n\nval enabled: Boolean = feature { AppFeatures.DARK_MODE }\nval endpoint: String = feature { AppFeatures.API_ENDPOINT }\n</code></pre> <p>What this buys you: - Property name becomes the key (no string keys at call sites) - Type flows from the delegate (<code>boolean</code> \u2192 <code>Boolean</code>, etc.) - Non-null evaluation (default is required)</p>"},{"location":"03-core-concepts/#supported-types","title":"Supported types","text":"Type DSL Method Kotlin Type Example Default Boolean <code>boolean()</code> <code>Boolean</code> <code>false</code> String <code>string()</code> <code>String</code> <code>\"production\"</code> Integer <code>int()</code> <code>Int</code> <code>42</code> Decimal <code>double()</code> <code>Double</code> <code>3.14</code> Enum <code>enum&lt;E&gt;()</code> <code>E : Enum&lt;E&gt;</code> <code>LogLevel.INFO</code>"},{"location":"03-core-concepts/#enums-instead-of-strings","title":"Enums instead of strings","text":"<pre><code>enum class LogLevel { DEBUG, INFO, WARN, ERROR }\nenum class Theme { LIGHT, DARK, AUTO }\n\nobject AppConfig : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val LOG_LEVEL by enum&lt;LogLevel, Context&gt;(default = LogLevel.INFO)\n    val THEME by enum&lt;Theme, Context&gt;(default = Theme.LIGHT)\n}\n\nval level: LogLevel = feature { AppConfig.LOG_LEVEL }\n</code></pre> <p>Because variants are enum values, invalid variants cannot compile.</p>"},{"location":"03-core-concepts/#rules","title":"Rules","text":"<p>Rules are a typed mapping from a set of criteria to a concrete return value:</p> <pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n}\n</code></pre> <p>Criteria you can compose (within a single rule): - <code>platforms(...)</code> - <code>locales(...)</code> - <code>versions { min(...); max(...) }</code> - <code>rollout { percent }</code> - <code>extension { ... }</code> for custom predicates</p> <p>Within a rule, criteria combine as AND: all specified criteria must match for the rule to match.</p>"},{"location":"03-core-concepts/#custom-predicates-via-extension","title":"Custom predicates via <code>extension { }</code>","text":"<p>To keep business targeting logic typed (not string-based), define a custom <code>Context</code> and use <code>extension { }</code>:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val employeeCount: Int\n) : Context\n\nenum class SubscriptionTier { FREE, PRO, ENTERPRISE }\n\nobject PremiumFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            extension {\n                Evaluable.factory { ctx -&gt;\n                    ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                        ctx.employeeCount &gt; 100\n                }\n            }\n        } returns true\n    }\n}\n</code></pre> <p>Because the feature is parameterized with <code>EnterpriseContext</code>, <code>ctx</code> is strongly typed inside the predicate.</p>"},{"location":"03-core-concepts/#context","title":"Context","text":"<p>Context provides evaluation inputs: it tells Konditional who is asking and where they are.</p> <p>Standard fields (the minimum required by the rule DSL):</p> <pre><code>data class Context(\n    val locale: AppLocale,\n    val platform: Platform,\n    val appVersion: Version,\n    val stableId: StableId\n)\n</code></pre>"},{"location":"03-core-concepts/#stableid-deterministic-rollouts","title":"StableId (deterministic rollouts)","text":"<p><code>stableId</code> is a stable identifier used for deterministic bucketing. It must be hex (32+ chars):</p> <pre><code>val id = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n</code></pre> <p>If you have an existing user ID, hash it into hex:</p> <pre><code>fun toStableId(userId: String): StableId {\n    val hash = MessageDigest.getInstance(\"SHA-256\")\n        .digest(userId.toByteArray())\n        .joinToString(\"\") { \"%02x\".format(it) }\n    return StableId.of(hash)\n}\n</code></pre>"},{"location":"03-core-concepts/#namespaces","title":"Namespaces","text":"<p>Namespaces are isolation boundaries: each namespace has its own registry and independent configuration lifecycle. Konditional provides <code>Namespace.Global</code>. If you need more isolation boundaries, define your own namespaces (consumer-defined) and bind containers to them.</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val APPLE_PAY by boolean(default = false)\n    val STRIPE_INTEGRATION by boolean(default = true)\n}\n\nAppDomain.Auth.load(authConfig)\nAppDomain.Payments.load(paymentConfig)\n</code></pre>"},{"location":"03-core-concepts/#custom-namespaces-governance","title":"Custom namespaces (governance)","text":"<pre><code>sealed class TeamDomain(id: String) : Namespace(id) {\n    data object Recommendations : TeamDomain(\"recommendations\")\n    data object Analytics : TeamDomain(\"analytics\")\n}\n\nobject RecFeatures : FeatureContainer&lt;TeamDomain.Recommendations&gt;(TeamDomain.Recommendations) {\n    val COLLABORATIVE_FILTERING by boolean(default = true)\n}\n</code></pre>"},{"location":"03-core-concepts/#type-safety-in-action-what-becomes-impossible","title":"Type safety in action (what becomes impossible)","text":""},{"location":"03-core-concepts/#wrong-value-type-at-call-site","title":"Wrong value type at call site","text":"<pre><code>object Config : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val MAX_RETRIES by int(default = 3)\n}\n\nval retries: Int = feature { Config.MAX_RETRIES }\n</code></pre>"},{"location":"03-core-concepts/#wrong-context-type-for-a-feature","title":"Wrong context type for a feature","text":"<pre><code>val basicContext: Context = Context(...)\nfeature { PremiumFeatures.ADVANCED_ANALYTICS } // Compile error (requires EnterpriseContext)\n</code></pre>"},{"location":"03-core-concepts/#cross-namespace-misuse","title":"Cross-namespace misuse","text":"<pre><code>AppDomain.Auth.load(paymentConfig) // Compile error (type mismatch)\n</code></pre>"},{"location":"03-core-concepts/#next-steps","title":"Next steps","text":"<ul> <li>Understand rule composition and rollouts: \"Targeting &amp; Rollouts\"</li> <li>Understand evaluation order and determinism: \"Evaluation\"</li> <li>Understand the runtime JSON boundary: \"Remote Configuration\"</li> </ul>"},{"location":"04-targeting-rollouts/","title":"Targeting &amp; Rollouts","text":"<p>Rules let you target specific contexts and roll out behavior safely. A rule is a typed mapping:</p> <pre><code>criteria(context) -&gt; returns value\n</code></pre> <p>Two properties define how rules behave: - AND semantics within a rule: all specified criteria must match. - Specificity ordering across rules: the most specific matching rule wins.</p>"},{"location":"04-targeting-rollouts/#criteria-you-can-combine","title":"Criteria you can combine","text":""},{"location":"04-targeting-rollouts/#platform","title":"Platform","text":"<pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n    rule { platforms(Platform.WEB) } returns \"https://api-web.example.com\"\n}\n</code></pre> <p>Multiple platforms combine as OR:</p> <pre><code>rule { platforms(Platform.IOS, Platform.ANDROID) } returns \"mobile value\"\n</code></pre>"},{"location":"04-targeting-rollouts/#locale","title":"Locale","text":"<pre><code>val WELCOME_MESSAGE by string(default = \"Hello!\") {\n    rule { locales(AppLocale.UNITED_STATES, AppLocale.CANADA) } returns \"Welcome!\"\n    rule { locales(AppLocale.FRANCE) } returns \"Bienvenue!\"\n    rule { locales(AppLocale.JAPAN) } returns \"\u3088\u3046\u3053\u305d!\"\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#version-ranges","title":"Version ranges","text":"<pre><code>val NEW_UI by boolean(default = false) {\n    rule { versions { min(2, 0, 0) } } returns true\n}\n</code></pre> <pre><code>val LEGACY_SUPPORT by boolean(default = false) {\n    rule { versions { max(2, 0, 0) } } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#percentage-rollout","title":"Percentage rollout","text":"<pre><code>val NEW_CHECKOUT by boolean(default = false) {\n    rule { rollout { 10.0 } } returns true\n}\n</code></pre> <p>Rollouts are deterministic: the same <code>(stableId, flagKey, salt)</code> produces the same bucket assignment.</p>"},{"location":"04-targeting-rollouts/#custom-predicates-via-extension","title":"Custom predicates via <code>extension { }</code>","text":"<pre><code>val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                    ctx.employeeCount &gt; 100\n            }\n        }\n    } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#and-semantics-inside-a-rule","title":"AND semantics inside a rule","text":"<p>All criteria in a rule must match:</p> <pre><code>val PREMIUM_FEATURE by boolean(default = false) {\n    rule {\n        platforms(Platform.IOS, Platform.ANDROID)\n        locales(AppLocale.UNITED_STATES)\n        versions { min(2, 0, 0) }\n        rollout { 50.0 }\n    } returns true\n}\n</code></pre> <pre><code>flowchart TD\n  Ctx[\"Context\"] --&gt; P{Platform match?}\n  P --&gt;|No| Skip[\"Rule fails\"]\n  P --&gt;|Yes| L{Locale match?}\n  L --&gt;|No| Skip\n  L --&gt;|Yes| V{Version match?}\n  V --&gt;|No| Skip\n  V --&gt;|Yes| R{Rollout bucket in range?}\n  R --&gt;|No| Skip\n  R --&gt;|Yes| Win[\"Rule matches\"]\n  style Win fill:#c8e6c9\n  style Skip fill:#ffcdd2</code></pre>"},{"location":"04-targeting-rollouts/#specificity-which-rule-wins","title":"Specificity: which rule wins","text":"<p>Konditional orders rules by specificity before evaluating them. Specificity is the count of criteria present on a rule:</p> <pre><code>specificity(rule):\n  +1 if platforms is set\n  +1 if locales is set\n  +1 if versions has bounds\n  +1 if rollout is set\n</code></pre> <p>Rules are evaluated in descending specificity; the first rule whose criteria all match determines the value. If no rules match, the default is returned.</p> <pre><code>flowchart TD\n  Rules[\"Rule set\"] --&gt; Sort[\"Sort by specificity (desc)\"]\n  Sort --&gt; Loop[\"Evaluate rules in order\"]\n  Loop --&gt;|First match| Value[\"Return rule value\"]\n  Loop --&gt;|No match| Default[\"Return default\"]\n  style Value fill:#c8e6c9\n  style Default fill:#fff3cd</code></pre>"},{"location":"04-targeting-rollouts/#deterministic-rollout-bucketing-sha-256","title":"Deterministic rollout bucketing (SHA-256)","text":"<p>Rollouts are computed locally. The bucketing input is stable and per-flag:</p> <pre><code>input = \"$stableId:$flagKey:$salt\"\nhash = input.sha256()\npercentage = (hash.mapToPercentage() % 10000) / 100.0   // [\"0.00, 100.00)\n</code></pre> <p>This yields three operational properties: - Deterministic: same inputs \u2192 same bucket - Per-flag isolation: changing one flag does not affect other flags\u2019 buckets - Salt-controlled redistribution: changing <code>salt</code> re-buckets users for that flag</p> <pre><code>flowchart TD\n  Id[\"stableId\"] --&gt; In[\"stableId:flagKey:salt\"]\n  Key[\"flagKey\"] --&gt; In\n  Salt[\"salt\"] --&gt; In\n  In --&gt; H[\"SHA-256\"]\n  H --&gt; M[\"mod 10,000\"]\n  M --&gt; P[\"percentage 0.00..99.99\"]\n  P --&gt; T{\"&lt; rollout % ?\"}\n  T --&gt;|Yes| Enabled[\"In rollout\"]\n  T --&gt;|No| Disabled[\"Out of rollout\"]\n  style Enabled fill:#c8e6c9\n  style Disabled fill:#ffcdd2</code></pre>"},{"location":"04-targeting-rollouts/#next-steps","title":"Next steps","text":"<ul> <li>Understand evaluation flow and performance: \"Evaluation\"</li> <li>Understand the compile-time vs runtime boundary: \"Theory\"</li> </ul>"},{"location":"05-evaluation/","title":"Evaluation","text":""},{"location":"05-evaluation/#konditional-evaluation-is-designed-to-be-predictable","title":"Konditional evaluation is designed to be predictable","text":"<ul> <li>Total \u2014 Evaluation always returns a value (rule value or default).</li> <li>Deterministic \u2014 The same inputs produce the same outputs.</li> <li>Non-null \u2014 Defaults are required, so evaluation does not return <code>T?</code>.</li> </ul>"},{"location":"05-evaluation/#feature-recommended","title":"<code>feature { }</code> (recommended)","text":"<p>Concise evaluation inside a context-aware scope:</p> <pre><code>val darkMode = feature { Features.DARK_MODE }\napplyDarkMode(darkMode)\n</code></pre> <p>Use this when: - defaults are meaningful - you want the smallest call-site surface</p>"},{"location":"05-evaluation/#explain-trace-operational-debugging","title":"Explain / trace (operational debugging)","text":"<p>When you need to diagnose a specific user\u2019s outcome, evaluate with a structured reason:</p> <pre><code>val result = Features.DARK_MODE.evaluateWithReason(context)\nprintln(result.decision)\n</code></pre> <p><code>EvaluationResult</code> includes: - decision kind (rule/default/inactive/disabled) - matched rule constraints + specificity - deterministic rollout bucket information</p>"},{"location":"05-evaluation/#evaluation-flow","title":"Evaluation flow","text":"<pre><code>flowchart TD\n  Start[\"Context available\"] --&gt; Lookup[\"Registry lookup\"]\n  Lookup --&gt; Active{Flag active?}\n  Active --&gt;|No| Default1[\"Return default\"]\n  Active --&gt;|Yes| Sort[\"Sort rules by specificity\"]\n  Sort --&gt; Next{Next rule?}\n  Next --&gt;|No| Default2[\"Return default\"]\n  Next --&gt;|Yes| Match{All criteria match?}\n  Match --&gt;|No| Next\n  Match --&gt;|Yes| Roll{Rollout passes?}\n  Roll --&gt;|No| Next\n  Roll --&gt;|Yes| Value[\"Return rule value\"]\n  style Default1 fill:#fff3cd\n  style Default2 fill:#fff3cd\n  style Value fill:#c8e6c9</code></pre>"},{"location":"05-evaluation/#emergency-kill-switch-namespace-scoped","title":"Emergency kill switch (namespace-scoped)","text":"<pre><code>Namespace.Global.disableAll()\n// ... all evaluations in this namespace return declared defaults ...\nNamespace.Global.enableAll()\n</code></pre>"},{"location":"05-evaluation/#bucketing-utility-rollout-debugging","title":"Bucketing utility (rollout debugging)","text":"<pre><code>val info = RolloutBucketing.explain(\n    stableId = context.stableId,\n    featureKey = Features.DARK_MODE.key,\n    salt = Namespace.Global.flag(Features.DARK_MODE).salt,\n    rollout = Rampup.of(10.0),\n)\nprintln(info)\n</code></pre>"},{"location":"05-evaluation/#rule-matching-and-semantics","title":"Rule matching (AND semantics)","text":"<p>All specified criteria must match; empty constraint sets match everything.</p> <pre><code>for (rule in rulesSortedBySpecificity) {\n    if (rule.matches(context)) {\n        return rule.value\n    }\n}\nreturn default\n</code></pre>"},{"location":"05-evaluation/#specificity-ordering-most-specific-wins","title":"Specificity ordering (most specific wins)","text":"<p>Rules are sorted by the number of criteria present (platforms/locales/versions/rollout). This makes \u201cmore targeted\u201d rules win over \u201cmore general\u201d rules.</p>"},{"location":"05-evaluation/#performance-model","title":"Performance model","text":"<p>The evaluation path is designed to be constant-time in typical usage: - Registry lookup: O(1) - Rule iteration: O(n) where n is rules per flag (typically small) - Rollout bucketing: O(1) SHA-256 hash</p> <p>Space model: - no allocations during evaluation - immutable, pre-built rule structures</p>"},{"location":"05-evaluation/#concurrency-model","title":"Concurrency model","text":"<p>Evaluation is designed for concurrent reads: - Lock-free reads: evaluation does not require synchronization. - Atomic updates: configuration updates swap the active snapshot atomically (<code>Namespace.load</code>).</p> <pre><code>// Thread 1\nNamespace.Global.load(newConfig)\n\n// Thread 2 (during update)\nval value = feature { Features.DARK_MODE } // sees old OR new, never a mixed state\n</code></pre>"},{"location":"05-evaluation/#testing-evaluation","title":"Testing evaluation","text":""},{"location":"05-evaluation/#rule-matching","title":"Rule matching","text":"<pre><code>@Test\nfun `iOS users in US get dark mode`() {\n    val context = Context(\n        locale = AppLocale.UNITED_STATES,\n        platform = Platform.IOS,\n        appVersion = Version.parse(\"2.1.0\"),\n        stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n    )\n\n    val enabled = feature { Features.DARK_MODE }\n    assertTrue(enabled)\n}\n</code></pre>"},{"location":"05-evaluation/#determinism","title":"Determinism","text":"<pre><code>@Test\nfun `evaluation is deterministic`() {\n    val context = Context(/*...*/)\n    val results = (1..100).map { feature { Features.DARK_MODE } }\n    assertTrue(results.distinct().size == 1, \"Non-deterministic!\")\n}\n</code></pre>"},{"location":"05-evaluation/#rollout-distribution-statistical-sanity-check","title":"Rollout distribution (statistical sanity check)","text":"<pre><code>@Test\nfun `50 percent rollout distributes correctly`() {\n    val sampleSize = 10_000\n    val enabled = (0 until sampleSize).count { i -&gt;\n        val ctx = Context(/*..., */\n                          stableId = StableId.of(i.toString(16).padStart(32, '0'))\n        )\n        feature { Features.ROLLOUT_FLAG }\n    }\n\n    val percentage = (enabled.toDouble() / sampleSize) * 100\n    assertTrue(percentage in 48.0..52.0)\n}\n</code></pre>"},{"location":"05-evaluation/#guarantees-and-boundaries","title":"Guarantees (and boundaries)","text":"Aspect Guarantee Boundary Type safety return type matches definition compile-time for statically-defined flags Non-null evaluation never returns null relies on required defaults Determinism same inputs \u2192 same outputs excludes malformed runtime JSON (see remote config) Updates atomic swap of configuration correctness depends on using <code>Namespace.load</code>"},{"location":"05-evaluation/#next-steps","title":"Next steps","text":"<ul> <li>Understand rollouts and bucketing inputs: \"Targeting &amp; Rollouts\"</li> <li>Add runtime-validated JSON configuration: \"Remote Configuration\"</li> </ul>"},{"location":"06-remote-config/","title":"Remote Configuration","text":"<p>Konditional supports dynamic configuration via JSON, but treats JSON as a trust boundary: - compile-time guarantees apply to statically-defined flags and rules - runtime JSON is accepted only after validation (<code>ParseResult.Success</code>), otherwise rejected (<code>ParseResult.Failure</code>)</p>"},{"location":"06-remote-config/#the-lifecycle-end-to-end","title":"The lifecycle (end-to-end)","text":"<pre><code>flowchart LR\n  Code[\"Flags defined in code\"] --&gt; Snap[\"SnapshotSerializer.serialize(...)\"]\n  Snap --&gt; Json[\"JSON snapshot\"]\n  Json --&gt; Parse[\"SnapshotSerializer.fromJson(json)\"]\n  Parse --&gt;|Success| Load[\"Namespace.load(snapshot)\"]\n  Parse --&gt;|Failure| Reject[\"Keep last-known-good + log\"]\n  Load --&gt; Eval[\"Evaluation uses active snapshot\"]\n  style Load fill:#c8e6c9\n  style Reject fill:#ffcdd2</code></pre>"},{"location":"06-remote-config/#exporting-configuration","title":"Exporting configuration","text":"<pre><code>val json = SnapshotSerializer.serialize(Namespace.Global.configuration)\n</code></pre> <p>Use this when you want to externalize a namespace\u2019s current configuration state into JSON for storage or transport.</p>"},{"location":"06-remote-config/#loading-configuration-validated-boundary","title":"Loading configuration (validated boundary)","text":"<pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre> <p>The contract is explicit: - Success means you have a type-correct, internally consistent snapshot representation (validated at the boundary). - Failure means the payload is rejected before it can affect evaluation.</p>"},{"location":"06-remote-config/#incremental-updates-via-patching","title":"Incremental updates via patching","text":"<pre><code>when (val result = SnapshotSerializer.applyPatchJson(currentConfig, patchJson)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre> <p>This supports applying incremental JSON updates, then atomically swapping the active configuration via <code>Namespace.load</code>.</p>"},{"location":"06-remote-config/#error-handling-model-parseresult","title":"Error handling model (<code>ParseResult</code>)","text":"<p>Remote configuration is designed to force explicit handling of invalid input:</p> <pre><code>sealed class ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;()\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;()\n}\n</code></pre> <p>Operationally, treat failures as non-fatal: keep last-known-good configuration, log for alerting, and retry on the next update.</p>"},{"location":"06-remote-config/#hot-reload-semantics-atomicity","title":"Hot-reload semantics (atomicity)","text":"<p><code>Namespace.load(newConfiguration)</code> applies updates with atomic replacement semantics: - readers see either the old snapshot or the new snapshot - readers never see a partially-applied configuration</p> <p>This aligns with the evaluation model documented in \"Evaluation\".</p>"},{"location":"06-remote-config/#lenient-deserialization-forward-compatibility","title":"Lenient deserialization (forward compatibility)","text":"<p>During migrations, you may prefer to skip unknown keys instead of failing the entire snapshot:</p> <pre><code>val options = SnapshotLoadOptions.skipUnknownKeys { warning -&gt;\n    log.warn(\"Skipping unknown key: ${warning.key}\")\n}\n\nwhen (val result = SnapshotSerializer.fromJson(json, options)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre> <p>This preserves strict correctness by default while enabling operationally-safe forward compatibility when needed.</p>"},{"location":"06-remote-config/#versioning-metadata-audit-rollback","title":"Versioning metadata (audit + rollback)","text":"<p>Snapshots optionally carry <code>meta</code> fields (version, timestamp, source). You can also attach metadata after parsing:</p> <pre><code>when (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(\n        result.value.withMetadata(\n            version = \"rev-123\",\n            source = \"s3://configs/global.json\",\n        )\n    )\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre>"},{"location":"06-remote-config/#whats-validated-and-what-is-not","title":"What\u2019s validated (and what is not)","text":"<p>Validated at the boundary: - JSON syntax validity - schema/structure validity - value type checking against declared feature types</p> <p>Not validated by the type system: - semantic correctness (e.g., whether 50% is the intended rollout) - business correctness (e.g., whether the targeted segment is correct)</p>"},{"location":"06-remote-config/#integration-patterns","title":"Integration patterns","text":""},{"location":"06-remote-config/#polling","title":"Polling","text":"<pre><code>while (running) {\n    val json = fetchFromServer()\n    when (val result = SnapshotSerializer.fromJson(json)) {\n        is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n        is ParseResult.Failure -&gt; log.error(\"Config parse failed: ${result.error}\")\n    }\n    delay(pollInterval)\n}\n</code></pre>"},{"location":"06-remote-config/#push-based-streams","title":"Push-based (streams)","text":"<pre><code>configStream.collect { json -&gt;\n    when (val result = SnapshotSerializer.fromJson(json)) {\n        is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n        is ParseResult.Failure -&gt; log.error(\"Config parse failed: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"06-remote-config/#where-kontracts-fits","title":"Where Kontracts fits","text":"<p>Konditional uses Kontracts (a standalone, zero-dependency JSON Schema DSL) for schema validation of configuration payloads.</p>"},{"location":"06-remote-config/#next-steps","title":"Next steps","text":"<ul> <li>Understand the \u201cif it compiles\u201d claim boundary: \"Theory\"</li> <li>Understand bucketing determinism inputs: \"Targeting &amp; Rollouts\"</li> <li>See the concrete snapshot/patch payload shapes: \"Persistence &amp; Storage Format\"</li> </ul>"},{"location":"07-theory/","title":"Theory: What \u201cIf it compiles, it works\u201d means","text":"<p>Konditional\u2019s core claim is intentionally narrow and testable: for statically-defined flags and rules, the compiler enforces type correctness and evaluation is non-null. When configuration crosses the JSON boundary, correctness is established via validation and explicit error handling (<code>ParseResult</code>), not via compile-time guarantees.</p> <pre><code>flowchart LR\n    Code[\"Flags + rules defined in code\"] --&gt; CT[\"Compile-time guarantees\"]\n    CT --&gt; Eval[\"Evaluation returns typed, non-null values\"]\n    Json[\"JSON payload\"] --&gt; RT[\"Runtime validation boundary\"]\n    RT --&gt;|Success| Load[\"Namespace.load(snapshot)\"]\n    RT --&gt;|Failure| Reject[\"Reject before evaluation\"]\n    style CT fill: #e1f5ff\n    style RT fill: #fff3cd\n    style Reject fill: #ffcdd2</code></pre>"},{"location":"07-theory/#the-three-failures-of-stringly-typed-flags","title":"The three failures of stringly-typed flags","text":"<p>Traditional flag systems are stringly-typed: a string key selects a value and the caller chooses a typed getter. That architecture introduces three classes of runtime failure:</p> <ol> <li>Key mismatch: <code>\"dark_mode\"</code> vs <code>\"darkMode\"</code> silently returns a default or null.</li> <li>Type mismatch: retrieving a boolean flag as a string is syntactically valid but semantically wrong.</li> <li>Null propagation: missing configurations surface as <code>null</code> and leak into business logic.</li> </ol> <p>Konditional targets this gap: prevent categories of runtime failure by moving key/type binding into the type system.</p>"},{"location":"07-theory/#mechanism-1-property-delegation-binds-identity-type","title":"Mechanism 1: Property delegation binds identity + type","text":"<p>Flags are delegated properties in a <code>FeatureContainer</code>:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val darkMode by boolean(default = false)\n    val timeout by double(default = 30.0)\n    val maxRetries by int(default = 3)\n}\n</code></pre> <p>Because the delegate (<code>boolean</code>, <code>double</code>, <code>int</code>, \u2026) determines the type parameter, the compiler knows the declared type at the definition site and carries it forward.</p> <p>Guarantee: the declared type of a feature is statically known and cannot drift without code changes the compiler re-checks.</p>"},{"location":"07-theory/#mechanism-2-rule-return-types-are-constrained","title":"Mechanism 2: Rule return types are constrained","text":"<p>Rules must return a value of the feature\u2019s declared type:</p> <pre><code>val timeout by double(default = 30.0) {\n    rule { platforms(Platform.ANDROID) } returns 45.0\n}\n</code></pre> <p>Guarantee: statically-defined rule return values are type-checked at compile time.</p> <p>Boundary: this applies to rules defined in code; JSON-loaded configurations are validated at the parse boundary.</p>"},{"location":"07-theory/#mechanism-3-evaluation-site-preserves-the-concrete-type","title":"Mechanism 3: Evaluation site preserves the concrete type","text":"<p>Evaluation preserves the type parameter from definition to usage:</p> <pre><code>val isDarkMode: Boolean = feature { AppFeatures.darkMode }\nval timeout: Double = feature { AppFeatures.timeout }\n</code></pre> <p>Guarantee: no casts are required at call sites; incompatible assignments are compile errors.</p>"},{"location":"07-theory/#mechanism-4-required-defaults-eliminate-nulls","title":"Mechanism 4: Required defaults eliminate nulls","text":"<p>Every feature requires a default:</p> <pre><code>val darkMode by boolean(default = false)\n</code></pre> <p>Guarantee: evaluation is total\u2014if no rules match, the default is returned\u2014and does not return null.</p>"},{"location":"07-theory/#mechanism-5-namespace-isolation-is-structural","title":"Mechanism 5: Namespace isolation is structural","text":"<p>Containers are bound to a namespace type, and namespaces have separate registries:</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) { ... }\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) { ... }\n</code></pre> <p>Guarantee: feature key collisions across namespaces cannot occur (separate registries bound at the type level).</p> <p>Boundary: defining conflicting keys within the same namespace is a design error that can be detected at runtime during registration.</p>"},{"location":"07-theory/#the-trust-boundary-runtime-json","title":"The trust boundary: runtime JSON","text":"<p>When configuration is loaded from JSON, compile-time guarantees necessarily end. Konditional establishes correctness at the boundary:</p> <pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Parse failed: ${result.error}\")\n}\n</code></pre> <p>The guarantee is qualified:</p> <ul> <li> <p>Guaranteed: invalid JSON is detected and rejected before it can affect evaluation.</p> </li> <li> <p>Not guaranteed: Semantic correctness of the configuration (rollout percentage, targeting intent, business   correctness).</p> </li> </ul>"},{"location":"07-theory/#summary-what-is-guaranteed-vs-what-is-not","title":"Summary: what is guaranteed vs what is not","text":"Claim Guarantee level Mechanism No typos in flag keys Compile-time property access, not strings Return type matches definition Compile-time generic type propagation Rule return types are correct Compile-time constrained rule DSL Evaluation is never null Compile-time required defaults Namespace isolation Compile-time type-bound containers + separate registries Remote config type safety Runtime (validated boundary) <code>ParseResult.Success</code> / <code>Failure</code> Semantic correctness of configs Not guaranteed human/process responsibility"},{"location":"07-theory/#next-steps","title":"Next steps","text":"<ul> <li>See the runtime boundary mechanics: \"Remote Configuration\"</li> <li>See deterministic behavior and concurrency claims in practice: \"Evaluation\"</li> </ul>"},{"location":"08-persistence-format/","title":"Persistence &amp; Storage Format","text":"<p>This page documents the JSON formats used to persist and transport Konditional configuration:</p> <ul> <li>Snapshot: the full configuration payload (<code>SnapshotSerializer.serialize(...)</code>)</li> <li>Patch: an incremental update payload (<code>SnapshotSerializer.applyPatchJson(...)</code>)</li> </ul> <p>These formats are intentionally storage-agnostic: you can store the JSON in files, a database, or ship it over the network.</p>"},{"location":"08-persistence-format/#mental-model-what-is-persisted","title":"Mental model: what is persisted","text":"<p>At persistence time, the library serializes a list of flag definitions:</p> <pre><code>flowchart LR\n    Snap[Snapshot JSON] --&gt; Flags[\"flags: List{SerializableFlag}\"]\n    Snap --&gt; Meta[\"meta: SerializableSnapshotMetadata?\"]\n    Flags --&gt; Flag[\"SerializableFlag\"]\n    Flag --&gt; Key[\"key: Identifier\"]\n    Flag --&gt; Default[\"defaultValue: FlagValue\"]\n    Flag --&gt; Salt[\"salt: String\"]\n    Flag --&gt; Active[\"isActive: Boolean\"]\n    Flag --&gt; Rules\n    Rules --&gt; Rule[\"SerializableRule\"]\n    Rule --&gt; RVal[\"value: FlagValue\"]\n    Rule --&gt; Ramp[\"rampUp: Double\"]\n    Rule --&gt; Note[\"note: String?\"]\n    Rule --&gt; Loc[\"locales: Set{String}\"]\n    Rule --&gt; Plat[\"platforms: Set{String}\"]\n    Rule --&gt; Vr[\"versionRange: VersionRange?\"]\n    Rule --&gt; Axes[\"axes: Map{String, Set{String}}\"]\n</code></pre>"},{"location":"08-persistence-format/#identifier-format-key","title":"Identifier format (<code>key</code>)","text":"<p>Each flag is stored under a stable Identifier string:</p> <pre><code>value::${namespaceIdentifierSeed}::${featureKey}\n</code></pre> <p>Where:</p> <ul> <li><code>${namespaceIdentifierSeed}</code> is <code>Namespace.identifierSeed</code> (defaults to the namespace <code>id</code>)</li> <li><code>${featureKey}</code> is the feature key (typically the Kotlin property name)</li> </ul> <p>Example (Global namespace, <code>DARK_MODE</code>):</p> <pre><code>value::global::DARK_MODE\n</code></pre>"},{"location":"08-persistence-format/#value-encoding-flagvalue","title":"Value encoding (<code>FlagValue</code>)","text":"<p>Both <code>defaultValue</code> and each rule\u2019s <code>value</code> are encoded as a tagged object:</p> <pre><code>{\n  \"type\": \"BOOLEAN\",\n  \"value\": true\n}\n</code></pre> <p>Supported shapes:</p> Kind JSON shape Boolean <code>{ \"type\": \"BOOLEAN\", \"value\": ${boolean} }</code> String <code>{ \"type\": \"STRING\", \"value\": \"${string}\" }</code> Int <code>{ \"type\": \"INT\", \"value\": ${int} }</code> Double <code>{ \"type\": \"DOUBLE\", \"value\": ${double} }</code> Enum <code>{ \"type\": \"ENUM\", \"value\": \"${enumName}\", \"enumClassName\": \"${fqcn}\" }</code> Data class <code>{ \"type\": \"DATA_CLASS\", \"dataClassName\": \"${fqcn}\", \"value\": { ...primitive fields... } }</code> <p>The <code>DATA_CLASS</code> representation stores a primitive map of fields along with the fully qualified class name.</p>"},{"location":"08-persistence-format/#version-range-encoding-versionrange","title":"Version range encoding (<code>versionRange</code>)","text":"<p>Rules may include a <code>versionRange</code> object. It uses a discriminator and optional bounds:</p> <pre><code>{\n  \"type\": \"MIN_AND_MAX_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  },\n  \"max\": {\n    \"major\": 4,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre> <p>Valid <code>type</code> values:</p> <ul> <li><code>UNBOUNDED</code></li> <li><code>MIN_BOUND</code> (requires <code>min</code>)</li> <li><code>MAX_BOUND</code> (requires <code>max</code>)</li> <li><code>MIN_AND_MAX_BOUND</code> (requires <code>min</code> and <code>max</code>)</li> </ul>"},{"location":"08-persistence-format/#generic-templates-kotlin-style","title":"Generic templates (Kotlin-style)","text":""},{"location":"08-persistence-format/#snapshot-template","title":"Snapshot template","text":"<pre><code>val snapshotJson = \"\"\"\n{\n  \"meta\": {\n    \"version\": \"${optionalVersionOrNull}\",\n    \"generatedAtEpochMillis\": ${optionalEpochMillisOrNull},\n    \"source\": \"${optionalSourceOrNull}\"\n  },\n  \"flags\": [\n    {\n      \"key\": \"value::${namespaceSeed}::${featureKey}\",\n      \"defaultValue\": {\n        \"type\": \"${valueType}\",\n        \"value\": ${defaultValueJson},\n        \"...\": \"${typeSpecificFields}\"\n      },\n      \"salt\": \"${salt}\",\n      \"isActive\": ${isActive},\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"${valueType}\",\n            \"value\": ${ruleValueJson},\n            \"...\": \"${typeSpecificFields}\"\n          },\n          \"rampUp\": ${rolloutPercent},\n          \"note\": \"${optionalNoteOrNull}\",\n          \"locales\": [\"${APP_LOCALE_ENUM_NAME}\", \"...\"],\n          \"platforms\": [\"${PLATFORM_ENUM_NAME}\", \"...\"],\n          \"axes\": {\n            \"${axisId}\": [\"${axisValueId}\", \"...\"]\n          },\n          \"versionRange\": {\n            \"type\": \"${UNBOUNDED|MIN_BOUND|MAX_BOUND|MIN_AND_MAX_BOUND}\",\n            \"min\": { \"major\": ${minMajor}, \"minor\": ${minMinor}, \"patch\": ${minPatch} },\n            \"max\": { \"major\": ${maxMajor}, \"minor\": ${maxMinor}, \"patch\": ${maxPatch} }\n          }\n        }\n      ]\n    }\n  ]\n}\n\"\"\"\n</code></pre>"},{"location":"08-persistence-format/#patch-template","title":"Patch template","text":"<pre><code>val patchJson = \"\"\"\n{\n  \"meta\": {\n    \"version\": \"${optionalVersionOrNull}\",\n    \"generatedAtEpochMillis\": ${optionalEpochMillisOrNull},\n    \"source\": \"${optionalSourceOrNull}\"\n  },\n  \"flags\": [\n    { \"...\": \"SerializableFlag objects (same shape as snapshot)\" }\n  ],\n  \"removeKeys\": [\n    \"value::${namespaceSeed}::${featureKeyToRemove}\",\n    \"value::${namespaceSeed}::${anotherKey}\"\n  ]\n}\n\"\"\"\n</code></pre>"},{"location":"08-persistence-format/#parse-boundary-and-failure-modes","title":"Parse boundary and failure modes","text":"<p>Deserialization reconstructs configurations by looking up each <code>key</code> in an internal registry of known features.</p> <ul> <li>If a key is not registered, parsing fails with <code>ParseError.FeatureNotFound</code>.</li> <li>JSON syntax/shape errors fail with <code>ParseError.InvalidJson</code> / <code>ParseError.InvalidSnapshot</code>.</li> </ul> <p>Operationally: treat parse failures as \u201creject update, keep last-known-good\u201d.</p>"},{"location":"08-persistence-format/#snapshot-metadata-meta","title":"Snapshot metadata (<code>meta</code>)","text":"<p>Snapshots and patches may include an optional <code>meta</code> object:</p> <pre><code>{\n  \"meta\": {\n    \"version\": \"rev-123\",\n    \"generatedAtEpochMillis\": 1700000000000,\n    \"source\": \"s3://configs/global.json\"\n  },\n  \"flags\": []\n}\n</code></pre>"},{"location":"08-persistence-format/#json-examples","title":"JSON examples","text":"Snapshot: booleans + string variants, with version ranges <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"value::global::DARK_MODE\",\n      \"defaultValue\": { \"type\": \"BOOLEAN\", \"value\": false },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": { \"type\": \"BOOLEAN\", \"value\": true },\n          \"rampUp\": 50.0,\n          \"note\": \"iOS gradual rollout\",\n          \"locales\": [\"UNITED_STATES\"],\n          \"platforms\": [\"IOS\"],\n          \"versionRange\": { \"type\": \"MIN_BOUND\", \"min\": { \"major\": 2, \"minor\": 0, \"patch\": 0 } }\n        }\n      ]\n    },\n    {\n      \"key\": \"value::global::API_ENDPOINT\",\n      \"defaultValue\": { \"type\": \"STRING\", \"value\": \"https://api.example.com\" },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": { \"type\": \"STRING\", \"value\": \"https://api-ios.example.com\" },\n          \"rampUp\": 100.0,\n          \"note\": \"iOS endpoint\",\n          \"locales\": [],\n          \"platforms\": [\"IOS\"],\n          \"versionRange\": { \"type\": \"UNBOUNDED\" }\n        },\n        {\n          \"value\": { \"type\": \"STRING\", \"value\": \"https://api-android.example.com\" },\n          \"rampUp\": 100.0,\n          \"note\": \"Android endpoint\",\n          \"locales\": [],\n          \"platforms\": [\"ANDROID\"],\n          \"versionRange\": { \"type\": \"UNBOUNDED\" }\n        }\n      ]\n    }\n  ]\n}\n</code></pre> Snapshot: enum value payload <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"value::global::THEME\",\n      \"defaultValue\": {\n        \"type\": \"ENUM\",\n        \"value\": \"LIGHT\",\n        \"enumClassName\": \"com.example.Theme\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"ENUM\",\n            \"value\": \"DARK\",\n            \"enumClassName\": \"com.example.Theme\"\n          },\n          \"rampUp\": 100.0,\n          \"note\": \"Dark theme for iOS\",\n          \"locales\": [],\n          \"platforms\": [\"IOS\"],\n          \"versionRange\": { \"type\": \"UNBOUNDED\" }\n        }\n      ]\n    }\n  ]\n}\n</code></pre> Patch: update one flag, remove one flag <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"value::global::DARK_MODE\",\n      \"defaultValue\": { \"type\": \"BOOLEAN\", \"value\": false },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": { \"type\": \"BOOLEAN\", \"value\": true },\n          \"rampUp\": 100.0,\n          \"note\": \"Rollout complete\",\n          \"locales\": [],\n          \"platforms\": [],\n          \"versionRange\": { \"type\": \"UNBOUNDED\" }\n        }\n      ]\n    }\n  ],\n  \"removeKeys\": [\n    \"value::global::LEGACY_SUPPORT\"\n  ]\n}\n</code></pre> Consumer Configuration Lifecycle Sample <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"value::consumer-lifecycle-3f02840e-abd0-4447-9bdc-0a8f41ca530e::darkMode\",\n      \"defaultValue\": {\n        \"type\": \"BOOLEAN\",\n        \"value\": false\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"BOOLEAN\",\n            \"value\": true\n          },\n          \"rampUp\": 100.0,\n          \"note\": \"iOS fully enabled\",\n          \"locales\": [],\n          \"platforms\": [\n            \"IOS\"\n          ],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          }\n        }\n      ]\n    },\n    {\n      \"key\": \"value::consumer-lifecycle-3f02840e-abd0-4447-9bdc-0a8f41ca530e::apiEndpoint\",\n      \"defaultValue\": {\n        \"type\": \"STRING\",\n        \"value\": \"https://api.example.com\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"STRING\",\n            \"value\": \"https://api-web.example.com\"\n          },\n          \"rampUp\": 100.0,\n          \"note\": \"Web endpoint override\",\n          \"locales\": [],\n          \"platforms\": [\n            \"WEB\"\n          ],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          }\n        }\n      ]\n    },\n    {\n      \"key\": \"value::consumer-lifecycle-3f02840e-abd0-4447-9bdc-0a8f41ca530e::maxRetries\",\n      \"defaultValue\": {\n        \"type\": \"INT\",\n        \"value\": 3\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"INT\",\n            \"value\": 5\n          },\n          \"rampUp\": 100.0,\n          \"note\": \"More retries on v2+\",\n          \"locales\": [],\n          \"platforms\": [],\n          \"versionRange\": {\n            \"type\": \"MIN_BOUND\",\n            \"min\": {\n              \"major\": 2,\n              \"minor\": 0,\n              \"patch\": 0\n            }\n          }\n        }\n      ]\n    },\n    {\n      \"key\": \"value::consumer-lifecycle-3f02840e-abd0-4447-9bdc-0a8f41ca530e::theme\",\n      \"defaultValue\": {\n        \"type\": \"ENUM\",\n        \"value\": \"LIGHT\",\n        \"enumClassName\": \"io.amichne.konditional.serialization.ConsumerConfigurationLifecycleTest$Theme\"\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"ENUM\",\n            \"value\": \"DARK\",\n            \"enumClassName\": \"io.amichne.konditional.serialization.ConsumerConfigurationLifecycleTest$Theme\"\n          },\n          \"rampUp\": 100.0,\n          \"note\": \"Dark theme for FR locale\",\n          \"locales\": [\n            \"FRANCE\"\n          ],\n          \"platforms\": [],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          }\n        }\n      ]\n    },\n    {\n      \"key\": \"value::consumer-lifecycle-3f02840e-abd0-4447-9bdc-0a8f41ca530e::userSettings\",\n      \"defaultValue\": {\n        \"type\": \"DATA_CLASS\",\n        \"dataClassName\": \"io.amichne.konditional.serialization.ConsumerConfigurationLifecycleTest$UserSettings\",\n        \"value\": {\n          \"enabled\": true,\n          \"maxRetries\": 3.0,\n          \"theme\": \"light\",\n          \"timeoutSeconds\": 30.0\n        }\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"DATA_CLASS\",\n            \"dataClassName\": \"io.amichne.konditional.serialization.ConsumerConfigurationLifecycleTest$UserSettings\",\n            \"value\": {\n              \"enabled\": false,\n              \"maxRetries\": 5.0,\n              \"theme\": \"dark\",\n              \"timeoutSeconds\": 10.0\n            }\n          },\n          \"rampUp\": 100.0,\n          \"note\": \"Custom settings for iOS\",\n          \"locales\": [],\n          \"platforms\": [\n            \"IOS\"\n          ],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"09-why-konditional/","title":"Why Konditional Exists","text":""},{"location":"09-why-konditional/#the-problem","title":"The Problem","text":"<p>Feature flags and configuration systems seem simple until they bite you in production. Here's what actually happens:</p>"},{"location":"09-why-konditional/#string-keyed-systems-create-invisible-failure-modes","title":"String-keyed systems create invisible failure modes","text":"<pre><code>// Somewhere in onboarding code\nval newFlow = flagClient.getBool(\"new_onboaring_flow\", false)  // typo\n\n// Somewhere in analytics\ntrack(\"new_onboarding_flow_completed\")  // correct spelling\n\n// Somewhere in config JSON\n{\"new_onboarding_flow\": true}  // correct spelling\n</code></pre> <p>The typo ships. The flag never activates. Your A/B test runs for weeks with 0% treatment. Nobody notices until you check the results.</p> <p>String keys fail silently. The compiler can't help you. Your IDE can't help you. You find out in production or in post-mortems.</p>"},{"location":"09-why-konditional/#boolean-only-systems-turn-into-boolean-matrices","title":"Boolean-only systems turn into boolean matrices","text":"<p>You start clean:</p> <pre><code>enum class Capability {\n    NEW_CHECKOUT\n}\n</code></pre> <p>Then you need variants:</p> <pre><code>enum class Capability {\n    NEW_CHECKOUT,\n    NEW_CHECKOUT_V2,\n    NEW_CHECKOUT_V3,\n    CHECKOUT_FAST_PATH,\n    CHECKOUT_STRIPE_INTEGRATION\n}\n\n// And now your code looks like:\nif (isEnabled(NEW_CHECKOUT) &amp;&amp; !isEnabled(NEW_CHECKOUT_V2)) {\n    // original new checkout\n} else if (isEnabled(NEW_CHECKOUT_V2) &amp;&amp; !isEnabled(CHECKOUT_FAST_PATH)) {\n    // v2 without fast path\n} else if (isEnabled(NEW_CHECKOUT_V3) || isEnabled(CHECKOUT_FAST_PATH)) {\n    // ... which logic wins?\n}\n</code></pre> <p>Boolean-only forces you to encode variants as control flow. Every combination requires explicit handling. Testing becomes exponential. Bugs hide in interactions.</p>"},{"location":"09-why-konditional/#each-team-reimplements-rollout-logic-differently","title":"Each team reimplements rollout logic differently","text":"<p>The account team implements rollouts with modulo arithmetic. The payments team uses random number generators. The growth team copies some Stack Overflow answer. Each has different edge cases:</p> <ul> <li>Do they bucket consistently for the same user?</li> <li>Can you replay decisions deterministically in logs?</li> <li>Does the same user get the same experience on web and mobile?</li> <li>What happens when you change the percentage?</li> </ul> <p>Inconsistent rollout semantics create A/B testing landmines. Results become untrustworthy. Debugging requires reading five different implementations.</p>"},{"location":"09-why-konditional/#type-safety-disappears-at-the-boundary","title":"Type safety disappears at the boundary","text":"<pre><code>// You define this\nval maxRetries: Int = flagClient.getInt(\"max_retries\", 3)\n\n// Someone deploys this\n{\"max_retries\": \"five\"}\n\n// Production gets this\nmaxRetries = 0  // or throws, or returns default, depends on the SDK\n</code></pre> <p>Runtime configuration breaks compile-time contracts. JSON is stringly-typed. Your code expects ints. The gap causes incidents.</p>"},{"location":"09-why-konditional/#what-konditional-does-differently","title":"What Konditional Does Differently","text":"<p>Konditional makes three structural commitments:</p> <ol> <li>Flags are properties, not strings \u2014 keys are bound at compile-time</li> <li>Types flow from definitions to callsites \u2014 no type casting or runtime coercion</li> <li>One evaluation semantics for the entire codebase \u2014 centralized, deterministic, testable</li> </ol> <pre><code>object AppFlags : FeatureContainer() {\n    val NEW_CHECKOUT by string(default = \"classic\") {\n        rule { platforms(Platform.MOBILE) } returns \"optimized\"\n        rule { rollout { 50.0 } } returns \"experimental\"\n    }\n\n    val MAX_RETRIES by int(default = 3) {\n        rule { platforms(Platform.WEB) } returns 5\n    }\n}\n\n// Usage\nval checkoutMode: String = AppFlags.NEW_CHECKOUT.value(ctx)  // typed, cannot be wrong\nval retries: Int = AppFlags.MAX_RETRIES.value(ctx)           // typed, cannot be wrong\n</code></pre>"},{"location":"09-why-konditional/#what-you-get","title":"What you get","text":"<p>Typos become compile errors: <pre><code>AppFlags.NEW_ONBOARING_FLOW  // doesn't compile\n</code></pre></p> <p>Type mismatches become compile errors: <pre><code>val retries: String = AppFlags.MAX_RETRIES.value(ctx)  // doesn't compile\n</code></pre></p> <p>Variants are values, not boolean matrices: <pre><code>when (AppFlags.NEW_CHECKOUT.value(ctx)) {\n    \"classic\" -&gt; classicCheckout()\n    \"optimized\" -&gt; optimizedCheckout()\n    \"experimental\" -&gt; experimentalCheckout()\n}\n</code></pre></p> <p>Rollouts are deterministic and consistent: <pre><code>// Same user, same flag, same percentage \u2192 same bucket\n// SHA-256(\"$userId:$flagKey:$salt\") determines bucket\n// No random numbers, no modulo edge cases, reproducible in logs\n</code></pre></p> <p>Configuration boundaries are explicit: <pre><code>when (val result = SnapshotSerializer.fromJson(remoteConfig)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; {\n        // Invalid JSON rejected, last-known-good remains active\n        logError(\"Config parse failed: ${result.error}\")\n    }\n}\n</code></pre></p>"},{"location":"09-why-konditional/#comparison-to-alternatives","title":"Comparison to Alternatives","text":"Aspect String-keyed SDKs Enum + boolean capabilities Konditional Typo safety Runtime failure (silent or crash) Compile-time (enum typos caught) Compile-time (property references) Type safety Runtime coercion (often unsafe) Boolean only Compile-time types (Boolean/String/Int/Double/Enum/custom) Variants Supported but runtime-typed Requires multiple booleans + control flow First-class typed values Rollout logic SDK-dependent, varies Reimplemented per domain/team Centralized, deterministic (SHA-256 bucketing) Evaluation semantics SDK-defined, often opaque Ad-hoc per evaluator (account, card, merchant, etc.) Single DSL with specificity ordering Configuration drift Implicit boundary, often fails silently Ad-hoc validation per evaluator Explicit <code>ParseResult</code> boundary, rejects invalid JSON Null/missing values Depends on SDK (null, exception, or default) Depends on implementation Total evaluation (defaults required, no null returns) Testing Mock SDK or replay config snapshots Mock evaluators or stub booleans Evaluate against typed contexts (deterministic, no mocks needed) Consistency Depends on SDK discipline and process Depends on how many evaluators you maintain One rule DSL, one evaluation engine, one set of semantics"},{"location":"09-why-konditional/#why-this-matters","title":"Why This Matters","text":""},{"location":"09-why-konditional/#for-engineers-writing-features","title":"For engineers writing features","text":"<ul> <li>Autocomplete works: Your IDE shows available flags. You can't reference flags that don't exist.</li> <li>Types flow: Return types are known at compile-time. No casting, no runtime surprises.</li> <li>Refactoring is safe: Rename a flag property and all callsites update. No grep-and-hope.</li> </ul>"},{"location":"09-why-konditional/#for-teams-running-experiments","title":"For teams running experiments","text":"<ul> <li>Rollouts are reproducible: Same user always gets same bucket. You can replay decisions from logs.</li> <li>Percentages are stable: Changing 10% \u2192 20% doesn't reshuffle existing users.</li> <li>Targeting is consistent: Platform/locale/version targeting works the same across all flags.</li> </ul>"},{"location":"09-why-konditional/#for-systems-that-grow","title":"For systems that grow","text":"<ul> <li>No boolean explosion: Variants are values, not combinatorial boolean checks.</li> <li>No evaluation logic duplication: One DSL, one evaluation engine, shared across all domains.</li> <li>Clear boundaries: Compile-time correctness for definitions. Runtime validation for remote config. No blurred lines.</li> </ul>"},{"location":"09-why-konditional/#when-konditional-fits","title":"When Konditional Fits","text":"<p>Choose Konditional when:</p> <ul> <li>You want compile-time correctness for flag definitions and callsites</li> <li>You need typed values beyond on/off booleans (variants, thresholds, configuration)</li> <li>You value consistency over bespoke per-domain solutions</li> <li>You run experiments and need deterministic, reproducible rollouts</li> <li>You have remote configuration and want explicit validation boundaries</li> </ul> <p>Konditional might not fit if:</p> <ul> <li>You need vendor-hosted dashboards more than you need compile-time safety</li> <li>Your flags are fully dynamic with zero static definitions (though you can still use Konditional for the static subset)</li> <li>You're okay with process and tooling to prevent string key drift (code review, linters, integration tests)</li> </ul>"},{"location":"09-why-konditional/#the-three-models-at-a-glance","title":"The Three Models at a Glance","text":"Approach Key/Definition Evaluation Result Main Trade-off String-based <code>\"flag-name\"</code> <code>getVal/...</code> Value (runtime) Flexibility vs. runtime safety Enum-bool <code>enum Capability</code> <code>isEnabled(ctx)</code> Boolean Compile-time keys vs. boolean-only values Konditional Compiled property Rules + default Typed value Static definitions vs. dynamic configuration"},{"location":"09-why-konditional/#real-problems-konditional-prevents","title":"Real Problems Konditional Prevents","text":""},{"location":"09-why-konditional/#production-incident-type-coercion","title":"Production incident: Type coercion","text":"<p>A string-keyed SDK returns <code>0</code> when parsing <code>\"max_retries\": \"disabled\"</code> from JSON. The service retries 0 times. All requests fail immediately. Incident lasts 45 minutes.</p> <p>With Konditional: The JSON parse fails at the boundary. <code>ParseResult.Failure</code> is logged. Last-known-good configuration remains active. No incident.</p>"},{"location":"09-why-konditional/#experiment-contamination-inconsistent-bucketing","title":"Experiment contamination: Inconsistent bucketing","text":"<p>Two teams implement rollouts with different hashing. Same user gets opposite buckets for related features. A/B test results are polluted. Experiment analysis is invalid.</p> <p>With Konditional: All rollouts use the same deterministic SHA-256 bucketing. Same user, same flag, same bucket. Results are clean.</p>"},{"location":"09-why-konditional/#maintenance-burden-boolean-explosion","title":"Maintenance burden: Boolean explosion","text":"<p>A feature has 5 boolean flags for variants. Testing requires 2^5 = 32 combinations. Most combinations are undefined. Bugs hide in interactions. Engineers avoid touching the code.</p> <p>With Konditional: One flag, one typed value, explicit variants. Testing covers defined cases. Code is readable.</p>"},{"location":"09-why-konditional/#configuration-drift-silent-deployment","title":"Configuration drift: Silent deployment","text":"<p>Someone changes <code>\"new_onboarding_flow\"</code> to <code>\"new_onboarding_experience\"</code> in the remote config. Half the codebase uses the old key, half uses the new key. Rollout percentage splits across both. Metrics are nonsense.</p> <p>With Konditional: Flag keys are derived from property names. Renaming the property updates all callsites (compile-time). Remote config uses the same derived key (validated at parse boundary). Drift is impossible.</p>"},{"location":"09-why-konditional/#migration-path","title":"Migration Path","text":"<p>If you're coming from a boolean capability system:</p> <ol> <li> <p>Mirror existing flags as properties in a <code>FeatureContainer</code>:    <pre><code>val FEATURE_X by boolean(default = false)\n</code></pre></p> </li> <li> <p>Centralize evaluation logic into rules:    <pre><code>val FEATURE_X by boolean(default = false) {\n    rule { platforms(Platform.WEB) } returns true\n    rule { rollout { 25.0 } } returns true\n}\n</code></pre></p> </li> <li> <p>Replace boolean matrices with typed values where variants exist:    <pre><code>// Before: CHECKOUT_V1, CHECKOUT_V2, CHECKOUT_V3 (3 booleans)\n// After:\nval CHECKOUT_VERSION by string(default = \"v1\") {\n    rule { rollout { 33.0 } } returns \"v2\"\n    rule { rollout { 66.0 } } returns \"v3\"\n}\n</code></pre></p> </li> <li> <p>Introduce namespaces only if you need independent registries:    <pre><code>sealed class Domain(id: String) : Namespace(id) {\n    data object Account : Domain(\"account\")\n    data object Payments : Domain(\"payments\")\n}\n</code></pre></p> </li> <li> <p>Add remote config with explicit boundaries:    <pre><code>when (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; namespace.load(result.value)\n    is ParseResult.Failure -&gt; keepLastKnownGood()\n}\n</code></pre></p> </li> </ol>"},{"location":"09-why-konditional/#summary","title":"Summary","text":"<p>Feature flags and configuration aren't just \"nice to have\" features. They're load-bearing infrastructure. When they fail, they fail at scale, in production, with user impact.</p> <p>Konditional exists because stringly-typed systems cause production incidents, boolean-only systems create maintenance nightmares, and inconsistent evaluation semantics make experiments untrustworthy.</p> <p>The solution isn't more process or better code review. The solution is structural: bind types at compile-time, centralize evaluation semantics, and draw explicit boundaries between static definitions and dynamic configuration.</p> <p>That's what Konditional does.</p>"},{"location":"venv/lib/python3.14/site-packages/backrefs-5.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/idna-3.11.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/markdown-3.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip-25.3.dist-info/licenses/src/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}