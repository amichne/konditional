{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Konditional","text":"<p>Type-safe, deterministic feature configuration for Kotlin</p> <p>Konditional provides a type-safe, composable API for feature flag management. This document introduces the core concepts and demonstrates common usage patterns.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#features","title":"Features","text":"<p>A Feature represents a configurable flag with a specific value type and evaluation context. Features are the primary interface for defining and evaluating flags.</p> <p>Features are typically organized as enum members for type safety and IDE support:</p> <pre><code>enum class AppFeatures(override val key: String) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ADVANCED_SEARCH(\"advanced_search\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"#context","title":"Context","text":"<p>Context provides the evaluation environment for feature flags. It contains standard targeting dimensions (locale, platform, version, stable ID) and can be extended with custom fields:</p> <pre><code>// Standard context\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\")\n)\n\n// Custom context with domain-specific fields\ndata class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier\n) : Context\n</code></pre>"},{"location":"#rules","title":"Rules","text":"<p>Rules define targeting criteria and rollout strategies. Each rule specifies conditions that must be met for a particular value to be returned:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n    locales(AppLocale.EN_US)\n    versions {\n        min(2, 0, 0)\n    }\n    rollout = Rollout.of(50.0)  // 50% gradual rollout\n    note(\"Mobile-only feature, 50% rollout\")\n}.implies(true)\n</code></pre>"},{"location":"#flag-definitions","title":"Flag Definitions","text":"<p>A FlagDefinition combines a feature with its configured rules and default value. Definitions are created through the DSL and evaluated against a context:</p> <pre><code>config {\n    AppFeatures.DARK_MODE with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS)\n            rollout = Rollout.of(100.0)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#using-the-dsl","title":"Using the DSL","text":"<p>The primary way to configure flags is through the <code>config</code> DSL:</p> <pre><code>config {\n    // Configure a boolean flag\n    AppFeatures.DARK_MODE with {\n        default(false)\n        salt(\"v2\")  // Optional: change to redistribute rollout buckets\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n\n    // Configure a complex type flag\n    AppConfig.API_SETTINGS with {\n        default(ApiSettings(url = \"https://prod.api.example.com\", timeout = 30))\n\n        rule {\n            platforms(Platform.WEB)\n            rollout = Rollout.of(25.0)\n        }.implies(ApiSettings(url = \"https://beta.api.example.com\", timeout = 60))\n    }\n}\n</code></pre>"},{"location":"#building-snapshots","title":"Building Snapshots","text":"<p>For testing or external configuration management, use <code>buildSnapshot</code> to create configurations without loading them:</p> <pre><code>val testConfig = buildSnapshot {\n    AppFeatures.DARK_MODE with {\n        default(true)\n    }\n}\n\n// Use with a test registry\nval testRegistry = FlagRegistry.create(testConfig)\n</code></pre>"},{"location":"#evaluation","title":"Evaluation","text":""},{"location":"#basic-evaluation","title":"Basic Evaluation","text":"<p>Evaluate flags by calling extension functions on your context:</p> <pre><code>// Returns EvaluationResult (Success, FlagNotFound, or EvaluationError)\nval result: EvaluationResult&lt;Boolean&gt; = context.evaluateSafe(AppFeatures.DARK_MODE)\n\nwhen (result) {\n    is EvaluationResult.Success -&gt; println(\"Dark mode: ${result.value}\")\n    is EvaluationResult.FlagNotFound -&gt; println(\"Flag not registered: ${result.key}\")\n    is EvaluationResult.EvaluationError -&gt; println(\"Evaluation failed: ${result.error}\")\n}\n</code></pre>"},{"location":"#convenience-methods","title":"Convenience Methods","text":"<p>For simpler use cases, convenience methods are available:</p> <pre><code>// Returns null on any failure\nval enabled: Boolean? = context.evaluateOrNull(AppFeatures.DARK_MODE)\n\n// Returns default value on failure\nval enabled: Boolean = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n\n// Throws exception on failure (use sparingly)\nval enabled: Boolean = context.evaluateOrThrow(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"#value-types","title":"Value Types","text":"<p>Konditional supports multiple value types through the <code>EncodableValue</code> abstraction.</p>"},{"location":"#primitive-types","title":"Primitive Types","text":"<p>Boolean, String, Int, and Double are supported natively:</p> <pre><code>val booleanFlag: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; = Feature(\"bool\")\nval stringFlag: Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; = Feature(\"string\")\nval intFlag: Feature&lt;EncodableValue.IntEncodeable, Int, Context&gt; = Feature(\"int\")\nval doubleFlag: Feature&lt;EncodableValue.DecimalEncodeable, Double, Context&gt; = Feature(\"double\")\n</code></pre>"},{"location":"#json-object-types","title":"JSON Object Types","text":"<p>Complex data classes can be used via the <code>OfJsonObject</code> feature type:</p> <pre><code>data class ThemeConfig(val primaryColor: String, val fontSize: Int)\n\nval themeFlag: Feature.OfJsonObject&lt;ThemeConfig, Context&gt; =\n    Feature.jsonObject(\"theme\")\n\nconfig {\n    themeFlag with {\n        default(ThemeConfig(primaryColor = \"#FFFFFF\", fontSize = 14))\n    }\n}\n</code></pre>"},{"location":"#custom-wrapper-types","title":"Custom Wrapper Types","text":"<p>Extend primitives with domain-specific wrappers:</p> <pre><code>data class ApiUrl(val value: String)\n\nval urlFlag: Feature.OfCustom&lt;ApiUrl, String, Context&gt; =\n    Feature.custom(\"api_url\")\n\nconfig {\n    urlFlag with {\n        default(\n            ApiUrl(\"https://prod.example.com\").asCustomString()\n                .encoder { it.value }\n                .decoder { ApiUrl(it) }\n        )\n    }\n}\n</code></pre>"},{"location":"#registry-management","title":"Registry Management","text":""},{"location":"#singleton-registry","title":"Singleton Registry","text":"<p>By default, Konditional uses a thread-safe singleton registry:</p> <pre><code>// Load configuration into singleton\nconfig {\n    // ... flag definitions\n}\n\n// Evaluate using singleton (implicit)\ncontext.evaluateSafe(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"#custom-registries","title":"Custom Registries","text":"<p>Create isolated registries for testing or multi-tenant scenarios:</p> <pre><code>// Create empty registry\nval customRegistry = FlagRegistry.create()\n\n// Create with initial configuration\nval customRegistry = FlagRegistry.create(buildSnapshot {\n    AppFeatures.DARK_MODE with { default(true) }\n})\n\n// Evaluate using custom registry\ncontext.evaluateSafe(AppFeatures.DARK_MODE, registry = customRegistry)\n</code></pre>"},{"location":"#dynamic-updates","title":"Dynamic Updates","text":"<p>Update configurations at runtime without restarting:</p> <pre><code>// Update individual flag\nval newDefinition = FlagDefinition(\n    feature = AppFeatures.DARK_MODE,\n    defaultValue = true,\n    bounds = emptyList()\n)\nregistry.update(newDefinition)\n\n// Load complete new configuration\nregistry.load(newConfig)\n\n// Apply incremental patch\nregistry.update(patch)\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>Konditional follows the \"parse, don't validate\" principle with explicit result types.</p>"},{"location":"#evaluationresult","title":"EvaluationResult","text":"<p>The primary result type for flag evaluation:</p> <pre><code>sealed interface EvaluationResult&lt;out S&gt; {\n    data class Success&lt;S&gt;(val value: S) : EvaluationResult&lt;S&gt;\n    data class FlagNotFound(val key: String) : EvaluationResult&lt;Nothing&gt;\n    data class EvaluationError(val key: String, val error: Throwable) : EvaluationResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"#folding-results","title":"Folding Results","text":"<p>Transform evaluation results into your preferred error handling type:</p> <pre><code>val outcome = context.evaluateSafe(AppFeatures.DARK_MODE).fold(\n    onSuccess = { Result.success(it) },\n    onFlagNotFound = { Result.failure(FlagMissingException(it)) },\n    onEvaluationError = { key, err -&gt; Result.failure(FlagFailedException(key, err)) }\n)\n</code></pre>"},{"location":"#parseresult","title":"ParseResult","text":"<p>Used for deserialization operations:</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"#thread-safety","title":"Thread Safety","text":"<p>Konditional is designed for safe concurrent access:</p> <ul> <li>Lock-free reads: Flag evaluation requires no locks</li> <li>Atomic updates: Configuration changes are atomic via <code>AtomicReference</code></li> <li>Independent evaluations: Each flag evaluation is independent and thread-safe</li> <li>Deterministic bucketing: Rollout assignments are stable across threads</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Context: Learn about context types and custom extensions</li> <li>Rules: Deep dive into rule evaluation and specificity</li> <li>Flags: Understand feature registration patterns</li> <li>Builders: Master the configuration DSL</li> <li>Serialization: Work with JSON configurations</li> <li>Architecture: Understand the internal design</li> </ul>"},{"location":"Architecture/","title":"Architecture","text":"<p>This document explains Konditional's internal architecture, design principles, and how the various components work together.</p>"},{"location":"Architecture/#design-principles","title":"Design Principles","text":""},{"location":"Architecture/#type-safety-first","title":"Type Safety First","text":"<p>Every API surface uses strong typing to prevent runtime errors:</p> <ul> <li>Generic type parameters enforce value type constraints</li> <li>Context polymorphism ensures features get appropriate evaluation contexts</li> <li>EncodableValue types make unsupported types unrepresentable</li> <li>No string-based lookups or unchecked casts</li> </ul>"},{"location":"Architecture/#parse-dont-validate","title":"Parse, Don't Validate","text":"<p>APIs return explicit result types rather than throwing exceptions:</p> <ul> <li><code>EvaluationResult&lt;T&gt;</code> for flag evaluation</li> <li><code>ParseResult&lt;T&gt;</code> for deserialization</li> <li>Fold functions for ergonomic error handling</li> </ul>"},{"location":"Architecture/#deterministic-behavior","title":"Deterministic Behavior","text":"<p>Same inputs always produce same outputs:</p> <ul> <li>SHA-256 based bucketing for rollouts</li> <li>Stable evaluation order (by specificity)</li> <li>Independent flag bucketing spaces</li> <li>No global mutable state (except atomic registry)</li> </ul>"},{"location":"Architecture/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>Components compose through interfaces:</p> <ul> <li>Rules compose BaseEvaluable + extension Evaluable</li> <li>Features compose key + registry + value type</li> <li>Builders use sealed interfaces with internal implementations</li> </ul>"},{"location":"Architecture/#core-components","title":"Core Components","text":""},{"location":"Architecture/#feature","title":"Feature","text":"<p>Entry point for defining flags:</p> <pre><code>Feature&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt;\n  |\n  +-- key: String\n  +-- registry: FlagRegistry\n  +-- update(definition)\n</code></pre> <p>Features are typically implemented as enum members or object declarations.</p>"},{"location":"Architecture/#flagdefinition","title":"FlagDefinition","text":"<p>Internal representation of configured flags:</p> <pre><code>FlagDefinition&lt;S, T, C&gt;\n  |\n  +-- feature: Feature&lt;S, T, C&gt;\n  +-- defaultValue: T\n  +-- values: List&lt;ConditionalValue&lt;S, T, C&gt;&gt;\n  +-- isActive: Boolean\n  +-- salt: String\n  |\n  +-- evaluate(context: C): T\n</code></pre> <p>FlagDefinition handles: - Rule evaluation and specificity ordering - Rollout bucketing via SHA-256 hashing - Fallback to default value</p>"},{"location":"Architecture/#context","title":"Context","text":"<p>Evaluation environment:</p> <pre><code>Context\n  |\n  +-- locale: AppLocale\n  +-- platform: Platform\n  +-- appVersion: Version\n  +-- stableId: StableId\n</code></pre> <p>Can be extended with custom fields for domain-specific targeting.</p>"},{"location":"Architecture/#rule","title":"Rule","text":"<p>Targeting criteria:</p> <pre><code>Rule&lt;C : Context&gt;\n  |\n  +-- rollout: Rollout\n  +-- note: String?\n  +-- baseEvaluable: BaseEvaluable&lt;C&gt;\n  +-- extension: Evaluable&lt;C&gt;\n  |\n  +-- matches(context: C): Boolean\n  +-- specificity(): Int\n</code></pre> <p>Rules compose: - Base targeting (locale, platform, version) - Custom extension logic - Both must match for rule to match</p>"},{"location":"Architecture/#evaluable","title":"Evaluable","text":"<p>Composable evaluation abstraction:</p> <pre><code>Evaluable&lt;C : Context&gt;\n  |\n  +-- matches(context: C): Boolean (default: true)\n  +-- specificity(): Int (default: 0)\n\nBaseEvaluable&lt;C&gt;\n  |\n  +-- locales: Set&lt;AppLocale&gt;\n  +-- platforms: Set&lt;Platform&gt;\n  +-- versionRange: VersionRange\n</code></pre> <p>Evaluables can be composed to create complex targeting logic.</p>"},{"location":"Architecture/#flagregistry","title":"FlagRegistry","text":"<p>Configuration storage:</p> <pre><code>FlagRegistry\n  |\n  +-- load(konfig: Konfig)\n  +-- update(patch: KonfigPatch)\n  +-- update(definition: FlagDefinition&lt;S, T, C&gt;)\n  +-- konfig(): Konfig\n  +-- featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;?\n  +-- allFlags(): Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n</code></pre> <p>Default implementation uses <code>AtomicReference&lt;Konfig&gt;</code> for thread-safe updates.</p>"},{"location":"Architecture/#data-flow","title":"Data Flow","text":""},{"location":"Architecture/#configuration-flow","title":"Configuration Flow","text":"<pre><code>DSL (config { })\n  -&gt; ConfigBuilder\n  -&gt; Konfig (immutable snapshot)\n  -&gt; FlagRegistry (AtomicReference)\n</code></pre> <ol> <li>DSL builds intermediate builder structure</li> <li>Builder creates immutable Konfig</li> <li>Konfig loaded into registry atomically</li> </ol>"},{"location":"Architecture/#evaluation-flow","title":"Evaluation Flow","text":"<pre><code>Context.evaluateSafe(feature)\n  -&gt; Registry.featureFlag(feature)\n  -&gt; FlagDefinition.evaluate(context)\n  -&gt; ConditionalValue matching (by specificity)\n  -&gt; Rule.matches(context) &amp;&amp; isInEligibleSegment()\n  -&gt; Return matched value or default\n</code></pre> <ol> <li>Lookup flag definition in registry</li> <li>Iterate through conditional values (sorted by specificity)</li> <li>Check if rule matches context</li> <li>Check if context is in rollout bucket</li> <li>Return value from first matching rule, or default</li> </ol>"},{"location":"Architecture/#specificity-ordering","title":"Specificity Ordering","text":"<p>Rules are evaluated in specificity order:</p> <pre><code>Rules sorted by:\n  1. specificity() DESC\n  2. note ASC (tie-breaker)\n\nSpecificity calculation:\n  baseEvaluable.specificity() + extension.specificity()\n\nBaseEvaluable specificity:\n  (locales not empty ? 1 : 0) +\n  (platforms not empty ? 1 : 0) +\n  (versionRange has bounds ? 1 : 0)\n</code></pre> <p>More specific rules are evaluated first.</p>"},{"location":"Architecture/#bucketing-algorithm","title":"Bucketing Algorithm","text":"<p>Rollout bucketing uses SHA-256:</p> <pre><code>fun isInEligibleSegment(\n    flagKey: String,\n    id: HexId,\n    salt: String,\n    rollout: Rollout\n): Boolean {\n    if (rollout &lt;= 0.0) return false\n    if (rollout &gt;= 100.0) return true\n\n    val bucket = stableBucket(flagKey, id, salt)\n    return bucket &lt; (rollout.value * 100).toInt()\n}\n\nfun stableBucket(\n    flagKey: String,\n    id: HexId,\n    salt: String\n): Int {\n    val hash = SHA256(\"$salt:$flagKey:${id.id}\")\n    val first4Bytes = hash[0..3]\n    return (first4Bytes as Int) % 10_000\n}\n</code></pre> <p>Properties: - Deterministic: Same inputs always hash to same bucket - Independent: Each flag has separate bucketing space - Stable: Changing salt redistributes buckets - Range: 0-9999 (0.01% granularity)</p>"},{"location":"Architecture/#thread-safety","title":"Thread Safety","text":""},{"location":"Architecture/#lock-free-reads","title":"Lock-Free Reads","text":"<p>Flag evaluation requires no locks:</p> <pre><code>class SingletonFlagRegistry : FlagRegistry {\n    private val konfigRef = AtomicReference&lt;Konfig&gt;(Konfig.EMPTY)\n\n    override fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;? {\n        return konfigRef.get().flags[key]  // No lock needed\n    }\n}\n</code></pre> <p>Reads use <code>AtomicReference.get()</code>, which is lock-free.</p>"},{"location":"Architecture/#atomic-updates","title":"Atomic Updates","text":"<p>Configuration updates are atomic:</p> <pre><code>override fun load(config: Konfig) {\n    konfigRef.set(config)  // Atomic swap\n}\n</code></pre> <p>New configuration replaces old atomically. Concurrent evaluations see either old or new, never partial state.</p>"},{"location":"Architecture/#immutable-data","title":"Immutable Data","text":"<p>All configuration data is immutable:</p> <pre><code>data class Konfig(\n    val flags: Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n)  // Map is immutable\n\ndata class FlagDefinition&lt;S, T, C&gt;(\n    val defaultValue: T,  // Immutable\n    val values: List&lt;ConditionalValue&lt;S, T, C&gt;&gt;,  // List is immutable\n    // ...\n)\n</code></pre> <p>Immutability ensures thread safety without locks.</p>"},{"location":"Architecture/#builder-dsl-architecture","title":"Builder DSL Architecture","text":""},{"location":"Architecture/#scope-hierarchy","title":"Scope Hierarchy","text":"<pre><code>ConfigScope (sealed interface)\n  -&gt; ConfigBuilder (internal implementation)\n\nFlagScope&lt;S, T, C&gt; (sealed interface)\n  -&gt; FlagBuilder&lt;S, T, C&gt; (internal implementation)\n\nRuleScope&lt;C&gt; (sealed interface)\n  -&gt; RuleBuilder&lt;C&gt; (internal implementation)\n</code></pre> <p>Sealed interfaces hide implementation, preventing direct instantiation.</p>"},{"location":"Architecture/#type-state","title":"Type State","text":"<p>Builders use typestate pattern:</p> <pre><code>interface FlagScope&lt;S, T, C&gt; {\n    fun rule(build: RuleScope&lt;C&gt;.() -&gt; Unit): Rule&lt;C&gt;\n    infix fun Rule&lt;C&gt;.implies(value: T)  // Rule must be associated with value\n}\n</code></pre> <p>The <code>implies</code> extension ensures rules are always associated with values.</p>"},{"location":"Architecture/#dsl-markers","title":"DSL Markers","text":"<p><code>@FeatureFlagDsl</code> prevents accidental scope nesting:</p> <pre><code>@DslMarker\nannotation class FeatureFlagDsl\n\n@FeatureFlagDsl\ninterface ConfigScope\n\n@FeatureFlagDsl\ninterface FlagScope&lt;S, T, C&gt;\n\n@FeatureFlagDsl\ninterface RuleScope&lt;C&gt;\n</code></pre> <p>This prevents constructions like <code>rule { rule { } }</code>.</p>"},{"location":"Architecture/#serialization-architecture","title":"Serialization Architecture","text":""},{"location":"Architecture/#type-adapters","title":"Type Adapters","text":"<p>Custom Moshi adapters handle domain types:</p> <pre><code>SnapshotSerializer\n  |\n  +-- SerializableSnapshot (DTO)\n  |     |\n  |     +-- List&lt;SerializableFlag&gt;\n  |           |\n  |           +-- SerializableRule\n  |                 |\n  |                 +-- VersionRange (polymorphic)\n  |\n  +-- FlagValueAdapter (handles EncodableValue)\n  +-- VersionRangeAdapter (handles VersionRange subtypes)\n</code></pre> <p>Domain models convert to/from serializable DTOs.</p>"},{"location":"Architecture/#polymorphic-serialization","title":"Polymorphic Serialization","text":"<p>VersionRange uses polymorphic JSON:</p> <pre><code>{\n  \"type\": \"MIN_AND_MAX_BOUND\",\n  \"min\": {...},\n  \"max\": {...}\n}\n</code></pre> <p>Moshi's <code>PolymorphicJsonAdapterFactory</code> handles type discrimination.</p>"},{"location":"Architecture/#parse-dont-validate_1","title":"Parse-Don't-Validate","text":"<p>Deserialization returns <code>ParseResult</code>:</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T)\n    data class Failure(val error: ParseError)\n}\n</code></pre> <p>Forces explicit error handling, no exceptions.</p>"},{"location":"Architecture/#extension-points","title":"Extension Points","text":""},{"location":"Architecture/#custom-contexts","title":"Custom Contexts","text":"<p>Extend <code>Context</code> interface:</p> <pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n\ndata class CustomContext(\n    override val locale: AppLocale,\n    // ... standard properties\n    val customField: CustomType  // Extension\n) : Context\n</code></pre>"},{"location":"Architecture/#custom-evaluables","title":"Custom Evaluables","text":"<p>Extend <code>Evaluable</code> for custom targeting:</p> <pre><code>abstract class Evaluable&lt;C : Context&gt; {\n    open fun matches(context: C): Boolean = true\n    open fun specificity(): Int = 0\n}\n\nclass CustomEvaluable : Evaluable&lt;CustomContext&gt;() {\n    override fun matches(context: CustomContext): Boolean {\n        // Custom logic\n    }\n\n    override fun specificity(): Int = 1\n}\n</code></pre>"},{"location":"Architecture/#custom-registries","title":"Custom Registries","text":"<p>Implement <code>FlagRegistry</code> for custom storage:</p> <pre><code>interface FlagRegistry {\n    fun load(config: Konfig)\n    fun update(patch: KonfigPatch)\n    fun update(definition: FlagDefinition&lt;S, T, C&gt;)\n    fun konfig(): Konfig\n    fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;?\n    fun allFlags(): Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n}\n\nclass DatabaseBackedRegistry(private val db: Database) : FlagRegistry {\n    // Implement using database storage\n}\n</code></pre>"},{"location":"Architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"Architecture/#evaluation","title":"Evaluation","text":"<ul> <li>Lookup: O(1) hash map lookup</li> <li>Matching: O(n) where n = number of rules (typically small, &lt;10)</li> <li>Bucketing: O(1) hash computation</li> <li>Memory: Immutable snapshots, no per-request allocation</li> </ul>"},{"location":"Architecture/#updates","title":"Updates","text":"<ul> <li>Load: O(1) atomic swap</li> <li>Patch: O(n) where n = number of flags in patch</li> </ul>"},{"location":"Architecture/#serialization","title":"Serialization","text":"<ul> <li>Serialize: O(n) where n = total flags</li> <li>Deserialize: O(n) where n = total flags</li> <li>Parse: Single-pass parsing via Moshi</li> </ul>"},{"location":"Architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"Architecture/#test-registries","title":"Test Registries","text":"<p>Create isolated registries for tests:</p> <pre><code>@Test\nfun `test feature evaluation`() {\n    val testRegistry = FlagRegistry.create()\n\n    config(testRegistry) {\n        MyFeature.FLAG with { default(false) }\n    }\n\n    val context = Context(...)\n    val result = context.evaluateSafe(MyFeature.FLAG, testRegistry)\n\n    assertTrue(result is EvaluationResult.Success)\n}\n</code></pre>"},{"location":"Architecture/#test-contexts","title":"Test Contexts","text":"<p>Create test context factories:</p> <pre><code>object TestContexts {\n    fun ios(version: Version = Version(2, 0, 0)): Context =\n        Context(\n            locale = AppLocale.EN_US,\n            platform = Platform.IOS,\n            appVersion = version,\n            stableId = StableId.of(\"test-user\")\n        )\n\n    fun android(): Context = // ...\n    fun web(): Context = // ...\n}\n</code></pre>"},{"location":"Architecture/#best-practices","title":"Best Practices","text":""},{"location":"Architecture/#immutability","title":"Immutability","text":"<p>Keep all domain models immutable for thread safety.</p>"},{"location":"Architecture/#composition","title":"Composition","text":"<p>Prefer composition over inheritance for extensibility.</p>"},{"location":"Architecture/#explicit-results","title":"Explicit Results","text":"<p>Use result types instead of exceptions for expected errors.</p>"},{"location":"Architecture/#type-safety","title":"Type Safety","text":"<p>Leverage generics and sealed types to make invalid states unrepresentable.</p>"},{"location":"Architecture/#lock-free","title":"Lock-Free","text":"<p>Design for lock-free concurrent access where possible.</p>"},{"location":"Architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Overview: Back to API overview</li> <li>Context: Deep dive into contexts</li> <li>Rules: Understand rule evaluation</li> </ul>"},{"location":"Builders/","title":"Builder DSL","text":"<p>Konditional provides a type-safe, expressive DSL for configuring feature flags. The DSL uses Kotlin's receiver types and inline functions to create a fluent configuration interface while maintaining compile-time safety.</p>"},{"location":"Builders/#overview","title":"Overview","text":"<p>The configuration DSL consists of three scope levels:</p> <ol> <li>ConfigScope: Top-level configuration block</li> <li>FlagScope: Individual flag configuration</li> <li>RuleScope: Rule definition within a flag</li> </ol> <pre><code>config {  // ConfigScope\n    MyFeature.FLAG with {  // FlagScope\n        default(value)\n        rule {  // RuleScope\n            platforms(Platform.IOS)\n        }.implies(value)\n    }\n}\n</code></pre>"},{"location":"Builders/#configscope","title":"ConfigScope","text":"<p>The outermost scope for defining flag configurations.</p>"},{"location":"Builders/#config-function","title":"config Function","text":"<p>Entry point for flag configuration:</p> <pre><code>config(registry: FlagRegistry = FlagRegistry) {\n    // Flag configurations\n}\n</code></pre> <p>Parameters: - <code>registry</code>: Target registry (defaults to singleton)</p> <p>Usage:</p> <pre><code>// Configure singleton registry\nconfig {\n    MyFeature.FLAG_A with { /* ... */ }\n    MyFeature.FLAG_B with { /* ... */ }\n}\n\n// Configure custom registry\nval testRegistry = FlagRegistry.create()\nconfig(testRegistry) {\n    MyFeature.FLAG_A with { /* ... */ }\n}\n</code></pre>"},{"location":"Builders/#feature-configuration","title":"Feature Configuration","text":"<p>Use the <code>with</code> infix function to configure features:</p> <pre><code>config {\n    MyFeature.DARK_MODE with {\n        default(false)\n        // ... rules\n    }\n\n    MyFeature.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n        // ... rules\n    }\n}\n</code></pre>"},{"location":"Builders/#flagscope","title":"FlagScope","text":"<p>Scope for configuring individual flags.</p>"},{"location":"Builders/#default","title":"default()","text":"<p>Sets the default value returned when no rules match:</p> <pre><code>MyFeature.BOOLEAN_FLAG with {\n    default(false)  // Boolean\n}\n\nMyFeature.STRING_FLAG with {\n    default(\"production\")  // String\n}\n\nMyFeature.INT_FLAG with {\n    default(42)  // Int\n}\n\nMyFeature.CONFIG_FLAG with {\n    default(Config(url = \"https://prod.example.com\", timeout = 30))  // Complex type\n}\n</code></pre> <p>Note: The default value type must match the feature's declared type.</p>"},{"location":"Builders/#salt","title":"salt()","text":"<p>Sets the hash salt for rollout bucketing:</p> <pre><code>MyFeature.EXPERIMENT with {\n    default(false)\n    salt(\"v1\")  // Initial experiment\n\n    rule {\n        rollout = Rollout.of(50.0)\n    }.implies(true)\n}\n</code></pre> <p>Changing the salt redistributes users across rollout buckets.</p>"},{"location":"Builders/#rule","title":"rule()","text":"<p>Defines a targeting rule:</p> <pre><code>MyFeature.FLAG with {\n    default(false)\n\n    rule {\n        // ... targeting criteria\n    }.implies(true)\n}\n</code></pre> <p>Returns a <code>Rule</code> object that must be associated with a value using <code>implies</code>.</p>"},{"location":"Builders/#implies","title":"implies","text":"<p>Associates a rule with its value:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n}.implies(true)  // When rule matches, return true\n</code></pre>"},{"location":"Builders/#rulescope","title":"RuleScope","text":"<p>Scope for defining rule targeting criteria.</p>"},{"location":"Builders/#platforms","title":"platforms()","text":"<p>Specify target platforms:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n}.implies(value)\n\nrule {\n    platforms(Platform.WEB)\n}.implies(webValue)\n</code></pre> <p>Empty platforms = match all.</p>"},{"location":"Builders/#locales","title":"locales()","text":"<p>Specify target locales:</p> <pre><code>rule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA)\n}.implies(value)\n\nrule {\n    locales(AppLocale.FR_FR)\n}.implies(frenchValue)\n</code></pre> <p>Empty locales = match all.</p>"},{"location":"Builders/#versions","title":"versions()","text":"<p>Specify version range using VersionRangeScope:</p> <pre><code>rule {\n    versions {\n        min(2, 0, 0)  // Minimum version\n        max(3, 0, 0)  // Maximum version\n    }\n}.implies(value)\n</code></pre>"},{"location":"Builders/#rollout","title":"rollout","text":"<p>Set rollout percentage:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(25.0)  // 25% rollout\n}.implies(value)\n</code></pre> <p>Values: 0.0 to 100.0 (use <code>Rollout.MAX</code> for 100.0)</p>"},{"location":"Builders/#extension","title":"extension()","text":"<p>Add custom evaluation logic:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(value)\n</code></pre>"},{"location":"Builders/#note","title":"note()","text":"<p>Add documentation to rules:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(10.0)\n    note(\"Initial iOS canary deployment\")\n}.implies(value)\n</code></pre>"},{"location":"Builders/#versionrangescope","title":"VersionRangeScope","text":"<p>Scope for defining version constraints.</p>"},{"location":"Builders/#min","title":"min()","text":"<p>Set minimum version (inclusive):</p> <pre><code>versions {\n    min(2, 0, 0)  // &gt;= 2.0.0\n}\n\nversions {\n    min(1, 5, 3)  // &gt;= 1.5.3\n}\n</code></pre>"},{"location":"Builders/#max","title":"max()","text":"<p>Set maximum version (inclusive):</p> <pre><code>versions {\n    max(3, 0, 0)  // &lt;= 3.0.0\n}\n\nversions {\n    max(2, 9, 99)  // &lt;= 2.9.99\n}\n</code></pre>"},{"location":"Builders/#combined","title":"Combined","text":"<p>Define version range:</p> <pre><code>versions {\n    min(2, 0, 0)  // &gt;= 2.0.0\n    max(3, 0, 0)  // &lt;= 3.0.0\n}\n\n// Exact version\nversions {\n    min(2, 1, 5)\n    max(2, 1, 5)  // Exactly 2.1.5\n}\n</code></pre>"},{"location":"Builders/#complete-examples","title":"Complete Examples","text":""},{"location":"Builders/#simple-boolean-flag","title":"Simple Boolean Flag","text":"<pre><code>config {\n    MyFeatures.DARK_MODE with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#multi-rule-configuration","title":"Multi-Rule Configuration","text":"<pre><code>config {\n    MyFeatures.THEME with {\n        default(\"light\")\n        salt(\"v2\")\n\n        // Highest specificity: platform + locale + version\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n            versions {\n                min(2, 0, 0)\n            }\n            rollout = Rollout.of(50.0)\n            note(\"iOS US users on v2+, 50% rollout\")\n        }.implies(\"dark\")\n\n        // Medium specificity: platform + locale\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n            note(\"All iOS US users not in above bucket\")\n        }.implies(\"auto\")\n\n        // Low specificity: platform only\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"light-ios\")\n    }\n}\n</code></pre>"},{"location":"Builders/#complex-type-flag","title":"Complex Type Flag","text":"<pre><code>data class ApiConfig(\n    val baseUrl: String,\n    val timeout: Int,\n    val retryEnabled: Boolean\n)\n\nconfig {\n    MyFeatures.API_CONFIG with {\n        default(ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30,\n            retryEnabled = true\n        ))\n\n        rule {\n            platforms(Platform.WEB)\n            rollout = Rollout.of(25.0)\n            note(\"Staging API for 25% of web users\")\n        }.implies(ApiConfig(\n            baseUrl = \"https://api.staging.example.com\",\n            timeout = 60,\n            retryEnabled = false\n        ))\n\n        rule {\n            locales(AppLocale.EN_US)\n        }.implies(ApiConfig(\n            baseUrl = \"https://api-us.prod.example.com\",\n            timeout = 30,\n            retryEnabled = true\n        ))\n    }\n}\n</code></pre>"},{"location":"Builders/#enterprise-context-flag","title":"Enterprise Context Flag","text":"<pre><code>config {\n    EnterpriseFeatures.ADVANCED_ANALYTICS with {\n        default(false)\n\n        // Enterprise tier customers\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n                    override fun specificity(): Int = 1\n                }\n            }\n            rollout = Rollout.MAX\n            note(\"Full rollout for enterprise customers\")\n        }.implies(true)\n\n        // Professional tier with admin role\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.PROFESSIONAL &amp;&amp;\n                        context.userRole == UserRole.ADMIN\n\n                    override fun specificity(): Int = 2\n                }\n            }\n            rollout = Rollout.of(50.0)\n            note(\"50% rollout for professional admins\")\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#buildsnapshot","title":"buildSnapshot()","text":"<p>Create configurations without loading them into a registry:</p> <pre><code>val snapshot = buildSnapshot {\n    MyFeatures.FLAG_A with {\n        default(false)\n    }\n\n    MyFeatures.FLAG_B with {\n        default(true)\n    }\n}\n\n// Use snapshot later\nregistry.load(snapshot)\n\n// Or serialize it\nval json = SnapshotSerializer.default.serialize(snapshot)\n</code></pre> <p>Use cases: - Testing configurations - Building configurations programmatically - Serializing configurations - External configuration management</p>"},{"location":"Builders/#type-safety","title":"Type Safety","text":"<p>The DSL provides compile-time type safety:</p> <pre><code>config {\n    // Type-safe: Boolean feature expects Boolean values\n    MyBooleanFeature.FLAG with {\n        default(false)\n        rule { platforms(Platform.IOS) }.implies(true)  // OK\n        // rule { platforms(Platform.IOS) }.implies(\"true\")  // Compile error!\n    }\n\n    // Type-safe: String feature expects String values\n    MyStringFeature.API_URL with {\n        default(\"https://prod.example.com\")\n        rule { platforms(Platform.WEB) }.implies(\"https://staging.example.com\")  // OK\n        // rule { platforms(Platform.WEB) }.implies(true)  // Compile error!\n    }\n}\n</code></pre>"},{"location":"Builders/#dsl-markers","title":"DSL Markers","text":"<p>The DSL uses <code>@FeatureFlagDsl</code> annotation to prevent accidental nesting:</p> <pre><code>@FeatureFlagDsl\ninterface ConfigScope { /* ... */ }\n\n@FeatureFlagDsl\ninterface FlagScope&lt;S, T, C&gt; { /* ... */ }\n\n@FeatureFlagDsl\ninterface RuleScope&lt;C&gt; { /* ... */ }\n</code></pre> <p>This prevents invalid constructions like:</p> <pre><code>config {\n    MyFeature.FLAG with {\n        rule {\n            rule {  // Compile error: Can't nest rule inside rule\n                // ...\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Builders/#best-practices","title":"Best Practices","text":""},{"location":"Builders/#separate-configuration-files","title":"Separate Configuration Files","text":"<p>Organize configurations by feature area:</p> <pre><code>// UIConfig.kt\nobject UIConfig {\n    fun configure() = config {\n        UIFeatures.DARK_MODE with { /* ... */ }\n        UIFeatures.ANIMATIONS with { /* ... */ }\n    }\n}\n\n// ApiConfig.kt\nobject ApiConfig {\n    fun configure() = config {\n        ApiFeatures.ENDPOINT with { /* ... */ }\n        ApiFeatures.TIMEOUT with { /* ... */ }\n    }\n}\n\n// Initialize all\nfun initializeFeatureFlags() {\n    UIConfig.configure()\n    ApiConfig.configure()\n}\n</code></pre>"},{"location":"Builders/#use-named-values-for-clarity","title":"Use Named Values for Clarity","text":"<pre><code>config {\n    MyFeatures.API_CONFIG with {\n        val prodConfig = ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30\n        )\n\n        val stagingConfig = ApiConfig(\n            baseUrl = \"https://api.staging.example.com\",\n            timeout = 60\n        )\n\n        default(prodConfig)\n\n        rule {\n            platforms(Platform.WEB)\n        }.implies(stagingConfig)\n    }\n}\n</code></pre>"},{"location":"Builders/#extract-complex-extensions","title":"Extract Complex Extensions","text":"<pre><code>class EnterpriseCustomerEvaluable : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier in setOf(\n            SubscriptionTier.PROFESSIONAL,\n            SubscriptionTier.ENTERPRISE\n        )\n\n    override fun specificity(): Int = 1\n}\n\nconfig {\n    MyFeatures.PREMIUM_FEATURE with {\n        default(false)\n\n        rule {\n            extension { EnterpriseCustomerEvaluable() }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#document-complex-configurations","title":"Document Complex Configurations","text":"<pre><code>config {\n    MyFeatures.EXPERIMENT_A with {\n        default(false)\n        salt(\"experiment_a_v2\")  // Changed salt for fresh distribution\n\n        rule {\n            platforms(Platform.IOS)\n            versions {\n                min(2, 5, 0)  // Requires new API features\n            }\n            rollout = Rollout.of(20.0)\n            note(\"\"\"\n                Phase 1 rollout of Experiment A.\n                Target: iOS users on v2.5+\n                Tracking: analytics_experiment_a_v2\n                Owner: product-team@example.com\n                Duration: 2024-Q1\n            \"\"\".trimIndent())\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#next-steps","title":"Next Steps","text":"<ul> <li>Rules: Understand rule evaluation</li> <li>Flags: Learn about feature patterns</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"Context/","title":"Context API","text":"<p>The <code>Context</code> interface defines the evaluation environment for feature flags. It provides standard targeting dimensions while allowing domain-specific extensions for custom business logic.</p>"},{"location":"Context/#base-context-interface","title":"Base Context Interface","text":"<p>The base <code>Context</code> interface defines four required properties:</p> <pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n</code></pre>"},{"location":"Context/#standard-properties","title":"Standard Properties","text":""},{"location":"Context/#locale-applocale","title":"locale: AppLocale","text":"<p>Represents the user's language and regional settings. Used for localization-based targeting.</p> <pre><code>enum class AppLocale {\n    EN_US,\n    EN_CA,\n    EN_GB,\n    FR_FR,\n    DE_DE,\n    ES_ES,\n    JA_JP,\n    ZH_CN,\n    // ... other locales\n}\n</code></pre>"},{"location":"Context/#platform-platform","title":"platform: Platform","text":"<p>Identifies the platform where the application is running.</p> <pre><code>enum class Platform {\n    IOS,\n    ANDROID,\n    WEB,\n    DESKTOP,\n    SERVER\n}\n</code></pre>"},{"location":"Context/#appversion-version","title":"appVersion: Version","text":"<p>Semantic version of the application, used for version-based targeting.</p> <pre><code>data class Version(\n    val major: Int,\n    val minor: Int,\n    val patch: Int\n) : Comparable&lt;Version&gt;\n\n// Create versions\nval version = Version(2, 5, 0)\nval parsed = Version.parse(\"2.5.0\")\n</code></pre>"},{"location":"Context/#stableid-stableid","title":"stableId: StableId","text":"<p>A stable, unique identifier used for deterministic rollout bucketing. This ensures users consistently see the same variation across sessions.</p> <pre><code>// Create from any unique identifier\nval stableId = StableId.of(\"user-12345\")\nval stableId = StableId.of(userId)\nval stableId = StableId.of(deviceId)\n</code></pre> <p>The <code>StableId</code> is crucial for consistent user experience. The same ID will always hash to the same bucket, ensuring that once a user is assigned to a rollout group, they remain in that group.</p>"},{"location":"Context/#creating-context-instances","title":"Creating Context Instances","text":""},{"location":"Context/#factory-method","title":"Factory Method","text":"<p>Use the companion object factory for basic contexts:</p> <pre><code>val context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\")\n)\n</code></pre>"},{"location":"Context/#data-classes","title":"Data Classes","text":"<p>For production use, create data class implementations:</p> <pre><code>data class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n\nval context = AppContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\")\n)\n</code></pre>"},{"location":"Context/#custom-context-extensions","title":"Custom Context Extensions","text":"<p>Extend the base <code>Context</code> interface to add domain-specific targeting fields. This is one of Konditional's most powerful features, allowing you to target flags based on your business logic.</p>"},{"location":"Context/#enterprise-context","title":"Enterprise Context","text":"<p>Add organization and subscription information:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val userRole: UserRole\n) : Context\n\nenum class SubscriptionTier {\n    FREE,\n    PROFESSIONAL,\n    ENTERPRISE\n}\n\nenum class UserRole {\n    VIEWER,\n    EDITOR,\n    ADMIN,\n    OWNER\n}\n</code></pre> <p>Use custom context fields in rule extensions:</p> <pre><code>enum class EnterpriseFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"advanced_analytics\"),\n    BULK_EXPORT(\"bulk_export\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    EnterpriseFeatures.ADVANCED_ANALYTICS with {\n        default(false)\n\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Context/#experimentation-context","title":"Experimentation Context","text":"<p>Add A/B testing and experiment tracking:</p> <pre><code>data class ExperimentContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val activeExperiments: Set&lt;String&gt;,\n    val userSegment: UserSegment\n) : Context\n\nenum class UserSegment {\n    NEW_USER,\n    ACTIVE_USER,\n    POWER_USER,\n    AT_RISK\n}\n</code></pre>"},{"location":"Context/#multi-tenant-context","title":"Multi-Tenant Context","text":"<p>Support multi-tenant applications:</p> <pre><code>data class TenantContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val tenantId: String,\n    val tenantRegion: String,\n    val tenantPlan: String,\n    val featureWhitelist: Set&lt;String&gt;\n) : Context\n</code></pre>"},{"location":"Context/#context-patterns","title":"Context Patterns","text":""},{"location":"Context/#immutability","title":"Immutability","text":"<p>Context instances should be immutable. This ensures thread safety and prevents accidental modifications during evaluation:</p> <pre><code>// Good: Immutable data class\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n\n// Bad: Mutable properties\nclass MutableContext(\n    override var locale: AppLocale,  // Don't do this\n    // ...\n) : Context\n</code></pre>"},{"location":"Context/#context-factories","title":"Context Factories","text":"<p>Create factory functions for common context creation patterns:</p> <pre><code>object ContextFactory {\n    fun fromRequest(request: HttpRequest): AppContext {\n        return AppContext(\n            locale = parseLocale(request.headers[\"Accept-Language\"]),\n            platform = detectPlatform(request.headers[\"User-Agent\"]),\n            appVersion = parseVersion(request.headers[\"X-App-Version\"]),\n            stableId = StableId.of(request.cookies[\"user_id\"] ?: generateAnonymousId())\n        )\n    }\n\n    fun fromUser(user: User, device: Device): AppContext {\n        return AppContext(\n            locale = user.preferredLocale,\n            platform = device.platform,\n            appVersion = device.appVersion,\n            stableId = StableId.of(user.id)\n        )\n    }\n}\n</code></pre>"},{"location":"Context/#context-builders","title":"Context Builders","text":"<p>For complex contexts, provide builders:</p> <pre><code>class EnterpriseContextBuilder {\n    private var locale: AppLocale? = null\n    private var platform: Platform? = null\n    private var appVersion: Version? = null\n    private var stableId: StableId? = null\n    private var organizationId: String? = null\n    private var subscriptionTier: SubscriptionTier? = null\n    private var userRole: UserRole? = null\n\n    fun locale(value: AppLocale) = apply { this.locale = value }\n    fun platform(value: Platform) = apply { this.platform = value }\n    fun appVersion(value: Version) = apply { this.appVersion = value }\n    fun stableId(value: StableId) = apply { this.stableId = value }\n    fun organizationId(value: String) = apply { this.organizationId = value }\n    fun subscriptionTier(value: SubscriptionTier) = apply { this.subscriptionTier = value }\n    fun userRole(value: UserRole) = apply { this.userRole = value }\n\n    fun build(): EnterpriseContext {\n        return EnterpriseContext(\n            locale = requireNotNull(locale) { \"locale is required\" },\n            platform = requireNotNull(platform) { \"platform is required\" },\n            appVersion = requireNotNull(appVersion) { \"appVersion is required\" },\n            stableId = requireNotNull(stableId) { \"stableId is required\" },\n            organizationId = requireNotNull(organizationId) { \"organizationId is required\" },\n            subscriptionTier = requireNotNull(subscriptionTier) { \"subscriptionTier is required\" },\n            userRole = requireNotNull(userRole) { \"userRole is required\" }\n        )\n    }\n}\n</code></pre>"},{"location":"Context/#stableid-best-practices","title":"StableId Best Practices","text":"<p>The <code>stableId</code> is critical for consistent rollout behavior. Follow these guidelines:</p>"},{"location":"Context/#choose-appropriate-identifiers","title":"Choose Appropriate Identifiers","text":"<pre><code>// User-level targeting: Use user ID\nval stableId = StableId.of(userId)\n\n// Device-level targeting: Use device ID\nval stableId = StableId.of(deviceId)\n\n// Session-level targeting: Use session ID\nval stableId = StableId.of(sessionId)\n\n// Anonymous users: Generate and persist an anonymous ID\nval stableId = StableId.of(anonymousUserId)\n</code></pre>"},{"location":"Context/#stability-considerations","title":"Stability Considerations","text":"<p>The identifier should be: - Persistent: Survives application restarts - Unique: Different for each user/device/session - Consistent: Same value across requests for the same entity</p>"},{"location":"Context/#anonymous-users","title":"Anonymous Users","text":"<p>For anonymous users, generate and persist an identifier:</p> <pre><code>fun getOrCreateAnonymousId(): String {\n    val stored = localStorage.getItem(\"anonymous_id\")\n    if (stored != null) return stored\n\n    val newId = UUID.randomUUID().toString()\n    localStorage.setItem(\"anonymous_id\", newId)\n    return newId\n}\n\nval stableId = StableId.of(getOrCreateAnonymousId())\n</code></pre>"},{"location":"Context/#context-polymorphism","title":"Context Polymorphism","text":"<p>Konditional's type system supports context polymorphism through generic type parameters. Features are bound to specific context types:</p> <pre><code>// Feature requiring base Context\nval basicFeature: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n    Feature(\"basic\")\n\n// Feature requiring EnterpriseContext\nval enterpriseFeature: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, EnterpriseContext&gt; =\n    Feature(\"enterprise\")\n\n// Base context can only evaluate basic features\nval baseContext: Context = Context(...)\nbaseContext.evaluateSafe(basicFeature)  // OK\n// baseContext.evaluateSafe(enterpriseFeature)  // Compile error!\n\n// Enterprise context can evaluate both\nval enterpriseContext: EnterpriseContext = EnterpriseContext(...)\nenterpriseContext.evaluateSafe(basicFeature)  // OK (subtype of Context)\nenterpriseContext.evaluateSafe(enterpriseFeature)  // OK\n</code></pre> <p>This type safety ensures you can only evaluate flags with contexts that provide the necessary information.</p>"},{"location":"Context/#common-patterns","title":"Common Patterns","text":""},{"location":"Context/#default-context-for-testing","title":"Default Context for Testing","text":"<p>Create a default context for unit tests:</p> <pre><code>object TestContext {\n    val default = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"test-user\")\n    )\n\n    fun withPlatform(platform: Platform) = default.copy(platform = platform)\n    fun withVersion(version: Version) = default.copy(appVersion = version)\n}\n</code></pre>"},{"location":"Context/#context-middleware","title":"Context Middleware","text":"<p>Extract context from HTTP requests in a consistent way:</p> <pre><code>class ContextMiddleware : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val request = chain.request()\n        val context = buildContext(request)\n\n        // Store in thread-local or request scope\n        ContextHolder.set(context)\n\n        return chain.proceed(request)\n    }\n\n    private fun buildContext(request: Request): AppContext {\n        return AppContext(\n            locale = parseLocale(request.header(\"Accept-Language\")),\n            platform = parsePlatform(request.header(\"User-Agent\")),\n            appVersion = parseVersion(request.header(\"X-App-Version\")),\n            stableId = StableId.of(request.cookie(\"user_id\"))\n        )\n    }\n}\n</code></pre>"},{"location":"Context/#next-steps","title":"Next Steps","text":"<ul> <li>Rules: Learn how rules use context for targeting</li> <li>Overview: Back to API overview</li> <li>Architecture: Understand how context flows through evaluation</li> </ul>"},{"location":"Flags/","title":"Feature Registration","text":"<p>Features are the entry point for defining and evaluating feature flags in Konditional. This document covers feature creation patterns, registration strategies, and organizational best practices.</p>"},{"location":"Flags/#feature-interface","title":"Feature Interface","text":"<p>The <code>Feature</code> interface represents a configurable flag with a specific value type and evaluation context:</p> <pre><code>interface Feature&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt; {\n    val registry: FlagRegistry\n    val key: String\n\n    fun update(definition: FlagDefinition&lt;S, T, C&gt;)\n}\n</code></pre>"},{"location":"Flags/#type-parameters","title":"Type Parameters","text":"<ul> <li>S: The <code>EncodableValue</code> type wrapping the actual value</li> <li>T: The actual value type (Boolean, String, custom types, etc.)</li> <li>C: The context type used for evaluation</li> </ul>"},{"location":"Flags/#creating-features","title":"Creating Features","text":""},{"location":"Flags/#direct-creation","title":"Direct Creation","text":"<p>Create features directly using the factory function:</p> <pre><code>val DARK_MODE: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n    Feature(\"dark_mode\")\n\nval API_URL: Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; =\n    Feature(\"api_url\")\n</code></pre>"},{"location":"Flags/#specialized-factory-methods","title":"Specialized Factory Methods","text":"<p>Use factory methods for specific value types:</p> <pre><code>// JSON Object features (complex data classes)\nval API_CONFIG: Feature.OfJsonObject&lt;ApiConfig, Context&gt; =\n    Feature.jsonObject(\"api_config\")\n\n// Custom wrapper features (domain types)\nval CREATED_AT: Feature.OfCustom&lt;DateTime, String, Context&gt; =\n    Feature.custom(\"created_at\")\n</code></pre>"},{"location":"Flags/#organizational-patterns","title":"Organizational Patterns","text":""},{"location":"Flags/#enum-pattern-recommended","title":"Enum Pattern (Recommended)","text":"<p>Organize features as enum members for type safety and discoverability:</p> <pre><code>enum class AppFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ADVANCED_SEARCH(\"advanced_search\"),\n    ANALYTICS_ENABLED(\"analytics_enabled\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre> <p>Benefits: - IDE auto-completion - Compile-time existence checking - Easy to find all features - Refactoring support</p> <p>Usage:</p> <pre><code>// Configure\nconfig {\n    AppFeatures.DARK_MODE with {\n        default(false)\n    }\n}\n\n// Evaluate\nval enabled = context.evaluateSafe(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"Flags/#object-pattern","title":"Object Pattern","text":"<p>For features with different value types, use object declarations:</p> <pre><code>object Features {\n    val DARK_MODE: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n        Feature(\"dark_mode\")\n\n    val API_ENDPOINT: Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; =\n        Feature(\"api_endpoint\")\n\n    val MAX_RETRIES: Feature&lt;EncodableValue.IntEncodeable, Int, Context&gt; =\n        Feature(\"max_retries\")\n\n    val THEME_CONFIG: Feature.OfJsonObject&lt;ThemeConfig, Context&gt; =\n        Feature.jsonObject(\"theme_config\")\n}\n</code></pre>"},{"location":"Flags/#grouped-by-domain","title":"Grouped by Domain","text":"<p>Organize features by functional area:</p> <pre><code>// UI Features\nenum class UIFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    DARK_MODE(\"ui_dark_mode\"),\n    ANIMATIONS_ENABLED(\"ui_animations\"),\n    COMPACT_VIEW(\"ui_compact_view\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// API Features\nenum class ApiFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; {\n    ENDPOINT(\"api_endpoint\"),\n    VERSION(\"api_version\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// Experimental Features\nenum class ExperimentalFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    NEW_ALGORITHM(\"exp_new_algorithm\"),\n    ML_PREDICTIONS(\"exp_ml_predictions\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"Flags/#value-type-patterns","title":"Value Type Patterns","text":""},{"location":"Flags/#boolean-features","title":"Boolean Features","text":"<p>The most common feature type for on/off toggles:</p> <pre><code>enum class FeatureToggles(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    NEW_UI(\"new_ui\"),\n    BETA_FEATURES(\"beta_features\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    FeatureToggles.NEW_UI with {\n        default(false)\n        rule { platforms(Platform.WEB) }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Flags/#string-features","title":"String Features","text":"<p>For configuration values and endpoints:</p> <pre><code>enum class StringConfig(\n    override val key: String\n) : Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; {\n    API_ENDPOINT(\"api_endpoint\"),\n    LOG_LEVEL(\"log_level\"),\n    THEME_NAME(\"theme_name\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    StringConfig.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n        rule { platforms(Platform.WEB) }.implies(\"https://api.staging.example.com\")\n    }\n}\n</code></pre>"},{"location":"Flags/#numeric-features","title":"Numeric Features","text":"<p>For thresholds, limits, and numeric configuration:</p> <pre><code>enum class NumericConfig(\n    override val key: String\n) : Feature&lt;EncodableValue.IntEncodeable, Int, Context&gt; {\n    MAX_RETRIES(\"max_retries\"),\n    TIMEOUT_SECONDS(\"timeout_seconds\"),\n    BATCH_SIZE(\"batch_size\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    NumericConfig.MAX_RETRIES with {\n        default(3)\n        rule { platforms(Platform.ANDROID) }.implies(5)\n    }\n}\n</code></pre>"},{"location":"Flags/#complex-object-features","title":"Complex Object Features","text":"<p>For structured configuration:</p> <pre><code>data class ApiConfig(\n    val baseUrl: String,\n    val timeout: Int,\n    val retryEnabled: Boolean\n)\n\nobject ComplexFeatures {\n    val API_CONFIG: Feature.OfJsonObject&lt;ApiConfig, Context&gt; =\n        Feature.jsonObject(\"api_config\")\n}\n\nconfig {\n    ComplexFeatures.API_CONFIG with {\n        default(ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30,\n            retryEnabled = true\n        ))\n\n        rule {\n            platforms(Platform.WEB)\n        }.implies(ApiConfig(\n            baseUrl = \"https://api.staging.example.com\",\n            timeout = 60,\n            retryEnabled = false\n        ))\n    }\n}\n</code></pre>"},{"location":"Flags/#custom-wrapper-types","title":"Custom Wrapper Types","text":"<p>For domain-specific types that encode to primitives:</p> <pre><code>data class ApiUrl(val value: String)\ndata class Timeout(val milliseconds: Long)\n\nobject CustomFeatures {\n    val API_URL: Feature.OfCustom&lt;ApiUrl, String, Context&gt; =\n        Feature.custom(\"api_url\")\n\n    val REQUEST_TIMEOUT: Feature.OfCustom&lt;Timeout, Double, Context&gt; =\n        Feature.custom(\"request_timeout\")\n}\n\nconfig {\n    CustomFeatures.API_URL with {\n        default(\n            ApiUrl(\"https://prod.example.com\").asCustomString()\n                .encoder { it.value }\n                .decoder { ApiUrl(it) }\n        )\n    }\n\n    CustomFeatures.REQUEST_TIMEOUT with {\n        default(\n            Timeout(30000).asCustomDouble()\n                .encoder { it.milliseconds.toDouble() }\n                .decoder { Timeout(it.toLong()) }\n        )\n    }\n}\n</code></pre>"},{"location":"Flags/#custom-context-features","title":"Custom Context Features","text":"<p>Features can require specific context types:</p> <pre><code>enum class EnterpriseFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"enterprise_advanced_analytics\"),\n    BULK_EXPORT(\"enterprise_bulk_export\"),\n    CUSTOM_BRANDING(\"enterprise_custom_branding\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// These features can only be evaluated with EnterpriseContext\nval enterpriseContext: EnterpriseContext = // ...\nenterpriseContext.evaluateSafe(EnterpriseFeatures.ADVANCED_ANALYTICS)  // OK\n\nval basicContext: Context = // ...\n// basicContext.evaluateSafe(EnterpriseFeatures.ADVANCED_ANALYTICS)  // Compile error!\n</code></pre>"},{"location":"Flags/#registry-management","title":"Registry Management","text":""},{"location":"Flags/#singleton-registry-default","title":"Singleton Registry (Default)","text":"<p>By default, features use the singleton registry:</p> <pre><code>enum class MyFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    FEATURE_A(\"feature_a\");\n\n    override val registry: FlagRegistry = FlagRegistry  // Singleton\n}\n</code></pre>"},{"location":"Flags/#custom-registry","title":"Custom Registry","text":"<p>Use custom registries for isolation (testing, multi-tenancy):</p> <pre><code>enum class TestFeatures(\n    override val key: String,\n    override val registry: FlagRegistry\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    ;  // Empty enum body\n\n    companion object {\n        private val testRegistry = FlagRegistry.create()\n\n        val FEATURE_A = TestFeature(\"feature_a\", testRegistry)\n    }\n\n    private data class TestFeature(\n        override val key: String,\n        override val registry: FlagRegistry\n    ) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;\n}\n\n// Configure with custom registry\nconfig(registry = testRegistry) {\n    // ... configurations\n}\n</code></pre>"},{"location":"Flags/#feature-naming-conventions","title":"Feature Naming Conventions","text":""},{"location":"Flags/#key-naming","title":"Key Naming","text":"<p>Use consistent, descriptive keys:</p> <pre><code>// Good: Clear, namespaced keys\nenum class Features(override val key: String) : Feature&lt;...&gt; {\n    NEW_CHECKOUT(\"checkout_v2\"),\n    DARK_MODE(\"ui_dark_mode\"),\n    ML_RECOMMENDATIONS(\"ml_recommendations_enabled\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// Avoid: Ambiguous or inconsistent keys\nenum class BadFeatures(override val key: String) : Feature&lt;...&gt; {\n    F1(\"f1\"),  // Not descriptive\n    newCheckout(\"newCheckout\"),  // Inconsistent casing\n    DARK_MODE_FEATURE_FLAG(\"DARK-MODE-FEATURE-FLAG\");  // Mixed conventions\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"Flags/#naming-patterns","title":"Naming Patterns","text":"<pre><code>// Pattern: &lt;domain&gt;_&lt;feature&gt;_&lt;variant?&gt;\nCHECKOUT_V2(\"checkout_v2\")\nPAYMENT_APPLE_PAY(\"payment_apple_pay\")\nUI_DARK_MODE(\"ui_dark_mode\")\n\n// Pattern: &lt;feature&gt;_&lt;state&gt;\nANALYTICS_ENABLED(\"analytics_enabled\")\nBETA_FEATURES_AVAILABLE(\"beta_features_available\")\n\n// Pattern: &lt;experiment&gt;_&lt;variant&gt;\nEXPERIMENT_CHECKOUT_LAYOUT_A(\"exp_checkout_layout_a\")\nEXPERIMENT_CHECKOUT_LAYOUT_B(\"exp_checkout_layout_b\")\n</code></pre>"},{"location":"Flags/#dynamic-features","title":"Dynamic Features","text":"<p>For scenarios requiring runtime feature creation:</p> <pre><code>class DynamicFeatureManager {\n    private val features = mutableMapOf&lt;String, Feature&lt;*, *, *&gt;&gt;()\n\n    fun createFeature(key: String): Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n        return features.getOrPut(key) {\n            Feature(key)\n        } as Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;\n    }\n\n    fun getFeature(key: String): Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;? {\n        return features[key] as? Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;\n    }\n}\n</code></pre> <p>However, prefer static feature definitions for type safety and discoverability.</p>"},{"location":"Flags/#feature-documentation","title":"Feature Documentation","text":"<p>Document features with KDoc:</p> <pre><code>enum class AppFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    /**\n     * Enables the new checkout flow with improved UX.\n     *\n     * Rollout plan:\n     * - Phase 1: 10% web users (Week 1)\n     * - Phase 2: 50% web users (Week 2)\n     * - Phase 3: 100% all platforms (Week 3)\n     *\n     * @since 2.5.0\n     * @see CheckoutService\n     */\n    NEW_CHECKOUT(\"new_checkout\"),\n\n    /**\n     * Enables dark mode UI theme.\n     *\n     * Platform support:\n     * - iOS: Full support\n     * - Android: Full support\n     * - Web: Partial support (no custom color schemes)\n     *\n     * @since 2.3.0\n     */\n    DARK_MODE(\"dark_mode\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"Flags/#testing-features","title":"Testing Features","text":""},{"location":"Flags/#test-specific-features","title":"Test-Specific Features","text":"<p>Create features for testing:</p> <pre><code>object TestFeatures {\n    val testRegistry = FlagRegistry.create()\n\n    val TEST_FEATURE: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n        Feature(\"test_feature\", testRegistry)\n}\n\n@Test\nfun `feature evaluation works correctly`() {\n    config(registry = TestFeatures.testRegistry) {\n        TestFeatures.TEST_FEATURE with {\n            default(false)\n            rule { platforms(Platform.IOS) }.implies(true)\n        }\n    }\n\n    val iosContext = Context(\n        platform = Platform.IOS,\n        // ...\n    )\n\n    val result = iosContext.evaluateSafe(TestFeatures.TEST_FEATURE, TestFeatures.testRegistry)\n    assertTrue(result is EvaluationResult.Success &amp;&amp; result.value == true)\n}\n</code></pre>"},{"location":"Flags/#feature-factories-for-tests","title":"Feature Factories for Tests","text":"<p>Create factory functions for test features:</p> <pre><code>object FeatureTestFactory {\n    fun createBooleanFeature(\n        key: String,\n        defaultValue: Boolean = false,\n        registry: FlagRegistry = FlagRegistry.create()\n    ): Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n        val feature = Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;(key, registry)\n\n        config(registry) {\n            feature with {\n                default(defaultValue)\n            }\n        }\n\n        return feature\n    }\n}\n</code></pre>"},{"location":"Flags/#best-practices","title":"Best Practices","text":""},{"location":"Flags/#use-enums-for-related-features","title":"Use Enums for Related Features","text":"<p>Group related features in enums for organization:</p> <pre><code>// Good: Related features grouped\nenum class CheckoutFeatures(override val key: String) : Feature&lt;...&gt; {\n    GUEST_CHECKOUT(\"checkout_guest\"),\n    SAVE_PAYMENT(\"checkout_save_payment\"),\n    ONE_CLICK_BUY(\"checkout_one_click\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// Avoid: Scattered features\nobject Features {\n    val GUEST_CHECKOUT = Feature(\"checkout_guest\")\n    val SAVE_PAYMENT = Feature(\"payment_save\")\n    val ANALYTICS = Feature(\"analytics\")\n    // ... unrelated features mixed together\n}\n</code></pre>"},{"location":"Flags/#make-keys-immutable","title":"Make Keys Immutable","text":"<p>Always use <code>val</code> for feature keys:</p> <pre><code>// Good: Immutable key\nenum class Features(override val key: String) : Feature&lt;...&gt;\n\n// Bad: Mutable key\nclass MutableFeature(override var key: String) : Feature&lt;...&gt;  // Don't do this\n</code></pre>"},{"location":"Flags/#modules-are-coming","title":"Modules are coming!!!","text":""},{"location":"Flags/#next-steps","title":"Next Steps","text":"<ul> <li>Builders: Learn the configuration DSL</li> <li>Rules: Understand rule evaluation</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"Rules/","title":"Rules &amp; Evaluables","text":"<p>Rules define targeting criteria and rollout strategies for feature flags. The Konditional rule system is built on a composable architecture that separates standard targeting (platform, locale, version) from custom domain logic through the <code>Evaluable</code> abstraction.</p>"},{"location":"Rules/#rule-fundamentals","title":"Rule Fundamentals","text":"<p>A Rule specifies conditions that must be met for a particular value to be returned. Rules combine:</p> <ul> <li>Standard targeting criteria (locale, platform, version)</li> <li>Custom evaluation logic through extensions</li> <li>Rollout percentage for gradual deployment</li> <li>Optional documentation notes</li> </ul> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n    locales(AppLocale.EN_US, AppLocale.EN_CA)\n    versions {\n        min(2, 0, 0)\n        max(3, 0, 0)\n    }\n    rollout = Rollout.of(50.0)\n    note(\"Mobile-only feature, 50% gradual rollout\")\n}.implies(true)\n</code></pre>"},{"location":"Rules/#basic-targeting","title":"Basic Targeting","text":""},{"location":"Rules/#platform-targeting","title":"Platform Targeting","text":"<p>Target specific platforms where your application runs:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n}.implies(mobileValue)\n\nrule {\n    platforms(Platform.WEB)\n}.implies(webValue)\n\nrule {\n    platforms(Platform.SERVER)\n}.implies(backendValue)\n</code></pre> <p>Available platforms: - <code>Platform.IOS</code> - <code>Platform.ANDROID</code> - <code>Platform.WEB</code> - <code>Platform.DESKTOP</code> - <code>Platform.SERVER</code></p>"},{"location":"Rules/#locale-targeting","title":"Locale Targeting","text":"<p>Target users based on language and region:</p> <pre><code>rule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA, AppLocale.EN_GB)\n}.implies(englishValue)\n\nrule {\n    locales(AppLocale.FR_FR, AppLocale.FR_CA)\n}.implies(frenchValue)\n\nrule {\n    locales(AppLocale.ES_ES, AppLocale.ES_MX)\n}.implies(spanishValue)\n</code></pre>"},{"location":"Rules/#version-targeting","title":"Version Targeting","text":"<p>Target specific version ranges using semantic versioning:</p> <pre><code>// Minimum version only\nrule {\n    versions {\n        min(2, 0, 0)  // Version 2.0.0 or higher\n    }\n}.implies(newFeatureValue)\n\n// Maximum version only\nrule {\n    versions {\n        max(2, 0, 0)  // Version 2.0.0 or lower\n    }\n}.implies(legacyValue)\n\n// Version range\nrule {\n    versions {\n        min(1, 5, 0)  // &gt;= 1.5.0\n        max(2, 0, 0)  // &lt;= 2.0.0\n    }\n}.implies(transitionValue)\n\n// Exact version\nrule {\n    versions {\n        min(2, 1, 3)\n        max(2, 1, 3)\n    }\n}.implies(specificVersionValue)\n</code></pre>"},{"location":"Rules/#combined-targeting","title":"Combined Targeting","text":"<p>Combine multiple criteria - all must match:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n    locales(AppLocale.EN_US)\n    versions {\n        min(2, 0, 0)\n    }\n}.implies(mobileEnglishV2Value)\n</code></pre>"},{"location":"Rules/#rollouts","title":"Rollouts","text":"<p>Rollouts enable gradual feature deployment to a percentage of users who match the rule criteria.</p>"},{"location":"Rules/#basic-rollout","title":"Basic Rollout","text":"<pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(25.0)  // 25% of iOS users\n}.implies(true)\n</code></pre>"},{"location":"Rules/#rollout-characteristics","title":"Rollout Characteristics","text":"<p>Deterministic: The same user (identified by <code>stableId</code>) always gets the same rollout assignment.</p> <pre><code>val user1 = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 0, 0),\n    stableId = StableId.of(\"user-123\")\n)\n\n// This user will always get the same result\nval result1 = user1.evaluateSafe(feature)  // Deterministic\nval result2 = user1.evaluateSafe(feature)  // Same as result1\n</code></pre> <p>Independent: Each flag has its own bucketing space. A user in the 25% rollout for one feature is independent of their assignment in another feature.</p> <p>Stable: Changing a flag's configuration does not affect rollout assignments unless you change the salt.</p>"},{"location":"Rules/#rollout-strategies","title":"Rollout Strategies","text":""},{"location":"Rules/#gradual-rollout","title":"Gradual Rollout","text":"<p>Increase rollout percentage over time:</p> <pre><code>// Phase 1: 10%\nconfig {\n    MyFeature.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.of(10.0)\n        }.implies(true)\n    }\n}\n\n// Phase 2: 50%\nconfig {\n    MyFeature.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n\n// Phase 3: 100%\nconfig {\n    MyFeature.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.MAX  // or Rollout.of(100.0)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#canary-deployment","title":"Canary Deployment","text":"<p>Test with a small percentage before wider rollout:</p> <pre><code>config {\n    MyFeature.RISKY_FEATURE with {\n        default(false)\n\n        // Canary: 1% of production users\n        rule {\n            rollout = Rollout.of(1.0)\n            note(\"Canary deployment - monitoring for issues\")\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#segmented-rollout","title":"Segmented Rollout","text":"<p>Different rollout percentages for different segments:</p> <pre><code>config {\n    MyFeature.BETA_FEATURE with {\n        default(false)\n\n        // 100% rollout for internal users\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext) =\n                        context.organizationId == \"internal\"\n                    override fun specificity() = 1\n                }\n            }\n            rollout = Rollout.MAX\n        }.implies(true)\n\n        // 25% rollout for enterprise customers\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext) =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n                    override fun specificity() = 1\n                }\n            }\n            rollout = Rollout.of(25.0)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#rollout-salt","title":"Rollout Salt","text":"<p>The salt affects hash-based bucketing. Changing the salt redistributes users across rollout buckets:</p> <pre><code>config {\n    MyFeature.EXPERIMENT with {\n        default(false)\n        salt(\"v1\")  // Initial salt\n\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n\n// Change salt to redistribute users\nconfig {\n    MyFeature.EXPERIMENT with {\n        default(false)\n        salt(\"v2\")  // Different salt = different buckets\n\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n</code></pre> <p>Use cases for changing salt: - Reset an A/B test with fresh user assignments - Fix biased rollout distributions - Run a new experiment on the same feature</p>"},{"location":"Rules/#rule-evaluation-order","title":"Rule Evaluation Order","text":"<p>Rules are evaluated in order of specificity (highest first). When multiple rules match, the first matching rule (by specificity) determines the value.</p>"},{"location":"Rules/#specificity-calculation","title":"Specificity Calculation","text":"<p>Specificity is the sum of specified constraints:</p> <pre><code>// Specificity = 0 (no constraints)\nrule {\n    rollout = Rollout.MAX\n}.implies(value)\n\n// Specificity = 1 (one constraint)\nrule {\n    platforms(Platform.IOS)\n}.implies(value)\n\n// Specificity = 2 (two constraints)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n}.implies(value)\n\n// Specificity = 3 (three constraints)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n}.implies(value)\n\n// Custom extensions add to specificity\nrule {\n    platforms(Platform.IOS)  // +1\n    extension {  // +1 (from extension's specificity())\n        object : Evaluable&lt;Context&gt;() {\n            override fun matches(context: Context) = /* custom logic */\n            override fun specificity() = 1\n        }\n    }\n}.implies(value)  // Total specificity = 2\n</code></pre>"},{"location":"Rules/#evaluation-example","title":"Evaluation Example","text":"<pre><code>config {\n    MyFeature.THEME with {\n        default(\"light\")\n\n        // Specificity = 2, evaluated first\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n        }.implies(\"dark-us\")\n\n        // Specificity = 1, evaluated second\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"dark-ios\")\n\n        // Specificity = 1, evaluated third (tie broken by note alphabetically)\n        rule {\n            locales(AppLocale.EN_US)\n        }.implies(\"light-us\")\n    }\n}\n\n// Context: iOS + EN_US\n// Matches both rule 1 (specificity 2) and rule 2 (specificity 1)\n// Returns \"dark-us\" (highest specificity wins)\nval context1 = Context(\n    platform = Platform.IOS,\n    locale = AppLocale.EN_US,\n    // ...\n)\ncontext1.evaluateSafe(MyFeature.THEME)  // \"dark-us\"\n\n// Context: iOS + FR_FR\n// Matches only rule 2 (specificity 1)\n// Returns \"dark-ios\"\nval context2 = Context(\n    platform = Platform.IOS,\n    locale = AppLocale.FR_FR,\n    // ...\n)\ncontext2.evaluateSafe(MyFeature.THEME)  // \"dark-ios\"\n</code></pre>"},{"location":"Rules/#custom-extensions","title":"Custom Extensions","text":"<p>Extensions allow domain-specific targeting beyond standard criteria using the <code>Evaluable</code> abstraction.</p>"},{"location":"Rules/#evaluable-interface","title":"Evaluable Interface","text":"<pre><code>abstract class Evaluable&lt;C : Context&gt; {\n    open fun matches(context: C): Boolean = true\n    open fun specificity(): Int = 0\n}\n</code></pre>"},{"location":"Rules/#basic-extension","title":"Basic Extension","text":"<pre><code>rule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(enterpriseValue)\n</code></pre>"},{"location":"Rules/#complex-extensions","title":"Complex Extensions","text":"<p>Combine multiple conditions:</p> <pre><code>rule {\n    platforms(Platform.WEB)\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean {\n                val isPremium = context.subscriptionTier in setOf(\n                    SubscriptionTier.PROFESSIONAL,\n                    SubscriptionTier.ENTERPRISE\n                )\n                val isAdmin = context.userRole in setOf(\n                    UserRole.ADMIN,\n                    UserRole.OWNER\n                )\n                return isPremium &amp;&amp; isAdmin\n            }\n\n            override fun specificity(): Int = 2  // Two conditions checked\n        }\n    }\n}.implies(premiumAdminValue)\n</code></pre>"},{"location":"Rules/#reusable-extensions","title":"Reusable Extensions","text":"<p>Define extension classes for reuse:</p> <pre><code>class SubscriptionTierEvaluable(\n    private val allowedTiers: Set&lt;SubscriptionTier&gt;\n) : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier in allowedTiers\n\n    override fun specificity(): Int = 1\n}\n\nclass UserRoleEvaluable(\n    private val allowedRoles: Set&lt;UserRole&gt;\n) : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.userRole in allowedRoles\n\n    override fun specificity(): Int = 1\n}\n\n// Use in rules\nconfig {\n    MyFeature.ADMIN_PANEL with {\n        default(false)\n\n        rule {\n            extension {\n                UserRoleEvaluable(setOf(UserRole.ADMIN, UserRole.OWNER))\n            }\n        }.implies(true)\n    }\n\n    MyFeature.PREMIUM_FEATURES with {\n        default(false)\n\n        rule {\n            extension {\n                SubscriptionTierEvaluable(setOf(\n                    SubscriptionTier.PROFESSIONAL,\n                    SubscriptionTier.ENTERPRISE\n                ))\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#rule-composition","title":"Rule Composition","text":"<p>Rules compose base targeting with custom extensions. Both must match for the rule to match.</p> <pre><code>rule {\n    // Base targeting (BaseEvaluable)\n    platforms(Platform.WEB)\n    locales(AppLocale.EN_US)\n\n    // Custom extension\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext) =\n                context.organizationId == \"enterprise-123\"\n            override fun specificity() = 1\n        }\n    }\n\n    // Rollout (checked after matching)\n    rollout = Rollout.of(50.0)\n}.implies(value)\n</code></pre> <p>Evaluation order: 1. Base targeting matches (platform, locale, version) 2. Extension matches (custom logic) 3. Rollout eligibility (hash-based bucketing)</p> <p>All three must succeed for the rule to select its value.</p>"},{"location":"Rules/#rule-notes","title":"Rule Notes","text":"<p>Add documentation to rules for clarity:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(25.0)\n    note(\"Gradual rollout to iOS users - Phase 1 of mobile launch\")\n}.implies(true)\n\nrule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext) =\n                context.organizationId in setOf(\"beta-tester-1\", \"beta-tester-2\")\n            override fun specificity() = 1\n        }\n    }\n    note(\"Beta testing with specific partner organizations\")\n}.implies(betaValue)\n</code></pre> <p>Notes are useful for: - Explaining complex targeting logic - Tracking rollout phases - Documenting business decisions - Debugging evaluation behavior</p>"},{"location":"Rules/#empty-rule-semantics","title":"Empty Rule Semantics","text":"<p>Empty constraints match everything:</p> <pre><code>// Matches all contexts (no constraints)\nrule {\n    rollout = Rollout.MAX\n}.implies(defaultValue)\n\n// Matches all platforms (locales empty)\nrule {\n    locales(AppLocale.EN_US)\n}.implies(englishValue)\n\n// Matches all versions (versionRange unbounded)\nrule {\n    platforms(Platform.IOS)\n}.implies(iosValue)\n</code></pre> <p>This \"match all\" semantic is useful for default rules or broad targeting.</p>"},{"location":"Rules/#best-practices","title":"Best Practices","text":""},{"location":"Rules/#order-rules-by-specificity","title":"Order Rules by Specificity","text":"<p>While Konditional handles this automatically, thinking in terms of specificity helps design clearer rules:</p> <pre><code>config {\n    MyFeature.VALUE with {\n        default(\"default\")\n\n        // Most specific: platform + locale + version\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n            versions { min(2, 0, 0) }\n        }.implies(\"specific\")\n\n        // Medium specific: platform + locale\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n        }.implies(\"medium\")\n\n        // Least specific: platform only\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"broad\")\n    }\n}\n</code></pre>"},{"location":"Rules/#use-extensions-for-domain-logic","title":"Use Extensions for Domain Logic","text":"<p>Keep standard targeting for platform/locale/version and use extensions for business logic:</p> <pre><code>// Good: Separation of concerns\nrule {\n    platforms(Platform.WEB)  // Standard targeting\n    extension {  // Domain logic\n        SubscriptionTierEvaluable(setOf(SubscriptionTier.ENTERPRISE))\n    }\n}.implies(value)\n\n// Avoid: Mixing concerns in one place would require custom rule types\n</code></pre>"},{"location":"Rules/#document-complex-rules","title":"Document Complex Rules","text":"<p>Use notes for rules with non-obvious logic:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;Context&gt;() {\n            override fun matches(context: Context) = /* complex logic */\n            override fun specificity() = 3\n        }\n    }\n    rollout = Rollout.of(15.0)\n    note(\"Targeting high-value users for premium feature test - approved by PM on 2024-01-15\")\n}.implies(premiumValue)\n</code></pre>"},{"location":"Rules/#test-rule-evaluation","title":"Test Rule Evaluation","text":"<p>Create unit tests for complex rule logic:</p> <pre><code>@Test\nfun `enterprise users get premium features`() {\n    val context = EnterpriseContext(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(2, 0, 0),\n        stableId = StableId.of(\"test-user\"),\n        subscriptionTier = SubscriptionTier.ENTERPRISE,\n        // ...\n    )\n\n    val result = context.evaluateSafe(MyFeature.PREMIUM_FEATURE)\n    assertTrue(result is EvaluationResult.Success &amp;&amp; result.value == true)\n}\n</code></pre>"},{"location":"Rules/#next-steps","title":"Next Steps","text":"<ul> <li>Flags: Learn about feature flag registration</li> <li>Builders: Master the rule DSL</li> <li>Context: Understand custom context extensions</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"Serialization/","title":"Serialization","text":"<p>Konditional provides JSON serialization for feature flag configurations, enabling external configuration management, snapshot storage, and dynamic updates.</p>"},{"location":"Serialization/#overview","title":"Overview","text":"<p>The serialization system allows you to:</p> <ul> <li>Export flag configurations to JSON</li> <li>Import configurations from JSON</li> <li>Apply incremental patches to existing configurations</li> <li>Store configurations in databases or file systems</li> <li>Load configurations from remote servers</li> </ul>"},{"location":"Serialization/#snapshotserializer","title":"SnapshotSerializer","text":"<p>The <code>SnapshotSerializer</code> class handles all serialization operations.</p>"},{"location":"Serialization/#creating-a-serializer","title":"Creating a Serializer","text":"<pre><code>// Use default instance\nval serializer = SnapshotSerializer.default\n\n// Or create with custom Moshi instance\nval customMoshi = Moshi.Builder()\n    // ... custom configuration\n    .build()\nval serializer = SnapshotSerializer(customMoshi)\n</code></pre>"},{"location":"Serialization/#serializing-configurations","title":"Serializing Configurations","text":""},{"location":"Serialization/#basic-serialization","title":"Basic Serialization","text":"<p>Export a <code>Konfig</code> to JSON:</p> <pre><code>// Build configuration\nval konfig = buildSnapshot {\n    MyFeatures.DARK_MODE with {\n        default(false)\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n}\n\n// Serialize to JSON\nval json = SnapshotSerializer.default.serialize(konfig)\n</code></pre>"},{"location":"Serialization/#serializing-from-registry","title":"Serializing from Registry","text":"<p>Export the current registry state:</p> <pre><code>// Get current configuration\nval currentKonfig = FlagRegistry.konfig()\n\n// Serialize\nval json = SnapshotSerializer.default.serialize(currentKonfig)\n\n// Save to file\nFile(\"flags.json\").writeText(json)\n</code></pre>"},{"location":"Serialization/#deserializing-configurations","title":"Deserializing Configurations","text":""},{"location":"Serialization/#basic-deserialization","title":"Basic Deserialization","text":"<p>Import configuration from JSON:</p> <pre><code>val json = File(\"flags.json\").readText()\n\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        val konfig = result.value\n        FlagRegistry.load(konfig)\n        println(\"Configuration loaded successfully\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Failed to parse: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"Serialization/#error-handling","title":"Error Handling","text":"<p>The deserialization API returns <code>ParseResult</code> for explicit error handling:</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n\nsealed interface ParseError {\n    data class InvalidJson(val message: String) : ParseError\n    data class InvalidSnapshot(val message: String) : ParseError\n    data class UnsupportedVersion(val version: String) : ParseError\n}\n</code></pre> <p>Usage:</p> <pre><code>val result = SnapshotSerializer.default.deserialize(json)\n\nresult.fold(\n    onSuccess = { konfig -&gt;\n        FlagRegistry.load(konfig)\n    },\n    onFailure = { error -&gt;\n        when (error) {\n            is ParseError.InvalidJson -&gt; logError(\"Malformed JSON: ${error.message}\")\n            is ParseError.InvalidSnapshot -&gt; logError(\"Invalid snapshot: ${error.message}\")\n            is ParseError.UnsupportedVersion -&gt; logError(\"Unsupported version: ${error.version}\")\n        }\n    }\n)\n</code></pre>"},{"location":"Serialization/#json-format","title":"JSON Format","text":""},{"location":"Serialization/#snapshot-structure","title":"Snapshot Structure","text":"<pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"valueType\": \"BOOLEAN\",\n      \"defaultValue\": false,\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"rules\": [\n        {\n          \"locales\": [],\n          \"platforms\": [\"IOS\"],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          },\n          \"rollout\": 100.0,\n          \"note\": \"iOS users get dark mode\",\n          \"value\": true\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"Serialization/#version-ranges","title":"Version Ranges","text":"<pre><code>// Unbounded (all versions)\n{\n  \"type\": \"UNBOUNDED\"\n}\n\n// Minimum bound (&gt;= 2.0.0)\n{\n  \"type\": \"MIN_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n\n// Maximum bound (&lt;= 3.0.0)\n{\n  \"type\": \"MAX_BOUND\",\n  \"max\": {\n    \"major\": 3,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n\n// Fully bound (&gt;= 2.0.0 and &lt;= 3.0.0)\n{\n  \"type\": \"MIN_AND_MAX_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  },\n  \"max\": {\n    \"major\": 3,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre>"},{"location":"Serialization/#value-types","title":"Value Types","text":"<pre><code>// Boolean\n{\n  \"valueType\": \"BOOLEAN\",\n  \"defaultValue\": false,\n  \"rules\": [\n    {\n      \"value\": true\n    }\n  ]\n}\n\n// String\n{\n  \"valueType\": \"STRING\",\n  \"defaultValue\": \"production\",\n  \"rules\": [\n    {\n      \"value\": \"staging\"\n    }\n  ]\n}\n\n// Integer\n{\n  \"valueType\": \"INTEGER\",\n  \"defaultValue\": 30,\n  \"rules\": [\n    {\n      \"value\": 60\n    }\n  ]\n}\n\n// Decimal\n{\n  \"valueType\": \"DECIMAL\",\n  \"defaultValue\": 0.5,\n  \"rules\": [\n    {\n      \"value\": 0.75\n    }\n  ]\n}\n\n// JSON Object\n{\n  \"valueType\": \"JSON\",\n  \"defaultValue\": {\n    \"baseUrl\": \"https://api.prod.example.com\",\n    \"timeout\": 30\n  },\n  \"rules\": [\n    {\n      \"value\": {\n        \"baseUrl\": \"https://api.staging.example.com\",\n        \"timeout\": 60\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"Serialization/#patches","title":"Patches","text":"<p>Apply incremental updates to configurations without replacing the entire snapshot.</p>"},{"location":"Serialization/#creating-patches","title":"Creating Patches","text":"<p>Patches are not directly created via DSL but through the internal serialization model. However, you can apply patches from JSON:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"new_feature\",\n      \"valueType\": \"BOOLEAN\",\n      \"defaultValue\": false,\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"rules\": []\n    }\n  ],\n  \"removeKeys\": [\"old_feature\"]\n}\n</code></pre>"},{"location":"Serialization/#applying-patches","title":"Applying Patches","text":"<pre><code>// Get current configuration\nval currentKonfig = FlagRegistry.konfig()\n\n// Apply patch from JSON\nval patchJson = \"\"\"\n{\n  \"flags\": [...],\n  \"removeKeys\": [...]\n}\n\"\"\".trimIndent()\n\nwhen (val result = SnapshotSerializer.default.applyPatchJson(currentKonfig, patchJson)) {\n    is ParseResult.Success -&gt; {\n        val updatedKonfig = result.value\n        FlagRegistry.load(updatedKonfig)\n    }\n    is ParseResult.Failure -&gt; {\n        logError(\"Failed to apply patch: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"Serialization/#remote-configuration","title":"Remote Configuration","text":""},{"location":"Serialization/#loading-from-remote-server","title":"Loading from Remote Server","text":"<pre><code>class RemoteConfigLoader(\n    private val apiClient: HttpClient,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    suspend fun loadConfiguration(url: String): Result&lt;Konfig&gt; {\n        return try {\n            val json = apiClient.get(url).bodyAsText()\n            when (val result = serializer.deserialize(json)) {\n                is ParseResult.Success -&gt; Result.success(result.value)\n                is ParseResult.Failure -&gt; Result.failure(\n                    ConfigurationException(\"Parse error: ${result.error}\")\n                )\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    suspend fun applyRemotePatch(patchUrl: String): Result&lt;Unit&gt; {\n        return try {\n            val patchJson = apiClient.get(patchUrl).bodyAsText()\n            val currentKonfig = FlagRegistry.konfig()\n\n            when (val result = serializer.applyPatchJson(currentKonfig, patchJson)) {\n                is ParseResult.Success -&gt; {\n                    FlagRegistry.load(result.value)\n                    Result.success(Unit)\n                }\n                is ParseResult.Failure -&gt; Result.failure(\n                    ConfigurationException(\"Patch error: ${result.error}\")\n                )\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>val loader = RemoteConfigLoader(httpClient)\n\n// Initial load\nloader.loadConfiguration(\"https://config.example.com/flags.json\")\n    .onSuccess { konfig -&gt;\n        FlagRegistry.load(konfig)\n        println(\"Configuration loaded\")\n    }\n    .onFailure { error -&gt;\n        logError(\"Failed to load configuration\", error)\n    }\n\n// Apply incremental update\nloader.applyRemotePatch(\"https://config.example.com/patches/123.json\")\n    .onSuccess {\n        println(\"Patch applied\")\n    }\n    .onFailure { error -&gt;\n        logError(\"Failed to apply patch\", error)\n    }\n</code></pre>"},{"location":"Serialization/#polling-for-updates","title":"Polling for Updates","text":"<pre><code>class ConfigurationPoller(\n    private val loader: RemoteConfigLoader,\n    private val pollIntervalMs: Long = 60_000\n) {\n    private var pollingJob: Job? = null\n\n    fun startPolling(configUrl: String, scope: CoroutineScope) {\n        pollingJob = scope.launch {\n            while (isActive) {\n                try {\n                    loader.loadConfiguration(configUrl)\n                        .onSuccess { konfig -&gt;\n                            FlagRegistry.load(konfig)\n                            logInfo(\"Configuration updated\")\n                        }\n                        .onFailure { error -&gt;\n                            logError(\"Poll failed\", error)\n                        }\n                } catch (e: Exception) {\n                    logError(\"Polling error\", e)\n                }\n\n                delay(pollIntervalMs)\n            }\n        }\n    }\n\n    fun stopPolling() {\n        pollingJob?.cancel()\n        pollingJob = null\n    }\n}\n</code></pre>"},{"location":"Serialization/#database-storage","title":"Database Storage","text":""},{"location":"Serialization/#storing-configurations","title":"Storing Configurations","text":"<pre><code>class ConfigurationRepository(\n    private val database: Database,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    fun saveConfiguration(name: String, konfig: Konfig) {\n        val json = serializer.serialize(konfig)\n        database.execute(\n            \"INSERT INTO configurations (name, json, updated_at) VALUES (?, ?, ?) \" +\n            \"ON CONFLICT (name) DO UPDATE SET json = ?, updated_at = ?\",\n            name, json, Instant.now(), json, Instant.now()\n        )\n    }\n\n    fun loadConfiguration(name: String): Konfig? {\n        val json = database.queryString(\n            \"SELECT json FROM configurations WHERE name = ?\",\n            name\n        ) ?: return null\n\n        return when (val result = serializer.deserialize(json)) {\n            is ParseResult.Success -&gt; result.value\n            is ParseResult.Failure -&gt; {\n                logError(\"Failed to deserialize configuration: ${result.error}\")\n                null\n            }\n        }\n    }\n\n    fun listConfigurations(): List&lt;String&gt; {\n        return database.queryList(\n            \"SELECT name FROM configurations ORDER BY name\"\n        )\n    }\n}\n</code></pre>"},{"location":"Serialization/#versioning-configurations","title":"Versioning Configurations","text":"<p>Track configuration versions:</p> <pre><code>data class VersionedConfiguration(\n    val version: Int,\n    val timestamp: Instant,\n    val konfig: Konfig,\n    val author: String,\n    val description: String\n)\n\nclass VersionedConfigurationRepository(\n    private val database: Database,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    fun saveVersion(config: VersionedConfiguration) {\n        val json = serializer.serialize(config.konfig)\n        database.execute(\n            \"\"\"\n            INSERT INTO configuration_versions\n            (version, timestamp, json, author, description)\n            VALUES (?, ?, ?, ?, ?)\n            \"\"\",\n            config.version,\n            config.timestamp,\n            json,\n            config.author,\n            config.description\n        )\n    }\n\n    fun loadVersion(version: Int): VersionedConfiguration? {\n        return database.queryOne(\n            \"\"\"\n            SELECT version, timestamp, json, author, description\n            FROM configuration_versions\n            WHERE version = ?\n            \"\"\",\n            version\n        ) { rs -&gt;\n            val json = rs.getString(\"json\")\n            when (val result = serializer.deserialize(json)) {\n                is ParseResult.Success -&gt; VersionedConfiguration(\n                    version = rs.getInt(\"version\"),\n                    timestamp = rs.getInstant(\"timestamp\"),\n                    konfig = result.value,\n                    author = rs.getString(\"author\"),\n                    description = rs.getString(\"description\")\n                )\n                is ParseResult.Failure -&gt; null\n            }\n        }\n    }\n\n    fun rollback(toVersion: Int) {\n        loadVersion(toVersion)?.let { config -&gt;\n            FlagRegistry.load(config.konfig)\n            logInfo(\"Rolled back to version $toVersion\")\n        }\n    }\n}\n</code></pre>"},{"location":"Serialization/#best-practices","title":"Best Practices","text":""},{"location":"Serialization/#validation","title":"Validation","text":"<p>Validate configurations after deserialization:</p> <pre><code>fun validateConfiguration(konfig: Konfig): List&lt;String&gt; {\n    val errors = mutableListOf&lt;String&gt;()\n\n    konfig.flags.forEach { (feature, definition) -&gt;\n        // Check for required flags\n        if (feature.key in requiredFlags &amp;&amp; !definition.isActive) {\n            errors.add(\"Required flag ${feature.key} is inactive\")\n        }\n\n        // Validate rollout percentages\n        definition.values.forEach { conditionalValue -&gt;\n            if (conditionalValue.rule.rollout.value !in 0.0..100.0) {\n                errors.add(\"Invalid rollout for ${feature.key}: ${conditionalValue.rule.rollout.value}\")\n            }\n        }\n    }\n\n    return errors\n}\n\n// Use validation\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        val errors = validateConfiguration(result.value)\n        if (errors.isEmpty()) {\n            FlagRegistry.load(result.value)\n        } else {\n            logError(\"Configuration validation failed: $errors\")\n        }\n    }\n    is ParseResult.Failure -&gt; logError(\"Parse error: ${result.error}\")\n}\n</code></pre>"},{"location":"Serialization/#backup-and-restore","title":"Backup and Restore","text":"<p>Implement backup mechanism:</p> <pre><code>class ConfigurationBackup(\n    private val backupDir: File,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    fun backup(name: String = \"backup-${Instant.now().epochSecond}\") {\n        val konfig = FlagRegistry.konfig()\n        val json = serializer.serialize(konfig)\n        val backupFile = File(backupDir, \"$name.json\")\n        backupFile.writeText(json)\n        logInfo(\"Configuration backed up to ${backupFile.absolutePath}\")\n    }\n\n    fun restore(name: String): Boolean {\n        val backupFile = File(backupDir, \"$name.json\")\n        if (!backupFile.exists()) {\n            logError(\"Backup file not found: $name\")\n            return false\n        }\n\n        val json = backupFile.readText()\n        return when (val result = serializer.deserialize(json)) {\n            is ParseResult.Success -&gt; {\n                FlagRegistry.load(result.value)\n                logInfo(\"Configuration restored from $name\")\n                true\n            }\n            is ParseResult.Failure -&gt; {\n                logError(\"Failed to restore: ${result.error}\")\n                false\n            }\n        }\n    }\n\n    fun listBackups(): List&lt;String&gt; {\n        return backupDir.listFiles { file -&gt; file.extension == \"json\" }\n            ?.map { it.nameWithoutExtension }\n            ?.sorted()\n            ?: emptyList()\n    }\n}\n</code></pre>"},{"location":"Serialization/#testing-serialization","title":"Testing Serialization","text":"<p>Test serialization round-trips:</p> <pre><code>@Test\nfun `serialization round-trip preserves configuration`() {\n    val original = buildSnapshot {\n        MyFeatures.DARK_MODE with {\n            default(false)\n            rule {\n                platforms(Platform.IOS)\n                locales(AppLocale.EN_US)\n                versions {\n                    min(2, 0, 0)\n                }\n                rollout = Rollout.of(50.0)\n            }.implies(true)\n        }\n    }\n\n    // Serialize\n    val json = SnapshotSerializer.default.serialize(original)\n\n    // Deserialize\n    val result = SnapshotSerializer.default.deserialize(json)\n    assertTrue(result is ParseResult.Success)\n\n    val deserialized = (result as ParseResult.Success).value\n\n    // Compare\n    assertEquals(original.flags.size, deserialized.flags.size)\n    // ... additional assertions\n}\n</code></pre>"},{"location":"Serialization/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture: Understand how serialization fits into the overall design</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"venv/lib/python3.14/site-packages/backrefs-5.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/idna-3.11.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/markdown-3.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip-25.2.dist-info/licenses/src/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}