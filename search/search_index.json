{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Konditional","text":"<p>Type-safe, deterministic feature flags for Kotlin</p>"},{"location":"#why-migrate-to-konditional","title":"Why Migrate to Konditional?","text":"<p>If you're tired of string-based feature flags with runtime errors, type casting nightmares, and inconsistent user experiences, Konditional offers a better way.</p> <pre><code>// Before: Typical untyped flags\nval isEnabled = featureFlags.getBoolean(\"new_checkout\", false)  // Typos, runtime errors\nval apiUrl = featureFlags.getString(\"api_url\", \"default\")       // No type safety\n\n// After: Konditional\nval isEnabled = context.evaluate(NEW_CHECKOUT)  // Compile-time safe\nval apiUrl = context.evaluate(API_URL)          // Type-safe\n</code></pre> <p>Start Migration \u2192 API Reference View on GitHub</p>"},{"location":"#migration-quick-start","title":"Migration Quick Start","text":"<p>Time: 10-15 minutes to migrate your first feature flag</p>"},{"location":"#step-1-add-dependency-2-min","title":"Step 1: Add Dependency (2 min)","text":"<pre><code>// build.gradle.kts\ndependencies {\n    implementation(\"io.amichne:konditional:0.0.1\")\n}\n</code></pre>"},{"location":"#step-2-define-your-context-3-min","title":"Step 2: Define Your Context (3 min)","text":"<p>Replace untyped context with structured <code>Context</code>:</p> Before: Untyped context map <pre><code>val context = mapOf(\n    \"userId\" to \"user-123\",\n    \"platform\" to \"iOS\",\n    \"version\" to \"2.1.0\",\n    \"locale\" to \"en_US\"\n)\n</code></pre> After: Type-safe Context <pre><code>import io.amichne.konditional.context.*\nimport io.amichne.konditional.core.id.StableId\n\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 1, 0),\n    stableId = StableId.of(\"user-123\")\n)\n</code></pre>"},{"location":"#step-3-convert-your-first-flag-5-min","title":"Step 3: Convert Your First Flag (5 min)","text":"<p>Transform string-based flags to type-safe <code>Conditional</code>:</p> Before: String-based flag <pre><code>// Definition (scattered across codebase)\nval FLAG_KEY = \"new_checkout_enabled\"\n\n// Usage (error-prone)\nif (featureFlags.getBoolean(FLAG_KEY, false)) {\n    showNewCheckout()\n}\n</code></pre> After: Type-safe Conditional <pre><code>import io.amichne.konditional.core.Conditional\nimport io.amichne.konditional.builders.ConfigBuilder\nimport io.amichne.konditional.context.evaluate\n\n// Define once\nval NEW_CHECKOUT: Conditional&lt;Boolean, Context&gt; =\n    Conditional(\"new_checkout_enabled\")\n\n// Configure\nConfigBuilder.config {\n    NEW_CHECKOUT with {\n        default(value = false)\n\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n            versions { min(Version(2, 0, 0)) }\n        } implies true\n    }\n}\n\n// Use everywhere (type-safe!)\nif (context.evaluate(NEW_CHECKOUT)) {\n    showNewCheckout()\n}\n</code></pre>"},{"location":"#step-4-test-verify-3-5-min","title":"Step 4: Test &amp; Verify (3-5 min)","text":"<pre><code>@Test\nfun `new checkout flag works correctly`() {\n    val iosContext = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version(2, 1, 0),\n        stableId = StableId.of(\"test-user\")\n    )\n\n    assertTrue(iosContext.evaluate(NEW_CHECKOUT))\n}\n</code></pre> <p>Complete Migration Guide \u2192</p>"},{"location":"#why-konditional","title":"Why Konditional?","text":""},{"location":"#compile-time-type-safety","title":"Compile-Time Type Safety","text":"<pre><code>graph LR\n    A[Old: String Keys] --&gt;|Runtime| B[Type Casting]\n    B --&gt;|Errors| C[Production Bugs]\n\n    D[Konditional] --&gt;|Compile Time| E[Type Checking]\n    E --&gt;|Safe| F[Zero Runtime Errors]\n\n    style A fill:#ffe1e1\n    style C fill:#ffe1e1\n    style D fill:#e1ffe1\n    style F fill:#e1ffe1\n</code></pre> <p>No more <code>ClassCastException</code> or <code>NullPointerException</code> from misconfigured flags.</p>"},{"location":"#deterministic-rollouts","title":"Deterministic Rollouts","text":"<p>Users get consistent experiences across sessions using SHA-256 bucketing:</p> <pre><code>// Same user always gets the same variant\nval variant = context.evaluate(AB_TEST_VARIANT)\n</code></pre>"},{"location":"#parse-dont-validate","title":"Parse, Don't Validate","text":"<p>Structured error handling without exceptions:</p> <pre><code>when (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; registry.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre>"},{"location":"#powerful-targeting","title":"Powerful Targeting","text":"<p>Combine multiple criteria seamlessly:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US, AppLocale.EN_CA)\n    versions { min(Version(2, 0, 0)) }\n    rollout = Rollout.of(50.0)\n} implies true\n</code></pre>"},{"location":"#custom-context-extensions","title":"Custom Context Extensions","text":"<p>Add domain-specific targeting without hacks:</p> <pre><code>data class UserContext(\n    // Standard fields\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    // Your custom fields\n    val isPremium: Boolean,\n    val accountAge: Int\n) : Context\n</code></pre>"},{"location":"#learn-by-example","title":"Learn by Example","text":""},{"location":"#quick-start","title":"Quick Start","text":"<p>Get your first flag running in 10 minutes</p> <p>Basic Usage \u2192</p>"},{"location":"#gradual-rollouts","title":"Gradual Rollouts","text":"<p>Deploy features to percentages of users safely</p> <p>Rollout Examples \u2192</p>"},{"location":"#custom-targeting","title":"Custom Targeting","text":"<p>Extend context for your business logic</p> <p>Custom Context \u2192</p>"},{"location":"#remote-configuration","title":"Remote Configuration","text":"<p>Serialize and load flags from your backend</p> <p>Serialization \u2192</p>"},{"location":"#common-migration-patterns","title":"Common Migration Patterns","text":""},{"location":"#boolean-feature-toggles","title":"Boolean Feature Toggles","text":"<pre><code>// Old\nval enabled = flags.getBoolean(\"feature_enabled\", false)\n\n// New\nval FEATURE_ENABLED: Conditional&lt;Boolean, Context&gt; = Conditional(\"feature_enabled\")\nval enabled = context.evaluate(FEATURE_ENABLED)\n</code></pre>"},{"location":"#configuration-values","title":"Configuration Values","text":"<pre><code>// Old\nval timeout = flags.getInt(\"api_timeout\", 5000)\nval endpoint = flags.getString(\"api_endpoint\", \"https://api.example.com\")\n\n// New\ndata class ApiConfig(val timeout: Int, val endpoint: String)\nval API_CONFIG: Conditional&lt;ApiConfig, Context&gt; = Conditional(\"api_config\")\nval config = context.evaluate(API_CONFIG)\n</code></pre>"},{"location":"#percentage-rollouts","title":"Percentage Rollouts","text":"<pre><code>// Old (often inconsistent)\nval userId = user.id.hashCode()\nval enabled = (userId % 100) &lt; 25  // 25% rollout\n\n// New (deterministic)\nConfigBuilder.config {\n    FEATURE with {\n        default(value = false)\n        rule { rollout = Rollout.of(25.0) } implies true\n    }\n}\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>New to Konditional?</p> <ol> <li>API Overview - Understand core concepts (10 min)</li> <li>Examples - See real code (20 min)</li> <li>Builder DSL - Learn the configuration syntax (10 min)</li> </ol> <p>Ready to integrate?</p> <ol> <li>Core API - Conditionals and evaluation</li> <li>Context System - Targeting dimensions</li> <li>Rules System - Advanced targeting logic</li> <li>Serialization - Remote configuration</li> </ol>"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":"Feature Traditional Flags Konditional Type Safety Runtime Compile-time Consistent Bucketing Often random SHA-256 deterministic Error Handling Exceptions ParseResult/EvaluationResult Custom Context Map-based First-class support Multi-variant Testing Complex Built-in JSON Serialization Manual Type-safe built-in Version Targeting String parsing Semantic versioning <p>Total migration time: 30-45 minutes for your first feature flag system migration.</p>"},{"location":"api/Builders/","title":"Builder DSL","text":"<p>Konditional provides a type-safe DSL for declaratively defining feature flags and their rules. The DSL uses Kotlin's builder pattern and infix notation for readable, maintainable flag configurations.</p>"},{"location":"api/Builders/#configbuilder","title":"ConfigBuilder","text":"<p>The entry point for defining flag configurations.</p> <pre><code>@FeatureFlagDsl\nclass ConfigBuilder\n</code></pre>"},{"location":"api/Builders/#creating-configurations","title":"Creating Configurations","text":""},{"location":"api/Builders/#load-directly-into-registry","title":"Load Directly into Registry","text":"<pre><code>import io.amichne.konditional.builders.ConfigBuilder\n\nConfigBuilder.config {\n    MY_FLAG with {\n        default(value = false)\n        // rules...\n    }\n}\n// Configuration is immediately loaded into FlagRegistry\n</code></pre>"},{"location":"api/Builders/#build-snapshot-for-later-use","title":"Build Snapshot for Later Use","text":"<pre><code>val konfig = ConfigBuilder.buildSnapshot {\n    MY_FLAG with {\n        default(value = false)\n    }\n}\n\n// Load later\nFlagRegistry.load(konfig)\n\n// Or serialize\nval json = SnapshotSerializer.default.serialize(konfig)\n</code></pre>"},{"location":"api/Builders/#custom-registry","title":"Custom Registry","text":"<pre><code>ConfigBuilder.config(registry = customRegistry) {\n    MY_FLAG with {\n        default(value = false)\n    }\n}\n</code></pre>"},{"location":"api/Builders/#flagbuilder","title":"FlagBuilder","text":"<p>Configures individual feature flags within a ConfigBuilder block.</p> <pre><code>@FeatureFlagDsl\nclass FlagBuilder&lt;S : Any, C : Context&gt;\n</code></pre>"},{"location":"api/Builders/#defining-flags","title":"Defining Flags","text":"<pre><code>MY_FLAG with {\n    // Required: set default value\n    default(value = false)\n\n    // Optional: set salt for hashing\n    salt(\"v2\")\n\n    // Optional: define targeting rules\n    rule {\n        platforms(Platform.IOS)\n        rollout = Rollout.of(50.0)\n    } implies true\n}\n</code></pre>"},{"location":"api/Builders/#default-value","title":"Default Value","text":"<p>Every flag must have a default value returned when no rules match:</p> <pre><code>MY_FLAG with {\n    default(value = false)\n}\n</code></pre> <p>For complex types:</p> <pre><code>CONFIG_FLAG with {\n    default(\n        value = FeatureConfig(\n            timeout = 5000,\n            retries = 3,\n            endpoint = \"https://api.example.com\"\n        )\n    )\n}\n</code></pre>"},{"location":"api/Builders/#salt","title":"Salt","text":"<p>Optional salt string for deterministic hashing (defaults to \"v1\"):</p> <pre><code>MY_FLAG with {\n    default(value = false)\n    salt(\"v2\")  // Use different salt for different bucketing\n}\n</code></pre>"},{"location":"api/Builders/#rules-and-implications","title":"Rules and Implications","text":"<p>Define targeting rules and their associated values using the <code>rule { } implies value</code> syntax:</p> <pre><code>MY_FLAG with {\n    default(value = false)\n\n    // Simple rule\n    rule {\n        platforms(Platform.IOS)\n    } implies true\n\n    // Multiple rules\n    rule {\n        platforms(Platform.ANDROID)\n        rollout = Rollout.of(50.0)\n    } implies true\n\n    rule {\n        locales(AppLocale.EN_US, AppLocale.EN_CA)\n        platforms(Platform.WEB)\n    } implies false\n}\n</code></pre>"},{"location":"api/Builders/#rulebuilder","title":"RuleBuilder","text":"<p>Configures individual targeting rules within a FlagBuilder block.</p> <pre><code>@FeatureFlagDsl\nclass RuleBuilder&lt;C : Context&gt;\n</code></pre>"},{"location":"api/Builders/#platform-targeting","title":"Platform Targeting","text":"<p>Target specific platforms:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n} implies true\n\n// Multiple platforms\nrule {\n    platforms(Platform.IOS, Platform.ANDROID)\n} implies true\n</code></pre>"},{"location":"api/Builders/#locale-targeting","title":"Locale Targeting","text":"<p>Target specific locales:</p> <pre><code>rule {\n    locales(AppLocale.EN_US)\n} implies true\n\n// Multiple locales\nrule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA, AppLocale.ES_US)\n} implies true\n</code></pre>"},{"location":"api/Builders/#version-targeting","title":"Version Targeting","text":"<p>Target version ranges:</p> <pre><code>rule {\n    versions {\n        min(Version(2, 0, 0))  // &gt;= 2.0.0\n    }\n} implies true\n\nrule {\n    versions {\n        max(Version(3, 0, 0))  // &lt; 3.0.0\n    }\n} implies true\n\nrule {\n    versions {\n        min(Version(2, 0, 0))  // &gt;= 2.0.0 and &lt; 3.0.0\n        max(Version(3, 0, 0))\n    }\n} implies true\n\nrule {\n    versions {\n        exactly(Version(2, 5, 0))  // exactly 2.5.0\n    }\n} implies true\n</code></pre>"},{"location":"api/Builders/#rollout-percentage","title":"Rollout Percentage","text":"<p>Gradually roll out features to a percentage of users:</p> <pre><code>rule {\n    rollout = Rollout.of(25.0)  // 25% of users\n} implies true\n\nrule {\n    rollout = Rollout.of(50)    // 50% of users (Int also works)\n} implies true\n\nrule {\n    rollout = Rollout.of(\"75.5\")  // 75.5% of users (String also works)\n} implies true\n</code></pre> <p>Rollout uses deterministic hashing with StableId for consistent bucketing.</p>"},{"location":"api/Builders/#notes","title":"Notes","text":"<p>Add documentation to rules:</p> <pre><code>rule {\n    note(\"iOS beta users only\")\n    platforms(Platform.IOS)\n    rollout = Rollout.of(10.0)\n} implies true\n</code></pre>"},{"location":"api/Builders/#custom-extension-logic","title":"Custom Extension Logic","text":"<p>Add custom evaluation logic beyond standard targeting:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean {\n                return context.subscriptionTier == SubscriptionTier.PREMIUM &amp;&amp;\n                       context.organizationId.startsWith(\"enterprise-\")\n            }\n\n            override fun specificity(): Int = 2\n        }\n    }\n} implies true\n</code></pre>"},{"location":"api/Builders/#combining-criteria","title":"Combining Criteria","text":"<p>All criteria in a rule must match (AND logic):</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions {\n        min(Version(2, 0, 0))\n    }\n    rollout = Rollout.of(50.0)\n} implies true\n// Matches if: iOS AND EN_US AND &gt;= 2.0.0 AND in rollout bucket\n</code></pre> <p>Multiple rules provide OR logic:</p> <pre><code>MY_FLAG with {\n    default(value = false)\n\n    // iOS users get true\n    rule {\n        platforms(Platform.IOS)\n    } implies true\n\n    // OR Android users with &gt;= 2.0.0 get true\n    rule {\n        platforms(Platform.ANDROID)\n        versions {\n            min(Version(2, 0, 0))\n        }\n    } implies true\n}\n</code></pre>"},{"location":"api/Builders/#complete-examples","title":"Complete Examples","text":""},{"location":"api/Builders/#simple-boolean-toggle","title":"Simple Boolean Toggle","text":"<pre><code>ConfigBuilder.config {\n    ENABLE_NEW_UI with {\n        default(value = false)\n\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n            rollout = Rollout.of(100.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/Builders/#phased-rollout","title":"Phased Rollout","text":"<pre><code>ConfigBuilder.config {\n    BETA_FEATURE with {\n        default(value = false)\n\n        // Phase 1: Internal testing (5%)\n        rule {\n            note(\"Internal testing phase\")\n            rollout = Rollout.of(5.0)\n        } implies true\n\n        // Phase 2: Beta users (25%)\n        rule {\n            note(\"Beta users\")\n            rollout = Rollout.of(25.0)\n        } implies true\n\n        // Phase 3: General availability (100%)\n        rule {\n            note(\"General availability\")\n            rollout = Rollout.of(100.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/Builders/#platform-specific-rollout","title":"Platform-Specific Rollout","text":"<pre><code>ConfigBuilder.config {\n    NEW_CHECKOUT with {\n        default(value = false)\n\n        // Full rollout on iOS\n        rule {\n            platforms(Platform.IOS)\n            versions {\n                min(Version(2, 0, 0))\n            }\n        } implies true\n\n        // 50% rollout on Android\n        rule {\n            platforms(Platform.ANDROID)\n            versions {\n                min(Version(2, 0, 0))\n            }\n            rollout = Rollout.of(50.0)\n        } implies true\n\n        // Not available on Web yet\n    }\n}\n</code></pre>"},{"location":"api/Builders/#configuration-flag","title":"Configuration Flag","text":"<pre><code>data class ApiConfig(\n    val endpoint: String,\n    val timeout: Int,\n    val retries: Int\n)\n\nval API_CONFIG: Conditional&lt;ApiConfig, AppContext&gt; =\n    Conditional(\"api_config\")\n\nConfigBuilder.config {\n    API_CONFIG with {\n        default(\n            value = ApiConfig(\n                endpoint = \"https://api.example.com\",\n                timeout = 5000,\n                retries = 3\n            )\n        )\n\n        // Beta endpoint for testing\n        rule {\n            note(\"Beta API endpoint\")\n            rollout = Rollout.of(10.0)\n        } implies ApiConfig(\n            endpoint = \"https://beta-api.example.com\",\n            timeout = 10000,\n            retries = 5\n        )\n    }\n}\n</code></pre>"},{"location":"api/Builders/#regional-configuration","title":"Regional Configuration","text":"<pre><code>ConfigBuilder.config {\n    FEATURE_ENABLED with {\n        default(value = false)\n\n        // North American launch\n        rule {\n            note(\"North America\")\n            locales(AppLocale.EN_US, AppLocale.EN_CA, AppLocale.ES_US)\n            versions {\n                min(Version(1, 5, 0))\n            }\n        } implies true\n\n        // International markets\n        rule {\n            note(\"International markets\")\n            locales(AppLocale.HI_IN)\n            versions {\n                min(Version(2, 0, 0))\n            }\n            rollout = Rollout.of(50.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/Builders/#extended-context-targeting","title":"Extended Context Targeting","text":"<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val organizationSize: Int\n) : Context\n\nenum class SubscriptionTier { FREE, BASIC, PREMIUM, ENTERPRISE }\n\nval PREMIUM_FEATURE: Conditional&lt;Boolean, EnterpriseContext&gt; =\n    Conditional(\"premium_feature\")\n\nConfigBuilder.config {\n    PREMIUM_FEATURE with {\n        default(value = false)\n\n        rule {\n            note(\"Premium and Enterprise tiers\")\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier in setOf(\n                            SubscriptionTier.PREMIUM,\n                            SubscriptionTier.ENTERPRISE\n                        )\n\n                    override fun specificity(): Int = 1\n                }\n            }\n        } implies true\n\n        rule {\n            note(\"Large Basic tier organizations (&gt;100 users)\")\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.BASIC &amp;&amp;\n                        context.organizationSize &gt; 100\n\n                    override fun specificity(): Int = 2\n                }\n            }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/Builders/#multi-variant-flag","title":"Multi-Variant Flag","text":"<pre><code>enum class CheckoutVariant {\n    CONTROL, VARIANT_A, VARIANT_B\n}\n\nval CHECKOUT_VARIANT: Conditional&lt;CheckoutVariant, AppContext&gt; =\n    Conditional(\"checkout_variant\")\n\nConfigBuilder.config {\n    CHECKOUT_VARIANT with {\n        default(value = CheckoutVariant.CONTROL)\n\n        // 33% get Variant A\n        rule {\n            note(\"Variant A\")\n            rollout = Rollout.of(33.0)\n        } implies CheckoutVariant.VARIANT_A\n\n        // 33% get Variant B\n        rule {\n            note(\"Variant B\")\n            rollout = Rollout.of(66.0)  // 66% total, so 33% additional\n        } implies CheckoutVariant.VARIANT_B\n\n        // Remaining 34% get control (default)\n    }\n}\n</code></pre>"},{"location":"api/Builders/#dsl-structure-diagram","title":"DSL Structure Diagram","text":"<pre><code>graph TD\n    A[ConfigBuilder] --&gt; B[config block]\n    B --&gt; C[Conditional with block]\n    C --&gt; D[FlagBuilder]\n    D --&gt; E[default]\n    D --&gt; F[salt]\n    D --&gt; G[rule block]\n    G --&gt; H[RuleBuilder]\n    H --&gt; I[platforms]\n    H --&gt; J[locales]\n    H --&gt; K[versions]\n    H --&gt; L[rollout]\n    H --&gt; M[extension]\n    H --&gt; N[note]\n    G --&gt; O[implies]\n    O --&gt; P[Target Value]\n\n    style A fill:#e1f5ff\n    style D fill:#ffe1f5\n    style H fill:#e1ffe1\n    style P fill:#fff4e1\n</code></pre>"},{"location":"api/Builders/#builder-flow","title":"Builder Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant ConfigBuilder\n    participant FlagBuilder\n    participant RuleBuilder\n    participant Registry\n\n    Client-&gt;&gt;ConfigBuilder: config { }\n    ConfigBuilder-&gt;&gt;FlagBuilder: FLAG with { }\n    FlagBuilder-&gt;&gt;FlagBuilder: default(value)\n    FlagBuilder-&gt;&gt;RuleBuilder: rule { }\n    RuleBuilder-&gt;&gt;RuleBuilder: platforms(...)\n    RuleBuilder-&gt;&gt;RuleBuilder: rollout = ...\n    RuleBuilder-&gt;&gt;FlagBuilder: return Rule\n    FlagBuilder-&gt;&gt;FlagBuilder: implies value\n    FlagBuilder-&gt;&gt;ConfigBuilder: return FeatureFlag\n    ConfigBuilder-&gt;&gt;Registry: load(konfig)\n</code></pre>"},{"location":"api/Builders/#best-practices","title":"Best Practices","text":""},{"location":"api/Builders/#1-one-configuration-block","title":"1. One Configuration Block","text":"<p>Define all flags in a single configuration block during initialization:</p> <pre><code>fun initializeFlags() {\n    ConfigBuilder.config {\n        FEATURE_A with { ... }\n        FEATURE_B with { ... }\n        FEATURE_C with { ... }\n    }\n}\n</code></pre>"},{"location":"api/Builders/#2-rule-specificity-ordering","title":"2. Rule Specificity Ordering","text":"<p>More specific rules are evaluated first. Order doesn't matter in the DSL:</p> <pre><code>MY_FLAG with {\n    default(value = \"default\")\n\n    // These are automatically ordered by specificity\n    rule {\n        // Specificity: 3 (locale + platform + version)\n        locales(AppLocale.EN_US)\n        platforms(Platform.IOS)\n        versions { min(Version(2, 0, 0)) }\n    } implies \"very-specific\"\n\n    rule {\n        // Specificity: 2 (locale + platform)\n        locales(AppLocale.EN_US)\n        platforms(Platform.IOS)\n    } implies \"less-specific\"\n\n    rule {\n        // Specificity: 1 (platform only)\n        platforms(Platform.IOS)\n    } implies \"least-specific\"\n}\n</code></pre>"},{"location":"api/Builders/#3-use-notes-for-documentation","title":"3. Use Notes for Documentation","text":"<p>Add notes to explain rule intent:</p> <pre><code>rule {\n    note(\"iOS beta program - 10% of users for testing\")\n    platforms(Platform.IOS)\n    rollout = Rollout.of(10.0)\n} implies true\n</code></pre>"},{"location":"api/Builders/#4-extract-complex-rules","title":"4. Extract Complex Rules","text":"<p>Extract complex extension logic to named classes:</p> <pre><code>class PremiumUserEvaluable : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier in setOf(\n            SubscriptionTier.PREMIUM,\n            SubscriptionTier.ENTERPRISE\n        ) &amp;&amp; context.accountAge &gt; 30\n\n    override fun specificity(): Int = 2\n}\n\nConfigBuilder.config {\n    PREMIUM_FEATURE with {\n        default(value = false)\n        rule {\n            extension { PremiumUserEvaluable() }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/Builders/#5-validate-configurations","title":"5. Validate Configurations","text":"<p>Build snapshots in tests to validate flag definitions:</p> <pre><code>@Test\nfun validateFlagConfiguration() {\n    val konfig = ConfigBuilder.buildSnapshot {\n        MY_FLAG with {\n            default(value = false)\n            rule { platforms(Platform.IOS) } implies true\n        }\n    }\n\n    assertEquals(1, konfig.flags.size)\n    assertTrue(konfig.flags.containsKey(MY_FLAG))\n}\n</code></pre>"},{"location":"api/Builders/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core API - Conditional and FeatureFlag types</li> <li>Rules System - Rule evaluation and composition</li> <li>Context - Context types and extension</li> <li>Flag Registry - Loading and managing configurations</li> </ul>"},{"location":"api/Context/","title":"Context System","text":"<p>The Context system provides the evaluation dimensions for feature flags. Contexts are passed to flags during evaluation to determine which rules match.</p>"},{"location":"api/Context/#context-interface","title":"Context Interface","text":"<pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n</code></pre>"},{"location":"api/Context/#standard-properties","title":"Standard Properties","text":"<ul> <li>locale: Application locale for region/language targeting</li> <li>platform: Deployment platform (iOS, Android, Web)</li> <li>appVersion: Semantic version for version-based targeting</li> <li>stableId: Unique identifier for deterministic rollout bucketing</li> </ul>"},{"location":"api/Context/#creating-contexts","title":"Creating Contexts","text":""},{"location":"api/Context/#factory-method","title":"Factory Method","text":"<pre><code>val context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(1, 2, 3),\n    stableId = StableId.of(\"550e8400-e29b-41d4-a716-446655440000\")\n)\n</code></pre>"},{"location":"api/Context/#data-class-implementation","title":"Data Class Implementation","text":"<pre><code>data class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n\nval context = AppContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.ANDROID,\n    appVersion = Version(2, 0, 0),\n    stableId = StableId.of(userId)\n)\n</code></pre>"},{"location":"api/Context/#context-extension","title":"Context Extension","text":"<p>Extend Context to add custom targeting dimensions:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val isAdmin: Boolean\n) : Context\n\nenum class SubscriptionTier {\n    FREE, BASIC, PREMIUM, ENTERPRISE\n}\n</code></pre>"},{"location":"api/Context/#using-extended-contexts","title":"Using Extended Contexts","text":"<pre><code>// Define flags with custom context type\nval PREMIUM_FEATURE: Conditional&lt;Boolean, EnterpriseContext&gt; =\n    Conditional(\"premium_feature\")\n\nConfigBuilder.config {\n    PREMIUM_FEATURE with {\n        default(value = false)\n\n        rule {\n            // Use custom extension for tier targeting\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier in setOf(\n                            SubscriptionTier.PREMIUM,\n                            SubscriptionTier.ENTERPRISE\n                        )\n\n                    override fun specificity(): Int = 1\n                }\n            }\n        } implies true\n    }\n}\n\n// Evaluate with extended context\nval context = EnterpriseContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.WEB,\n    appVersion = Version(1, 0, 0),\n    stableId = StableId.of(userId),\n    organizationId = \"acme-corp\",\n    subscriptionTier = SubscriptionTier.PREMIUM,\n    isAdmin = true\n)\n\nval isEnabled = context.evaluate(PREMIUM_FEATURE)\n</code></pre>"},{"location":"api/Context/#context-properties","title":"Context Properties","text":""},{"location":"api/Context/#applocale","title":"AppLocale","text":"<p>Enum representing application locales:</p> <pre><code>enum class AppLocale {\n    EN_US,  // English - United States\n    ES_US,  // Spanish - United States\n    EN_CA,  // English - Canada\n    HI_IN   // Hindi - India\n}\n</code></pre> <p>Extend with your supported locales:</p> <pre><code>enum class CustomLocale {\n    EN_US, EN_GB, FR_FR, DE_DE, JA_JP, ZH_CN\n}\n\ndata class CustomContext(\n    val customLocale: CustomLocale,\n    override val locale: AppLocale,  // Map to closest AppLocale\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n</code></pre>"},{"location":"api/Context/#platform","title":"Platform","text":"<p>Enum representing deployment platforms:</p> <pre><code>enum class Platform {\n    IOS,\n    ANDROID,\n    WEB\n}\n</code></pre> <p>Target specific platforms in rules:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n} implies true\n</code></pre>"},{"location":"api/Context/#version","title":"Version","text":"<p>Semantic version with major, minor, and patch components:</p> <pre><code>data class Version(\n    val major: Int,\n    val minor: Int,\n    val patch: Int\n) : Comparable&lt;Version&gt;\n</code></pre>"},{"location":"api/Context/#creating-versions","title":"Creating Versions","text":"<pre><code>// Constructor\nval v1 = Version(1, 2, 3)\n\n// Factory method\nval v2 = Version.of(2, 0, 0)\n\n// Parsing strings\nval v3 = Version.parse(\"1.5.2\")  // Version(1, 5, 2)\nval v4 = Version.parse(\"2.0\")    // Version(2, 0, 0)\nval v5 = Version.parse(\"3\")      // Version(3, 0, 0)\n\n// Default version\nval vDefault = Version.default  // Version(-1, -1, -1)\n</code></pre>"},{"location":"api/Context/#version-comparison","title":"Version Comparison","text":"<pre><code>val v1 = Version(1, 0, 0)\nval v2 = Version(1, 5, 0)\nval v3 = Version(2, 0, 0)\n\nprintln(v1 &lt; v2)  // true\nprintln(v2 &lt; v3)  // true\nprintln(v1 == Version(1, 0, 0))  // true\n</code></pre>"},{"location":"api/Context/#stableid","title":"StableId","text":"<p>Type-safe wrapper for stable identifiers used in rollout bucketing:</p> <pre><code>sealed interface StableId {\n    val id: String\n    val hexId: HexId\n}\n</code></pre>"},{"location":"api/Context/#creating-stableids","title":"Creating StableIds","text":"<pre><code>// From UUID string (automatically normalized to hex)\nval id1 = StableId.of(\"550e8400-e29b-41d4-a716-446655440000\")\n\n// From user ID\nval id2 = StableId.of(userId)\n\n// From device ID\nval id3 = StableId.of(deviceId)\n</code></pre> <p>StableId validates and normalizes identifiers to hexadecimal format for consistent hashing.</p>"},{"location":"api/Context/#context-evaluation","title":"Context Evaluation","text":""},{"location":"api/Context/#evaluation-extension-functions","title":"Evaluation Extension Functions","text":"<p>The Context system provides extension functions for evaluating flags:</p> <pre><code>// Evaluate single flag (throws if not found)\nfun &lt;S : Any, C : Context&gt; C.evaluate(\n    key: Conditional&lt;S, C&gt;,\n    registry: FlagRegistry = FlagRegistry\n): S\n\n// Evaluate all flags\nfun &lt;C : Context&gt; C.evaluate(\n    registry: FlagRegistry = FlagRegistry\n): Map&lt;Conditional&lt;*, *&gt;, Any?&gt;\n</code></pre>"},{"location":"api/Context/#single-flag-evaluation","title":"Single Flag Evaluation","text":"<pre><code>val MY_FLAG: Conditional&lt;Boolean, MyContext&gt; = Conditional(\"my_flag\")\n\n// Evaluate single flag\nval value: Boolean = context.evaluate(MY_FLAG)\n\n// With custom registry\nval value2: Boolean = context.evaluate(MY_FLAG, registry = customRegistry)\n</code></pre>"},{"location":"api/Context/#batch-evaluation","title":"Batch Evaluation","text":"<pre><code>// Evaluate all flags in registry\nval allValues: Map&lt;Conditional&lt;*, *&gt;, Any?&gt; = context.evaluate()\n\nallValues.forEach { (conditional, value) -&gt;\n    println(\"${conditional.key}: $value\")\n}\n\n// Filter to specific flags\nval myFlags = listOf(FLAG_A, FLAG_B, FLAG_C)\nval values = context.evaluate().filterKeys { it in myFlags }\n</code></pre>"},{"location":"api/Context/#context-polymorphism","title":"Context Polymorphism","text":"<p>Konditional supports context type polymorphism through Kotlin's type system:</p> <pre><code>classDiagram\n    class Context {\n        &lt;&gt;\n        +locale: AppLocale\n        +platform: Platform\n        +appVersion: Version\n        +stableId: StableId\n    }\n\n    class BaseContext {\n        +locale: AppLocale\n        +platform: Platform\n        +appVersion: Version\n        +stableId: StableId\n    }\n\n    class EnterpriseContext {\n        +locale: AppLocale\n        +platform: Platform\n        +appVersion: Version\n        +stableId: StableId\n        +organizationId: String\n        +subscriptionTier: Tier\n    }\n\n    class MobileContext {\n        +locale: AppLocale\n        +platform: Platform\n        +appVersion: Version\n        +stableId: StableId\n        +deviceModel: String\n        +osVersion: String\n    }\n\n    Context &lt;|.. BaseContext\n    Context &lt;|.. EnterpriseContext\n    Context &lt;|.. MobileContext"},{"location":"api/Context/#hierarchical-contexts","title":"Hierarchical Contexts","text":"<pre><code>// Base context for all flags\ninterface AppContext : Context\n\n// Specialized context for authenticated users\ninterface AuthenticatedContext : AppContext {\n    val userId: String\n    val accountType: AccountType\n}\n\n// Specialized context for premium features\ninterface PremiumContext : AuthenticatedContext {\n    val subscriptionLevel: Int\n    val expirationDate: LocalDate\n}\n\n// Flags can target any level of the hierarchy\nval PUBLIC_FLAG: Conditional&lt;Boolean, AppContext&gt; = Conditional(\"public_feature\")\nval USER_FLAG: Conditional&lt;Boolean, AuthenticatedContext&gt; = Conditional(\"user_feature\")\nval PREMIUM_FLAG: Conditional&lt;Boolean, PremiumContext&gt; = Conditional(\"premium_feature\")\n\n// More specific contexts can evaluate more general flags\nval premiumContext: PremiumContext = ...\npremiumContext.evaluate(PUBLIC_FLAG)    // OK\npremiumContext.evaluate(USER_FLAG)      // OK\npremiumContext.evaluate(PREMIUM_FLAG)   // OK\n\n// Less specific contexts cannot evaluate more specific flags\nval appContext: AppContext = ...\nappContext.evaluate(PUBLIC_FLAG)    // OK\n// appContext.evaluate(USER_FLAG)   // Compile error!\n</code></pre>"},{"location":"api/Context/#common-patterns","title":"Common Patterns","text":""},{"location":"api/Context/#application-wide-context","title":"Application-Wide Context","text":"<pre><code>class ContextProvider(\n    private val localeProvider: LocaleProvider,\n    private val platformDetector: PlatformDetector,\n    private val versionProvider: VersionProvider,\n    private val userIdProvider: UserIdProvider\n) {\n    fun current(): AppContext = AppContext(\n        locale = localeProvider.current(),\n        platform = platformDetector.detect(),\n        appVersion = versionProvider.current(),\n        stableId = StableId.of(userIdProvider.currentUserId())\n    )\n}\n\n// Use throughout application\nval context = contextProvider.current()\nval isFeatureEnabled = context.evaluate(MY_FLAG)\n</code></pre>"},{"location":"api/Context/#context-caching","title":"Context Caching","text":"<pre><code>class CachedContextProvider {\n    private var cachedContext: AppContext? = null\n    private var lastUpdate = System.currentTimeMillis()\n    private val cacheTimeout = 60_000L // 1 minute\n\n    fun current(): AppContext {\n        val now = System.currentTimeMillis()\n        if (cachedContext == null || now - lastUpdate &gt; cacheTimeout) {\n            cachedContext = buildContext()\n            lastUpdate = now\n        }\n        return cachedContext!!\n    }\n\n    private fun buildContext(): AppContext = AppContext(\n        locale = getCurrentLocale(),\n        platform = getCurrentPlatform(),\n        appVersion = getCurrentVersion(),\n        stableId = StableId.of(getUserId())\n    )\n}\n</code></pre>"},{"location":"api/Context/#testing-contexts","title":"Testing Contexts","text":"<pre><code>object TestContexts {\n    fun minimal() = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(0, 0, 1),\n        stableId = StableId.of(\"test-user-id\")\n    )\n\n    fun withPlatform(platform: Platform) = minimal().copy(platform = platform)\n\n    fun withVersion(version: Version) = minimal().copy(appVersion = version)\n\n    fun withLocale(locale: AppLocale) = minimal().copy(locale = locale)\n}\n\n@Test\nfun testIOSFeature() {\n    val context = TestContexts.withPlatform(Platform.IOS)\n    val value = context.evaluate(IOS_FEATURE)\n    assertTrue(value)\n}\n</code></pre>"},{"location":"api/Context/#dynamic-context-resolution","title":"Dynamic Context Resolution","text":"<pre><code>class DynamicContextResolver {\n    fun resolve(request: HttpRequest): AppContext {\n        val locale = request.headers[\"Accept-Language\"]?.let {\n            parseLocale(it)\n        } ?: AppLocale.EN_US\n\n        val platform = request.headers[\"User-Agent\"]?.let {\n            detectPlatform(it)\n        } ?: Platform.WEB\n\n        val version = request.headers[\"App-Version\"]?.let {\n            Version.parse(it)\n        } ?: Version.default\n\n        val userId = request.session[\"user_id\"] ?: \"anonymous\"\n\n        return AppContext(\n            locale = locale,\n            platform = platform,\n            appVersion = version,\n            stableId = StableId.of(userId)\n        )\n    }\n}\n</code></pre>"},{"location":"api/Context/#best-practices","title":"Best Practices","text":""},{"location":"api/Context/#1-keep-contexts-lightweight","title":"1. Keep Contexts Lightweight","text":"<p>Only include properties needed for targeting:</p>\n<pre><code>// Good - focused context\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val isPremium: Boolean\n) : Context\n\n// Avoid - too much data\ndata class BloatedContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val userProfile: UserProfile,      // Heavy object\n    val preferences: Preferences,      // Heavy object\n    val sessionHistory: List&lt;Event&gt;   // Large collection\n) : Context\n</code></pre>"},{"location":"api/Context/#2-use-stableid-for-users-not-sessions","title":"2. Use StableId for Users, Not Sessions","text":"<p>StableId should be consistent across sessions for deterministic bucketing:</p>\n<pre><code>// Good - stable across sessions\nStableId.of(userId)\n\n// Bad - changes every session\nStableId.of(sessionId)\n</code></pre>"},{"location":"api/Context/#3-provide-context-factories","title":"3. Provide Context Factories","text":"<p>Make context creation consistent:</p>\n<pre><code>object Contexts {\n    fun forUser(userId: String): AppContext = AppContext(\n        locale = getUserLocale(userId),\n        platform = getUserPlatform(userId),\n        appVersion = getAppVersion(),\n        stableId = StableId.of(userId)\n    )\n\n    fun forAnonymous(): AppContext = AppContext(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = getAppVersion(),\n        stableId = StableId.of(\"anonymous-${generateId()}\")\n    )\n}\n</code></pre>"},{"location":"api/Context/#4-validate-extended-properties","title":"4. Validate Extended Properties","text":"<p>When extending Context, validate custom properties:</p>\n<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier\n) : Context {\n    init {\n        require(organizationId.isNotBlank()) {\n            \"organizationId cannot be blank\"\n        }\n    }\n}\n</code></pre>"},{"location":"api/Context/#related-documentation","title":"Related Documentation","text":"<ul>\n<li>Core API - Conditional and evaluation basics</li>\n<li>Rules System - Using context in rule matching</li>\n<li>Builders - Building flags with context types</li>\n<li>Examples - Complete context usage examples</li>\n</ul>"},{"location":"api/Core/","title":"Core API","text":"<p>The core API provides the fundamental types and operations for working with feature flags.</p>"},{"location":"api/Core/#conditional","title":"Conditional","text":"<p>A <code>Conditional&lt;S, C&gt;</code> is a typed key that identifies a feature flag in the registry.</p> <pre><code>interface Conditional&lt;S : Any, C : Context&gt; {\n    val registry: FlagRegistry\n    val key: String\n\n    fun update(definition: FeatureFlag&lt;S, C&gt;)\n}\n</code></pre>"},{"location":"api/Core/#creating-conditionals","title":"Creating Conditionals","text":"<pre><code>// Using the invoke operator\nval MY_FLAG: Conditional&lt;Boolean, MyContext&gt; =\n    Conditional(\"my_flag\")\n\n// With custom registry\nval MY_FLAG: Conditional&lt;Boolean, MyContext&gt; =\n    Conditional(\"my_flag\", registry = customRegistry)\n</code></pre>"},{"location":"api/Core/#type-parameters","title":"Type Parameters","text":"<ul> <li><code>S</code>: The value type this flag returns (must be non-nullable)</li> <li><code>C</code>: The context type used for evaluation</li> </ul>"},{"location":"api/Core/#common-patterns","title":"Common Patterns","text":""},{"location":"api/Core/#enum-based-flags","title":"Enum-Based Flags","text":"<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, AppContext&gt; {\n    ENABLE_NEW_UI(\"enable_new_ui\"),\n    ENABLE_ANALYTICS(\"enable_analytics\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// Usage\nval isEnabled = context.evaluate(Features.ENABLE_NEW_UI)\n</code></pre>"},{"location":"api/Core/#sealed-class-flags","title":"Sealed Class Flags","text":"<pre><code>sealed class StringFlags(override val key: String) : Conditional&lt;String, AppContext&gt; {\n    override val registry: FlagRegistry = FlagRegistry\n\n    data object ApiEndpoint : StringFlags(\"api_endpoint\")\n    data object ThemeColor : StringFlags(\"theme_color\")\n}\n\n// Usage\nval endpoint = context.evaluate(StringFlags.ApiEndpoint)\n</code></pre>"},{"location":"api/Core/#featureflag","title":"FeatureFlag","text":"<p>A <code>FeatureFlag&lt;S, C&gt;</code> defines the complete behavior of a flag.</p> <pre><code>sealed class FeatureFlag&lt;S : Any, C : Context&gt;(\n    val defaultValue: S,\n    val isActive: Boolean,\n    val conditional: Conditional&lt;S, C&gt;,\n    val values: List&lt;ConditionalValue&lt;S, C&gt;&gt;,\n    val salt: String = \"v1\"\n)\n</code></pre>"},{"location":"api/Core/#properties","title":"Properties","text":"<ul> <li>defaultValue: Returned when no rules match or flag is inactive</li> <li>isActive: If false, always returns defaultValue</li> <li>conditional: The key identifying this flag</li> <li>values: List of rules paired with target values</li> <li>salt: Salt string for deterministic hashing</li> </ul>"},{"location":"api/Core/#construction","title":"Construction","text":"<p>Feature flags are typically constructed via the Builder DSL (see Builders), but can be created directly:</p> <pre><code>val flag = FeatureFlag(\n    conditional = MY_FLAG,\n    bounds = listOf(\n        ConditionalValue(\n            rule = Rule(\n                rollout = Rollout.of(50.0),\n                locales = setOf(AppLocale.EN_US)\n            ),\n            value = true\n        )\n    ),\n    defaultValue = false,\n    salt = \"v1\",\n    isActive = true\n)\n</code></pre>"},{"location":"api/Core/#evaluation-results","title":"Evaluation Results","text":""},{"location":"api/Core/#evaluationresult","title":"EvaluationResult","text":"<p>Type-safe result type for flag evaluation operations.</p> <pre><code>sealed interface EvaluationResult&lt;out S&gt; {\n    data class Success&lt;S&gt;(val value: S) : EvaluationResult&lt;S&gt;\n    data class FlagNotFound(val key: String) : EvaluationResult&lt;Nothing&gt;\n    data class EvaluationError(val key: String, val error: Throwable) : EvaluationResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"api/Core/#usage-patterns","title":"Usage Patterns","text":"<pre><code>import io.amichne.konditional.core.result.EvaluationResult\n\n// Pattern matching\nwhen (val result = evaluateSafe(MY_FLAG, context)) {\n    is EvaluationResult.Success -&gt; println(\"Value: ${result.value}\")\n    is EvaluationResult.FlagNotFound -&gt; println(\"Flag not found: ${result.key}\")\n    is EvaluationResult.EvaluationError -&gt; println(\"Error: ${result.error}\")\n}\n\n// Folding to custom types\nval kotlinResult: Result&lt;Boolean&gt; = when (val result = evaluateSafe(MY_FLAG, context)) {\n    is EvaluationResult.Success -&gt; Result.success(result.value)\n    is EvaluationResult.FlagNotFound -&gt; Result.failure(Exception(result.key))\n    is EvaluationResult.EvaluationError -&gt; Result.failure(result.error)\n}\n</code></pre>"},{"location":"api/Core/#parseresult","title":"ParseResult","text":"<p>Type-safe result for parsing operations (deserialization, validation).</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"api/Core/#parseerror-types","title":"ParseError Types","text":"<pre><code>sealed interface ParseError {\n    data class InvalidJson(val message: String) : ParseError\n    data class InvalidSnapshot(val message: String) : ParseError\n    data class MissingKey(val key: String) : ParseError\n    data class InvalidType(val expected: String, val actual: String) : ParseError\n}\n</code></pre>"},{"location":"api/Core/#usage-example","title":"Usage Example","text":"<pre><code>val serializer = SnapshotSerializer.default\n\n// Deserialize with type-safe error handling\nwhen (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        registry.load(result.value)\n        println(\"Loaded ${result.value.flags.size} flags\")\n    }\n    is ParseResult.Failure -&gt; when (val error = result.error) {\n        is ParseError.InvalidJson -&gt; println(\"Invalid JSON: ${error.message}\")\n        is ParseError.InvalidSnapshot -&gt; println(\"Invalid snapshot: ${error.message}\")\n        is ParseError.MissingKey -&gt; println(\"Missing key: ${error.key}\")\n        is ParseError.InvalidType -&gt; println(\"Type mismatch: ${error.expected} vs ${error.actual}\")\n    }\n}\n</code></pre>"},{"location":"api/Core/#value-types","title":"Value Types","text":""},{"location":"api/Core/#valuetype-internal","title":"ValueType (Internal)","text":"<p>Internal sealed hierarchy representing the types of values flags can produce. Users typically don't interact with this directly.</p>"},{"location":"api/Core/#type-safety-examples","title":"Type Safety Examples","text":""},{"location":"api/Core/#compile-time-safety","title":"Compile-Time Safety","text":"<pre><code>// Type-safe flag definitions\nval BOOLEAN_FLAG: Conditional&lt;Boolean, MyContext&gt; = Conditional(\"bool_flag\")\nval STRING_FLAG: Conditional&lt;String, MyContext&gt; = Conditional(\"string_flag\")\nval INT_FLAG: Conditional&lt;Int, MyContext&gt; = Conditional(\"int_flag\")\n\n// Compiler enforces correct types\nval boolValue: Boolean = context.evaluate(BOOLEAN_FLAG) // OK\nval stringValue: String = context.evaluate(STRING_FLAG) // OK\n\n// Won't compile - type mismatch\n// val wrongType: String = context.evaluate(BOOLEAN_FLAG) // Compile error!\n</code></pre>"},{"location":"api/Core/#custom-value-types","title":"Custom Value Types","text":"<pre><code>// Any non-nullable type works\ndata class FeatureConfig(\n    val timeout: Int,\n    val retries: Int,\n    val endpoint: String\n)\n\nval CONFIG_FLAG: Conditional&lt;FeatureConfig, MyContext&gt; =\n    Conditional(\"feature_config\")\n\nConfigBuilder.config {\n    CONFIG_FLAG with {\n        default(\n            value = FeatureConfig(\n                timeout = 5000,\n                retries = 3,\n                endpoint = \"https://api.example.com\"\n            )\n        )\n    }\n}\n\n// Type-safe evaluation\nval config: FeatureConfig = context.evaluate(CONFIG_FLAG)\nprintln(\"Timeout: ${config.timeout}ms\")\n</code></pre>"},{"location":"api/Core/#evaluation-flow-diagram","title":"Evaluation Flow Diagram","text":"<pre><code>graph TD\n    A[Start Evaluation] --&gt; B{Flag Active?}\n    B --&gt;|No| C[Return Default Value]\n    B --&gt;|Yes| D[Sort Rules by Specificity]\n    D --&gt; E[Iterate Rules High to Low]\n    E --&gt; F{Rule Matches?}\n    F --&gt;|No| G{More Rules?}\n    G --&gt;|Yes| E\n    G --&gt;|No| C\n    F --&gt;|Yes| H{Rollout Check}\n    H --&gt;|Pass| I[Return Rule Value]\n    H --&gt;|Fail| G\n\n    style A fill:#e1f5ff\n    style C fill:#ffe1e1\n    style I fill:#e1ffe1\n</code></pre>"},{"location":"api/Core/#best-practices","title":"Best Practices","text":""},{"location":"api/Core/#1-use-enums-for-related-flags","title":"1. Use Enums for Related Flags","text":"<pre><code>enum class FeatureToggles(override val key: String) : Conditional&lt;Boolean, AppContext&gt; {\n    NEW_CHECKOUT(\"new_checkout\"),\n    FAST_SHIPPING(\"fast_shipping\"),\n    LOYALTY_PROGRAM(\"loyalty_program\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"api/Core/#2-group-by-value-type","title":"2. Group by Value Type","text":"<pre><code>// Boolean toggles\nobject Toggles {\n    val FEATURE_A: Conditional&lt;Boolean, AppContext&gt; = Conditional(\"feature_a\")\n    val FEATURE_B: Conditional&lt;Boolean, AppContext&gt; = Conditional(\"feature_b\")\n}\n\n// String configuration\nobject Config {\n    val API_URL: Conditional&lt;String, AppContext&gt; = Conditional(\"api_url\")\n    val THEME: Conditional&lt;String, AppContext&gt; = Conditional(\"theme\")\n}\n</code></pre>"},{"location":"api/Core/#3-define-once-use-everywhere","title":"3. Define Once, Use Everywhere","text":"<pre><code>// In shared module\nobject AppFlags {\n    val ENABLE_DARK_MODE: Conditional&lt;Boolean, AppContext&gt; = Conditional(\"dark_mode\")\n}\n\n// In feature module\nclass SettingsViewModel {\n    fun isDarkModeEnabled(): Boolean =\n        appContext.evaluate(AppFlags.ENABLE_DARK_MODE)\n}\n</code></pre>"},{"location":"api/Core/#4-handle-evaluation-safely","title":"4. Handle Evaluation Safely","text":"<pre><code>// Throwing version (use when flag must exist)\nfun getCriticalValue(): String =\n    context.evaluate(CRITICAL_FLAG)\n\n// Safe version (use when flag may not exist)\nfun getOptionalValue(): String? =\n    when (val result = evaluateSafe(OPTIONAL_FLAG, context)) {\n        is EvaluationResult.Success -&gt; result.value\n        else -&gt; null\n    }\n</code></pre>"},{"location":"api/Core/#related-documentation","title":"Related Documentation","text":"<ul> <li>Context System - Context types and evaluation</li> <li>Flag Registry - Managing flag configurations</li> <li>Rules System - Rule composition and matching</li> <li>Builders - DSL for flag definition</li> </ul>"},{"location":"api/Flags/","title":"Flag Registry API","text":"<p>The <code>FlagRegistry</code> manages the lifecycle of feature flag configurations, providing thread-safe operations for loading, updating, and querying flags.</p>"},{"location":"api/Flags/#flagregistry-interface","title":"FlagRegistry Interface","text":"<pre><code>interface FlagRegistry {\n    fun load(config: Konfig)\n    fun update(patch: KonfigPatch)\n    fun &lt;S : Any, C : Context&gt; update(definition: FeatureFlag&lt;S, C&gt;)\n    fun konfig(): Konfig\n    fun &lt;S : Any, C : Context&gt; featureFlag(key: Conditional&lt;S, C&gt;): FeatureFlag&lt;S, C&gt;?\n    fun allFlags(): Map&lt;Conditional&lt;*, *&gt;, FeatureFlag&lt;*, *&gt;&gt;\n}\n</code></pre>"},{"location":"api/Flags/#default-singleton-registry","title":"Default Singleton Registry","text":"<p>The companion object delegates to <code>SingletonFlagRegistry</code>, providing a thread-safe, global registry:</p> <pre><code>// Access the default registry\nval registry = FlagRegistry\n\n// All operations use atomic updates\nregistry.load(konfig)\n</code></pre>"},{"location":"api/Flags/#operations","title":"Operations","text":""},{"location":"api/Flags/#loading-complete-configurations","title":"Loading Complete Configurations","text":"<p>Replace the entire registry with a new configuration atomically:</p> <pre><code>import io.amichne.konditional.builders.ConfigBuilder\n\nConfigBuilder.config {\n    MY_FLAG with {\n        default(value = false)\n        rule {\n            platforms(Platform.IOS)\n        } implies true\n    }\n\n    ANOTHER_FLAG with {\n        default(value = \"default\")\n    }\n}\n\n// Registry is now loaded with these flags\n</code></pre> <p>Alternatively, build a snapshot and load explicitly:</p> <pre><code>val konfig = ConfigBuilder.buildSnapshot {\n    MY_FLAG with {\n        default(value = false)\n    }\n}\n\nFlagRegistry.load(konfig)\n</code></pre>"},{"location":"api/Flags/#applying-patches","title":"Applying Patches","text":"<p>Update specific flags without replacing the entire configuration:</p> <pre><code>import io.amichne.konditional.core.instance.KonfigPatch\n\n// Create a patch\nval patch = KonfigPatch.patch {\n    add(newFlagDefinition)\n    remove(OLD_FLAG)\n}\n\n// Apply atomically\nFlagRegistry.update(patch)\n</code></pre> <p>Build a patch from current state:</p> <pre><code>val currentKonfig = FlagRegistry.konfig()\n\nval patch = KonfigPatch.from(currentKonfig) {\n    add(updatedFlagDefinition)\n    remove(DEPRECATED_FLAG)\n}\n\nFlagRegistry.update(patch)\n</code></pre>"},{"location":"api/Flags/#updating-individual-flags","title":"Updating Individual Flags","text":"<p>Update a single flag definition:</p> <pre><code>import io.amichne.konditional.builders.FlagBuilder.Companion.flag\n\nval updatedFlag = MY_FLAG.flag {\n    default(value = true)\n    rule {\n        rollout = Rollout.of(100.0)\n    } implies false\n}\n\nFlagRegistry.update(updatedFlag)\n</code></pre> <p>Or use the Conditional's update method:</p> <pre><code>MY_FLAG.update(updatedFlag)\n</code></pre>"},{"location":"api/Flags/#querying-flags","title":"Querying Flags","text":""},{"location":"api/Flags/#get-specific-flag","title":"Get Specific Flag","text":"<pre><code>val flag: FeatureFlag&lt;Boolean, MyContext&gt;? =\n    FlagRegistry.featureFlag(MY_FLAG)\n\nif (flag != null) {\n    println(\"Default value: ${flag.defaultValue}\")\n    println(\"Active: ${flag.isActive}\")\n    println(\"Rules: ${flag.values.size}\")\n}\n</code></pre>"},{"location":"api/Flags/#get-all-flags","title":"Get All Flags","text":"<pre><code>val allFlags: Map&lt;Conditional&lt;*, *&gt;, FeatureFlag&lt;*, *&gt;&gt; =\n    FlagRegistry.allFlags()\n\nprintln(\"Total flags: ${allFlags.size}\")\n\nallFlags.forEach { (conditional, flag) -&gt;\n    println(\"Flag: ${conditional.key}, Active: ${flag.isActive}\")\n}\n</code></pre>"},{"location":"api/Flags/#get-current-snapshot","title":"Get Current Snapshot","text":"<pre><code>val snapshot: Konfig = FlagRegistry.konfig()\n\nprintln(\"Snapshot contains ${snapshot.flags.size} flags\")\n\n// Snapshot is immutable and can be safely serialized\nval json = SnapshotSerializer.default.serialize(snapshot)\n</code></pre>"},{"location":"api/Flags/#konfig","title":"Konfig","text":"<p>A <code>Konfig</code> represents an immutable snapshot of flag configurations:</p> <pre><code>data class Konfig internal constructor(\n    val flags: Map&lt;Conditional&lt;*, *&gt;, FeatureFlag&lt;*, *&gt;&gt;\n)\n</code></pre>"},{"location":"api/Flags/#creating-snapshots","title":"Creating Snapshots","text":"<pre><code>// Via ConfigBuilder\nval konfig = ConfigBuilder.buildSnapshot {\n    FLAG_A with { default(value = true) }\n    FLAG_B with { default(value = \"value\") }\n}\n\n// Load into registry\nFlagRegistry.load(konfig)\n</code></pre>"},{"location":"api/Flags/#konfigpatch","title":"KonfigPatch","text":"<p>A <code>KonfigPatch</code> represents incremental changes to a configuration:</p> <pre><code>data class KonfigPatch internal constructor(\n    val flags: Map&lt;Conditional&lt;*, *&gt;, FeatureFlag&lt;*, *&gt;&gt;,\n    val removeKeys: Set&lt;Conditional&lt;*, *&gt;&gt;\n)\n</code></pre>"},{"location":"api/Flags/#creating-patches","title":"Creating Patches","text":""},{"location":"api/Flags/#empty-patch","title":"Empty Patch","text":"<pre><code>val emptyPatch = KonfigPatch.empty()\n</code></pre>"},{"location":"api/Flags/#patch-builder","title":"Patch Builder","text":"<pre><code>val patch = KonfigPatch.patch {\n    // Add or update flags\n    add(newFlagDefinition)\n    add(updatedFlagDefinition)\n\n    // Remove flags\n    remove(OLD_FLAG)\n    remove(DEPRECATED_FLAG)\n}\n</code></pre>"},{"location":"api/Flags/#from-current-snapshot","title":"From Current Snapshot","text":"<pre><code>val currentKonfig = FlagRegistry.konfig()\n\nval patch = KonfigPatch.from(currentKonfig) {\n    add(MY_FLAG.flag {\n        default(value = true)\n    })\n}\n</code></pre>"},{"location":"api/Flags/#applying-patches_1","title":"Applying Patches","text":""},{"location":"api/Flags/#directly-to-registry","title":"Directly to Registry","text":"<pre><code>FlagRegistry.update(patch)\n</code></pre>"},{"location":"api/Flags/#to-a-snapshot","title":"To a Snapshot","text":"<pre><code>val currentKonfig = FlagRegistry.konfig()\nval newKonfig = patch.applyTo(currentKonfig)\n\n// Load the patched configuration\nFlagRegistry.load(newKonfig)\n</code></pre>"},{"location":"api/Flags/#thread-safety","title":"Thread Safety","text":"<p>The singleton registry uses atomic operations for all mutations:</p> <pre><code>// Safe from multiple threads\nThread {\n    FlagRegistry.update(patch1)\n}.start()\n\nThread {\n    FlagRegistry.update(patch2)\n}.start()\n\n// All reads see consistent snapshots\nval snapshot = FlagRegistry.konfig()\n</code></pre>"},{"location":"api/Flags/#immutable-snapshots","title":"Immutable Snapshots","text":"<p>Konfig snapshots are immutable and safe to share:</p> <pre><code>val snapshot1 = FlagRegistry.konfig()\n\n// Update the registry\nFlagRegistry.update(patch)\n\nval snapshot2 = FlagRegistry.konfig()\n\n// snapshot1 is unchanged\nassert(snapshot1 != snapshot2)\n</code></pre>"},{"location":"api/Flags/#registry-lifecycle-diagram","title":"Registry Lifecycle Diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Empty\n    Empty --&gt; Loaded: load(konfig)\n    Loaded --&gt; Updated: update(patch)\n    Updated --&gt; Updated: update(patch)\n    Loaded --&gt; Updated: update(definition)\n    Updated --&gt; Loaded: load(konfig)\n    Loaded --&gt; [*]: konfig()\n    Updated --&gt; [*]: konfig()\n\n    note right of Empty\n        Initial state\n        No flags registered\n    end note\n\n    note right of Loaded\n        Complete configuration\n        All flags available\n    end note\n\n    note right of Updated\n        Incremental changes\n        Preserves unmodified flags\n    end note\n</code></pre>"},{"location":"api/Flags/#common-patterns","title":"Common Patterns","text":""},{"location":"api/Flags/#application-startup","title":"Application Startup","text":"<pre><code>class Application {\n    fun onCreate() {\n        // Load initial configuration\n        ConfigBuilder.config {\n            FEATURE_A with { default(value = false) }\n            FEATURE_B with { default(value = \"default\") }\n        }\n\n        // Flags are now available\n        println(\"Registry loaded: ${FlagRegistry.allFlags().size} flags\")\n    }\n}\n</code></pre>"},{"location":"api/Flags/#remote-configuration-updates","title":"Remote Configuration Updates","text":"<pre><code>class FlagService {\n    private val serializer = SnapshotSerializer.default\n\n    suspend fun fetchAndApplyRemoteConfig() {\n        val json = httpClient.get(\"/api/flags\")\n\n        when (val result = serializer.deserialize(json)) {\n            is ParseResult.Success -&gt; {\n                FlagRegistry.load(result.value)\n                println(\"Loaded remote configuration\")\n            }\n            is ParseResult.Failure -&gt; {\n                println(\"Failed to parse: ${result.error}\")\n            }\n        }\n    }\n\n    suspend fun fetchAndApplyPatch() {\n        val json = httpClient.get(\"/api/flags/patch\")\n\n        when (val result = serializer.deserializePatchToCore(json)) {\n            is ParseResult.Success -&gt; {\n                FlagRegistry.update(result.value)\n                println(\"Applied patch\")\n            }\n            is ParseResult.Failure -&gt; {\n                println(\"Failed to parse patch: ${result.error}\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/Flags/#testing-with-custom-registry","title":"Testing with Custom Registry","text":"<pre><code>class TestFlagRegistry : FlagRegistry {\n    private val flags = mutableMapOf&lt;Conditional&lt;*, *&gt;, FeatureFlag&lt;*, *&gt;&gt;()\n\n    override fun load(config: Konfig) {\n        flags.clear()\n        flags.putAll(config.flags)\n    }\n\n    override fun konfig(): Konfig = Konfig(flags.toMap())\n\n    // Implement other methods...\n}\n\nclass MyTest {\n    private val testRegistry = TestFlagRegistry()\n\n    @Test\n    fun testWithCustomFlags() {\n        val konfig = ConfigBuilder.buildSnapshot {\n            TEST_FLAG with {\n                default(value = true)\n            }\n        }\n\n        testRegistry.load(konfig)\n\n        // Use test registry for evaluation\n        val context = MyContext(...)\n        val value = context.evaluate(TEST_FLAG, registry = testRegistry)\n\n        assertEquals(true, value)\n    }\n}\n</code></pre>"},{"location":"api/Flags/#hot-reloading-in-development","title":"Hot Reloading in Development","text":"<pre><code>class DevelopmentFlagManager {\n    private val watcher = FileWatcher(\"/path/to/flags.json\")\n\n    init {\n        watcher.onChange { file -&gt;\n            val json = file.readText()\n            when (val result = SnapshotSerializer.default.deserialize(json)) {\n                is ParseResult.Success -&gt; {\n                    FlagRegistry.load(result.value)\n                    println(\"Reloaded flags from ${file.name}\")\n                }\n                is ParseResult.Failure -&gt; {\n                    println(\"Failed to reload: ${result.error}\")\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/Flags/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>class ResilientFlagService {\n    private var lastGoodKonfig: Konfig? = null\n\n    suspend fun updateFlags() {\n        try {\n            val json = fetchRemoteFlags()\n            when (val result = SnapshotSerializer.default.deserialize(json)) {\n                is ParseResult.Success -&gt; {\n                    lastGoodKonfig = result.value\n                    FlagRegistry.load(result.value)\n                }\n                is ParseResult.Failure -&gt; {\n                    // Fall back to last known good configuration\n                    lastGoodKonfig?.let { FlagRegistry.load(it) }\n                }\n            }\n        } catch (e: Exception) {\n            // Network error - keep current configuration\n            println(\"Failed to fetch flags, keeping current config\")\n        }\n    }\n}\n</code></pre>"},{"location":"api/Flags/#best-practices","title":"Best Practices","text":""},{"location":"api/Flags/#1-load-configuration-early","title":"1. Load Configuration Early","text":"<p>Load flags during application initialization before they're needed:</p> <pre><code>class Application {\n    fun onCreate() {\n        loadFlags() // Synchronous initial load\n        startRemoteFlagSync() // Async updates\n    }\n}\n</code></pre>"},{"location":"api/Flags/#2-use-patches-for-incremental-updates","title":"2. Use Patches for Incremental Updates","text":"<p>When only a few flags change, use patches instead of full snapshots:</p> <pre><code>// Efficient - only updates changed flags\nval patch = KonfigPatch.patch {\n    add(updatedFlag)\n}\nFlagRegistry.update(patch)\n\n// Less efficient - replaces everything\nFlagRegistry.load(newKonfig)\n</code></pre>"},{"location":"api/Flags/#3-validate-before-loading","title":"3. Validate Before Loading","text":"<p>Use ParseResult to validate configurations before applying:</p> <pre><code>when (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        // Validation passed, safe to load\n        FlagRegistry.load(result.value)\n    }\n    is ParseResult.Failure -&gt; {\n        // Handle invalid configuration\n        reportError(result.error)\n    }\n}\n</code></pre>"},{"location":"api/Flags/#4-snapshot-for-consistency","title":"4. Snapshot for Consistency","text":"<p>Capture a snapshot when you need a consistent view across multiple evaluations:</p> <pre><code>val snapshot = FlagRegistry.konfig()\n\n// Evaluate multiple flags against the same snapshot\nval results = listOf(FLAG_A, FLAG_B, FLAG_C).map { flag -&gt;\n    snapshot.flags[flag]?.evaluate(context)\n}\n</code></pre>"},{"location":"api/Flags/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core API - Conditional and FeatureFlag types</li> <li>Serialization - JSON serialization and deserialization</li> <li>Builders - DSL for building configurations</li> <li>Context - Evaluation contexts</li> </ul>"},{"location":"api/Overview/","title":"Konditional API Overview","text":"<p>Konditional is a type-safe, composable feature flag library for Kotlin that follows Parse Don't Validate principles. It enables context-driven conditional logic with compile-time safety and runtime flexibility.</p>"},{"location":"api/Overview/#core-concepts","title":"Core Concepts","text":""},{"location":"api/Overview/#1-conditionals","title":"1. Conditionals","text":"<p>A <code>Conditional&lt;S, C&gt;</code> is a typed feature flag key that identifies a flag in the registry.</p> <ul> <li><code>S</code>: The value type the flag returns (Boolean, String, custom types, etc.)</li> <li><code>C</code>: The context type used for evaluation</li> </ul> <pre><code>val ENABLE_FEATURE: Conditional&lt;Boolean, MyContext&gt; =\n    Conditional(\"enable_feature\")\n</code></pre>"},{"location":"api/Overview/#2-context","title":"2. Context","text":"<p><code>Context</code> provides the evaluation dimensions for feature flags:</p> <ul> <li>locale: Application locale (AppLocale)</li> <li>platform: Deployment platform (Platform)</li> <li>appVersion: Semantic version (Version)</li> <li>stableId: Unique identifier for deterministic bucketing (StableId)</li> </ul> <p>Extend <code>Context</code> to add custom targeting dimensions.</p>"},{"location":"api/Overview/#3-feature-flags","title":"3. Feature Flags","text":"<p><code>FeatureFlag&lt;S, C&gt;</code> defines the behavior of a flag:</p> <ul> <li>Default value when no rules match</li> <li>List of conditional values (rule + target value pairs)</li> <li>Active/inactive state</li> <li>Salt for deterministic hashing</li> </ul>"},{"location":"api/Overview/#4-rules","title":"4. Rules","text":"<p><code>Rule&lt;C&gt;</code> defines matching criteria:</p> <ul> <li>Base matching: locale, platform, version range</li> <li>Extension matching: custom logic via <code>Evaluable&lt;C&gt;</code></li> <li>Rollout: percentage-based gradual deployment</li> <li>Specificity: precedence when multiple rules match</li> </ul>"},{"location":"api/Overview/#5-registry","title":"5. Registry","text":"<p><code>FlagRegistry</code> manages flag configurations:</p> <ul> <li>Thread-safe singleton registry (default)</li> <li>Load complete snapshots</li> <li>Apply incremental patches</li> <li>Update individual flags</li> </ul>"},{"location":"api/Overview/#architecture","title":"Architecture","text":"<pre><code>graph TB\n    subgraph \"1. Define\"\n        A[Conditional KeyType-safe identifier]\n    end\n\n    subgraph \"2. Register\"\n        B[FlagRegistryThread-safe storage]\n        C[FeatureFlagConfiguration]\n    end\n\n    subgraph \"3. Configure\"\n        D[ConditionalValueRule + Target pair]\n        E[RuleMatching criteria]\n        F[Target ValueResult when matched]\n    end\n\n    subgraph \"4. Evaluate\"\n        G[ContextEvaluation dimensions]\n        H{Matches?}\n        I[Return Value]\n    end\n\n    A --&gt;|registers into| B\n    B --&gt;|contains| C\n    C --&gt;|has multiple| D\n    D --&gt;|contains| E\n    D --&gt;|returns| F\n    G --&gt;|evaluates against| E\n    E --&gt; H\n    H --&gt;|Yes| F\n    H --&gt;|No| I[Default Value]\n    F --&gt; I\n\n    style A fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n    style B fill:#fff4e1,stroke:#cc8800,stroke-width:2px\n    style C fill:#ffe1f5,stroke:#cc0066,stroke-width:2px\n    style G fill:#e1ffe1,stroke:#00cc66,stroke-width:2px\n    style I fill:#f0f0f0,stroke:#333,stroke-width:3px\n</code></pre> Architecture Walkthrough  1. **Define**: Create a `Conditional` key with value type `S` and context type `C` 2. **Register**: Store the flag configuration in `FlagRegistry` (thread-safe singleton) 3. **Configure**: Define rules and their target values using the builder DSL 4. **Evaluate**: Pass a `Context` to evaluate which rule matches and return the appropriate value  This architecture ensures type safety at every step while maintaining flexibility for complex targeting logic."},{"location":"api/Overview/#evaluation-flow","title":"Evaluation Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client Code\n    participant Ctx as Context\n    participant R as FlagRegistry\n    participant F as FeatureFlag\n    participant Rule as Rules Engine\n\n    C-&gt;&gt;+Ctx: evaluate(FEATURE_FLAG)\n    Ctx-&gt;&gt;+R: get(FEATURE_FLAG)\n    R--&gt;&gt;-Ctx: FeatureFlag instance\n\n    Ctx-&gt;&gt;+F: evaluate(context)\n\n    alt Flag is inactive\n        F--&gt;&gt;Ctx: Return default value\n    else Flag is active\n        F-&gt;&gt;+Rule: Sort rules by specificity (high\u2192low)\n        Rule--&gt;&gt;-F: Sorted rules\n\n        loop For each rule (highest specificity first)\n            F-&gt;&gt;+Rule: matches(context)?\n\n            alt Base criteria match\n                Rule-&gt;&gt;Rule: Check locale, platform, version\n                alt Rollout specified\n                    Rule-&gt;&gt;Rule: Calculate hash(stableId + salt)\n                    Rule-&gt;&gt;Rule: Compare with rollout %\n                    alt In rollout bucket\n                        Rule--&gt;&gt;F: \u2705 MATCH\n                    else Not in bucket\n                        Rule--&gt;&gt;F: \u274c No match\n                    end\n                else No rollout\n                    Rule--&gt;&gt;F: \u2705 MATCH\n                end\n            else Base criteria don't match\n                Rule--&gt;&gt;-F: \u274c No match\n            end\n\n            alt Rule matched\n                F--&gt;&gt;Ctx: Return rule's target value\n            end\n        end\n\n        F--&gt;&gt;Ctx: No matches \u2192 Return default value\n    end\n\n    Ctx--&gt;&gt;-C: Final value (type-safe!)\n\n    Note over C,Rule: All type checking happens at compile time\n</code></pre> Evaluation Flow Explained  1. **Client calls** `context.evaluate(FEATURE_FLAG)` 2. **Registry lookup**: Find the `FeatureFlag` configuration 3. **Active check**: If inactive, return default immediately 4. **Sort rules**: Order by specificity (most specific first) 5. **Match loop**: For each rule:    - Check base criteria (locale, platform, version)    - If rollout specified, perform deterministic bucket check using SHA-256    - Return target value on first match 6. **Default fallback**: If no rules match, return default value  The entire flow is type-safe - the compiler ensures the returned value matches the `Conditional` type parameter `S`."},{"location":"api/Overview/#type-safety","title":"Type Safety","text":"<p>Konditional enforces type safety at compile time:</p> <pre><code>// Compile error: Type mismatch\nval BOOLEAN_FLAG: Conditional&lt;Boolean, MyContext&gt; = Conditional(\"flag\")\nval stringValue: String = context.evaluate(BOOLEAN_FLAG) // Won't compile!\n\n// Correct usage\nval boolValue: Boolean = context.evaluate(BOOLEAN_FLAG) // Type-safe\n</code></pre>"},{"location":"api/Overview/#parse-dont-validate","title":"Parse Don't Validate","text":"<p>Konditional follows functional programming principles:</p> <ul> <li>Refined types encode invariants (Rollout, StableId, Version)</li> <li>Result types for fallible operations (EvaluationResult, ParseResult)</li> <li>Illegal states are unrepresentable</li> <li>No redundant validation in domain logic</li> </ul>"},{"location":"api/Overview/#key-features","title":"Key Features","text":""},{"location":"api/Overview/#thread-safe-registry","title":"Thread-Safe Registry","text":"<p>The singleton <code>FlagRegistry</code> uses atomic operations for safe concurrent access.</p>"},{"location":"api/Overview/#composable-rules","title":"Composable Rules","text":"<p>Rules compose base targeting with custom extension logic:</p> <pre><code>Rule(\n    locales = setOf(AppLocale.EN_US),\n    platforms = setOf(Platform.IOS),\n    extension = object : Evaluable&lt;MyContext&gt;() {\n        override fun matches(context: MyContext) = context.isPremium\n        override fun specificity() = 1\n    }\n)\n</code></pre>"},{"location":"api/Overview/#deterministic-rollouts","title":"Deterministic Rollouts","text":"<p>Rollout percentages use consistent hashing with stable IDs for deterministic bucketing.</p>"},{"location":"api/Overview/#json-serialization","title":"JSON Serialization","text":"<p>Built-in serialization for remote configuration:</p> <pre><code>val serializer = SnapshotSerializer.default\nval json = serializer.serialize(konfig)\nval result = serializer.deserialize(json) // ParseResult&lt;Konfig&gt;\n</code></pre>"},{"location":"api/Overview/#dsl-builders","title":"DSL Builders","text":"<p>Type-safe DSL for defining flags:</p> <pre><code>ConfigBuilder.config {\n    MY_FLAG with {\n        default(value = false)\n        rule {\n            platforms(Platform.IOS)\n            rollout = Rollout.of(50.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/Overview/#next-steps","title":"Next Steps","text":"<ul> <li>Core API - Conditional evaluation and results</li> <li>Context System - Context types and extension</li> <li>Flag Registry - Registry operations and lifecycle</li> <li>Rules System - Rule composition and evaluation</li> <li>Builder DSL - Declarative flag configuration</li> <li>Serialization - JSON serialization and deserialization</li> <li>[Examples](examples/README.md - Complete working examples</li> </ul>"},{"location":"api/Rules/","title":"Rules System","text":"<p>The Rules system provides composable evaluation logic for feature flags. Rules determine which contexts match and return target values based on targeting criteria.</p>"},{"location":"api/Rules/#rule","title":"Rule","text":"<p>A <code>Rule&lt;C&gt;</code> combines standard client targeting with extensible custom logic.</p> <pre><code>data class Rule&lt;C : Context&gt;(\n    val rollout: Rollout = Rollout.of(100.0),\n    val note: String? = null,\n    val baseEvaluable: BaseEvaluable&lt;C&gt; = BaseEvaluable(),\n    val extension: Evaluable&lt;C&gt; = object : Evaluable&lt;C&gt;() {}\n)\n</code></pre>"},{"location":"api/Rules/#properties","title":"Properties","text":"<ul> <li>rollout: Percentage of users (0-100) that should match after criteria are met</li> <li>note: Optional documentation explaining the rule's purpose</li> <li>baseEvaluable: Standard targeting (locale, platform, version)</li> <li>extension: Custom evaluation logic</li> </ul>"},{"location":"api/Rules/#composition-architecture","title":"Composition Architecture","text":"<p>Rules compose two evaluation strategies:</p> <pre><code>Rule.matches(context) = baseEvaluable.matches(context) &amp;&amp; extension.matches(context)\nRule.specificity() = baseEvaluable.specificity() + extension.specificity()\n</code></pre> <p>Both evaluators must match for the rule to match, and specificity values are summed.</p>"},{"location":"api/Rules/#conditionalvalue","title":"ConditionalValue","text":"<p>A <code>ConditionalValue&lt;S, C&gt;</code> pairs a rule with its target value.</p> <pre><code>data class ConditionalValue&lt;S, Any, C : Context&gt;(\n    val rule: Rule&lt;C&gt;,\n    val value: S\n)\n</code></pre> <p>When a rule matches, its paired value is returned:</p> <pre><code>// Created via the DSL\nrule {\n    platforms(Platform.IOS)\n} implies true\n// Creates: ConditionalValue(rule=..., value=true)\n</code></pre>"},{"location":"api/Rules/#evaluable","title":"Evaluable","text":"<p>Base abstraction for composable evaluation logic.</p> <pre><code>abstract class Evaluable&lt;C : Context&gt; {\n    open fun matches(context: C): Boolean = true\n    open fun specificity(): Int = 0\n}\n</code></pre>"},{"location":"api/Rules/#implementing-custom-evaluables","title":"Implementing Custom Evaluables","text":"<pre><code>class PremiumUserEvaluable : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier in setOf(\n            SubscriptionTier.PREMIUM,\n            SubscriptionTier.ENTERPRISE\n        )\n\n    override fun specificity(): Int = 1\n}\n\n// Usage in rules\nrule {\n    extension { PremiumUserEvaluable() }\n} implies true\n</code></pre>"},{"location":"api/Rules/#anonymous-evaluables","title":"Anonymous Evaluables","text":"<pre><code>rule {\n    extension {\n        object : Evaluable&lt;MyContext&gt;() {\n            override fun matches(context: MyContext): Boolean =\n                context.customProperty == \"value\"\n\n            override fun specificity(): Int = 1\n        }\n    }\n} implies true\n</code></pre>"},{"location":"api/Rules/#baseevaluable","title":"BaseEvaluable","text":"<p>Standard targeting for locale, platform, and version.</p> <pre><code>data class BaseEvaluable&lt;C : Context&gt;(\n    val locales: Set&lt;AppLocale&gt; = emptySet(),\n    val platforms: Set&lt;Platform&gt; = emptySet(),\n    val versionRange: VersionRange = Unbounded\n) : Evaluable&lt;C&gt;()\n</code></pre>"},{"location":"api/Rules/#empty-means-match-all","title":"Empty Means Match All","text":"<p>BaseEvaluable follows an \"empty matches all\" semantic:</p> <ul> <li>Empty <code>locales</code> set matches all locales</li> <li>Empty <code>platforms</code> set matches all platforms</li> <li><code>Unbounded</code> version range matches all versions</li> </ul>"},{"location":"api/Rules/#specificity","title":"Specificity","text":"<p>Each non-empty constraint adds 1 to specificity:</p> <ul> <li>No constraints: specificity = 0</li> <li>Locale only: specificity = 1</li> <li>Platform + version: specificity = 2</li> <li>All three: specificity = 3</li> </ul>"},{"location":"api/Rules/#version-ranges","title":"Version Ranges","text":"<p>Version ranges define which app versions a rule targets.</p>"},{"location":"api/Rules/#versionrange-types","title":"VersionRange Types","text":"<pre><code>sealed class VersionRange(\n    val type: Type,\n    val min: Version? = null,\n    val max: Version? = null\n) {\n    enum class Type {\n        MIN_BOUND,        // &gt;= min\n        MAX_BOUND,        // &lt; max\n        MIN_AND_MAX_BOUND, // &gt;= min and &lt; max\n        UNBOUNDED         // All versions\n    }\n\n    fun contains(v: Version): Boolean\n    fun hasBounds(): Boolean\n}\n</code></pre>"},{"location":"api/Rules/#version-range-variants","title":"Version Range Variants","text":""},{"location":"api/Rules/#unbounded","title":"Unbounded","text":"<p>Matches all versions:</p> <pre><code>object Unbounded : VersionRange(Type.UNBOUNDED)\n\n// Usage in rules\nrule {\n    // No version constraint - matches all versions\n} implies value\n</code></pre>"},{"location":"api/Rules/#leftbound-minimum","title":"LeftBound (Minimum)","text":"<p>Matches versions &gt;= min:</p> <pre><code>data class LeftBound(val min: Version) : VersionRange(Type.MIN_BOUND, min = min)\n\n// Via DSL\nrule {\n    versions {\n        min(Version(2, 0, 0))  // &gt;= 2.0.0\n    }\n} implies value\n</code></pre>"},{"location":"api/Rules/#rightbound-maximum","title":"RightBound (Maximum)","text":"<p>Matches versions &lt; max:</p> <pre><code>data class RightBound(val max: Version) : VersionRange(Type.MAX_BOUND, max = max)\n\n// Via DSL\nrule {\n    versions {\n        max(Version(3, 0, 0))  // &lt; 3.0.0\n    }\n} implies value\n</code></pre>"},{"location":"api/Rules/#fullybound-range","title":"FullyBound (Range)","text":"<p>Matches versions &gt;= min and &lt; max:</p> <pre><code>data class FullyBound(\n    val min: Version,\n    val max: Version\n) : VersionRange(Type.MIN_AND_MAX_BOUND, min = min, max = max)\n\n// Via DSL\nrule {\n    versions {\n        min(Version(2, 0, 0))\n        max(Version(3, 0, 0))  // &gt;= 2.0.0 and &lt; 3.0.0\n    }\n} implies value\n</code></pre>"},{"location":"api/Rules/#version-range-examples","title":"Version Range Examples","text":"<pre><code>// All versions &gt;= 2.0.0\nrule {\n    versions { min(Version(2, 0, 0)) }\n} implies true\n\n// All versions &lt; 3.0.0\nrule {\n    versions { max(Version(3, 0, 0)) }\n} implies true\n\n// Versions 2.x.x only\nrule {\n    versions {\n        min(Version(2, 0, 0))\n        max(Version(3, 0, 0))\n    }\n} implies true\n\n// Specific version\nrule {\n    versions { exactly(Version(2, 5, 0)) }\n} implies true\n</code></pre>"},{"location":"api/Rules/#rollout","title":"Rollout","text":"<p>Type-safe percentage for gradual deployment.</p> <pre><code>@JvmInline\nvalue class Rollout private constructor(val value: Double) : Comparable&lt;Number&gt;\n</code></pre>"},{"location":"api/Rules/#creating-rollouts","title":"Creating Rollouts","text":"<pre><code>// From Double\nval r1 = Rollout.of(50.0)   // 50%\n\n// From Int\nval r2 = Rollout.of(75)     // 75%\n\n// From String\nval r3 = Rollout.of(\"25.5\") // 25.5%\n\n// Maximum (100%)\nval r4 = Rollout.MAX\n\n// Default (100%)\nval r5 = Rollout.default\n</code></pre>"},{"location":"api/Rules/#rollout-validation","title":"Rollout Validation","text":"<p>Rollout enforces valid percentage ranges at construction:</p> <pre><code>Rollout.of(50.0)   // OK\nRollout.of(100.0)  // OK\nRollout.of(0.0)    // OK\n\n// Rollout.of(150.0)  // IllegalArgumentException\n// Rollout.of(-10.0)  // IllegalArgumentException\n</code></pre>"},{"location":"api/Rules/#deterministic-bucketing","title":"Deterministic Bucketing","text":"<p>Rollout uses consistent hashing with <code>StableId</code> for deterministic bucketing:</p> <pre><code>// Same user always gets the same bucket\nval context1 = Context(..., stableId = StableId.of(\"user-123\"))\nval context2 = Context(..., stableId = StableId.of(\"user-123\"))\n\nval result1 = evaluateFlag(context1)\nval result2 = evaluateFlag(context2)\n// result1 == result2 (deterministic)\n\n// Different users get different buckets\nval context3 = Context(..., stableId = StableId.of(\"user-456\"))\nval result3 = evaluateFlag(context3)\n// result3 may differ from result1\n</code></pre>"},{"location":"api/Rules/#rule-evaluation-flow","title":"Rule Evaluation Flow","text":"<pre><code>graph TD\n    A[Start Evaluation] --&gt; B[Get All Rules]\n    B --&gt; C[Sort by Specificity DESC]\n    C --&gt; D[Iterate Rules]\n    D --&gt; E{BaseEvaluable Matches?}\n    E --&gt;|No| F{More Rules?}\n    E --&gt;|Yes| G{Extension Matches?}\n    G --&gt;|No| F\n    G --&gt;|Yes| H{Rollout Check}\n    H --&gt;|Pass| I[Return Rule Value]\n    H --&gt;|Fail| F\n    F --&gt;|Yes| D\n    F --&gt;|No| J[Return Default Value]\n\n    style A fill:#e1f5ff\n    style I fill:#e1ffe1\n    style J fill:#ffe1e1\n</code></pre>"},{"location":"api/Rules/#specificity_1","title":"Specificity","text":"<p>Specificity determines rule evaluation order. Higher specificity rules are evaluated first.</p>"},{"location":"api/Rules/#calculating-specificity","title":"Calculating Specificity","text":"<pre><code>// Rule specificity is sum of components\nrule.specificity() = baseEvaluable.specificity() + extension.specificity()\n\n// BaseEvaluable specificity\nbaseEvaluable.specificity() =\n    (if locales.isNotEmpty() then 1 else 0) +\n    (if platforms.isNotEmpty() then 1 else 0) +\n    (if versionRange.hasBounds() then 1 else 0)\n</code></pre>"},{"location":"api/Rules/#specificity-examples","title":"Specificity Examples","text":"<pre><code>// Specificity: 0 (no constraints)\nrule {\n    rollout = Rollout.of(50.0)\n} implies value\n\n// Specificity: 1 (platform only)\nrule {\n    platforms(Platform.IOS)\n} implies value\n\n// Specificity: 2 (platform + locale)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n} implies value\n\n// Specificity: 3 (platform + locale + version)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(Version(2, 0, 0)) }\n} implies value\n\n// Specificity: 4 (base=3 + extension=1)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(Version(2, 0, 0)) }\n    extension {\n        object : Evaluable&lt;MyContext&gt;() {\n            override fun matches(context: MyContext) = context.isPremium\n            override fun specificity() = 1\n        }\n    }\n} implies value\n</code></pre>"},{"location":"api/Rules/#evaluation-order","title":"Evaluation Order","text":"<p>Rules are sorted by specificity before evaluation:</p> <pre><code>MY_FLAG with {\n    default(value = \"default\")\n\n    // Evaluated 3rd (specificity: 1)\n    rule {\n        platforms(Platform.IOS)\n    } implies \"ios\"\n\n    // Evaluated 1st (specificity: 3)\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.EN_US)\n        versions { min(Version(2, 0, 0)) }\n    } implies \"ios-us-v2\"\n\n    // Evaluated 2nd (specificity: 2)\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.EN_US)\n    } implies \"ios-us\"\n}\n</code></pre>"},{"location":"api/Rules/#rule-composition-patterns","title":"Rule Composition Patterns","text":""},{"location":"api/Rules/#and-logic-within-rules","title":"AND Logic Within Rules","text":"<p>All criteria in a rule must match (AND):</p> <pre><code>rule {\n    platforms(Platform.IOS)           // AND\n    locales(AppLocale.EN_US)          // AND\n    versions { min(Version(2, 0, 0)) } // AND\n    rollout = Rollout.of(50.0)        // AND in rollout bucket\n} implies value\n</code></pre>"},{"location":"api/Rules/#or-logic-across-rules","title":"OR Logic Across Rules","text":"<p>Multiple rules provide OR logic:</p> <pre><code>MY_FLAG with {\n    default(value = false)\n\n    // iOS users OR\n    rule {\n        platforms(Platform.IOS)\n    } implies true\n\n    // Android users with v2+ OR\n    rule {\n        platforms(Platform.ANDROID)\n        versions { min(Version(2, 0, 0)) }\n    } implies true\n\n    // Web users in EN_US\n    rule {\n        platforms(Platform.WEB)\n        locales(AppLocale.EN_US)\n    } implies true\n}\n</code></pre>"},{"location":"api/Rules/#hierarchical-targeting","title":"Hierarchical Targeting","text":"<p>Use specificity for fallback behavior:</p> <pre><code>CONFIG_FLAG with {\n    default(value = DefaultConfig)\n\n    // Most specific: iOS + EN_US + v2+\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.EN_US)\n        versions { min(Version(2, 0, 0)) }\n    } implies SpecializedConfig\n\n    // Less specific: iOS + EN_US\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.EN_US)\n    } implies StandardConfig\n\n    // Least specific: iOS\n    rule {\n        platforms(Platform.IOS)\n    } implies BasicConfig\n}\n</code></pre>"},{"location":"api/Rules/#phased-rollouts","title":"Phased Rollouts","text":"<p>Gradually increase rollout percentage:</p> <pre><code>BETA_FEATURE with {\n    default(value = false)\n\n    // Phase 1: 10% rollout\n    rule {\n        note(\"Phase 1: Initial testing\")\n        rollout = Rollout.of(10.0)\n    } implies true\n\n    // Phase 2: 50% rollout\n    rule {\n        note(\"Phase 2: Expanded testing\")\n        rollout = Rollout.of(50.0)\n    } implies true\n\n    // Phase 3: 100% rollout\n    rule {\n        note(\"Phase 3: General availability\")\n        rollout = Rollout.of(100.0)\n    } implies true\n}\n</code></pre>"},{"location":"api/Rules/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"api/Rules/#multi-dimensional-targeting","title":"Multi-Dimensional Targeting","text":"<p>Combine base targeting with custom logic:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(Version(2, 0, 0)) }\n\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.PREMIUM &amp;&amp;\n                context.organizationSize &gt; 100\n\n            override fun specificity(): Int = 2\n        }\n    }\n\n    rollout = Rollout.of(50.0)\n} implies true\n// Matches if: iOS AND EN_US AND v2+ AND premium AND large org AND in rollout\n</code></pre>"},{"location":"api/Rules/#complex-business-logic","title":"Complex Business Logic","text":"<pre><code>class ComplexBusinessRuleEvaluable : Evaluable&lt;BusinessContext&gt;() {\n    override fun matches(context: BusinessContext): Boolean {\n        // Complex multi-criteria evaluation\n        val hasFeatureAccess = context.entitlements.contains(\"feature-x\")\n        val isInBetaProgram = context.betaProgramId != null\n        val hasRecentActivity = context.lastActivityDays &lt; 7\n\n        return hasFeatureAccess &amp;&amp; (isInBetaProgram || hasRecentActivity)\n    }\n\n    override fun specificity(): Int = 3  // High specificity for complex logic\n}\n\nrule {\n    extension { ComplexBusinessRuleEvaluable() }\n} implies true\n</code></pre>"},{"location":"api/Rules/#time-based-targeting","title":"Time-Based Targeting","text":"<pre><code>class TimeWindowEvaluable(\n    private val startTime: Instant,\n    private val endTime: Instant\n) : Evaluable&lt;MyContext&gt;() {\n    override fun matches(context: MyContext): Boolean {\n        val now = Instant.now()\n        return now in startTime..endTime\n    }\n\n    override fun specificity(): Int = 1\n}\n\nrule {\n    extension {\n        TimeWindowEvaluable(\n            startTime = Instant.parse(\"2024-01-01T00:00:00Z\"),\n            endTime = Instant.parse(\"2024-12-31T23:59:59Z\")\n        )\n    }\n} implies true\n</code></pre>"},{"location":"api/Rules/#rule-evaluation-diagram","title":"Rule Evaluation Diagram","text":"<pre><code>sequenceDiagram\n    participant Flag\n    participant Rules\n    participant Rule\n    participant Base\n    participant Extension\n    participant Rollout\n\n    Flag-&gt;&gt;Rules: Sort by specificity\n    Rules-&gt;&gt;Rule: Evaluate highest specificity\n    Rule-&gt;&gt;Base: matches(context)\n    Base--&gt;&gt;Rule: true/false\n    alt Base matches\n        Rule-&gt;&gt;Extension: matches(context)\n        Extension--&gt;&gt;Rule: true/false\n        alt Extension matches\n            Rule-&gt;&gt;Rollout: check bucket\n            Rollout--&gt;&gt;Rule: true/false\n            alt In rollout\n                Rule--&gt;&gt;Flag: Return rule value\n            else Not in rollout\n                Rule--&gt;&gt;Rules: Try next rule\n            end\n        else Extension no match\n            Rule--&gt;&gt;Rules: Try next rule\n        end\n    else Base no match\n        Rule--&gt;&gt;Rules: Try next rule\n    end\n</code></pre>"},{"location":"api/Rules/#best-practices","title":"Best Practices","text":""},{"location":"api/Rules/#1-use-specificity-intentionally","title":"1. Use Specificity Intentionally","text":"<p>Design rules from most to least specific:</p> <pre><code>MY_FLAG with {\n    default(value = \"default\")\n\n    // Most specific first (automatically ordered)\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.EN_US)\n        versions { min(Version(2, 0, 0)) }\n    } implies \"very-specific\"\n\n    rule {\n        platforms(Platform.IOS)\n    } implies \"less-specific\"\n}\n</code></pre>"},{"location":"api/Rules/#2-document-rules-with-notes","title":"2. Document Rules with Notes","text":"<pre><code>rule {\n    note(\"iOS beta program - targeting early adopters with v2.1+\")\n    platforms(Platform.IOS)\n    versions { min(Version(2, 1, 0)) }\n    rollout = Rollout.of(10.0)\n} implies true\n</code></pre>"},{"location":"api/Rules/#3-keep-extension-logic-simple","title":"3. Keep Extension Logic Simple","text":"<p>Prefer simple, testable evaluable classes:</p> <pre><code>// Good - simple, focused\nclass PremiumUserEvaluable : Evaluable&lt;AppContext&gt;() {\n    override fun matches(context: AppContext) = context.isPremium\n    override fun specificity() = 1\n}\n\n// Avoid - too complex\nclass ComplexEvaluable : Evaluable&lt;AppContext&gt;() {\n    override fun matches(context: AppContext) =\n        // Many lines of complex logic...\n        // Hard to test and maintain\n    override fun specificity() = 5\n}\n</code></pre>"},{"location":"api/Rules/#4-test-rules-in-isolation","title":"4. Test Rules in Isolation","text":"<pre><code>@Test\nfun testPremiumRule() {\n    val rule = Rule&lt;AppContext&gt;(\n        extension = PremiumUserEvaluable()\n    )\n\n    val premiumContext = TestContexts.premium()\n    val freeContext = TestContexts.free()\n\n    assertTrue(rule.matches(premiumContext))\n    assertFalse(rule.matches(freeContext))\n}\n</code></pre>"},{"location":"api/Rules/#5-use-rollout-for-gradual-deployment","title":"5. Use Rollout for Gradual Deployment","text":"<p>Start with low rollout and gradually increase:</p> <pre><code>// Week 1: 10%\nFlagRegistry.update(MY_FLAG.flag {\n    default(value = false)\n    rule { rollout = Rollout.of(10.0) } implies true\n})\n\n// Week 2: 25%\nFlagRegistry.update(MY_FLAG.flag {\n    default(value = false)\n    rule { rollout = Rollout.of(25.0) } implies true\n})\n\n// Week 3: 100%\nFlagRegistry.update(MY_FLAG.flag {\n    default(value = false)\n    rule { rollout = Rollout.of(100.0) } implies true\n})\n</code></pre>"},{"location":"api/Rules/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core API - Conditional and FeatureFlag types</li> <li>Context - Context types and extension</li> <li>Builders - DSL for defining rules</li> <li>[Examples](examples/README.md - Complete rule examples</li> </ul>"},{"location":"api/Serialization/","title":"Serialization","text":"<p>Konditional provides JSON serialization capabilities for feature flag configurations, enabling remote configuration management and distribution.</p>"},{"location":"api/Serialization/#snapshotserializer","title":"SnapshotSerializer","text":"<p>The main serialization interface for Konfig configurations.</p> <pre><code>class SnapshotSerializer(moshi: Moshi = defaultMoshi())\n</code></pre>"},{"location":"api/Serialization/#default-instance","title":"Default Instance","text":"<pre><code>val serializer = SnapshotSerializer.default\n</code></pre>"},{"location":"api/Serialization/#custom-moshi","title":"Custom Moshi","text":"<pre><code>val customMoshi = Moshi.Builder()\n    .add(FlagValueAdapter.FACTORY)\n    .add(VersionRangeAdapter(baseMoshi))\n    .add(KotlinJsonAdapterFactory())\n    .build()\n\nval serializer = SnapshotSerializer(customMoshi)\n</code></pre>"},{"location":"api/Serialization/#snapshot-operations","title":"Snapshot Operations","text":""},{"location":"api/Serialization/#serializing-konfig","title":"Serializing Konfig","text":"<p>Convert a Konfig to JSON:</p> <pre><code>val konfig = FlagRegistry.konfig()\nval json = SnapshotSerializer.default.serialize(konfig)\n\n// JSON is pretty-printed with 2-space indentation\nprintln(json)\n</code></pre>"},{"location":"api/Serialization/#deserializing-konfig","title":"Deserializing Konfig","text":"<p>Parse JSON to Konfig using type-safe ParseResult:</p> <pre><code>val json = \"\"\"\n{\n  \"flags\": [\n    {\n      \"key\": \"my_flag\",\n      \"defaultValue\": { \"type\": \"boolean\", \"value\": false },\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"values\": []\n    }\n  ]\n}\n\"\"\"\n\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        FlagRegistry.load(result.value)\n        println(\"Loaded ${result.value.flags.size} flags\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Parse error: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#patch-operations","title":"Patch Operations","text":""},{"location":"api/Serialization/#serializing-patches","title":"Serializing Patches","text":"<p>Convert a KonfigPatch to JSON:</p> <pre><code>val patch = KonfigPatch.patch {\n    add(updatedFlag)\n    remove(OLD_FLAG)\n}\n\nval json = SnapshotSerializer.default.serializePatch(patch)\n</code></pre>"},{"location":"api/Serialization/#deserializing-patches","title":"Deserializing Patches","text":"<p>Parse JSON to KonfigPatch:</p> <pre><code>val patchJson = \"\"\"\n{\n  \"flags\": [\n    {\n      \"key\": \"updated_flag\",\n      \"defaultValue\": { \"type\": \"boolean\", \"value\": true },\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"values\": []\n    }\n  ],\n  \"removeKeys\": [\"old_flag\"]\n}\n\"\"\"\n\nwhen (val result = SnapshotSerializer.default.deserializePatchToCore(patchJson)) {\n    is ParseResult.Success -&gt; {\n        FlagRegistry.update(result.value)\n        println(\"Applied patch\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Parse error: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#applying-patches-to-snapshots","title":"Applying Patches to Snapshots","text":"<p>Apply a patch to an existing Konfig:</p> <pre><code>val currentKonfig = FlagRegistry.konfig()\nval patchJson = fetchPatchFromServer()\n\nwhen (val result = SnapshotSerializer.default.applyPatchJson(currentKonfig, patchJson)) {\n    is ParseResult.Success -&gt; {\n        FlagRegistry.load(result.value)\n        println(\"Applied patch\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Failed to apply patch: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#parseresult","title":"ParseResult","text":"<p>Type-safe result type for deserialization operations.</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"api/Serialization/#parseerror-types","title":"ParseError Types","text":"<pre><code>sealed interface ParseError {\n    data class InvalidJson(val message: String) : ParseError\n    data class InvalidSnapshot(val message: String) : ParseError\n    data class MissingKey(val key: String) : ParseError\n    data class InvalidType(val expected: String, val actual: String) : ParseError\n}\n</code></pre>"},{"location":"api/Serialization/#error-handling","title":"Error Handling","text":"<pre><code>when (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        // Use result.value\n    }\n    is ParseResult.Failure -&gt; when (val error = result.error) {\n        is ParseError.InvalidJson -&gt; {\n            log.error(\"Malformed JSON: ${error.message}\")\n        }\n        is ParseError.InvalidSnapshot -&gt; {\n            log.error(\"Invalid snapshot structure: ${error.message}\")\n        }\n        is ParseError.MissingKey -&gt; {\n            log.error(\"Missing required key: ${error.key}\")\n        }\n        is ParseError.InvalidType -&gt; {\n            log.error(\"Type mismatch: expected ${error.expected}, got ${error.actual}\")\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#json-format","title":"JSON Format","text":""},{"location":"api/Serialization/#snapshot-structure","title":"Snapshot Structure","text":"<pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"feature_flag\",\n      \"defaultValue\": {\n        \"type\": \"boolean\",\n        \"value\": false\n      },\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"values\": [\n        {\n          \"rule\": {\n            \"rollout\": 50.0,\n            \"note\": \"iOS beta users\",\n            \"baseEvaluable\": {\n              \"locales\": [\"EN_US\"],\n              \"platforms\": [\"IOS\"],\n              \"versionRange\": {\n                \"type\": \"MIN_BOUND\",\n                \"min\": {\n                  \"major\": 2,\n                  \"minor\": 0,\n                  \"patch\": 0\n                }\n              }\n            }\n          },\n          \"value\": {\n            \"type\": \"boolean\",\n            \"value\": true\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"api/Serialization/#patch-structure","title":"Patch Structure","text":"<pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"updated_flag\",\n      \"defaultValue\": {\n        \"type\": \"string\",\n        \"value\": \"new-value\"\n      },\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"values\": []\n    }\n  ],\n  \"removeKeys\": [\"deprecated_flag\", \"old_feature\"]\n}\n</code></pre>"},{"location":"api/Serialization/#flagvalue-types","title":"FlagValue Types","text":"<p>The <code>FlagValue</code> type is polymorphic based on the value type:</p>"},{"location":"api/Serialization/#boolean","title":"Boolean","text":"<pre><code>{\n  \"type\": \"boolean\",\n  \"value\": true\n}\n</code></pre>"},{"location":"api/Serialization/#string","title":"String","text":"<pre><code>{\n  \"type\": \"string\",\n  \"value\": \"some-value\"\n}\n</code></pre>"},{"location":"api/Serialization/#integer","title":"Integer","text":"<pre><code>{\n  \"type\": \"int\",\n  \"value\": 42\n}\n</code></pre>"},{"location":"api/Serialization/#long","title":"Long","text":"<pre><code>{\n  \"type\": \"long\",\n  \"value\": 9223372036854775807\n}\n</code></pre>"},{"location":"api/Serialization/#double","title":"Double","text":"<pre><code>{\n  \"type\": \"double\",\n  \"value\": 3.14159\n}\n</code></pre>"},{"location":"api/Serialization/#json-complex-objects","title":"JSON (Complex Objects)","text":"<pre><code>{\n  \"type\": \"json\",\n  \"value\": {\n    \"timeout\": 5000,\n    \"retries\": 3,\n    \"endpoint\": \"https://api.example.com\"\n  }\n}\n</code></pre>"},{"location":"api/Serialization/#version-ranges","title":"Version Ranges","text":""},{"location":"api/Serialization/#unbounded","title":"Unbounded","text":"<pre><code>{\n  \"type\": \"UNBOUNDED\"\n}\n</code></pre>"},{"location":"api/Serialization/#leftbound-minimum","title":"LeftBound (Minimum)","text":"<pre><code>{\n  \"type\": \"MIN_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre>"},{"location":"api/Serialization/#rightbound-maximum","title":"RightBound (Maximum)","text":"<pre><code>{\n  \"type\": \"MAX_BOUND\",\n  \"max\": {\n    \"major\": 3,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre>"},{"location":"api/Serialization/#fullybound-range","title":"FullyBound (Range)","text":"<pre><code>{\n  \"type\": \"MIN_AND_MAX_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  },\n  \"max\": {\n    \"major\": 3,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre>"},{"location":"api/Serialization/#serialization-flow","title":"Serialization Flow","text":"<pre><code>graph LR\n    A[Konfig] --&gt; B[SnapshotSerializer]\n    B --&gt; C[SerializableSnapshot]\n    C --&gt; D[JSON String]\n    D --&gt; E[SnapshotSerializer]\n    E --&gt; F{ParseResult}\n    F --&gt;|Success| G[Konfig]\n    F --&gt;|Failure| H[ParseError]\n\n    style A fill:#e1f5ff\n    style G fill:#e1ffe1\n    style H fill:#ffe1e1\n</code></pre>"},{"location":"api/Serialization/#custom-type-adapters","title":"Custom Type Adapters","text":""},{"location":"api/Serialization/#flagvalueadapter","title":"FlagValueAdapter","text":"<p>Handles polymorphic serialization of flag values:</p> <pre><code>object FlagValueAdapter {\n    val FACTORY: JsonAdapter.Factory\n}\n</code></pre> <p>Automatically serializes any type to appropriate FlagValue format.</p>"},{"location":"api/Serialization/#versionrangeadapter","title":"VersionRangeAdapter","text":"<p>Handles polymorphic serialization of version ranges:</p> <pre><code>class VersionRangeAdapter(moshi: Moshi) : JsonAdapter&lt;VersionRange&gt;()\n</code></pre> <p>Serializes version ranges based on their type and bounds.</p>"},{"location":"api/Serialization/#common-patterns","title":"Common Patterns","text":""},{"location":"api/Serialization/#remote-configuration-loading","title":"Remote Configuration Loading","text":"<pre><code>class RemoteConfigService(\n    private val httpClient: HttpClient,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    suspend fun loadConfiguration(): Result&lt;Unit&gt; {\n        return try {\n            val json = httpClient.get(\"/api/flags/snapshot\")\n\n            when (val result = serializer.deserialize(json)) {\n                is ParseResult.Success -&gt; {\n                    FlagRegistry.load(result.value)\n                    Result.success(Unit)\n                }\n                is ParseResult.Failure -&gt; {\n                    Result.failure(Exception(\"Parse error: ${result.error}\"))\n                }\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#incremental-updates","title":"Incremental Updates","text":"<pre><code>class ConfigUpdateService(\n    private val httpClient: HttpClient,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    private var lastETag: String? = null\n\n    suspend fun checkForUpdates() {\n        val response = httpClient.get(\"/api/flags/patch\", headers = mapOf(\n            \"If-None-Match\" to (lastETag ?: \"\")\n        ))\n\n        if (response.statusCode == 304) {\n            // No updates\n            return\n        }\n\n        when (val result = serializer.deserializePatchToCore(response.body)) {\n            is ParseResult.Success -&gt; {\n                FlagRegistry.update(result.value)\n                lastETag = response.headers[\"ETag\"]\n                println(\"Applied patch: ${result.value.flags.size} changes\")\n            }\n            is ParseResult.Failure -&gt; {\n                println(\"Failed to parse patch: ${result.error}\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#persistent-storage","title":"Persistent Storage","text":"<pre><code>class FlagPersistence(\n    private val file: File,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    fun save() {\n        val konfig = FlagRegistry.konfig()\n        val json = serializer.serialize(konfig)\n        file.writeText(json)\n    }\n\n    fun load(): ParseResult&lt;Konfig&gt; {\n        if (!file.exists()) {\n            return ParseResult.Failure(ParseError.InvalidSnapshot(\"File not found\"))\n        }\n\n        val json = file.readText()\n        return serializer.deserialize(json)\n    }\n\n    fun autoSave() {\n        FlagRegistry.konfig()  // Trigger snapshot\n        save()\n    }\n}\n\n// Usage\nval persistence = FlagPersistence(File(\"/path/to/flags.json\"))\n\n// Load on startup\nwhen (val result = persistence.load()) {\n    is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n    is ParseResult.Failure -&gt; println(\"No saved config: ${result.error}\")\n}\n\n// Save periodically\nTimer().scheduleAtFixedRate(timerTask {\n    persistence.save()\n}, 60_000, 60_000)  // Every minute\n</code></pre>"},{"location":"api/Serialization/#snapshot-versioning","title":"Snapshot Versioning","text":"<pre><code>data class VersionedSnapshot(\n    val version: String,\n    val timestamp: Long,\n    val snapshot: String\n)\n\nclass VersionedConfigService {\n    private val snapshots = mutableListOf&lt;VersionedSnapshot&gt;()\n\n    fun saveSnapshot() {\n        val konfig = FlagRegistry.konfig()\n        val json = SnapshotSerializer.default.serialize(konfig)\n\n        snapshots.add(VersionedSnapshot(\n            version = \"v${snapshots.size + 1}\",\n            timestamp = System.currentTimeMillis(),\n            snapshot = json\n        ))\n    }\n\n    fun rollbackTo(version: String) {\n        val snapshot = snapshots.find { it.version == version }\n            ?: return\n\n        when (val result = SnapshotSerializer.default.deserialize(snapshot.snapshot)) {\n            is ParseResult.Success -&gt; {\n                FlagRegistry.load(result.value)\n                println(\"Rolled back to $version\")\n            }\n            is ParseResult.Failure -&gt; {\n                println(\"Rollback failed: ${result.error}\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#ab-testing-configuration","title":"A/B Testing Configuration","text":"<pre><code>data class ExperimentConfig(\n    val experimentId: String,\n    val variants: List&lt;Variant&gt;,\n    val enabled: Boolean\n)\n\ndata class Variant(\n    val name: String,\n    val weight: Double\n)\n\nval EXPERIMENT: Conditional&lt;ExperimentConfig, AppContext&gt; =\n    Conditional(\"experiment_config\")\n\n// Serialize experiment configuration\nConfigBuilder.config {\n    EXPERIMENT with {\n        default(\n            value = ExperimentConfig(\n                experimentId = \"checkout-v2\",\n                variants = listOf(\n                    Variant(\"control\", 50.0),\n                    Variant(\"variant-a\", 25.0),\n                    Variant(\"variant-b\", 25.0)\n                ),\n                enabled = true\n            )\n        )\n    }\n}\n\nval json = SnapshotSerializer.default.serialize(FlagRegistry.konfig())\n// Distribute to clients\n</code></pre>"},{"location":"api/Serialization/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/Serialization/#caching-parsed-configs","title":"Caching Parsed Configs","text":"<pre><code>class CachedConfigService {\n    private var cachedKonfig: Konfig? = null\n    private var lastFetch = 0L\n    private val cacheDuration = 60_000L // 1 minute\n\n    suspend fun getConfig(): Konfig {\n        val now = System.currentTimeMillis()\n\n        if (cachedKonfig != null &amp;&amp; now - lastFetch &lt; cacheDuration) {\n            return cachedKonfig!!\n        }\n\n        val json = fetchFromServer()\n        when (val result = SnapshotSerializer.default.deserialize(json)) {\n            is ParseResult.Success -&gt; {\n                cachedKonfig = result.value\n                lastFetch = now\n                return result.value\n            }\n            is ParseResult.Failure -&gt; {\n                // Return cached config on error\n                return cachedKonfig ?: throw Exception(\"No cached config\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#streaming-large-configs","title":"Streaming Large Configs","text":"<p>For very large configurations, consider chunking:</p> <pre><code>class ChunkedConfigLoader {\n    suspend fun loadInChunks(url: String) {\n        val chunks = fetchChunks(url)\n\n        chunks.forEach { chunk -&gt;\n            when (val result = SnapshotSerializer.default.deserializePatch(chunk)) {\n                is ParseResult.Success -&gt; {\n                    // Apply each chunk as a patch\n                    val patch = result.value.toPatch()\n                    FlagRegistry.update(patch)\n                }\n                is ParseResult.Failure -&gt; {\n                    println(\"Failed to parse chunk: ${result.error}\")\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#best-practices","title":"Best Practices","text":""},{"location":"api/Serialization/#1-use-parseresult-for-error-handling","title":"1. Use ParseResult for Error Handling","text":"<p>Never ignore deserialization errors:</p> <pre><code>// Good - handle all cases\nwhen (val result = serializer.deserialize(json)) {\n    is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n    is ParseResult.Failure -&gt; logError(result.error)\n}\n\n// Bad - ignoring errors\nval konfig = serializer.deserialize(json) as? ParseResult.Success\nkonfig?.let { FlagRegistry.load(it.value) }\n</code></pre>"},{"location":"api/Serialization/#2-validate-before-loading","title":"2. Validate Before Loading","text":"<pre><code>fun loadConfig(json: String): Boolean {\n    return when (val result = serializer.deserialize(json)) {\n        is ParseResult.Success -&gt; {\n            // Validate konfig\n            if (result.value.flags.isEmpty()) {\n                log.warn(\"Empty configuration\")\n                false\n            } else {\n                FlagRegistry.load(result.value)\n                true\n            }\n        }\n        is ParseResult.Failure -&gt; {\n            log.error(\"Parse failed: ${result.error}\")\n            false\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#3-graceful-degradation","title":"3. Graceful Degradation","text":"<p>Keep a fallback configuration:</p> <pre><code>class ResilientConfigLoader {\n    private val fallbackConfig = loadEmbeddedConfig()\n\n    suspend fun load() {\n        try {\n            val json = fetchRemoteConfig()\n            when (val result = serializer.deserialize(json)) {\n                is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n                is ParseResult.Failure -&gt; {\n                    log.error(\"Using fallback config: ${result.error}\")\n                    FlagRegistry.load(fallbackConfig)\n                }\n            }\n        } catch (e: Exception) {\n            log.error(\"Network error, using fallback\", e)\n            FlagRegistry.load(fallbackConfig)\n        }\n    }\n}\n</code></pre>"},{"location":"api/Serialization/#4-version-your-json-schema","title":"4. Version Your JSON Schema","text":"<p>Include version metadata:</p> <pre><code>{\n  \"version\": \"1.0\",\n  \"schemaVersion\": \"2024-01\",\n  \"flags\": [...]\n}\n</code></pre>"},{"location":"api/Serialization/#5-test-serialization-roundtrips","title":"5. Test Serialization Roundtrips","text":"<pre><code>@Test\nfun testSerializationRoundtrip() {\n    val original = ConfigBuilder.buildSnapshot {\n        MY_FLAG with {\n            default(value = false)\n            rule { platforms(Platform.IOS) } implies true\n        }\n    }\n\n    val json = serializer.serialize(original)\n    val result = serializer.deserialize(json)\n\n    assertTrue(result is ParseResult.Success)\n    val deserialized = (result as ParseResult.Success).value\n\n    assertEquals(original.flags.size, deserialized.flags.size)\n}\n</code></pre>"},{"location":"api/Serialization/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core API - ParseResult and error handling</li> <li>Flag Registry - Loading and updating configurations</li> <li>Builders - Creating configurations to serialize</li> <li>[Examples](examples/README.md - Complete serialization examples</li> </ul>"},{"location":"api/examples/","title":"Konditional Examples","text":"<p>Time to complete: 20-30 minutes</p> <p>This directory contains complete, runnable examples showing you how to migrate from traditional feature flags to Konditional's type-safe approach.</p> <pre><code>gh repo clone https://github.com/amichne/konditional-examples.git\n</code></pre>"},{"location":"api/examples/#learning-path","title":"Learning Path","text":"<p>Follow these examples in order for the best learning experience:</p>"},{"location":"api/examples/#1-basic-usage","title":"1. Basic Usage","text":"<p>Time: 5-8 minutes</p> <p>Your first steps with Konditional - learn the fundamentals by migrating simple boolean toggles.</p> What you'll learn <ul> <li>Defining type-safe feature flags with <code>Conditional&lt;S, C&gt;</code></li> <li>Creating evaluation <code>Context</code> for targeting</li> <li>Platform-specific targeting rules</li> <li>Version-based rollouts</li> <li>Configuration flags (non-boolean values)</li> <li>Multiple rules with specificity ordering</li> </ul> <p>Migration focus: Replace <code>getBoolean()</code> and <code>getString()</code> calls with type-safe flags.</p>"},{"location":"api/examples/#2-rollouts","title":"2. Rollouts","text":"<p>Time: 8-10 minutes</p> <p>Master gradual rollouts and percentage-based distribution with deterministic bucketing.</p> What you'll learn <ul> <li>Gradual percentage rollouts (10%, 25%, 50%, 100%)</li> <li>Phased rollout strategies</li> <li>Platform-specific rollout percentages</li> <li>Deterministic bucketing with StableId (no more random distributions!)</li> <li>Multi-variant A/B testing</li> <li>Salt-based re-bucketing for new experiments</li> </ul> <p>Migration focus: Replace manual modulo-based rollouts with deterministic <code>Rollout</code>.</p>"},{"location":"api/examples/#3-custom-context","title":"3. Custom Context","text":"<p>Time: 8-10 minutes</p> <p>Extend <code>Context</code> with your domain-specific properties for advanced targeting.</p> What you'll learn <ul> <li>Extending Context with custom properties (premium status, subscription tiers, etc.)</li> <li>Enterprise contexts with complex business logic</li> <li>Creating reusable <code>Evaluable</code> classes</li> <li>Combining standard targeting (platform, locale) with custom logic</li> <li>Context hierarchies and polymorphism</li> </ul> <p>Migration focus: Replace map-based context with structured, type-safe context extensions.</p>"},{"location":"api/examples/#4-serialization","title":"4. Serialization","text":"<p>Time: 8-10 minutes</p> <p>Integrate with remote configuration systems using type-safe JSON serialization.</p> What you'll learn <ul> <li>Serializing and deserializing flag configurations</li> <li>Type-safe error handling with <code>ParseResult</code></li> <li>Patch-based incremental updates</li> <li>Remote configuration loading patterns</li> <li>Graceful degradation with fallback configs</li> <li>Configuration versioning and rollback strategies</li> <li>Hot reloading flags without app restart</li> </ul> <p>Migration focus: Replace manual JSON parsing with built-in type-safe serialization.</p>"},{"location":"api/examples/#running-the-examples","title":"Running the Examples","text":"<p>Each example file is a standalone Kotlin file with a <code>main()</code> function.</p>"},{"location":"api/examples/#using-intellij-idea-android-studio","title":"Using IntelliJ IDEA / Android Studio","text":"<ol> <li>Open the example file</li> <li>Click the green play button next to <code>main()</code></li> <li>View output in the Run window</li> </ol>"},{"location":"api/examples/#using-command-line","title":"Using Command Line","text":"<pre><code># Using Kotlin compiler\nkotlinc 01-BasicUsage.kt -include-runtime -d basic-usage.jar\njava -jar basic-usage.jar\n\n# Or with Gradle (if in a project)\n./gradlew run\n</code></pre>"},{"location":"api/examples/#common-migration-patterns","title":"Common Migration Patterns","text":""},{"location":"api/examples/#before-after-simple-boolean-toggle","title":"Before &amp; After: Simple Boolean Toggle","text":"Traditional approach (click to expand) <pre><code>// Scattered definitions\nconst val FEATURE_KEY = \"new_checkout\"\n\n// Usage site 1\nif (featureManager.isEnabled(FEATURE_KEY)) {\n    showNewCheckout()\n}\n\n// Usage site 2 - typo risk!\nif (featureManager.isEnabled(\"new_chekout\")) {  // \u274c Typo!\n    showNewCheckout()\n}\n</code></pre> Konditional approach (click to expand) <pre><code>// Define once\nval NEW_CHECKOUT: Conditional&lt;Boolean, Context&gt; = Conditional(\"new_checkout\")\n\n// Configure once\nConfigBuilder.config {\n    NEW_CHECKOUT with {\n        default(value = false)\n        rule { platforms(Platform.IOS) } implies true\n    }\n}\n\n// Use everywhere - compile-time safe!\nif (context.evaluate(NEW_CHECKOUT)) {\n    showNewCheckout()\n}\n\n// Typos caught at compile time\n// if (context.evaluate(NEW_CHEKOUT)) { }  // \u274c Won't compile!\n</code></pre>"},{"location":"api/examples/#before-after-percentage-rollout","title":"Before &amp; After: Percentage Rollout","text":"Traditional approach (inconsistent) <pre><code>// Manual bucketing - different results each session\nval userId = user.id.hashCode()\nval inRollout = (userId % 100) &lt; 25  // 25% rollout\n\n// Problem: Same user gets different results across sessions\n</code></pre> Konditional approach (deterministic) <pre><code>ConfigBuilder.config {\n    BETA_FEATURE with {\n        default(value = false)\n        rule {\n            rollout = Rollout.of(25.0)  // Deterministic SHA-256 bucketing\n        } implies true\n    }\n}\n\n// Same user ALWAYS gets the same result\nval enabled = context.evaluate(BETA_FEATURE)\n</code></pre>"},{"location":"api/examples/#before-after-custom-targeting","title":"Before &amp; After: Custom Targeting","text":"Traditional approach (map-based) <pre><code>// Untyped context map\nval context = mapOf(\n    \"userId\" to user.id,\n    \"isPremium\" to user.isPremium,\n    \"accountAge\" to user.accountAge\n)\n\n// Manual logic scattered throughout codebase\nfun isFeatureEnabled(): Boolean {\n    val isPremium = context[\"isPremium\"] as? Boolean ?: false\n    val accountAge = context[\"accountAge\"] as? Int ?: 0\n    return isPremium &amp;&amp; accountAge &gt; 30\n}\n</code></pre> Konditional approach (type-safe) <pre><code>// Type-safe context extension\ndata class UserContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val isPremium: Boolean,\n    val accountAge: Int\n) : Context\n\n// Declarative rules\nConfigBuilder.config {\n    PREMIUM_FEATURE with {\n        default(value = false)\n        rule {\n            extension {\n                object : Evaluable&lt;UserContext&gt;() {\n                    override fun matches(ctx: UserContext) =\n                        ctx.isPremium &amp;&amp; ctx.accountAge &gt; 30\n                    override fun specificity() = 2\n                }\n            }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/examples/#common-patterns-demonstrated","title":"Common Patterns Demonstrated","text":""},{"location":"api/examples/#simple-feature-toggle","title":"Simple Feature Toggle","text":"<pre><code>val FEATURE: Conditional&lt;Boolean, Context&gt; = Conditional(\"feature\")\n\nConfigBuilder.config {\n    FEATURE with {\n        default(value = false)\n    }\n}\n\nval isEnabled = context.evaluate(FEATURE)\n</code></pre>"},{"location":"api/examples/#platform-specific-feature","title":"Platform-Specific Feature","text":"<pre><code>ConfigBuilder.config {\n    FEATURE with {\n        default(value = false)\n        rule {\n            platforms(Platform.IOS)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/examples/#gradual-rollout","title":"Gradual Rollout","text":"<pre><code>ConfigBuilder.config {\n    FEATURE with {\n        default(value = false)\n        rule {\n            rollout = Rollout.of(25.0)  // 25% of users\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/examples/#custom-targeting","title":"Custom Targeting","text":"<pre><code>data class UserContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val isPremium: Boolean\n) : Context\n\nConfigBuilder.config {\n    FEATURE with {\n        default(value = false)\n        rule {\n            extension {\n                object : Evaluable&lt;UserContext&gt;() {\n                    override fun matches(context: UserContext) = context.isPremium\n                    override fun specificity() = 1\n                }\n            }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"api/examples/#remote-configuration","title":"Remote Configuration","text":"<pre><code>val json = fetchFromServer()\n\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        FlagRegistry.load(result.value)\n        println(\"Configuration loaded\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Error: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"api/examples/#migration-checklist","title":"Migration Checklist","text":"<p>After completing these examples, you should be able to:</p> <ul> <li>[ ] Replace string-based flags with type-safe <code>Conditional&lt;S, C&gt;</code></li> <li>[ ] Create evaluation contexts with proper targeting dimensions</li> <li>[ ] Configure flags using the builder DSL</li> <li>[ ] Implement gradual rollouts with deterministic bucketing</li> <li>[ ] Extend <code>Context</code> for domain-specific targeting</li> <li>[ ] Serialize and deserialize flag configurations</li> <li>[ ] Handle errors gracefully with <code>ParseResult</code> and <code>EvaluationResult</code></li> </ul>"},{"location":"api/examples/#next-steps","title":"Next Steps","text":""},{"location":"api/examples/#for-quick-integration","title":"For Quick Integration","text":"<ol> <li>Builder DSL (10 min) - Master the configuration syntax</li> <li>Core API (10 min) - Understand Conditionals and evaluation</li> <li>Start migrating! - Pick one flag and convert it</li> </ol>"},{"location":"api/examples/#for-deep-understanding","title":"For Deep Understanding","text":"<ol> <li>API Overview (10 min) - Architecture and design principles</li> <li>Context System (8 min) - Targeting dimensions explained</li> <li>Rules System (8 min) - Advanced rule composition</li> <li>Serialization (8 min) - Remote config integration</li> </ol>"},{"location":"api/examples/#for-production-deployment","title":"For Production Deployment","text":"<ol> <li>Review the test suite for testing patterns</li> <li>Set up remote configuration with your backend</li> <li>Plan your rollout strategy (start with low-risk flags)</li> <li>Monitor and iterate</li> </ol>"},{"location":"api/examples/#common-questions","title":"Common Questions","text":"Q: Can I gradually migrate, or must I convert everything at once?  **A:** You can migrate gradually! Konditional flags can coexist with your existing flag system. Start with one or two flags, gain confidence, then migrate more.  <pre><code>// Both can coexist\nval newFeature = context.evaluate(NEW_FEATURE)        // Konditional\nval oldFeature = legacyFlags.getBoolean(\"old_feature\", false)  // Legacy\n</code></pre> Q: How do I handle flags that don't fit the standard Context?  **A:** Extend `Context` with custom properties! See [03-CustomContext.kt](03-CustomContext.kt) for examples.  <pre><code>data class MyContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val customProperty: String  // Your custom targeting\n) : Context\n</code></pre> Q: What if my rollout percentages need to change frequently?  **A:** Use remote configuration! See [04-Serialization.kt](04-Serialization.kt) to learn how to load flag configs from your backend without app updates.  Q: How do I ensure deterministic bucketing for A/B tests?  **A:** Use `StableId` with a consistent user identifier:  <pre><code>val context = Context(\n    // ... other fields\n    stableId = StableId.of(userId)  // Same user ID = same bucket\n)\n</code></pre>  Konditional uses SHA-256 hashing to ensure the same user always gets the same variant."},{"location":"api/examples/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Repository - Source code and issues</li> <li>API Reference - Complete API documentation</li> <li>Parse, Don't Validate - Design philosophy</li> </ul> <p>Estimated total time to migrate your first production flag: 30-45 minutes </p>"},{"location":"venv/lib/python3.14/site-packages/backrefs-5.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/idna-3.11.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/markdown-3.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip-25.2.dist-info/licenses/src/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}