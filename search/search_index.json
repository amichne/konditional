{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Konditional","text":"<p>Type-safe, deterministic feature configuration for Kotlin</p> <p>Konditional provides a type-safe, composable API for feature flag management. This document introduces the core concepts and demonstrates common usage patterns.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#features","title":"Features","text":"<p>A Feature represents a configurable flag with a specific value type and evaluation context. Features are the primary interface for defining and evaluating flags.</p> <p>Features are typically organized as enum members for type safety and IDE support:</p> <pre><code>enum class AppFeatures(override val key: String) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ADVANCED_SEARCH(\"advanced_search\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"#context","title":"Context","text":"<p>Context provides the evaluation environment for feature flags. It contains standard targeting dimensions (locale, platform, version, stable ID) and can be extended with custom fields:</p> <pre><code>// Standard context\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\")\n)\n\n// Custom context with domain-specific fields\ndata class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier\n) : Context\n</code></pre>"},{"location":"#rules","title":"Rules","text":"<p>Rules define targeting criteria and rollout strategies. Each rule specifies conditions that must be met for a particular value to be returned:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n    locales(AppLocale.EN_US)\n    versions {\n        min(2, 0, 0)\n    }\n    rollout = Rollout.of(50.0)  // 50% gradual rollout\n    note(\"Mobile-only feature, 50% rollout\")\n}.implies(true)\n</code></pre>"},{"location":"#flag-definitions","title":"Flag Definitions","text":"<p>A FlagDefinition combines a feature with its configured rules and default value. Definitions are created through the DSL and evaluated against a context:</p> <pre><code>config {\n    AppFeatures.DARK_MODE with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS)\n            rollout = Rollout.of(100.0)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#using-the-dsl","title":"Using the DSL","text":"<p>The primary way to configure flags is through the <code>config</code> DSL:</p> <pre><code>config {\n    // Configure a boolean flag\n    AppFeatures.DARK_MODE with {\n        default(false)\n        salt(\"v2\")  // Optional: change to redistribute rollout buckets\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n\n    // Configure a complex type flag\n    AppConfig.API_SETTINGS with {\n        default(ApiSettings(url = \"https://prod.api.example.com\", timeout = 30))\n\n        rule {\n            platforms(Platform.WEB)\n            rollout = Rollout.of(25.0)\n        }.implies(ApiSettings(url = \"https://beta.api.example.com\", timeout = 60))\n    }\n}\n</code></pre>"},{"location":"#building-snapshots","title":"Building Snapshots","text":"<p>For testing or external configuration management, use <code>buildSnapshot</code> to create configurations without loading them:</p> <pre><code>val testConfig = buildSnapshot {\n    AppFeatures.DARK_MODE with {\n        default(true)\n    }\n}\n\n// Use with a test registry\nval testRegistry = FlagRegistry.create(testConfig)\n</code></pre>"},{"location":"#evaluation","title":"Evaluation","text":""},{"location":"#basic-evaluation","title":"Basic Evaluation","text":"<p>Evaluate flags by calling extension functions on your context:</p> <pre><code>// Returns EvaluationResult (Success, FlagNotFound, or EvaluationError)\nval result: EvaluationResult&lt;Boolean&gt; = context.evaluateSafe(AppFeatures.DARK_MODE)\n\nwhen (result) {\n    is EvaluationResult.Success -&gt; println(\"Dark mode: ${result.value}\")\n    is EvaluationResult.FlagNotFound -&gt; println(\"Flag not registered: ${result.key}\")\n    is EvaluationResult.EvaluationError -&gt; println(\"Evaluation failed: ${result.error}\")\n}\n</code></pre>"},{"location":"#convenience-methods","title":"Convenience Methods","text":"<p>For simpler use cases, convenience methods are available:</p> <pre><code>// Returns null on any failure\nval enabled: Boolean? = context.evaluateOrNull(AppFeatures.DARK_MODE)\n\n// Returns default value on failure\nval enabled: Boolean = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n\n// Throws exception on failure (use sparingly)\nval enabled: Boolean = context.evaluateOrThrow(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"#value-types","title":"Value Types","text":"<p>Konditional supports multiple value types through the <code>EncodableValue</code> abstraction.</p>"},{"location":"#primitive-types","title":"Primitive Types","text":"<p>Boolean, String, Int, and Double are supported natively:</p> <pre><code>val booleanFlag: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; = Feature(\"bool\")\nval stringFlag: Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; = Feature(\"string\")\nval intFlag: Feature&lt;EncodableValue.IntEncodeable, Int, Context&gt; = Feature(\"int\")\nval doubleFlag: Feature&lt;EncodableValue.DecimalEncodeable, Double, Context&gt; = Feature(\"double\")\n</code></pre>"},{"location":"#json-object-types","title":"JSON Object Types","text":"<p>Complex data classes can be used via the <code>OfJsonObject</code> feature type:</p> <pre><code>data class ThemeConfig(val primaryColor: String, val fontSize: Int)\n\nval themeFlag: Feature.OfJsonObject&lt;ThemeConfig, Context&gt; =\n    Feature.jsonObject(\"theme\")\n\nconfig {\n    themeFlag with {\n        default(ThemeConfig(primaryColor = \"#FFFFFF\", fontSize = 14))\n    }\n}\n</code></pre>"},{"location":"#custom-wrapper-types","title":"Custom Wrapper Types","text":"<p>Extend primitives with domain-specific wrappers:</p> <pre><code>data class ApiUrl(val value: String)\n\nval urlFlag: Feature.OfCustom&lt;ApiUrl, String, Context&gt; =\n    Feature.custom(\"api_url\")\n\nconfig {\n    urlFlag with {\n        default(\n            ApiUrl(\"https://prod.example.com\").asCustomString()\n                .encoder { it.value }\n                .decoder { ApiUrl(it) }\n        )\n    }\n}\n</code></pre>"},{"location":"#registry-management","title":"Registry Management","text":""},{"location":"#singleton-registry","title":"Singleton Registry","text":"<p>By default, Konditional uses a thread-safe singleton registry:</p> <pre><code>// Load configuration into singleton\nconfig {\n    // ... flag definitions\n}\n\n// Evaluate using singleton (implicit)\ncontext.evaluateSafe(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"#custom-registries","title":"Custom Registries","text":"<p>Create isolated registries for testing or multi-tenant scenarios:</p> <pre><code>// Create empty registry\nval customRegistry = FlagRegistry.create()\n\n// Create with initial configuration\nval customRegistry = FlagRegistry.create(buildSnapshot {\n    AppFeatures.DARK_MODE with { default(true) }\n})\n\n// Evaluate using custom registry\ncontext.evaluateSafe(AppFeatures.DARK_MODE, registry = customRegistry)\n</code></pre>"},{"location":"#dynamic-updates","title":"Dynamic Updates","text":"<p>Update configurations at runtime without restarting:</p> <pre><code>// Update individual flag\nval newDefinition = FlagDefinition(\n    feature = AppFeatures.DARK_MODE,\n    defaultValue = true,\n    bounds = emptyList()\n)\nregistry.update(newDefinition)\n\n// Load complete new configuration\nregistry.load(newConfig)\n\n// Apply incremental patch\nregistry.update(patch)\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>Konditional follows the \"parse, don't validate\" principle with explicit result types.</p>"},{"location":"#evaluationresult","title":"EvaluationResult","text":"<p>The primary result type for flag evaluation:</p> <pre><code>sealed interface EvaluationResult&lt;out S&gt; {\n    data class Success&lt;S&gt;(val value: S) : EvaluationResult&lt;S&gt;\n    data class FlagNotFound(val key: String) : EvaluationResult&lt;Nothing&gt;\n    data class EvaluationError(val key: String, val error: Throwable) : EvaluationResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"#folding-results","title":"Folding Results","text":"<p>Transform evaluation results into your preferred error handling type:</p> <pre><code>val outcome = context.evaluateSafe(AppFeatures.DARK_MODE).fold(\n    onSuccess = { Result.success(it) },\n    onFlagNotFound = { Result.failure(FlagMissingException(it)) },\n    onEvaluationError = { key, err -&gt; Result.failure(FlagFailedException(key, err)) }\n)\n</code></pre>"},{"location":"#parseresult","title":"ParseResult","text":"<p>Used for deserialization operations:</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"#thread-safety","title":"Thread Safety","text":"<p>Konditional is designed for safe concurrent access:</p> <ul> <li>Lock-free reads: Flag evaluation requires no locks</li> <li>Atomic updates: Configuration changes are atomic via <code>AtomicReference</code></li> <li>Independent evaluations: Each flag evaluation is independent and thread-safe</li> <li>Deterministic bucketing: Rollout assignments are stable across threads</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Context: Learn about context types and custom extensions</li> <li>Rules: Deep dive into rule evaluation and specificity</li> <li>Flags: Understand feature registration patterns</li> <li>Builders: Master the configuration DSL</li> <li>Serialization: Work with JSON configurations</li> <li>Architecture: Understand the internal design</li> </ul>"},{"location":"Architecture/","title":"Architecture","text":"<p>This document explains Konditional's internal architecture, design principles, and how the various components work together.</p>"},{"location":"Architecture/#design-principles","title":"Design Principles","text":""},{"location":"Architecture/#type-safety-first","title":"Type Safety First","text":"<p>Every API surface uses strong typing to prevent runtime errors:</p> <ul> <li>Generic type parameters enforce value type constraints</li> <li>Context polymorphism ensures features get appropriate evaluation contexts</li> <li>EncodableValue types make unsupported types unrepresentable</li> <li>No string-based lookups or unchecked casts</li> </ul>"},{"location":"Architecture/#parse-dont-validate","title":"Parse, Don't Validate","text":"<p>APIs return explicit result types rather than throwing exceptions:</p> <ul> <li><code>EvaluationResult&lt;T&gt;</code> for flag evaluation</li> <li><code>ParseResult&lt;T&gt;</code> for deserialization</li> <li>Fold functions for ergonomic error handling</li> </ul>"},{"location":"Architecture/#deterministic-behavior","title":"Deterministic Behavior","text":"<p>Same inputs always produce same outputs:</p> <ul> <li>SHA-256 based bucketing for rollouts</li> <li>Stable evaluation order (by specificity)</li> <li>Independent flag bucketing spaces</li> <li>No global mutable state (except atomic registry)</li> </ul>"},{"location":"Architecture/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>Components compose through interfaces:</p> <ul> <li>Rules compose BaseEvaluable + extension Evaluable</li> <li>Features compose key + registry + value type</li> <li>Builders use sealed interfaces with internal implementations</li> </ul>"},{"location":"Architecture/#core-components","title":"Core Components","text":""},{"location":"Architecture/#feature","title":"Feature","text":"<p>Entry point for defining flags:</p> <pre><code>Feature&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt;\n  |\n  +-- key: String\n  +-- registry: FlagRegistry\n  +-- update(definition)\n</code></pre> <p>Features are typically implemented as enum members or object declarations.</p>"},{"location":"Architecture/#flagdefinition","title":"FlagDefinition","text":"<p>Internal representation of configured flags:</p> <pre><code>FlagDefinition&lt;S, T, C&gt;\n  |\n  +-- feature: Feature&lt;S, T, C&gt;\n  +-- defaultValue: T\n  +-- values: List&lt;ConditionalValue&lt;S, T, C&gt;&gt;\n  +-- isActive: Boolean\n  +-- salt: String\n  |\n  +-- evaluate(context: C): T\n</code></pre> <p>FlagDefinition handles: - Rule evaluation and specificity ordering - Rollout bucketing via SHA-256 hashing - Fallback to default value</p>"},{"location":"Architecture/#context","title":"Context","text":"<p>Evaluation environment:</p> <pre><code>Context\n  |\n  +-- locale: AppLocale\n  +-- platform: Platform\n  +-- appVersion: Version\n  +-- stableId: StableId\n</code></pre> <p>Can be extended with custom fields for domain-specific targeting.</p>"},{"location":"Architecture/#rule","title":"Rule","text":"<p>Targeting criteria:</p> <pre><code>Rule&lt;C : Context&gt;\n  |\n  +-- rollout: Rollout\n  +-- note: String?\n  +-- baseEvaluable: BaseEvaluable&lt;C&gt;\n  +-- extension: Evaluable&lt;C&gt;\n  |\n  +-- matches(context: C): Boolean\n  +-- specificity(): Int\n</code></pre> <p>Rules compose: - Base targeting (locale, platform, version) - Custom extension logic - Both must match for rule to match</p>"},{"location":"Architecture/#evaluable","title":"Evaluable","text":"<p>Composable evaluation abstraction:</p> <pre><code>Evaluable&lt;C : Context&gt;\n  |\n  +-- matches(context: C): Boolean (default: true)\n  +-- specificity(): Int (default: 0)\n\nBaseEvaluable&lt;C&gt;\n  |\n  +-- locales: Set&lt;AppLocale&gt;\n  +-- platforms: Set&lt;Platform&gt;\n  +-- versionRange: VersionRange\n</code></pre> <p>Evaluables can be composed to create complex targeting logic.</p>"},{"location":"Architecture/#flagregistry","title":"FlagRegistry","text":"<p>Configuration storage:</p> <pre><code>FlagRegistry\n  |\n  +-- load(konfig: Konfig)\n  +-- update(patch: KonfigPatch)\n  +-- update(definition: FlagDefinition&lt;S, T, C&gt;)\n  +-- konfig(): Konfig\n  +-- featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;?\n  +-- allFlags(): Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n</code></pre> <p>Default implementation uses <code>AtomicReference&lt;Konfig&gt;</code> for thread-safe updates.</p>"},{"location":"Architecture/#data-flow","title":"Data Flow","text":""},{"location":"Architecture/#configuration-flow","title":"Configuration Flow","text":"<pre><code>DSL (config { })\n  -&gt; ConfigBuilder\n  -&gt; Konfig (immutable snapshot)\n  -&gt; FlagRegistry (AtomicReference)\n</code></pre> <ol> <li>DSL builds intermediate builder structure</li> <li>Builder creates immutable Konfig</li> <li>Konfig loaded into registry atomically</li> </ol>"},{"location":"Architecture/#evaluation-flow","title":"Evaluation Flow","text":"<pre><code>Context.evaluateSafe(feature)\n  -&gt; Registry.featureFlag(feature)\n  -&gt; FlagDefinition.evaluate(context)\n  -&gt; ConditionalValue matching (by specificity)\n  -&gt; Rule.matches(context) &amp;&amp; isInEligibleSegment()\n  -&gt; Return matched value or default\n</code></pre> <ol> <li>Lookup flag definition in registry</li> <li>Iterate through conditional values (sorted by specificity)</li> <li>Check if rule matches context</li> <li>Check if context is in rollout bucket</li> <li>Return value from first matching rule, or default</li> </ol>"},{"location":"Architecture/#specificity-ordering","title":"Specificity Ordering","text":"<p>Rules are evaluated in specificity order:</p> <pre><code>Rules sorted by:\n  1. specificity() DESC\n  2. note ASC (tie-breaker)\n\nSpecificity calculation:\n  baseEvaluable.specificity() + extension.specificity()\n\nBaseEvaluable specificity:\n  (locales not empty ? 1 : 0) +\n  (platforms not empty ? 1 : 0) +\n  (versionRange has bounds ? 1 : 0)\n</code></pre> <p>More specific rules are evaluated first.</p>"},{"location":"Architecture/#bucketing-algorithm","title":"Bucketing Algorithm","text":"<p>Rollout bucketing uses SHA-256:</p> <pre><code>fun isInEligibleSegment(\n    flagKey: String,\n    id: HexId,\n    salt: String,\n    rollout: Rollout\n): Boolean {\n    if (rollout &lt;= 0.0) return false\n    if (rollout &gt;= 100.0) return true\n\n    val bucket = stableBucket(flagKey, id, salt)\n    return bucket &lt; (rollout.value * 100).toInt()\n}\n\nfun stableBucket(\n    flagKey: String,\n    id: HexId,\n    salt: String\n): Int {\n    val hash = SHA256(\"$salt:$flagKey:${id.id}\")\n    val first4Bytes = hash[0..3]\n    return (first4Bytes as Int) % 10_000\n}\n</code></pre> <p>Properties: - Deterministic: Same inputs always hash to same bucket - Independent: Each flag has separate bucketing space - Stable: Changing salt redistributes buckets - Range: 0-9999 (0.01% granularity)</p>"},{"location":"Architecture/#thread-safety","title":"Thread Safety","text":""},{"location":"Architecture/#lock-free-reads","title":"Lock-Free Reads","text":"<p>Flag evaluation requires no locks:</p> <pre><code>class SingletonFlagRegistry : FlagRegistry {\n    private val konfigRef = AtomicReference&lt;Konfig&gt;(Konfig.EMPTY)\n\n    override fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;? {\n        return konfigRef.get().flags[key]  // No lock needed\n    }\n}\n</code></pre> <p>Reads use <code>AtomicReference.get()</code>, which is lock-free.</p>"},{"location":"Architecture/#atomic-updates","title":"Atomic Updates","text":"<p>Configuration updates are atomic:</p> <pre><code>override fun load(config: Konfig) {\n    konfigRef.set(config)  // Atomic swap\n}\n</code></pre> <p>New configuration replaces old atomically. Concurrent evaluations see either old or new, never partial state.</p>"},{"location":"Architecture/#immutable-data","title":"Immutable Data","text":"<p>All configuration data is immutable:</p> <pre><code>data class Konfig(\n    val flags: Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n)  // Map is immutable\n\ndata class FlagDefinition&lt;S, T, C&gt;(\n    val defaultValue: T,  // Immutable\n    val values: List&lt;ConditionalValue&lt;S, T, C&gt;&gt;,  // List is immutable\n    // ...\n)\n</code></pre> <p>Immutability ensures thread safety without locks.</p>"},{"location":"Architecture/#builder-dsl-architecture","title":"Builder DSL Architecture","text":""},{"location":"Architecture/#scope-hierarchy","title":"Scope Hierarchy","text":"<pre><code>ConfigScope (sealed interface)\n  -&gt; ConfigBuilder (internal implementation)\n\nFlagScope&lt;S, T, C&gt; (sealed interface)\n  -&gt; FlagBuilder&lt;S, T, C&gt; (internal implementation)\n\nRuleScope&lt;C&gt; (sealed interface)\n  -&gt; RuleBuilder&lt;C&gt; (internal implementation)\n</code></pre> <p>Sealed interfaces hide implementation, preventing direct instantiation.</p>"},{"location":"Architecture/#type-state","title":"Type State","text":"<p>Builders use typestate pattern:</p> <pre><code>interface FlagScope&lt;S, T, C&gt; {\n    fun rule(build: RuleScope&lt;C&gt;.() -&gt; Unit): Rule&lt;C&gt;\n    infix fun Rule&lt;C&gt;.implies(value: T)  // Rule must be associated with value\n}\n</code></pre> <p>The <code>implies</code> extension ensures rules are always associated with values.</p>"},{"location":"Architecture/#dsl-markers","title":"DSL Markers","text":"<p><code>@FeatureFlagDsl</code> prevents accidental scope nesting:</p> <pre><code>@DslMarker\nannotation class FeatureFlagDsl\n\n@FeatureFlagDsl\ninterface ConfigScope\n\n@FeatureFlagDsl\ninterface FlagScope&lt;S, T, C&gt;\n\n@FeatureFlagDsl\ninterface RuleScope&lt;C&gt;\n</code></pre> <p>This prevents constructions like <code>rule { rule { } }</code>.</p>"},{"location":"Architecture/#serialization-architecture","title":"Serialization Architecture","text":""},{"location":"Architecture/#type-adapters","title":"Type Adapters","text":"<p>Custom Moshi adapters handle domain types:</p> <pre><code>SnapshotSerializer\n  |\n  +-- SerializableSnapshot (DTO)\n  |     |\n  |     +-- List&lt;SerializableFlag&gt;\n  |           |\n  |           +-- SerializableRule\n  |                 |\n  |                 +-- VersionRange (polymorphic)\n  |\n  +-- FlagValueAdapter (handles EncodableValue)\n  +-- VersionRangeAdapter (handles VersionRange subtypes)\n</code></pre> <p>Domain models convert to/from serializable DTOs.</p>"},{"location":"Architecture/#polymorphic-serialization","title":"Polymorphic Serialization","text":"<p>VersionRange uses polymorphic JSON:</p> <pre><code>{\n  \"type\": \"MIN_AND_MAX_BOUND\",\n  \"min\": {...},\n  \"max\": {...}\n}\n</code></pre> <p>Moshi's <code>PolymorphicJsonAdapterFactory</code> handles type discrimination.</p>"},{"location":"Architecture/#parse-dont-validate_1","title":"Parse-Don't-Validate","text":"<p>Deserialization returns <code>ParseResult</code>:</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T)\n    data class Failure(val error: ParseError)\n}\n</code></pre> <p>Forces explicit error handling, no exceptions.</p>"},{"location":"Architecture/#extension-points","title":"Extension Points","text":""},{"location":"Architecture/#custom-contexts","title":"Custom Contexts","text":"<p>Extend <code>Context</code> interface:</p> <pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n\ndata class CustomContext(\n    override val locale: AppLocale,\n    // ... standard properties\n    val customField: CustomType  // Extension\n) : Context\n</code></pre>"},{"location":"Architecture/#custom-evaluables","title":"Custom Evaluables","text":"<p>Extend <code>Evaluable</code> for custom targeting:</p> <pre><code>abstract class Evaluable&lt;C : Context&gt; {\n    open fun matches(context: C): Boolean = true\n    open fun specificity(): Int = 0\n}\n\nclass CustomEvaluable : Evaluable&lt;CustomContext&gt;() {\n    override fun matches(context: CustomContext): Boolean {\n        // Custom logic\n    }\n\n    override fun specificity(): Int = 1\n}\n</code></pre>"},{"location":"Architecture/#custom-registries","title":"Custom Registries","text":"<p>Implement <code>FlagRegistry</code> for custom storage:</p> <pre><code>interface FlagRegistry {\n    fun load(config: Konfig)\n    fun update(patch: KonfigPatch)\n    fun update(definition: FlagDefinition&lt;S, T, C&gt;)\n    fun konfig(): Konfig\n    fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;?\n    fun allFlags(): Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n}\n\nclass DatabaseBackedRegistry(private val db: Database) : FlagRegistry {\n    // Implement using database storage\n}\n</code></pre>"},{"location":"Architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"Architecture/#evaluation","title":"Evaluation","text":"<ul> <li>Lookup: O(1) hash map lookup</li> <li>Matching: O(n) where n = number of rules (typically small, &lt;10)</li> <li>Bucketing: O(1) hash computation</li> <li>Memory: Immutable snapshots, no per-request allocation</li> </ul>"},{"location":"Architecture/#updates","title":"Updates","text":"<ul> <li>Load: O(1) atomic swap</li> <li>Patch: O(n) where n = number of flags in patch</li> </ul>"},{"location":"Architecture/#serialization","title":"Serialization","text":"<ul> <li>Serialize: O(n) where n = total flags</li> <li>Deserialize: O(n) where n = total flags</li> <li>Parse: Single-pass parsing via Moshi</li> </ul>"},{"location":"Architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"Architecture/#test-registries","title":"Test Registries","text":"<p>Create isolated registries for tests:</p> <pre><code>@Test\nfun `test feature evaluation`() {\n    val testRegistry = FlagRegistry.create()\n\n    config(testRegistry) {\n        MyFeature.FLAG with { default(false) }\n    }\n\n    val context = Context(...)\n    val result = context.evaluateSafe(MyFeature.FLAG, testRegistry)\n\n    assertTrue(result is EvaluationResult.Success)\n}\n</code></pre>"},{"location":"Architecture/#test-contexts","title":"Test Contexts","text":"<p>Create test context factories:</p> <pre><code>object TestContexts {\n    fun ios(version: Version = Version(2, 0, 0)): Context =\n        Context(\n            locale = AppLocale.EN_US,\n            platform = Platform.IOS,\n            appVersion = version,\n            stableId = StableId.of(\"test-user\")\n        )\n\n    fun android(): Context = // ...\n    fun web(): Context = // ...\n}\n</code></pre>"},{"location":"Architecture/#best-practices","title":"Best Practices","text":""},{"location":"Architecture/#immutability","title":"Immutability","text":"<p>Keep all domain models immutable for thread safety.</p>"},{"location":"Architecture/#composition","title":"Composition","text":"<p>Prefer composition over inheritance for extensibility.</p>"},{"location":"Architecture/#explicit-results","title":"Explicit Results","text":"<p>Use result types instead of exceptions for expected errors.</p>"},{"location":"Architecture/#type-safety","title":"Type Safety","text":"<p>Leverage generics and sealed types to make invalid states unrepresentable.</p>"},{"location":"Architecture/#lock-free","title":"Lock-Free","text":"<p>Design for lock-free concurrent access where possible.</p>"},{"location":"Architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Overview: Back to API overview</li> <li>Context: Deep dive into contexts</li> <li>Rules: Understand rule evaluation</li> </ul>"},{"location":"Builders/","title":"Builder DSL","text":"<p>Konditional provides a type-safe, expressive DSL for configuring feature flags. The DSL uses Kotlin's receiver types and inline functions to create a fluent configuration interface while maintaining compile-time safety.</p>"},{"location":"Builders/#overview","title":"Overview","text":"<p>The configuration DSL consists of three scope levels:</p> <ol> <li>ConfigScope: Top-level configuration block</li> <li>FlagScope: Individual flag configuration</li> <li>RuleScope: Rule definition within a flag</li> </ol> <pre><code>config {  // ConfigScope\n    MyFeature.FLAG with {  // FlagScope\n        default(value)\n        rule {  // RuleScope\n            platforms(Platform.IOS)\n        }.implies(value)\n    }\n}\n</code></pre>"},{"location":"Builders/#configscope","title":"ConfigScope","text":"<p>The outermost scope for defining flag configurations.</p>"},{"location":"Builders/#config-function","title":"config Function","text":"<p>Entry point for flag configuration:</p> <pre><code>config(registry: FlagRegistry = FlagRegistry) {\n    // Flag configurations\n}\n</code></pre> <p>Parameters: - <code>registry</code>: Target registry (defaults to singleton)</p> <p>Usage:</p> <pre><code>// Configure singleton registry\nconfig {\n    MyFeature.FLAG_A with { /* ... */ }\n    MyFeature.FLAG_B with { /* ... */ }\n}\n\n// Configure custom registry\nval testRegistry = FlagRegistry.create()\nconfig(testRegistry) {\n    MyFeature.FLAG_A with { /* ... */ }\n}\n</code></pre>"},{"location":"Builders/#feature-configuration","title":"Feature Configuration","text":"<p>Use the <code>with</code> infix function to configure features:</p> <pre><code>config {\n    MyFeature.DARK_MODE with {\n        default(false)\n        // ... rules\n    }\n\n    MyFeature.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n        // ... rules\n    }\n}\n</code></pre>"},{"location":"Builders/#flagscope","title":"FlagScope","text":"<p>Scope for configuring individual flags.</p>"},{"location":"Builders/#default","title":"default()","text":"<p>Sets the default value returned when no rules match:</p> <pre><code>MyFeature.BOOLEAN_FLAG with {\n    default(false)  // Boolean\n}\n\nMyFeature.STRING_FLAG with {\n    default(\"production\")  // String\n}\n\nMyFeature.INT_FLAG with {\n    default(42)  // Int\n}\n\nMyFeature.CONFIG_FLAG with {\n    default(Config(url = \"https://prod.example.com\", timeout = 30))  // Complex type\n}\n</code></pre> <p>Note: The default value type must match the feature's declared type.</p>"},{"location":"Builders/#salt","title":"salt()","text":"<p>Sets the hash salt for rollout bucketing:</p> <pre><code>MyFeature.EXPERIMENT with {\n    default(false)\n    salt(\"v1\")  // Initial experiment\n\n    rule {\n        rollout = Rollout.of(50.0)\n    }.implies(true)\n}\n</code></pre> <p>Changing the salt redistributes users across rollout buckets.</p>"},{"location":"Builders/#rule","title":"rule()","text":"<p>Defines a targeting rule:</p> <pre><code>MyFeature.FLAG with {\n    default(false)\n\n    rule {\n        // ... targeting criteria\n    }.implies(true)\n}\n</code></pre> <p>Returns a <code>Rule</code> object that must be associated with a value using <code>implies</code>.</p>"},{"location":"Builders/#implies","title":"implies","text":"<p>Associates a rule with its value:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n}.implies(true)  // When rule matches, return true\n</code></pre>"},{"location":"Builders/#rulescope","title":"RuleScope","text":"<p>Scope for defining rule targeting criteria.</p>"},{"location":"Builders/#platforms","title":"platforms()","text":"<p>Specify target platforms:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n}.implies(value)\n\nrule {\n    platforms(Platform.WEB)\n}.implies(webValue)\n</code></pre> <p>Empty platforms = match all.</p>"},{"location":"Builders/#locales","title":"locales()","text":"<p>Specify target locales:</p> <pre><code>rule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA)\n}.implies(value)\n\nrule {\n    locales(AppLocale.FR_FR)\n}.implies(frenchValue)\n</code></pre> <p>Empty locales = match all.</p>"},{"location":"Builders/#versions","title":"versions()","text":"<p>Specify version range using VersionRangeScope:</p> <pre><code>rule {\n    versions {\n        min(2, 0, 0)  // Minimum version\n        max(3, 0, 0)  // Maximum version\n    }\n}.implies(value)\n</code></pre>"},{"location":"Builders/#rollout","title":"rollout","text":"<p>Set rollout percentage:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(25.0)  // 25% rollout\n}.implies(value)\n</code></pre> <p>Values: 0.0 to 100.0 (use <code>Rollout.MAX</code> for 100.0)</p>"},{"location":"Builders/#extension","title":"extension()","text":"<p>Add custom evaluation logic:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(value)\n</code></pre>"},{"location":"Builders/#note","title":"note()","text":"<p>Add documentation to rules:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(10.0)\n    note(\"Initial iOS canary deployment\")\n}.implies(value)\n</code></pre>"},{"location":"Builders/#versionrangescope","title":"VersionRangeScope","text":"<p>Scope for defining version constraints.</p>"},{"location":"Builders/#min","title":"min()","text":"<p>Set minimum version (inclusive):</p> <pre><code>versions {\n    min(2, 0, 0)  // &gt;= 2.0.0\n}\n\nversions {\n    min(1, 5, 3)  // &gt;= 1.5.3\n}\n</code></pre>"},{"location":"Builders/#max","title":"max()","text":"<p>Set maximum version (inclusive):</p> <pre><code>versions {\n    max(3, 0, 0)  // &lt;= 3.0.0\n}\n\nversions {\n    max(2, 9, 99)  // &lt;= 2.9.99\n}\n</code></pre>"},{"location":"Builders/#combined","title":"Combined","text":"<p>Define version range:</p> <pre><code>versions {\n    min(2, 0, 0)  // &gt;= 2.0.0\n    max(3, 0, 0)  // &lt;= 3.0.0\n}\n\n// Exact version\nversions {\n    min(2, 1, 5)\n    max(2, 1, 5)  // Exactly 2.1.5\n}\n</code></pre>"},{"location":"Builders/#complete-examples","title":"Complete Examples","text":""},{"location":"Builders/#simple-boolean-flag","title":"Simple Boolean Flag","text":"<pre><code>config {\n    MyFeatures.DARK_MODE with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#multi-rule-configuration","title":"Multi-Rule Configuration","text":"<pre><code>config {\n    MyFeatures.THEME with {\n        default(\"light\")\n        salt(\"v2\")\n\n        // Highest specificity: platform + locale + version\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n            versions {\n                min(2, 0, 0)\n            }\n            rollout = Rollout.of(50.0)\n            note(\"iOS US users on v2+, 50% rollout\")\n        }.implies(\"dark\")\n\n        // Medium specificity: platform + locale\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n            note(\"All iOS US users not in above bucket\")\n        }.implies(\"auto\")\n\n        // Low specificity: platform only\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"light-ios\")\n    }\n}\n</code></pre>"},{"location":"Builders/#complex-type-flag","title":"Complex Type Flag","text":"<pre><code>data class ApiConfig(\n    val baseUrl: String,\n    val timeout: Int,\n    val retryEnabled: Boolean\n)\n\nconfig {\n    MyFeatures.API_CONFIG with {\n        default(ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30,\n            retryEnabled = true\n        ))\n\n        rule {\n            platforms(Platform.WEB)\n            rollout = Rollout.of(25.0)\n            note(\"Staging API for 25% of web users\")\n        }.implies(ApiConfig(\n            baseUrl = \"https://api.staging.example.com\",\n            timeout = 60,\n            retryEnabled = false\n        ))\n\n        rule {\n            locales(AppLocale.EN_US)\n        }.implies(ApiConfig(\n            baseUrl = \"https://api-us.prod.example.com\",\n            timeout = 30,\n            retryEnabled = true\n        ))\n    }\n}\n</code></pre>"},{"location":"Builders/#enterprise-context-flag","title":"Enterprise Context Flag","text":"<pre><code>config {\n    EnterpriseFeatures.ADVANCED_ANALYTICS with {\n        default(false)\n\n        // Enterprise tier customers\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n                    override fun specificity(): Int = 1\n                }\n            }\n            rollout = Rollout.MAX\n            note(\"Full rollout for enterprise customers\")\n        }.implies(true)\n\n        // Professional tier with admin role\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.PROFESSIONAL &amp;&amp;\n                        context.userRole == UserRole.ADMIN\n\n                    override fun specificity(): Int = 2\n                }\n            }\n            rollout = Rollout.of(50.0)\n            note(\"50% rollout for professional admins\")\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#buildsnapshot","title":"buildSnapshot()","text":"<p>Create configurations without loading them into a registry:</p> <pre><code>val snapshot = buildSnapshot {\n    MyFeatures.FLAG_A with {\n        default(false)\n    }\n\n    MyFeatures.FLAG_B with {\n        default(true)\n    }\n}\n\n// Use snapshot later\nregistry.load(snapshot)\n\n// Or serialize it\nval json = SnapshotSerializer.default.serialize(snapshot)\n</code></pre> <p>Use cases: - Testing configurations - Building configurations programmatically - Serializing configurations - External configuration management</p>"},{"location":"Builders/#type-safety","title":"Type Safety","text":"<p>The DSL provides compile-time type safety:</p> <pre><code>config {\n    // Type-safe: Boolean feature expects Boolean values\n    MyBooleanFeature.FLAG with {\n        default(false)\n        rule { platforms(Platform.IOS) }.implies(true)  // OK\n        // rule { platforms(Platform.IOS) }.implies(\"true\")  // Compile error!\n    }\n\n    // Type-safe: String feature expects String values\n    MyStringFeature.API_URL with {\n        default(\"https://prod.example.com\")\n        rule { platforms(Platform.WEB) }.implies(\"https://staging.example.com\")  // OK\n        // rule { platforms(Platform.WEB) }.implies(true)  // Compile error!\n    }\n}\n</code></pre>"},{"location":"Builders/#dsl-markers","title":"DSL Markers","text":"<p>The DSL uses <code>@FeatureFlagDsl</code> annotation to prevent accidental nesting:</p> <pre><code>@FeatureFlagDsl\ninterface ConfigScope { /* ... */ }\n\n@FeatureFlagDsl\ninterface FlagScope&lt;S, T, C&gt; { /* ... */ }\n\n@FeatureFlagDsl\ninterface RuleScope&lt;C&gt; { /* ... */ }\n</code></pre> <p>This prevents invalid constructions like:</p> <pre><code>config {\n    MyFeature.FLAG with {\n        rule {\n            rule {  // Compile error: Can't nest rule inside rule\n                // ...\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Builders/#best-practices","title":"Best Practices","text":""},{"location":"Builders/#separate-configuration-files","title":"Separate Configuration Files","text":"<p>Organize configurations by feature area:</p> <pre><code>// UIConfig.kt\nobject UIConfig {\n    fun configure() = config {\n        UIFeatures.DARK_MODE with { /* ... */ }\n        UIFeatures.ANIMATIONS with { /* ... */ }\n    }\n}\n\n// ApiConfig.kt\nobject ApiConfig {\n    fun configure() = config {\n        ApiFeatures.ENDPOINT with { /* ... */ }\n        ApiFeatures.TIMEOUT with { /* ... */ }\n    }\n}\n\n// Initialize all\nfun initializeFeatureFlags() {\n    UIConfig.configure()\n    ApiConfig.configure()\n}\n</code></pre>"},{"location":"Builders/#use-named-values-for-clarity","title":"Use Named Values for Clarity","text":"<pre><code>config {\n    MyFeatures.API_CONFIG with {\n        val prodConfig = ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30\n        )\n\n        val stagingConfig = ApiConfig(\n            baseUrl = \"https://api.staging.example.com\",\n            timeout = 60\n        )\n\n        default(prodConfig)\n\n        rule {\n            platforms(Platform.WEB)\n        }.implies(stagingConfig)\n    }\n}\n</code></pre>"},{"location":"Builders/#extract-complex-extensions","title":"Extract Complex Extensions","text":"<pre><code>class EnterpriseCustomerEvaluable : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier in setOf(\n            SubscriptionTier.PROFESSIONAL,\n            SubscriptionTier.ENTERPRISE\n        )\n\n    override fun specificity(): Int = 1\n}\n\nconfig {\n    MyFeatures.PREMIUM_FEATURE with {\n        default(false)\n\n        rule {\n            extension { EnterpriseCustomerEvaluable() }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#document-complex-configurations","title":"Document Complex Configurations","text":"<pre><code>config {\n    MyFeatures.EXPERIMENT_A with {\n        default(false)\n        salt(\"experiment_a_v2\")  // Changed salt for fresh distribution\n\n        rule {\n            platforms(Platform.IOS)\n            versions {\n                min(2, 5, 0)  // Requires new API features\n            }\n            rollout = Rollout.of(20.0)\n            note(\"\"\"\n                Phase 1 rollout of Experiment A.\n                Target: iOS users on v2.5+\n                Tracking: analytics_experiment_a_v2\n                Owner: product-team@example.com\n                Duration: 2024-Q1\n            \"\"\".trimIndent())\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Builders/#next-steps","title":"Next Steps","text":"<ul> <li>Rules: Understand rule evaluation</li> <li>Flags: Learn about feature patterns</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"Context/","title":"Context API","text":"<p>The <code>Context</code> interface defines the evaluation environment for feature flags. It provides standard targeting dimensions while allowing domain-specific extensions for custom business logic.</p>"},{"location":"Context/#base-context-interface","title":"Base Context Interface","text":"<p>The base <code>Context</code> interface defines four required properties:</p> <pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n</code></pre>"},{"location":"Context/#standard-properties","title":"Standard Properties","text":""},{"location":"Context/#locale-applocale","title":"locale: AppLocale","text":"<p>Represents the user's language and regional settings. Used for localization-based targeting.</p> <pre><code>enum class AppLocale {\n    EN_US,\n    EN_CA,\n    EN_GB,\n    FR_FR,\n    DE_DE,\n    ES_ES,\n    JA_JP,\n    ZH_CN,\n    // ... other locales\n}\n</code></pre>"},{"location":"Context/#platform-platform","title":"platform: Platform","text":"<p>Identifies the platform where the application is running.</p> <pre><code>enum class Platform {\n    IOS,\n    ANDROID,\n    WEB,\n    DESKTOP,\n    SERVER\n}\n</code></pre>"},{"location":"Context/#appversion-version","title":"appVersion: Version","text":"<p>Semantic version of the application, used for version-based targeting.</p> <pre><code>data class Version(\n    val major: Int,\n    val minor: Int,\n    val patch: Int\n) : Comparable&lt;Version&gt;\n\n// Create versions\nval version = Version(2, 5, 0)\nval parsed = Version.parse(\"2.5.0\")\n</code></pre>"},{"location":"Context/#stableid-stableid","title":"stableId: StableId","text":"<p>A stable, unique identifier used for deterministic rollout bucketing. This ensures users consistently see the same variation across sessions.</p> <pre><code>// Create from any unique identifier\nval stableId = StableId.of(\"user-12345\")\nval stableId = StableId.of(userId)\nval stableId = StableId.of(deviceId)\n</code></pre> <p>The <code>StableId</code> is crucial for consistent user experience. The same ID will always hash to the same bucket, ensuring that once a user is assigned to a rollout group, they remain in that group.</p>"},{"location":"Context/#creating-context-instances","title":"Creating Context Instances","text":""},{"location":"Context/#factory-method","title":"Factory Method","text":"<p>Use the companion object factory for basic contexts:</p> <pre><code>val context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\")\n)\n</code></pre>"},{"location":"Context/#data-classes","title":"Data Classes","text":"<p>For production use, create data class implementations:</p> <pre><code>data class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n\nval context = AppContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 5, 0),\n    stableId = StableId.of(\"user-123\")\n)\n</code></pre>"},{"location":"Context/#custom-context-extensions","title":"Custom Context Extensions","text":"<p>Extend the base <code>Context</code> interface to add domain-specific targeting fields. This is one of Konditional's most powerful features, allowing you to target flags based on your business logic.</p>"},{"location":"Context/#enterprise-context","title":"Enterprise Context","text":"<p>Add organization and subscription information:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val userRole: UserRole\n) : Context\n\nenum class SubscriptionTier {\n    FREE,\n    PROFESSIONAL,\n    ENTERPRISE\n}\n\nenum class UserRole {\n    VIEWER,\n    EDITOR,\n    ADMIN,\n    OWNER\n}\n</code></pre> <p>Use custom context fields in rule extensions:</p> <pre><code>enum class EnterpriseFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"advanced_analytics\"),\n    BULK_EXPORT(\"bulk_export\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    EnterpriseFeatures.ADVANCED_ANALYTICS with {\n        default(false)\n\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Context/#experimentation-context","title":"Experimentation Context","text":"<p>Add A/B testing and experiment tracking:</p> <pre><code>data class ExperimentContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val activeExperiments: Set&lt;String&gt;,\n    val userSegment: UserSegment\n) : Context\n\nenum class UserSegment {\n    NEW_USER,\n    ACTIVE_USER,\n    POWER_USER,\n    AT_RISK\n}\n</code></pre>"},{"location":"Context/#multi-tenant-context","title":"Multi-Tenant Context","text":"<p>Support multi-tenant applications:</p> <pre><code>data class TenantContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val tenantId: String,\n    val tenantRegion: String,\n    val tenantPlan: String,\n    val featureWhitelist: Set&lt;String&gt;\n) : Context\n</code></pre>"},{"location":"Context/#context-patterns","title":"Context Patterns","text":""},{"location":"Context/#immutability","title":"Immutability","text":"<p>Context instances should be immutable. This ensures thread safety and prevents accidental modifications during evaluation:</p> <pre><code>// Good: Immutable data class\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n\n// Bad: Mutable properties\nclass MutableContext(\n    override var locale: AppLocale,  // Don't do this\n    // ...\n) : Context\n</code></pre>"},{"location":"Context/#context-factories","title":"Context Factories","text":"<p>Create factory functions for common context creation patterns:</p> <pre><code>object ContextFactory {\n    fun fromRequest(request: HttpRequest): AppContext {\n        return AppContext(\n            locale = parseLocale(request.headers[\"Accept-Language\"]),\n            platform = detectPlatform(request.headers[\"User-Agent\"]),\n            appVersion = parseVersion(request.headers[\"X-App-Version\"]),\n            stableId = StableId.of(request.cookies[\"user_id\"] ?: generateAnonymousId())\n        )\n    }\n\n    fun fromUser(user: User, device: Device): AppContext {\n        return AppContext(\n            locale = user.preferredLocale,\n            platform = device.platform,\n            appVersion = device.appVersion,\n            stableId = StableId.of(user.id)\n        )\n    }\n}\n</code></pre>"},{"location":"Context/#context-builders","title":"Context Builders","text":"<p>For complex contexts, provide builders:</p> <pre><code>class EnterpriseContextBuilder {\n    private var locale: AppLocale? = null\n    private var platform: Platform? = null\n    private var appVersion: Version? = null\n    private var stableId: StableId? = null\n    private var organizationId: String? = null\n    private var subscriptionTier: SubscriptionTier? = null\n    private var userRole: UserRole? = null\n\n    fun locale(value: AppLocale) = apply { this.locale = value }\n    fun platform(value: Platform) = apply { this.platform = value }\n    fun appVersion(value: Version) = apply { this.appVersion = value }\n    fun stableId(value: StableId) = apply { this.stableId = value }\n    fun organizationId(value: String) = apply { this.organizationId = value }\n    fun subscriptionTier(value: SubscriptionTier) = apply { this.subscriptionTier = value }\n    fun userRole(value: UserRole) = apply { this.userRole = value }\n\n    fun build(): EnterpriseContext {\n        return EnterpriseContext(\n            locale = requireNotNull(locale) { \"locale is required\" },\n            platform = requireNotNull(platform) { \"platform is required\" },\n            appVersion = requireNotNull(appVersion) { \"appVersion is required\" },\n            stableId = requireNotNull(stableId) { \"stableId is required\" },\n            organizationId = requireNotNull(organizationId) { \"organizationId is required\" },\n            subscriptionTier = requireNotNull(subscriptionTier) { \"subscriptionTier is required\" },\n            userRole = requireNotNull(userRole) { \"userRole is required\" }\n        )\n    }\n}\n</code></pre>"},{"location":"Context/#stableid-best-practices","title":"StableId Best Practices","text":"<p>The <code>stableId</code> is critical for consistent rollout behavior. Follow these guidelines:</p>"},{"location":"Context/#choose-appropriate-identifiers","title":"Choose Appropriate Identifiers","text":"<pre><code>// User-level targeting: Use user ID\nval stableId = StableId.of(userId)\n\n// Device-level targeting: Use device ID\nval stableId = StableId.of(deviceId)\n\n// Session-level targeting: Use session ID\nval stableId = StableId.of(sessionId)\n\n// Anonymous users: Generate and persist an anonymous ID\nval stableId = StableId.of(anonymousUserId)\n</code></pre>"},{"location":"Context/#stability-considerations","title":"Stability Considerations","text":"<p>The identifier should be: - Persistent: Survives application restarts - Unique: Different for each user/device/session - Consistent: Same value across requests for the same entity</p>"},{"location":"Context/#anonymous-users","title":"Anonymous Users","text":"<p>For anonymous users, generate and persist an identifier:</p> <pre><code>fun getOrCreateAnonymousId(): String {\n    val stored = localStorage.getItem(\"anonymous_id\")\n    if (stored != null) return stored\n\n    val newId = UUID.randomUUID().toString()\n    localStorage.setItem(\"anonymous_id\", newId)\n    return newId\n}\n\nval stableId = StableId.of(getOrCreateAnonymousId())\n</code></pre>"},{"location":"Context/#context-polymorphism","title":"Context Polymorphism","text":"<p>Konditional's type system supports context polymorphism through generic type parameters. Features are bound to specific context types:</p> <pre><code>// Feature requiring base Context\nval basicFeature: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n    Feature(\"basic\")\n\n// Feature requiring EnterpriseContext\nval enterpriseFeature: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, EnterpriseContext&gt; =\n    Feature(\"enterprise\")\n\n// Base context can only evaluate basic features\nval baseContext: Context = Context(...)\nbaseContext.evaluateSafe(basicFeature)  // OK\n// baseContext.evaluateSafe(enterpriseFeature)  // Compile error!\n\n// Enterprise context can evaluate both\nval enterpriseContext: EnterpriseContext = EnterpriseContext(...)\nenterpriseContext.evaluateSafe(basicFeature)  // OK (subtype of Context)\nenterpriseContext.evaluateSafe(enterpriseFeature)  // OK\n</code></pre> <p>This type safety ensures you can only evaluate flags with contexts that provide the necessary information.</p>"},{"location":"Context/#common-patterns","title":"Common Patterns","text":""},{"location":"Context/#default-context-for-testing","title":"Default Context for Testing","text":"<p>Create a default context for unit tests:</p> <pre><code>object TestContext {\n    val default = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"test-user\")\n    )\n\n    fun withPlatform(platform: Platform) = default.copy(platform = platform)\n    fun withVersion(version: Version) = default.copy(appVersion = version)\n}\n</code></pre>"},{"location":"Context/#context-middleware","title":"Context Middleware","text":"<p>Extract context from HTTP requests in a consistent way:</p> <pre><code>class ContextMiddleware : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val request = chain.request()\n        val context = buildContext(request)\n\n        // Store in thread-local or request scope\n        ContextHolder.set(context)\n\n        return chain.proceed(request)\n    }\n\n    private fun buildContext(request: Request): AppContext {\n        return AppContext(\n            locale = parseLocale(request.header(\"Accept-Language\")),\n            platform = parsePlatform(request.header(\"User-Agent\")),\n            appVersion = parseVersion(request.header(\"X-App-Version\")),\n            stableId = StableId.of(request.cookie(\"user_id\"))\n        )\n    }\n}\n</code></pre>"},{"location":"Context/#next-steps","title":"Next Steps","text":"<ul> <li>Rules: Learn how rules use context for targeting</li> <li>Overview: Back to API overview</li> <li>Architecture: Understand how context flows through evaluation</li> </ul>"},{"location":"CoreConcepts/","title":"Core Concepts: The Type-Safe Building Blocks","text":"<p>This document explains the fundamental types that make Konditional's compile-time type safety possible.</p>"},{"location":"CoreConcepts/#the-type-safety-architecture","title":"The Type Safety Architecture","text":"<p>Konditional's type safety comes from generic type parameters that flow through every component:</p> <pre><code>Feature&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt;\n           \u2193                      \u2193          \u2193\n    EncodableValue wrapper    Actual value  Context type\n</code></pre> <p>Let's understand each component and how they guarantee compile-time safety.</p>"},{"location":"CoreConcepts/#feature-your-type-safe-flag-definition","title":"Feature: Your Type-Safe Flag Definition","text":""},{"location":"CoreConcepts/#what-it-is","title":"What It Is","text":"<p>A <code>Feature</code> is your entry point for defining a flag. It's typically implemented as an enum member:</p> <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n</code></pre>"},{"location":"CoreConcepts/#type-parameters-explained","title":"Type Parameters Explained","text":"<pre><code>interface Feature&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt; {\n    val key: String\n}\n\n// Example:\n// S = BooleanEncodeable (wrapper type)\n// T = Boolean (actual value type)\n// C = Context (evaluation context type)\n</code></pre> <p>What this guarantees: - <code>DARK_MODE</code> always returns <code>Boolean</code>, never <code>String</code> or <code>Int</code> - Evaluation requires <code>Context</code>, not some other type - The compiler enforces these at every usage site</p>"},{"location":"CoreConcepts/#why-three-type-parameters","title":"Why Three Type Parameters?","text":"<p><code>S: EncodableValue&lt;T&gt;</code> - The wrapper type for serialization <pre><code>// Internal: How the value is encoded/decoded\nsealed interface EncodableValue&lt;T : Any&gt; {\n    val value: T\n    val encoding: Encoding\n}\n</code></pre></p> <p><code>T: Any</code> - The actual value type you work with <pre><code>// What you get when evaluating\nval enabled: Boolean = context.evaluate(Features.DARK_MODE)\n//            \u2191 This is T\n</code></pre></p> <p><code>C: Context</code> - The required evaluation context <pre><code>// What information evaluation needs\ninterface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n</code></pre></p>"},{"location":"CoreConcepts/#common-feature-patterns","title":"Common Feature Patterns","text":"<p>Boolean flags: <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ANALYTICS(\"analytics_enabled\")\n}\n</code></pre></p> <p>String configuration: <pre><code>enum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\"),\n    AUTH_URL(\"auth_url\")\n}\n</code></pre></p> <p>Integer limits: <pre><code>enum class Limits(override val key: String) : Conditional&lt;Int, Context&gt; {\n    MAX_RETRIES(\"max_retries\"),\n    BATCH_SIZE(\"batch_size\")\n}\n</code></pre></p> <p>Custom types: <pre><code>data class ThemeConfig(val primaryColor: String, val fontSize: Int)\n\nenum class Theme(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    APP_THEME(\"app_theme\")\n}\n</code></pre></p>"},{"location":"CoreConcepts/#encodablevalue-making-invalid-types-unrepresentable","title":"EncodableValue: Making Invalid Types Unrepresentable","text":""},{"location":"CoreConcepts/#the-problem-it-solves","title":"The Problem It Solves","text":"<p>String-based systems: Any type can be stored, leading to runtime errors <pre><code>config.set(\"timeout\", \"not-a-number\")  // \u2713 Compiles\nval timeout: Int = config.getInt(\"timeout\")  // \ud83d\udca3 Runtime error\n</code></pre></p> <p>Konditional: Only supported types can exist <pre><code>enum class Config(override val key: String) : Conditional&lt;Int, Context&gt; {\n    TIMEOUT(\"timeout\")\n}\n\nconfig {\n    Config.TIMEOUT with {\n        default(\"not-a-number\")  // \u2717 Type mismatch: Required Int, found String\n    }\n}\n</code></pre></p>"},{"location":"CoreConcepts/#supported-types","title":"Supported Types","text":"<pre><code>sealed interface EncodableValue&lt;T : Any&gt; {\n    enum class Encoding {\n        BOOLEAN,   // Boolean values\n        STRING,    // String values\n        INTEGER,   // Int values\n        DECIMAL,   // Double values\n        JSON       // Arbitrary data classes (serialized as JSON)\n    }\n}\n</code></pre> <p>Built-in encodeable types:</p> Kotlin Type EncodableValue Wrapper Encoding <code>Boolean</code> <code>BooleanEncodeable</code> <code>BOOLEAN</code> <code>String</code> <code>StringEncodeable</code> <code>STRING</code> <code>Int</code> <code>IntEncodeable</code> <code>INTEGER</code> <code>Double</code> <code>DecimalEncodeable</code> <code>DECIMAL</code> Data classes <code>JsonObjectEncodeable&lt;T&gt;</code> <code>JSON</code> Custom wrappers <code>CustomEncodeable&lt;T, P&gt;</code> Varies"},{"location":"CoreConcepts/#how-it-works","title":"How It Works","text":"<p>When you define a flag, the type parameter automatically selects the right wrapper:</p> <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")  // Compiler infers: BooleanEncodeable wrapper\n}\n\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\")  // Compiler infers: StringEncodeable wrapper\n}\n</code></pre> <p>You never interact with wrappers directly - they're internal. You just specify the value type (<code>Boolean</code>, <code>String</code>, etc.) and the compiler handles the rest.</p>"},{"location":"CoreConcepts/#custom-types-via-json","title":"Custom Types via JSON","text":"<p>For data classes, use <code>asJsonObject()</code> evidence:</p> <pre><code>data class ThemeConfig(\n    val primaryColor: String,\n    val fontSize: Int\n)\n\nenum class Theme(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    APP_THEME(\"app_theme\")\n}\n\n// Configure with type-safe values\nconfig {\n    Theme.APP_THEME with {\n        default(ThemeConfig(\"#FFFFFF\", 14))  // \u2713 Type-safe\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(ThemeConfig(\"#000000\", 16))  // \u2713 Type-safe\n    }\n}\n</code></pre>"},{"location":"CoreConcepts/#the-parse-dont-validate-principle","title":"The \"Parse, Don't Validate\" Principle","text":"<p>Invalid types cannot be represented:</p> <pre><code>// This enum won't compile:\nenum class BadConfig(override val key: String) : Conditional&lt;MyWeirdType, Context&gt; {\n    //                                                         \u2191 Error: No EncodableEvidence for MyWeirdType\n    BAD_FLAG(\"bad_flag\")\n}\n</code></pre> <p>Guarantee: If your flag compiles, its type is supported. No runtime type errors possible.</p>"},{"location":"CoreConcepts/#context-type-safe-evaluation-environment","title":"Context: Type-Safe Evaluation Environment","text":""},{"location":"CoreConcepts/#what-it-provides","title":"What It Provides","text":"<p>Context carries the information needed to evaluate flags:</p> <pre><code>interface Context {\n    val locale: AppLocale        // User's locale (e.g., EN_US, FR_FR)\n    val platform: Platform       // Platform (IOS, ANDROID, WEB, etc.)\n    val appVersion: Version      // App version (e.g., 2.1.0)\n    val stableId: StableId       // Stable user ID for rollout bucketing\n}\n</code></pre>"},{"location":"CoreConcepts/#why-context-is-type-safe","title":"Why Context Is Type-Safe","text":"<p>String-based systems: Context requirements are invisible <pre><code>// What does this flag need to know?\nval enabled = config.getBoolean(\"premium_export\")  // \u26a0\ufe0f Hidden dependencies\n</code></pre></p> <p>Konditional: Context requirements are explicit in the type <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier  // \u2190 Visible requirement\n) : Context\n\nenum class PremiumFeatures(override val key: String)\n    : Conditional&lt;Boolean, EnterpriseContext&gt; {  // \u2190 Type documents requirement\n    DATA_EXPORT(\"export_enabled\")\n}\n\n// Compiler enforces correct context\nval basicContext: Context = basicContext(...)\nbasicContext.evaluate(PremiumFeatures.DATA_EXPORT)  // \u2717 Type mismatch\n\nval enterpriseContext: EnterpriseContext = EnterpriseContext(...)\nenterpriseContext.evaluate(PremiumFeatures.DATA_EXPORT)  // \u2713 Compiles\n</code></pre></p>"},{"location":"CoreConcepts/#custom-context-extensions","title":"Custom Context Extensions","text":"<p>Extend <code>Context</code> with your business domain:</p> <pre><code>data class AppContext(\n    // Base fields (required)\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    // Custom fields\n    val userId: String,\n    val subscriptionTier: SubscriptionTier,\n    val organizationId: String?,\n    val experimentGroups: Set&lt;String&gt;\n) : Context\n\nenum class SubscriptionTier {\n    FREE, PROFESSIONAL, ENTERPRISE\n}\n</code></pre> <p>What this enables: -  Type-safe access to business fields in rules -  Compiler prevents evaluation with wrong context -  Self-documenting context requirements -  IDE auto-complete for all context fields</p>"},{"location":"CoreConcepts/#context-polymorphism","title":"Context Polymorphism","text":"<p>Different flags can require different contexts:</p> <pre><code>// Basic features use base Context\nenum class BasicFeatures(override val key: String)\n    : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// Premium features require AppContext\nenum class PremiumFeatures(override val key: String)\n    : Conditional&lt;Boolean, AppContext&gt; {\n    DATA_EXPORT(\"export_enabled\")\n}\n\n// Enterprise features require EnterpriseContext\nenum class EnterpriseFeatures(override val key: String)\n    : Conditional&lt;Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"analytics\")\n}\n\n// Usage: Type system enforces correct context\nval basic: Context = basicContext(...)\nbasic.evaluate(BasicFeatures.DARK_MODE)  // \u2713 Works\n\nval app: AppContext = AppContext(...)\napp.evaluate(BasicFeatures.DARK_MODE)     // \u2713 Works (AppContext extends Context)\napp.evaluate(PremiumFeatures.DATA_EXPORT) // \u2713 Works\n\nval enterprise: EnterpriseContext = EnterpriseContext(...)\nenterprise.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)  // \u2713 Works\n</code></pre>"},{"location":"CoreConcepts/#rule-declarative-targeting-logic","title":"Rule: Declarative Targeting Logic","text":""},{"location":"CoreConcepts/#what-it-is_1","title":"What It Is","text":"<p>A <code>Rule</code> defines when a value should be used:</p> <pre><code>config {\n    Features.DARK_MODE with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS)  // \u2190 Targeting criteria\n        }.implies(true)              // \u2190 Value when rule matches\n    }\n}\n</code></pre>"},{"location":"CoreConcepts/#structure","title":"Structure","text":"<pre><code>class Rule&lt;C : Context&gt;(\n    val rollout: Rollout,                  // Percentage rollout (0-100)\n    val note: String?,                     // Optional description\n    val baseEvaluable: BaseEvaluable&lt;C&gt;,   // Built-in targeting (platform, locale, version)\n    val extension: Evaluable&lt;C&gt;            // Custom targeting logic\n)\n</code></pre>"},{"location":"CoreConcepts/#base-targeting","title":"Base Targeting","text":"<p>Built-in targeting criteria:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)  // Platform targeting\n    locales(AppLocale.EN_US, AppLocale.EN_GB)  // Locale targeting\n    versions { min(2, 0, 0) }                  // Version targeting\n    rollout = Rollout.of(50.0)                 // 50% rollout\n    note(\"iOS/Android 50% rollout\")           // Documentation\n}.implies(true)\n</code></pre> <p>All criteria must match for the rule to match: - Platform must be in specified set - Locale must be in specified set - Version must be in specified range - Context must be in rollout bucket (if &lt; 100%)</p>"},{"location":"CoreConcepts/#custom-targeting-via-extensions","title":"Custom Targeting via Extensions","text":"<p>For business logic, use custom evaluables:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;AppContext&gt;() {\n            override fun matches(context: AppContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(true)\n</code></pre>"},{"location":"CoreConcepts/#type-safety-in-rules","title":"Type Safety in Rules","text":"<p>Value type is enforced:</p> <pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\nconfig {\n    Features.DARK_MODE with {\n        default(false)  // \u2713 Boolean\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)  // \u2713 Boolean\n\n        rule {\n            platforms(Platform.ANDROID)\n        }.implies(\"enabled\")  // \u2717 Type mismatch: Required Boolean, found String\n    }\n}\n</code></pre> <p>Context type is enforced:</p> <pre><code>enum class PremiumFeatures(override val key: String)\n    : Conditional&lt;Boolean, AppContext&gt; {\n    DATA_EXPORT(\"export_enabled\")\n}\n\nconfig {\n    PremiumFeatures.DATA_EXPORT with {\n        default(false)\n\n        rule {\n            extension {\n                object : Evaluable&lt;AppContext&gt;() {  // \u2713 Correct context type\n                    override fun matches(context: AppContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.PREMIUM\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(true)\n\n        rule {\n            extension {\n                object : Evaluable&lt;Context&gt;() {  // \u2717 Type mismatch: Required AppContext\n                    override fun matches(context: Context): Boolean = true\n                    override fun specificity(): Int = 0\n                }\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"CoreConcepts/#flagdefinition-the-internal-representation","title":"FlagDefinition: The Internal Representation","text":""},{"location":"CoreConcepts/#what-it-is_2","title":"What It Is","text":"<p><code>FlagDefinition</code> is the internal representation of a configured flag:</p> <pre><code>data class FlagDefinition&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt;(\n    val feature: Feature&lt;S, T, C&gt;,\n    val defaultValue: T,\n    val values: List&lt;ConditionalValue&lt;S, T, C&gt;&gt;,\n    val isActive: Boolean,\n    val salt: String\n)\n</code></pre> <p>You never create these directly - the builder DSL creates them for you.</p>"},{"location":"CoreConcepts/#what-it-does","title":"What It Does","text":"<ol> <li>Stores configuration: Default value and conditional values</li> <li>Evaluates flags: Matches rules against context</li> <li>Handles rollouts: Bucketing via SHA-256 hashing</li> <li>Enforces type safety: Generic type parameters flow through</li> </ol>"},{"location":"CoreConcepts/#evaluation-logic","title":"Evaluation Logic","text":"<pre><code>fun evaluate(context: C): T {\n    if (!isActive) return defaultValue\n\n    // Iterate through rules (sorted by specificity)\n    for (conditionalValue in values) {\n        if (conditionalValue.rule.matches(context) &amp;&amp;\n            isInEligibleSegment(context.stableId, rollout)) {\n            return conditionalValue.value  // \u2190 Type T guaranteed\n        }\n    }\n\n    return defaultValue  // \u2190 Type T guaranteed\n}\n</code></pre> <p>Type guarantee: <code>evaluate()</code> always returns type <code>T</code>, never null, never wrong type.</p>"},{"location":"CoreConcepts/#how-components-compose","title":"How Components Compose","text":""},{"location":"CoreConcepts/#the-type-flow","title":"The Type Flow","text":"<pre><code>// 1. Define feature with types\nenum class Features : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n//                         \u2193          \u2193        \u2193\n//                      Boolean    Boolean  Context\n\n// 2. Configure with type-safe DSL\nconfig {\n    Features.DARK_MODE with {\n        default(false)  // \u2190 Must be Boolean\n        rule { ... }.implies(true)  // \u2190 Must be Boolean\n    }\n}\n\n// 3. Internal FlagDefinition created\n//    FlagDefinition&lt;BooleanEncodeable, Boolean, Context&gt;\n\n// 4. Evaluate with type-safe return\nval result: Boolean = context.evaluate(Features.DARK_MODE)\n//          \u2191 Type guaranteed by Feature's type parameter\n</code></pre>"},{"location":"CoreConcepts/#design-principles-in-action","title":"Design Principles in Action","text":"<p>1. Type Safety First - Generic type parameters enforce constraints - Invalid types are unrepresentable - No string-based lookups</p> <p>2. Parse, Don't Validate - Configuration validated at definition time - Evaluation never fails with type errors - Results are always the expected type</p> <p>3. Composition Over Inheritance - Rules compose base + extension evaluables - Features compose key + type + context - Builders use sealed interfaces</p>"},{"location":"CoreConcepts/#summary-the-type-safety-guarantees","title":"Summary: The Type Safety Guarantees","text":"Component Type Safety Guarantee Feature Generic type parameters enforce value and context types EncodableValue Only supported types can be stored Context Context requirements explicit in type parameter Rule Value type and context type enforced in builders FlagDefinition Returns exactly the declared type, never null <p>Core Principle: If it compiles, the types are correct. No runtime type errors possible.</p>"},{"location":"CoreConcepts/#next-steps","title":"Next Steps","text":"<ul> <li>Evaluation Deep Dive - Understand rule matching and specificity</li> <li>Registry and Concurrency - Thread safety and performance</li> <li>Builders Guide - Master the DSL</li> <li>Context Guide - Design custom contexts</li> </ul>"},{"location":"ErrorPrevention/","title":"Error Prevention Reference","text":"<p>This document catalogs every class of runtime error that Konditional's type system completely eliminates. These errors are not just caught early\u2014they're impossible to write.</p>"},{"location":"ErrorPrevention/#eliminated-nullpointerexception","title":"Eliminated: NullPointerException","text":""},{"location":"ErrorPrevention/#string-based-system","title":"String-Based System","text":"<pre><code>// All getters return nullable types\nval enabled: Boolean? = config.getBoolean(\"dark_mode\")\nval endpoint: String? = config.getString(\"api_endpoint\")\nval timeout: Int? = config.getInt(\"timeout_ms\")\n\n// NPE risk at every usage site\nif (enabled) { }  // \u26a0\ufe0f Compilation warning: nullable in boolean context\n\n// Defensive code everywhere\nval safeEnabled = enabled ?: false\nval safeEndpoint = endpoint ?: \"https://default.com\"\nval safeTimeout = timeout ?: 5000\n\n// Still possible to forget\nfun processConfig() {\n    val value = config.getString(\"endpoint\")\n    httpClient.setEndpoint(value)  // \ud83d\udca3 NPE if value is null\n}\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system","title":"Type-Safe System","text":"<pre><code>// Default value REQUIRED at compile time\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\nconfig {\n    Features.DARK_MODE with {\n        default(false)  // \u2713 Compiler enforces this\n    }\n}\n\n// Evaluation returns non-null\nval enabled: Boolean = context.evaluate(Features.DARK_MODE)  // Never null\n\n// No defensive code needed\nif (enabled) { }  // \u2713 Direct usage\n\n// Impossible to forget\nval endpoint: String = context.evaluate(ApiConfig.ENDPOINT)  // Always non-null\nhttpClient.setEndpoint(endpoint)  // \u2713 Safe\n</code></pre> <p>Guarantee: <code>context.evaluate()</code> never returns null. The compiler enforces default values.</p>"},{"location":"ErrorPrevention/#eliminated-classcastexception","title":"Eliminated: ClassCastException","text":""},{"location":"ErrorPrevention/#string-based-system_1","title":"String-Based System","text":"<pre><code>// Type is in method name, not type system\nval value1 = config.getBoolean(\"timeout_ms\")  // Wrong type getter\nval value2 = config.getInt(\"dark_mode\")       // Wrong type getter\nval value3 = config.getString(\"max_retries\")  // Wrong type getter\n\n// Compiles fine, crashes at runtime\nfun configure() {\n    val timeout: Int = config.getBoolean(\"timeout_ms\") as Int  // \ud83d\udca3 ClassCastException\n}\n\n// Or silent wrong behavior\nval enabled = config.getInt(\"dark_mode\")  // Returns null, not crash\nif (enabled == 1) { }  // Silently broken\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_1","title":"Type-Safe System","text":"<pre><code>// Type is in generic parameter\nenum class Config(override val key: String) : Conditional&lt;Int, Context&gt; {\n    TIMEOUT_MS(\"timeout_ms\")  // \u2190 Int type enforced here\n}\n\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")  // \u2190 Boolean type enforced here\n}\n\n// Type mismatch is compile error\nval timeout: Boolean = context.evaluate(Config.TIMEOUT_MS)  // \u2717 Type mismatch\nval timeout: Int = context.evaluate(Config.TIMEOUT_MS)      // \u2713 Correct\n\n// Wrong flag type won't compile\nval enabled: Int = context.evaluate(Features.DARK_MODE)  // \u2717 Type mismatch\nval enabled: Boolean = context.evaluate(Features.DARK_MODE)  // \u2713 Correct\n</code></pre> <p>Guarantee: The returned value always matches the declared type. Type mismatches are compile errors.</p>"},{"location":"ErrorPrevention/#eliminated-keynotfoundexception-silent-failures","title":"Eliminated: KeyNotFoundException / Silent Failures","text":""},{"location":"ErrorPrevention/#string-based-system_2","title":"String-Based System","text":"<pre><code>// Typos compile successfully\nval enabled = config.getBoolean(\"dakr_mode\")  // \u2713 Compiles - \"dark_mode\" typo\nval endpoint = config.getString(\"api_edpoint\")  // \u2713 Compiles - \"endpoint\" typo\nval timeout = config.getInt(\"timout_ms\")  // \u2713 Compiles - \"timeout\" typo\n\n// Returns null, uses wrong default\nval enabled = config.getBoolean(\"dakr_mode\") ?: false  // Silent failure\n// User intended dark mode, gets light mode\n\n// No IDE help\nconfig.getBoolean(\"???\")  // What flags exist?\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_2","title":"Type-Safe System","text":"<pre><code>// Typos are compile errors\nval enabled = context.evaluate(Features.DAKR_MODE)  // \u2717 Unresolved reference\n\n// IDE shows all available flags\ncontext.evaluate(Features.  // Auto-complete: DARK_MODE, NEW_CHECKOUT, ...\n\n// Refactoring updates all usages\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")  // \u2190 Rename this symbol\n}\n\n// IDE rename refactoring updates every usage site automatically\n</code></pre> <p>Guarantee: Flag names must exist as enum members, or code won't compile.</p>"},{"location":"ErrorPrevention/#eliminated-wrong-context-type","title":"Eliminated: Wrong Context Type","text":""},{"location":"ErrorPrevention/#string-based-system_3","title":"String-Based System","text":"<pre><code>// Context requirements invisible\nfun canExport(config: ConfigService): Boolean {\n    return config.getBoolean(\"premium_export\") ?: false\n    // \u26a0\ufe0f How does it know user tier? Runtime surprise!\n}\n\n// Runtime error when wrong context passed\nval basicContext = mapOf(\"platform\" to \"ios\")\nval exportEnabled = evaluator.evaluate(\"premium_export\", basicContext)  // \ud83d\udca3 Missing \"tier\"\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_3","title":"Type-Safe System","text":"<pre><code>// Context requirements explicit in type parameter\nenum class PremiumFeatures(override val key: String)\n    : Conditional&lt;Boolean, AppContext&gt; {  // \u2190 Requires AppContext\n    PREMIUM_EXPORT(\"premium_export\")\n}\n\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier  // \u2190 Required field\n) : Context\n\n// Wrong context type won't compile\nval basicContext: Context = // ...\nval enabled = basicContext.evaluate(PremiumFeatures.PREMIUM_EXPORT)  // \u2717 Type mismatch\n\n// Correct context type required\nval appContext: AppContext = // ...\nval enabled = appContext.evaluate(PremiumFeatures.PREMIUM_EXPORT)  // \u2713 Compiles\n</code></pre> <p>Guarantee: Evaluation requires compatible context type, enforced at compile time.</p>"},{"location":"ErrorPrevention/#eliminated-configuration-inconsistency","title":"Eliminated: Configuration Inconsistency","text":""},{"location":"ErrorPrevention/#string-based-system_4","title":"String-Based System","text":"<pre><code>// Related config split across multiple keys\nclass ThemeManager(private val config: ConfigService) {\n    fun getTheme(): Theme {\n        val primaryColor = config.getString(\"theme_primary\") ?: \"#FFF\"\n        val secondaryColor = config.getString(\"theme_secondary\") ?: \"#000\"\n        val fontSize = config.getInt(\"theme_font_size\") ?: 14\n        val darkMode = config.getBoolean(\"theme_dark_mode\") ?: false\n\n        return Theme(primaryColor, secondaryColor, fontSize, darkMode)\n    }\n}\n\n// Problem: Inconsistent partial updates\n// Server sends:\n// { \"theme_primary\": \"#000\", \"theme_dark_mode\": true }\n// But forgets \"theme_secondary\": \"#FFF\"\n//\n// Result: Dark mode with light secondary color - visually broken\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_4","title":"Type-Safe System","text":"<pre><code>// Single atomic type for related config\ndata class ThemeConfig(\n    val primaryColor: String,\n    val secondaryColor: String,\n    val fontSize: Int,\n    val darkMode: Boolean\n)\n\nenum class Theme(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    APP_THEME(\"app_theme\")\n}\n\nconfig {\n    Theme.APP_THEME with {\n        default(\n            ThemeConfig(\"#FFFFFF\", \"#000000\", 14, false)\n        )\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\n            ThemeConfig(\"#000000\", \"#FFFFFF\", 16, true)  // All values together\n        )\n    }\n}\n\n// Evaluation returns complete, consistent theme\nval theme: ThemeConfig = context.evaluate(Theme.APP_THEME)\n// \u2713 primaryColor, secondaryColor, fontSize, darkMode always consistent\n</code></pre> <p>Guarantee: Related configuration values are updated atomically as a single unit.</p>"},{"location":"ErrorPrevention/#eliminated-validation-duplication","title":"Eliminated: Validation Duplication","text":""},{"location":"ErrorPrevention/#string-based-system_5","title":"String-Based System","text":"<pre><code>// Validation scattered across codebase\nclass PaymentService(private val config: ConfigService) {\n    fun getMaxRetries(): Int {\n        val value = config.getInt(\"max_retries\") ?: 3\n        require(value in 1..10) { \"max_retries must be 1-10\" }\n        return value\n    }\n}\n\nclass NetworkService(private val config: ConfigService) {\n    fun getMaxRetries(): Int {\n        val value = config.getInt(\"max_retries\") ?: 3\n        // \u26a0\ufe0f Forgot validation here - inconsistent!\n        return value\n    }\n}\n\nclass BackgroundWorker(private val config: ConfigService) {\n    fun getMaxRetries(): Int {\n        val value = config.getInt(\"max_retries\") ?: 3\n        require(value &gt;= 1) { \"max_retries must be positive\" }\n        // \u26a0\ufe0f Different validation rules!\n        return value\n    }\n}\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_5","title":"Type-Safe System","text":"<pre><code>// Validation once at configuration time\n@JvmInline\nvalue class Retries(val value: Int) {\n    init {\n        require(value in 1..10) { \"Retries must be 1-10\" }\n    }\n}\n\nenum class Config(override val key: String) : Conditional&lt;Retries, Context&gt; {\n    MAX_RETRIES(\"max_retries\")\n}\n\nconfig {\n    Config.MAX_RETRIES with {\n        default(Retries(3))  // \u2713 Validated at construction\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(Retries(5))  // \u2713 Validated at construction\n    }\n}\n\n// Usage: No validation needed\nval retries: Retries = context.evaluate(Config.MAX_RETRIES)\n// \u2713 Guaranteed valid by type system\n</code></pre> <p>Guarantee: Invalid values are unrepresentable in the type system. Parse once, use everywhere.</p>"},{"location":"ErrorPrevention/#eliminated-rollout-bucketing-bugs","title":"Eliminated: Rollout Bucketing Bugs","text":""},{"location":"ErrorPrevention/#string-based-system_6","title":"String-Based System","text":"<pre><code>// Manual bucketing logic\nclass RolloutManager(private val config: ConfigService) {\n    fun isEnabled(flagKey: String, userId: String): Boolean {\n        val baseEnabled = config.getBoolean(flagKey) ?: false\n        if (!baseEnabled) return false\n\n        val percentage = config.getInt(\"${flagKey}_rollout_pct\") ?: 0\n\n        // Bug: hashCode() differs across platforms\n        val hash = userId.hashCode()\n        val bucket = (hash % 100).absoluteValue\n        return bucket &lt; percentage\n    }\n}\n\n// Problems:\n// 1. hashCode() not stable across JVM restarts\n// 2. Different bucketing per flag leads to correlation\n// 3. Easy to forget absoluteValue - negative buckets\n// 4. Percentage stored separately from flag\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_6","title":"Type-Safe System","text":"<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    NEW_CHECKOUT(\"new_checkout\")\n}\n\nconfig {\n    Features.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.of(25.0)  // 25% rollout\n        }.implies(true)\n    }\n}\n\n// Usage: Automatic, deterministic bucketing\nval enabled = context.evaluate(Features.NEW_CHECKOUT)\n\n// Bucketing properties:\n// \u2713 SHA-256 based (deterministic, platform-independent)\n// \u2713 Independent buckets per flag (no correlation)\n// \u2713 Stable across sessions via context.stableId\n// \u2713 Percentage stored with flag definition\n</code></pre> <p>Guarantee: Rollouts use cryptographic hashing for deterministic, independent bucketing.</p>"},{"location":"ErrorPrevention/#eliminated-refactoring-breaks","title":"Eliminated: Refactoring Breaks","text":""},{"location":"ErrorPrevention/#string-based-system_7","title":"String-Based System","text":"<pre><code>// Flag name used in 50 places\nclass FeatureA { config.getBoolean(\"dark_mode\") }\nclass FeatureB { config.getBoolean(\"dark_mode\") }\n// ... 48 more usages\n\n// Developer renames flag\n// Changes backend config: \"dark_mode\" \u2192 \"darkMode\"\n\n// Update code:\nclass FeatureA { config.getBoolean(\"darkMode\") }  // \u2713 Updated\nclass FeatureB { config.getBoolean(\"dark_mode\") }  // \u2717 Forgot to update!\n// ... 48 more to manually update\n\n// Runtime failures in production\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_7","title":"Type-Safe System","text":"<pre><code>// Flag name as enum member\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// Used in 50 places\nclass FeatureA { context.evaluate(Features.DARK_MODE) }\nclass FeatureB { context.evaluate(Features.DARK_MODE) }\n// ... 48 more usages\n\n// Developer renames: Right-click \u2192 Rename Symbol\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"darkMode\")  // IDE updates all 50 usages automatically\n}\n\n// \u2713 All usages updated atomically\n// \u2713 Compile error if any usage missed\n</code></pre> <p>Guarantee: IDE refactoring updates all usages atomically. Missed updates = compile errors.</p>"},{"location":"ErrorPrevention/#eliminated-testing-complexity","title":"Eliminated: Testing Complexity","text":""},{"location":"ErrorPrevention/#string-based-system_8","title":"String-Based System","text":"<pre><code>// Test requires mocking config service\n@Test\nfun `test premium feature enabled`() {\n    val mockConfig = mock&lt;ConfigService&gt;()\n\n    // Mock setup for every related flag\n    whenever(mockConfig.getBoolean(\"premium_export\")).thenReturn(true)\n    whenever(mockConfig.getBoolean(\"premium_analytics\")).thenReturn(true)\n    whenever(mockConfig.getString(\"premium_tier\")).thenReturn(\"enterprise\")\n\n    val manager = FeatureManager(mockConfig)\n    assertTrue(manager.canExport())\n\n    // Verify mock interactions\n    verify(mockConfig).getBoolean(\"premium_export\")\n}\n\n// Problems:\n// - Mocking framework required\n// - String literals duplicated\n// - Setup boilerplate\n// - Mock verification noise\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_8","title":"Type-Safe System","text":"<pre><code>// Test uses simple data class\n@Test\nfun `test premium feature enabled`() {\n    val context = AppContext(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"test-user\"),\n        subscriptionTier = SubscriptionTier.ENTERPRISE\n    )\n\n    val enabled = context.evaluate(PremiumFeatures.DATA_EXPORT)\n\n    assertTrue(enabled)\n}\n\n// Reusable test factory\nfun testContext(\n    tier: SubscriptionTier = SubscriptionTier.FREE\n) = AppContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.ANDROID,\n    appVersion = Version(1, 0, 0),\n    stableId = StableId.of(\"test-user\"),\n    subscriptionTier = tier\n)\n\n@Test\nfun `test enterprise features`() {\n    val context = testContext(tier = SubscriptionTier.ENTERPRISE)\n    assertTrue(context.evaluate(PremiumFeatures.DATA_EXPORT))\n}\n</code></pre> <p>Guarantee: Tests use simple data classes, no mocking frameworks needed.</p>"},{"location":"ErrorPrevention/#eliminated-json-parsing-errors","title":"Eliminated: JSON Parsing Errors","text":""},{"location":"ErrorPrevention/#string-based-system_9","title":"String-Based System","text":"<pre><code>// Manual JSON parsing\nval json = \"\"\"{ \"dark_mode\": \"true\" }\"\"\"  // \u26a0\ufe0f String instead of boolean\n\nval config = mutableMapOf&lt;String, Any&gt;()\nval jsonObj = JSONObject(json)\njsonObj.keys().forEach { key -&gt;\n    config[key] = jsonObj.get(key)\n}\n\n// Runtime crash\nval enabled = config[\"dark_mode\"] as Boolean  // \ud83d\udca3 ClassCastException: String cannot be cast to Boolean\n\n// Or silent wrong behavior\nval enabled = config[\"dark_mode\"] as? Boolean ?: false  // Returns false for \"true\"\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_9","title":"Type-Safe System","text":"<pre><code>// Type-safe deserialization with error handling\nval json = \"\"\"\n{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"value_type\": \"boolean\",\n      \"default\": \"true\"\n    }\n  ]\n}\n\"\"\"\n\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        FlagRegistry.load(result.value)\n        // \u2713 Type-safe configuration loaded\n    }\n    is ParseResult.Failure -&gt; {\n        logger.error(\"Parse error: ${result.error}\")\n        // \u26a0\ufe0f Error caught before applying bad config\n    }\n}\n</code></pre> <p>Guarantee: Invalid JSON is rejected before application, not at evaluation time.</p>"},{"location":"ErrorPrevention/#eliminated-hidden-dependencies","title":"Eliminated: Hidden Dependencies","text":""},{"location":"ErrorPrevention/#string-based-system_10","title":"String-Based System","text":"<pre><code>// What context does this flag need?\nfun canAccessPremiumFeature(userId: String): Boolean {\n    return config.getBoolean(\"premium_feature\") ?: false\n    // \u26a0\ufe0f How does backend know user tier?\n    // \u26a0\ufe0f What other context is needed?\n    // \u26a0\ufe0f Documentation only source of truth\n}\n\n// Runtime surprise\nval canAccess = canAccessPremiumFeature(\"user-123\")\n// \ud83d\udca3 Backend evaluation fails: Missing required field \"subscription_tier\"\n</code></pre>"},{"location":"ErrorPrevention/#type-safe-system_10","title":"Type-Safe System","text":"<pre><code>// Context requirements explicit in types\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier  // \u2190 Visible requirement\n) : Context\n\nenum class PremiumFeatures(override val key: String)\n    : Conditional&lt;Boolean, AppContext&gt; {  // \u2190 Type documents requirement\n    ADVANCED_ANALYTICS(\"premium_feature\")\n}\n\n// Compiler enforces requirements\nfun canAccessPremiumFeature(context: AppContext): Boolean {\n    return context.evaluate(PremiumFeatures.ADVANCED_ANALYTICS)\n    // \u2713 All required context fields present\n}\n\n// IDE shows type signature\nval context: AppContext = buildAppContext(...)  // \u2713 Explicit construction\nval canAccess = canAccessPremiumFeature(context)\n</code></pre> <p>Guarantee: Context requirements are self-documenting via type system.</p>"},{"location":"ErrorPrevention/#summary-error-classes-eliminated","title":"Summary: Error Classes Eliminated","text":"Error Class String-Based Risk Type-Safe Guarantee NullPointerException Nullable returns, forgotten null checks Non-null returns, compiler-enforced defaults ClassCastException Wrong type getter used Generic type parameter enforced KeyNotFoundException Typos in flag names Enum member or compile error Wrong Context Context requirements invisible Context type parameter enforced Inconsistent Config Partial updates of related values Atomic updates of compound types Validation Errors Validation scattered/duplicated Type invariants enforced once Rollout Bugs Manual bucketing, platform differences SHA-256 deterministic bucketing Refactoring Breaks String search-replace, manual updates IDE symbol refactoring Test Complexity Mock framework required Simple data class construction Parse Errors Runtime crashes on bad JSON Parse errors before application Hidden Dependencies Documentation only Type signatures self-document"},{"location":"ErrorPrevention/#what-you-can-now-guarantee","title":"What You Can Now Guarantee","text":"<p>With Konditional, you can make these statements with 100% confidence:</p> <ol> <li>\"This flag evaluation will never return null\"</li> <li> <p>Default value required at compile time</p> </li> <li> <p>\"This flag's type matches my variable\"</p> </li> <li> <p>Generic type parameter enforced</p> </li> <li> <p>\"This flag name exists in our system\"</p> </li> <li> <p>Enum member or code won't compile</p> </li> <li> <p>\"This evaluation has the correct context\"</p> </li> <li> <p>Context type parameter enforced</p> </li> <li> <p>\"Refactoring updated all usages\"</p> </li> <li> <p>IDE symbol rename guarantees it</p> </li> <li> <p>\"Related config values are consistent\"</p> </li> <li> <p>Atomic compound types</p> </li> <li> <p>\"Rollout bucketing is deterministic\"</p> </li> <li> <p>SHA-256 based with stable IDs</p> </li> <li> <p>\"Invalid config won't reach production\"</p> </li> <li> <p>Parse errors caught before application</p> </li> <li> <p>\"Tests don't need mocking frameworks\"</p> </li> <li> <p>Simple context data classes</p> </li> <li> <p>\"Context requirements are documented\"</p> <ul> <li>Type signatures are self-documenting</li> </ul> </li> </ol>"},{"location":"ErrorPrevention/#the-core-principle","title":"The Core Principle","text":"<p>\"Parse, Don't Validate\"</p> <p>Invalid states are unrepresentable in the type system.</p> <p>If it compiles, it works.</p> <p>This isn't just \"fewer errors\" \u2014 entire error classes cannot exist in type-safe code.</p>"},{"location":"ErrorPrevention/#next-steps","title":"Next Steps","text":"<ul> <li>Migration Guide - Eliminate these errors from your codebase</li> <li>Why Type Safety - Understand the value proposition</li> <li>Quick Start - See type safety in action</li> </ul> <p>The Result: Ship faster with confidence. Let the compiler catch errors, not your users.</p>"},{"location":"Evaluation/","title":"Evaluation: Deterministic Flag Resolution","text":"<p>This document explains how Konditional evaluates flags, including rule matching, specificity ordering, and rollout bucketing.</p>"},{"location":"Evaluation/#the-evaluation-flow","title":"The Evaluation Flow","text":""},{"location":"Evaluation/#high-level-overview","title":"High-Level Overview","text":"<pre><code>context.evaluate(Features.DARK_MODE)\n    \u2193\nRegistry lookup: Get FlagDefinition for DARK_MODE\n    \u2193\nIterate through rules (sorted by specificity DESC)\n    \u2193\nFor each rule:\n    - Does rule match context? (platform, locale, version, custom logic)\n    - Is context in rollout bucket? (SHA-256 bucketing)\n    \u2193\nReturn first matching value, or default if no match\n</code></pre>"},{"location":"Evaluation/#complete-flow-diagram","title":"Complete Flow Diagram","text":"<pre><code>Context.evaluate(feature)\n  |\n  +-&gt; FlagRegistry.featureFlag(feature)\n  |     |\n  |     +-&gt; Returns FlagDefinition&lt;S, T, C&gt;?\n  |\n  +-&gt; If null: Return EvaluationResult.NotFound\n  |\n  +-&gt; FlagDefinition.evaluate(context)\n        |\n        +-&gt; Check isActive\n        |     |\n        |     +-&gt; If false: Return defaultValue\n        |\n        +-&gt; Iterate rules (sorted by specificity DESC)\n        |     |\n        |     +-&gt; For each ConditionalValue:\n        |           |\n        |           +-&gt; Rule.matches(context)?\n        |           |     |\n        |           |     +-&gt; BaseEvaluable.matches(context)?\n        |           |     |     |\n        |           |     |     +-&gt; Platform match?\n        |           |     |     +-&gt; Locale match?\n        |           |     |     +-&gt; Version match?\n        |           |     |\n        |           |     +-&gt; Extension.matches(context)?\n        |           |           |\n        |           |           +-&gt; Custom business logic\n        |           |\n        |           +-&gt; isInEligibleSegment(context, rollout)?\n        |           |     |\n        |           |     +-&gt; SHA-256 bucketing\n        |           |\n        |           +-&gt; If both true: RETURN value\n        |\n        +-&gt; No match: Return defaultValue\n</code></pre>"},{"location":"Evaluation/#rule-matching","title":"Rule Matching","text":""},{"location":"Evaluation/#the-and-logic","title":"The AND Logic","text":"<p>For a rule to match, all criteria must be true:</p> <pre><code>config {\n    Features.PREMIUM_EXPORT with {\n        default(false)\n\n        rule {\n            platforms(Platform.IOS)           // Must be iOS\n            versions { min(2, 0, 0) }         // AND version &gt;= 2.0.0\n            rollout = Rollout.of(50.0)        // AND in 50% bucket\n        }.implies(true)\n    }\n}\n\n// Match requires ALL three:\nval context = AppContext(\n    platform = Platform.IOS,        // \u2713 Match\n    appVersion = Version(2, 1, 0),  // \u2713 Match (&gt;= 2.0.0)\n    stableId = StableId.of(\"user-123\")  // SHA-256 bucket check\n)\n\n// If stableId hashes into top 50% bucket:\ncontext.evaluate(Features.PREMIUM_EXPORT)  // Returns: true\n\n// If any condition fails:\nval androidContext = context.copy(platform = Platform.ANDROID)\nandroidContext.evaluate(Features.PREMIUM_EXPORT)  // Returns: false (default)\n</code></pre>"},{"location":"Evaluation/#platform-matching","title":"Platform Matching","text":"<pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n}.implies(value)\n\n// Match if:\ncontext.platform in setOf(Platform.IOS, Platform.ANDROID)\n\n// If platforms() not called:\n// Matches ALL platforms (no constraint)\n</code></pre>"},{"location":"Evaluation/#locale-matching","title":"Locale Matching","text":"<pre><code>rule {\n    locales(AppLocale.EN_US, AppLocale.EN_GB)\n}.implies(value)\n\n// Match if:\ncontext.locale in setOf(AppLocale.EN_US, AppLocale.EN_GB)\n\n// If locales() not called:\n// Matches ALL locales (no constraint)\n</code></pre>"},{"location":"Evaluation/#version-matching","title":"Version Matching","text":"<pre><code>rule {\n    versions { min(2, 0, 0) }           // &gt;= 2.0.0\n}.implies(value)\n\nrule {\n    versions { max(3, 0, 0) }           // &lt; 3.0.0\n}.implies(value)\n\nrule {\n    versions {\n        min(2, 0, 0)\n        max(3, 0, 0)\n    }                                    // &gt;= 2.0.0 AND &lt; 3.0.0\n}.implies(value)\n\n// Match if:\ncontext.appVersion in versionRange\n\n// If versions() not called:\n// Matches ALL versions (no constraint)\n</code></pre>"},{"location":"Evaluation/#custom-extension-matching","title":"Custom Extension Matching","text":"<pre><code>rule {\n    extension {\n        object : Evaluable&lt;AppContext&gt;() {\n            override fun matches(context: AppContext): Boolean {\n                // Custom business logic\n                return context.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                       context.experimentGroups.contains(\"new-ui\")\n            }\n\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(value)\n\n// Match if:\nextension.matches(context) == true\n</code></pre>"},{"location":"Evaluation/#combining-base-and-extension","title":"Combining Base and Extension","text":"<pre><code>rule {\n    // Base targeting\n    platforms(Platform.IOS)\n    versions { min(2, 0, 0) }\n\n    // Custom extension\n    extension {\n        object : Evaluable&lt;AppContext&gt;() {\n            override fun matches(context: AppContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(value)\n\n// Match requires:\n// context.platform == Platform.IOS\n// AND context.appVersion &gt;= Version(2, 0, 0)\n// AND context.subscriptionTier == SubscriptionTier.ENTERPRISE\n</code></pre>"},{"location":"Evaluation/#specificity-ordering","title":"Specificity Ordering","text":""},{"location":"Evaluation/#why-specificity-matters","title":"Why Specificity Matters","text":"<p>When multiple rules match, the most specific rule wins:</p> <pre><code>config {\n    Features.THEME with {\n        default(\"light\")\n\n        // Specificity = 1 (platform only)\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"dark-ios\")\n\n        // Specificity = 2 (platform + locale)\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n        }.implies(\"dark-us-ios\")\n    }\n}\n\n// Context: iOS + EN_US\nval context = basicContext(\n    platform = Platform.IOS,\n    locale = AppLocale.EN_US\n)\n\n// Both rules match, but specificity = 2 wins\ncontext.evaluate(Features.THEME)  // Returns: \"dark-us-ios\"\n</code></pre>"},{"location":"Evaluation/#specificity-calculation","title":"Specificity Calculation","text":"<pre><code>Rule specificity = baseEvaluable.specificity() + extension.specificity()\n\nBaseEvaluable specificity:\n  (platforms not empty ? 1 : 0) +\n  (locales not empty ? 1 : 0) +\n  (version has bounds ? 1 : 0)\n\nExtension specificity:\n  Custom evaluable's specificity() method (default: 0)\n\nTotal range: 0 to 4+ (base 0-3, extension 0+)\n</code></pre>"},{"location":"Evaluation/#examples","title":"Examples","text":"<pre><code>// Specificity = 0 (no constraints)\nrule {\n    // No criteria\n}.implies(\"default\")\n\n// Specificity = 1 (platform)\nrule {\n    platforms(Platform.IOS)\n}.implies(\"ios\")\n\n// Specificity = 2 (platform + locale)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n}.implies(\"ios-us\")\n\n// Specificity = 3 (platform + locale + version)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n}.implies(\"ios-us-v2\")\n\n// Specificity = 4 (base 3 + extension 1)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n    extension {\n        object : Evaluable&lt;AppContext&gt;() {\n            override fun matches(context: AppContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(\"ios-us-v2-enterprise\")\n</code></pre>"},{"location":"Evaluation/#tie-breaking","title":"Tie-Breaking","text":"<p>If two rules have the same specificity, note text is used for deterministic ordering:</p> <pre><code>config {\n    Features.THEME with {\n        default(\"light\")\n\n        // Both have specificity = 1\n        rule {\n            platforms(Platform.IOS)\n            note(\"iOS dark theme\")  // \u2190 Comes first alphabetically\n        }.implies(\"dark-ios\")\n\n        rule {\n            locales(AppLocale.EN_US)\n            note(\"US light theme\")  // \u2190 Comes second alphabetically\n        }.implies(\"light-us\")\n    }\n}\n\n// If both match, \"iOS dark theme\" wins (alphabetically first)\n</code></pre> <p>Best practice: Use unique, descriptive notes to ensure deterministic ordering.</p>"},{"location":"Evaluation/#evaluation-order","title":"Evaluation Order","text":"<p>Rules are sorted once at configuration time:</p> <pre><code>// Configuration time:\nvalues.sortedWith(\n    compareByDescending&lt;ConditionalValue&lt;S, T, C&gt;&gt; { it.rule.specificity() }\n        .thenBy { it.rule.note ?: \"\" }\n)\n\n// Evaluation time:\n// Iterate through pre-sorted list\n// Return first match\n</code></pre> <p>Performance: O(n) where n = number of rules (typically &lt; 10)</p>"},{"location":"Evaluation/#rollout-bucketing","title":"Rollout Bucketing","text":""},{"location":"Evaluation/#the-bucketing-algorithm","title":"The Bucketing Algorithm","text":"<p>Konditional uses SHA-256 hashing for deterministic bucketing:</p> <pre><code>fun isInEligibleSegment(\n    flagKey: String,\n    stableId: StableId,\n    salt: String,\n    rollout: Rollout\n): Boolean {\n    if (rollout &lt;= 0.0) return false\n    if (rollout &gt;= 100.0) return true\n\n    val bucket = stableBucket(flagKey, stableId, salt)\n    return bucket &lt; (rollout.value * 100).toInt()\n}\n\nfun stableBucket(\n    flagKey: String,\n    stableId: StableId,\n    salt: String\n): Int {\n    val hash = SHA256(\"$salt:$flagKey:${stableId.id}\")\n    val first4Bytes = hash.take(4).toInt()\n    return first4Bytes % 10_000  // Range: 0-9999 (0.01% granularity)\n}\n</code></pre>"},{"location":"Evaluation/#bucketing-properties","title":"Bucketing Properties","text":"<p>1. Deterministic <pre><code>// Same inputs always produce same bucket\nval context = basicContext(stableId = StableId.of(\"user-123\"))\n\ncontext.evaluate(Features.NEW_CHECKOUT)  // Result: true\ncontext.evaluate(Features.NEW_CHECKOUT)  // Result: true (always)\n</code></pre></p> <p>2. Independent Per Flag <pre><code>// Flag key is part of hash input\n// Each flag has its own bucketing space\nSHA256(\"salt:feature_a:user-123\")  // Bucket for feature A\nSHA256(\"salt:feature_b:user-123\")  // Bucket for feature B (independent!)\n\n// User in 50% rollout for feature A != user in 50% rollout for feature B\n</code></pre></p> <p>3. Platform-Stable <pre><code>// SHA-256 is platform-independent\n// Same user gets same bucket on JVM, Android, iOS, web\nval jvmBucket = stableBucket(\"flag\", StableId.of(\"user-123\"), \"salt\")\nval androidBucket = stableBucket(\"flag\", StableId.of(\"user-123\"), \"salt\")\n// jvmBucket == androidBucket (guaranteed)\n</code></pre></p> <p>4. Fine-Grained <pre><code>// 0-9999 range = 0.01% granularity\nrollout = Rollout.of(0.5)   // 0.5% rollout (50 out of 10,000)\nrollout = Rollout.of(25.0)  // 25% rollout (2,500 out of 10,000)\nrollout = Rollout.of(99.99) // 99.99% rollout (9,999 out of 10,000)\n</code></pre></p> <p>5. Salt-Based Redistribution <pre><code>// Changing salt redistributes buckets\nconfig {\n    Features.NEW_CHECKOUT with {\n        default(false)\n        salt(\"v1\")  // Salt version\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n\n// If rollout goes wrong, change salt to redistribute\nconfig {\n    Features.NEW_CHECKOUT with {\n        default(false)\n        salt(\"v2\")  // \u2190 New salt = new bucket assignments\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n</code></pre></p>"},{"location":"Evaluation/#rollout-guarantees","title":"Rollout Guarantees","text":"Property String-Based Approach Konditional Deterministic hashCode() varies by platform/restart SHA-256 always same Independent Same hash for all flags = correlation Separate hash per flag Stable Changes across sessions Same via stableId Fine-grained Usually % only 0.01% granularity Redistributable Hard to change Change salt"},{"location":"Evaluation/#why-this-prevents-errors","title":"Why This Prevents Errors","text":""},{"location":"Evaluation/#string-based-evaluation","title":"String-Based Evaluation","text":"<pre><code>// Runtime errors possible at every step\nval definition = config.getFlag(\"dark_mode\")  // Could be null\nval value = definition?.evaluate(context)     // Could be null\nval enabled: Boolean = value as Boolean       // Could throw ClassCastException\n\n// Wrong context type: Runtime error\nval wrongContext = BasicContext(...)\nwrongContext.evaluate(\"enterprise_feature\")  // \ud83d\udca3 Missing required fields\n</code></pre>"},{"location":"Evaluation/#type-safe-evaluation","title":"Type-Safe Evaluation","text":"<pre><code>// Type safety at every step\nval enabled: Boolean = context.evaluate(Features.DARK_MODE)\n//          \u2191 Non-null                  \u2191 Enum member     \u2191 Context type enforced\n\n// Wrong context type: Compile error\nval basicContext: Context = basicContext(...)\nbasicContext.evaluate(EnterpriseFeatures.ANALYTICS)  // \u2717 Type mismatch\n</code></pre>"},{"location":"Evaluation/#evaluation-guarantees","title":"Evaluation Guarantees","text":"Guarantee How Achieved Non-null result Default value required at compile time Correct type Generic type parameter enforced Correct context Context type parameter enforced Deterministic SHA-256 bucketing, sorted rules Thread-safe Immutable data structures"},{"location":"Evaluation/#evaluation-performance","title":"Evaluation Performance","text":""},{"location":"Evaluation/#lookup-o1","title":"Lookup: O(1)","text":"<pre><code>// HashMap lookup by feature key\nval definition = registry.featureFlag(Features.DARK_MODE)\n// Time: O(1) average case\n</code></pre>"},{"location":"Evaluation/#matching-on","title":"Matching: O(n)","text":"<pre><code>// Iterate through rules (sorted by specificity)\nfor (conditionalValue in sortedValues) {\n    if (conditionalValue.rule.matches(context)) {\n        return conditionalValue.value\n    }\n}\n// Time: O(n) where n = number of rules\n// Typical: n &lt; 10, so effectively constant\n</code></pre>"},{"location":"Evaluation/#bucketing-o1","title":"Bucketing: O(1)","text":"<pre><code>// SHA-256 hash computation\nval bucket = stableBucket(flagKey, stableId, salt)\n// Time: O(1) for fixed-length input\n</code></pre>"},{"location":"Evaluation/#total-o1-on-o1-on","title":"Total: O(1) + O(n) + O(1) = O(n)","text":"<p>In practice: Near-constant time for typical flag configurations (&lt; 10 rules).</p>"},{"location":"Evaluation/#memory-zero-per-request-allocation","title":"Memory: Zero Per-Request Allocation","text":"<pre><code>// All data structures immutable and pre-allocated\nval definition = registry.featureFlag(feature)  // No allocation\nval result = definition.evaluate(context)       // No allocation\n</code></pre> <p>Performance characteristics: -  No locks (lock-free reads) -  No allocations (immutable snapshots) -  Predictable latency (deterministic algorithm) -  Cache-friendly (sorted data, sequential access)</p>"},{"location":"Evaluation/#testing-evaluation","title":"Testing Evaluation","text":""},{"location":"Evaluation/#testing-specificity","title":"Testing Specificity","text":"<pre><code>@Test\nfun `most specific rule wins`() {\n    val registry = FlagRegistry.create()\n\n    config(registry) {\n        Features.THEME with {\n            default(\"light\")\n\n            rule {\n                platforms(Platform.IOS)\n            }.implies(\"dark-ios\")\n\n            rule {\n                platforms(Platform.IOS)\n                locales(AppLocale.EN_US)\n            }.implies(\"dark-us-ios\")\n        }\n    }\n\n    val context = basicContext(\n        platform = Platform.IOS,\n        locale = AppLocale.EN_US\n    )\n\n    val result = context.evaluate(Features.THEME, registry)\n\n    assertEquals(\"dark-us-ios\", result)  // Most specific wins\n}\n</code></pre>"},{"location":"Evaluation/#testing-rollout-bucketing","title":"Testing Rollout Bucketing","text":"<pre><code>@Test\nfun `rollout bucketing is deterministic`() {\n    val registry = FlagRegistry.create()\n\n    config(registry) {\n        Features.NEW_CHECKOUT with {\n            default(false)\n            rule {\n                rollout = Rollout.of(50.0)  // 50% rollout\n            }.implies(true)\n        }\n    }\n\n    val context = basicContext(stableId = StableId.of(\"user-123\"))\n\n    // Evaluate multiple times\n    val result1 = context.evaluate(Features.NEW_CHECKOUT, registry)\n    val result2 = context.evaluate(Features.NEW_CHECKOUT, registry)\n    val result3 = context.evaluate(Features.NEW_CHECKOUT, registry)\n\n    // Same result every time\n    assertEquals(result1, result2)\n    assertEquals(result2, result3)\n}\n\n@Test\nfun `rollout percentage approximate`() {\n    val registry = FlagRegistry.create()\n\n    config(registry) {\n        Features.NEW_CHECKOUT with {\n            default(false)\n            rule {\n                rollout = Rollout.of(50.0)\n            }.implies(true)\n        }\n    }\n\n    // Test with 1000 different users\n    val enabled = (1..1000).count { i -&gt;\n        val context = basicContext(stableId = StableId.of(\"user-$i\"))\n        context.evaluate(Features.NEW_CHECKOUT, registry)\n    }\n\n    // Should be approximately 500 (50%)\n    assertTrue(enabled in 450..550)  // Allow 10% variance\n}\n</code></pre>"},{"location":"Evaluation/#summary-evaluation-guarantees","title":"Summary: Evaluation Guarantees","text":"Aspect Guarantee Type safety Return type matches flag definition, enforced at compile time Determinism Same inputs always produce same output Specificity Most specific matching rule always wins Bucketing SHA-256 ensures independent, stable buckets per flag Performance O(n) where n = rules per flag (typically &lt; 10) Thread safety Lock-free reads, immutable data Null safety Never returns null, default value guaranteed <p>Core Principle: Evaluation is deterministic, type-safe, and performant.</p>"},{"location":"Evaluation/#next-steps","title":"Next Steps","text":"<ul> <li>Registry and Concurrency - Thread safety and atomic updates</li> <li>Core Concepts - Back to type system fundamentals</li> <li>Rules Guide - Advanced rule patterns</li> <li>Context Guide - Design evaluation contexts</li> </ul>"},{"location":"Flags/","title":"Feature Registration","text":"<p>Features are the entry point for defining and evaluating feature flags in Konditional. This document covers feature creation patterns, registration strategies, and organizational best practices.</p>"},{"location":"Flags/#feature-interface","title":"Feature Interface","text":"<p>The <code>Feature</code> interface represents a configurable flag with a specific value type and evaluation context:</p> <pre><code>interface Feature&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt; {\n    val registry: FlagRegistry\n    val key: String\n\n    fun update(definition: FlagDefinition&lt;S, T, C&gt;)\n}\n</code></pre>"},{"location":"Flags/#type-parameters","title":"Type Parameters","text":"<ul> <li>S: The <code>EncodableValue</code> type wrapping the actual value</li> <li>T: The actual value type (Boolean, String, custom types, etc.)</li> <li>C: The context type used for evaluation</li> </ul>"},{"location":"Flags/#creating-features","title":"Creating Features","text":""},{"location":"Flags/#direct-creation","title":"Direct Creation","text":"<p>Create features directly using the factory function:</p> <pre><code>val DARK_MODE: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n    Feature(\"dark_mode\")\n\nval API_URL: Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; =\n    Feature(\"api_url\")\n</code></pre>"},{"location":"Flags/#specialized-factory-methods","title":"Specialized Factory Methods","text":"<p>Use factory methods for specific value types:</p> <pre><code>// JSON Object features (complex data classes)\nval API_CONFIG: Feature.OfJsonObject&lt;ApiConfig, Context&gt; =\n    Feature.jsonObject(\"api_config\")\n\n// Custom wrapper features (domain types)\nval CREATED_AT: Feature.OfCustom&lt;DateTime, String, Context&gt; =\n    Feature.custom(\"created_at\")\n</code></pre>"},{"location":"Flags/#organizational-patterns","title":"Organizational Patterns","text":""},{"location":"Flags/#enum-pattern-recommended","title":"Enum Pattern (Recommended)","text":"<p>Organize features as enum members for type safety and discoverability:</p> <pre><code>enum class AppFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ADVANCED_SEARCH(\"advanced_search\"),\n    ANALYTICS_ENABLED(\"analytics_enabled\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre> <p>Benefits: - IDE auto-completion - Compile-time existence checking - Easy to find all features - Refactoring support</p> <p>Usage:</p> <pre><code>// Configure\nconfig {\n    AppFeatures.DARK_MODE with {\n        default(false)\n    }\n}\n\n// Evaluate\nval enabled = context.evaluateSafe(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"Flags/#object-pattern","title":"Object Pattern","text":"<p>For features with different value types, use object declarations:</p> <pre><code>object Features {\n    val DARK_MODE: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n        Feature(\"dark_mode\")\n\n    val API_ENDPOINT: Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; =\n        Feature(\"api_endpoint\")\n\n    val MAX_RETRIES: Feature&lt;EncodableValue.IntEncodeable, Int, Context&gt; =\n        Feature(\"max_retries\")\n\n    val THEME_CONFIG: Feature.OfJsonObject&lt;ThemeConfig, Context&gt; =\n        Feature.jsonObject(\"theme_config\")\n}\n</code></pre>"},{"location":"Flags/#grouped-by-domain","title":"Grouped by Domain","text":"<p>Organize features by functional area:</p> <pre><code>// UI Features\nenum class UIFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    DARK_MODE(\"ui_dark_mode\"),\n    ANIMATIONS_ENABLED(\"ui_animations\"),\n    COMPACT_VIEW(\"ui_compact_view\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// API Features\nenum class ApiFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; {\n    ENDPOINT(\"api_endpoint\"),\n    VERSION(\"api_version\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// Experimental Features\nenum class ExperimentalFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    NEW_ALGORITHM(\"exp_new_algorithm\"),\n    ML_PREDICTIONS(\"exp_ml_predictions\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"Flags/#value-type-patterns","title":"Value Type Patterns","text":""},{"location":"Flags/#boolean-features","title":"Boolean Features","text":"<p>The most common feature type for on/off toggles:</p> <pre><code>enum class FeatureToggles(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    NEW_UI(\"new_ui\"),\n    BETA_FEATURES(\"beta_features\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    FeatureToggles.NEW_UI with {\n        default(false)\n        rule { platforms(Platform.WEB) }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Flags/#string-features","title":"String Features","text":"<p>For configuration values and endpoints:</p> <pre><code>enum class StringConfig(\n    override val key: String\n) : Feature&lt;EncodableValue.StringEncodeable, String, Context&gt; {\n    API_ENDPOINT(\"api_endpoint\"),\n    LOG_LEVEL(\"log_level\"),\n    THEME_NAME(\"theme_name\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    StringConfig.API_ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n        rule { platforms(Platform.WEB) }.implies(\"https://api.staging.example.com\")\n    }\n}\n</code></pre>"},{"location":"Flags/#numeric-features","title":"Numeric Features","text":"<p>For thresholds, limits, and numeric configuration:</p> <pre><code>enum class NumericConfig(\n    override val key: String\n) : Feature&lt;EncodableValue.IntEncodeable, Int, Context&gt; {\n    MAX_RETRIES(\"max_retries\"),\n    TIMEOUT_SECONDS(\"timeout_seconds\"),\n    BATCH_SIZE(\"batch_size\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\nconfig {\n    NumericConfig.MAX_RETRIES with {\n        default(3)\n        rule { platforms(Platform.ANDROID) }.implies(5)\n    }\n}\n</code></pre>"},{"location":"Flags/#complex-object-features","title":"Complex Object Features","text":"<p>For structured configuration:</p> <pre><code>data class ApiConfig(\n    val baseUrl: String,\n    val timeout: Int,\n    val retryEnabled: Boolean\n)\n\nobject ComplexFeatures {\n    val API_CONFIG: Feature.OfJsonObject&lt;ApiConfig, Context&gt; =\n        Feature.jsonObject(\"api_config\")\n}\n\nconfig {\n    ComplexFeatures.API_CONFIG with {\n        default(ApiConfig(\n            baseUrl = \"https://api.prod.example.com\",\n            timeout = 30,\n            retryEnabled = true\n        ))\n\n        rule {\n            platforms(Platform.WEB)\n        }.implies(ApiConfig(\n            baseUrl = \"https://api.staging.example.com\",\n            timeout = 60,\n            retryEnabled = false\n        ))\n    }\n}\n</code></pre>"},{"location":"Flags/#custom-wrapper-types","title":"Custom Wrapper Types","text":"<p>For domain-specific types that encode to primitives:</p> <pre><code>data class ApiUrl(val value: String)\ndata class Timeout(val milliseconds: Long)\n\nobject CustomFeatures {\n    val API_URL: Feature.OfCustom&lt;ApiUrl, String, Context&gt; =\n        Feature.custom(\"api_url\")\n\n    val REQUEST_TIMEOUT: Feature.OfCustom&lt;Timeout, Double, Context&gt; =\n        Feature.custom(\"request_timeout\")\n}\n\nconfig {\n    CustomFeatures.API_URL with {\n        default(\n            ApiUrl(\"https://prod.example.com\").asCustomString()\n                .encoder { it.value }\n                .decoder { ApiUrl(it) }\n        )\n    }\n\n    CustomFeatures.REQUEST_TIMEOUT with {\n        default(\n            Timeout(30000).asCustomDouble()\n                .encoder { it.milliseconds.toDouble() }\n                .decoder { Timeout(it.toLong()) }\n        )\n    }\n}\n</code></pre>"},{"location":"Flags/#custom-context-features","title":"Custom Context Features","text":"<p>Features can require specific context types:</p> <pre><code>enum class EnterpriseFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"enterprise_advanced_analytics\"),\n    BULK_EXPORT(\"enterprise_bulk_export\"),\n    CUSTOM_BRANDING(\"enterprise_custom_branding\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// These features can only be evaluated with EnterpriseContext\nval enterpriseContext: EnterpriseContext = // ...\nenterpriseContext.evaluateSafe(EnterpriseFeatures.ADVANCED_ANALYTICS)  // OK\n\nval basicContext: Context = // ...\n// basicContext.evaluateSafe(EnterpriseFeatures.ADVANCED_ANALYTICS)  // Compile error!\n</code></pre>"},{"location":"Flags/#registry-management","title":"Registry Management","text":""},{"location":"Flags/#singleton-registry-default","title":"Singleton Registry (Default)","text":"<p>By default, features use the singleton registry:</p> <pre><code>enum class MyFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    FEATURE_A(\"feature_a\");\n\n    override val registry: FlagRegistry = FlagRegistry  // Singleton\n}\n</code></pre>"},{"location":"Flags/#custom-registry","title":"Custom Registry","text":"<p>Use custom registries for isolation (testing, multi-tenancy):</p> <pre><code>enum class TestFeatures(\n    override val key: String,\n    override val registry: FlagRegistry\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    ;  // Empty enum body\n\n    companion object {\n        private val testRegistry = FlagRegistry.create()\n\n        val FEATURE_A = TestFeature(\"feature_a\", testRegistry)\n    }\n\n    private data class TestFeature(\n        override val key: String,\n        override val registry: FlagRegistry\n    ) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;\n}\n\n// Configure with custom registry\nconfig(registry = testRegistry) {\n    // ... configurations\n}\n</code></pre>"},{"location":"Flags/#feature-naming-conventions","title":"Feature Naming Conventions","text":""},{"location":"Flags/#key-naming","title":"Key Naming","text":"<p>Use consistent, descriptive keys:</p> <pre><code>// Good: Clear, namespaced keys\nenum class Features(override val key: String) : Feature&lt;...&gt; {\n    NEW_CHECKOUT(\"checkout_v2\"),\n    DARK_MODE(\"ui_dark_mode\"),\n    ML_RECOMMENDATIONS(\"ml_recommendations_enabled\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// Avoid: Ambiguous or inconsistent keys\nenum class BadFeatures(override val key: String) : Feature&lt;...&gt; {\n    F1(\"f1\"),  // Not descriptive\n    newCheckout(\"newCheckout\"),  // Inconsistent casing\n    DARK_MODE_FEATURE_FLAG(\"DARK-MODE-FEATURE-FLAG\");  // Mixed conventions\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"Flags/#naming-patterns","title":"Naming Patterns","text":"<pre><code>// Pattern: &lt;domain&gt;_&lt;feature&gt;_&lt;variant?&gt;\nCHECKOUT_V2(\"checkout_v2\")\nPAYMENT_APPLE_PAY(\"payment_apple_pay\")\nUI_DARK_MODE(\"ui_dark_mode\")\n\n// Pattern: &lt;feature&gt;_&lt;state&gt;\nANALYTICS_ENABLED(\"analytics_enabled\")\nBETA_FEATURES_AVAILABLE(\"beta_features_available\")\n\n// Pattern: &lt;experiment&gt;_&lt;variant&gt;\nEXPERIMENT_CHECKOUT_LAYOUT_A(\"exp_checkout_layout_a\")\nEXPERIMENT_CHECKOUT_LAYOUT_B(\"exp_checkout_layout_b\")\n</code></pre>"},{"location":"Flags/#dynamic-features","title":"Dynamic Features","text":"<p>For scenarios requiring runtime feature creation:</p> <pre><code>class DynamicFeatureManager {\n    private val features = mutableMapOf&lt;String, Feature&lt;*, *, *&gt;&gt;()\n\n    fun createFeature(key: String): Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n        return features.getOrPut(key) {\n            Feature(key)\n        } as Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;\n    }\n\n    fun getFeature(key: String): Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;? {\n        return features[key] as? Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;\n    }\n}\n</code></pre> <p>However, prefer static feature definitions for type safety and discoverability.</p>"},{"location":"Flags/#feature-documentation","title":"Feature Documentation","text":"<p>Document features with KDoc:</p> <pre><code>enum class AppFeatures(\n    override val key: String\n) : Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n    /**\n     * Enables the new checkout flow with improved UX.\n     *\n     * Rollout plan:\n     * - Phase 1: 10% web users (Week 1)\n     * - Phase 2: 50% web users (Week 2)\n     * - Phase 3: 100% all platforms (Week 3)\n     *\n     * @since 2.5.0\n     * @see CheckoutService\n     */\n    NEW_CHECKOUT(\"new_checkout\"),\n\n    /**\n     * Enables dark mode UI theme.\n     *\n     * Platform support:\n     * - iOS: Full support\n     * - Android: Full support\n     * - Web: Partial support (no custom color schemes)\n     *\n     * @since 2.3.0\n     */\n    DARK_MODE(\"dark_mode\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n</code></pre>"},{"location":"Flags/#testing-features","title":"Testing Features","text":""},{"location":"Flags/#test-specific-features","title":"Test-Specific Features","text":"<p>Create features for testing:</p> <pre><code>object TestFeatures {\n    val testRegistry = FlagRegistry.create()\n\n    val TEST_FEATURE: Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; =\n        Feature(\"test_feature\", testRegistry)\n}\n\n@Test\nfun `feature evaluation works correctly`() {\n    config(registry = TestFeatures.testRegistry) {\n        TestFeatures.TEST_FEATURE with {\n            default(false)\n            rule { platforms(Platform.IOS) }.implies(true)\n        }\n    }\n\n    val iosContext = Context(\n        platform = Platform.IOS,\n        // ...\n    )\n\n    val result = iosContext.evaluateSafe(TestFeatures.TEST_FEATURE, TestFeatures.testRegistry)\n    assertTrue(result is EvaluationResult.Success &amp;&amp; result.value == true)\n}\n</code></pre>"},{"location":"Flags/#feature-factories-for-tests","title":"Feature Factories for Tests","text":"<p>Create factory functions for test features:</p> <pre><code>object FeatureTestFactory {\n    fun createBooleanFeature(\n        key: String,\n        defaultValue: Boolean = false,\n        registry: FlagRegistry = FlagRegistry.create()\n    ): Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt; {\n        val feature = Feature&lt;EncodableValue.BooleanEncodeable, Boolean, Context&gt;(key, registry)\n\n        config(registry) {\n            feature with {\n                default(defaultValue)\n            }\n        }\n\n        return feature\n    }\n}\n</code></pre>"},{"location":"Flags/#best-practices","title":"Best Practices","text":""},{"location":"Flags/#use-enums-for-related-features","title":"Use Enums for Related Features","text":"<p>Group related features in enums for organization:</p> <pre><code>// Good: Related features grouped\nenum class CheckoutFeatures(override val key: String) : Feature&lt;...&gt; {\n    GUEST_CHECKOUT(\"checkout_guest\"),\n    SAVE_PAYMENT(\"checkout_save_payment\"),\n    ONE_CLICK_BUY(\"checkout_one_click\");\n\n    override val registry: FlagRegistry = FlagRegistry\n}\n\n// Avoid: Scattered features\nobject Features {\n    val GUEST_CHECKOUT = Feature(\"checkout_guest\")\n    val SAVE_PAYMENT = Feature(\"payment_save\")\n    val ANALYTICS = Feature(\"analytics\")\n    // ... unrelated features mixed together\n}\n</code></pre>"},{"location":"Flags/#make-keys-immutable","title":"Make Keys Immutable","text":"<p>Always use <code>val</code> for feature keys:</p> <pre><code>// Good: Immutable key\nenum class Features(override val key: String) : Feature&lt;...&gt;\n\n// Bad: Mutable key\nclass MutableFeature(override var key: String) : Feature&lt;...&gt;  // Don't do this\n</code></pre>"},{"location":"Flags/#modules-are-coming","title":"Modules are coming!!!","text":""},{"location":"Flags/#next-steps","title":"Next Steps","text":"<ul> <li>Builders: Learn the configuration DSL</li> <li>Rules: Understand rule evaluation</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"Migration/","title":"Migration Guide: From String-Based to Type-Safe Configuration","text":"<p>This guide walks you through migrating your existing string-based configuration system to Konditional's type-safe approach.</p>"},{"location":"Migration/#migration-strategy","title":"Migration Strategy","text":""},{"location":"Migration/#phase-1-run-in-parallel-recommended","title":"Phase 1: Run in Parallel (Recommended)","text":"<p>Keep your existing system running while gradually migrating flags to Konditional. This allows: - Safe rollback if issues arise - Team learns the new system incrementally - Production confidence builds gradually</p>"},{"location":"Migration/#phase-2-full-migration","title":"Phase 2: Full Migration","text":"<p>Once confident, deprecate the old system and complete the migration.</p>"},{"location":"Migration/#step-1-identify-your-current-flags","title":"Step 1: Identify Your Current Flags","text":""},{"location":"Migration/#audit-your-string-based-config","title":"Audit Your String-Based Config","text":"<p>Create an inventory of your current flags:</p> <pre><code>// Example current system\ninterface ConfigService {\n    fun getBoolean(key: String): Boolean?\n    fun getString(key: String): String?\n    fun getInt(key: String): Int?\n}\n\n// Current usage scattered across codebase:\nconfig.getBoolean(\"dark_mode\")\nconfig.getString(\"api_endpoint\")\nconfig.getInt(\"max_retries\")\nconfig.getBoolean(\"premium_export\")\nconfig.getString(\"theme_color\")\n</code></pre> <p>Action: Search your codebase for all <code>config.get*</code> calls and create a spreadsheet:</p> Flag Name Type Default Value Used In Business Logic <code>dark_mode</code> Boolean <code>false</code> SettingsActivity Platform-dependent <code>api_endpoint</code> String <code>\"https://api.prod\"</code> ApiClient Environment-dependent <code>max_retries</code> Int <code>3</code> NetworkService None <code>premium_export</code> Boolean <code>false</code> ExportManager Subscription-dependent"},{"location":"Migration/#step-2-set-up-konditional","title":"Step 2: Set Up Konditional","text":""},{"location":"Migration/#add-dependency","title":"Add Dependency","text":"<pre><code>// build.gradle.kts\ndependencies {\n    implementation(\"io.amichne:konditional:1.0.0\")\n}\n</code></pre>"},{"location":"Migration/#create-base-context","title":"Create Base Context","text":"<p>Define what information your flags need for evaluation:</p> <pre><code>// Before: Context is implicit, scattered\nconfig.getBoolean(\"premium_export\")  // How does it know user tier?\n\n// After: Context is explicit\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,  // For rollout bucketing\n    val userId: String,\n    val subscriptionTier: SubscriptionTier\n) : Context\n\nenum class SubscriptionTier {\n    FREE, PROFESSIONAL, ENTERPRISE\n}\n</code></pre> <p>Key Insight: Making context explicit immediately reveals hidden dependencies in your current system.</p>"},{"location":"Migration/#step-3-migrate-flag-by-flag","title":"Step 3: Migrate Flag-by-Flag","text":""},{"location":"Migration/#example-1-simple-boolean-flag","title":"Example 1: Simple Boolean Flag","text":"<p>Before: <pre><code>class SettingsActivity {\n    private val config: ConfigService\n\n    fun isDarkModeEnabled(): Boolean {\n        return config.getBoolean(\"dark_mode\") ?: false\n    }\n}\n</code></pre></p> <p>After: <pre><code>// 1. Define the flag\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// 2. Configure it\nconfig {\n    Features.DARK_MODE with {\n        default(false)  // No more null handling!\n\n        rule {\n            platforms(Platform.IOS)  // Platform-specific behavior\n        }.implies(true)\n    }\n}\n\n// 3. Use it\nclass SettingsActivity(private val context: Context) {\n    fun isDarkModeEnabled(): Boolean =\n        context.evaluate(Features.DARK_MODE)  // Type-safe, non-null\n}\n</code></pre></p> <p>Migration Checklist: -  No null check needed -  Type mismatch impossible -  Platform logic moved to configuration -  IDE auto-complete for flag name</p>"},{"location":"Migration/#example-2-string-configuration","title":"Example 2: String Configuration","text":"<p>Before: <pre><code>class ApiClient {\n    private val config: ConfigService\n\n    fun getEndpoint(): String {\n        val env = System.getenv(\"ENV\") ?: \"prod\"\n        return when (env) {\n            \"dev\" -&gt; config.getString(\"api_endpoint_dev\") ?: \"https://dev.api\"\n            \"staging\" -&gt; config.getString(\"api_endpoint_staging\") ?: \"https://staging.api\"\n            else -&gt; config.getString(\"api_endpoint_prod\") ?: \"https://api.prod\"\n        }\n    }\n}\n</code></pre></p> <p>Issues: - 3 separate flag names - Environment logic in application code - 3 null checks - Easy to typo flag names</p> <p>After: <pre><code>// 1. Define the flag\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\")\n}\n\n// 2. Configure with environment-based rules\nconfig {\n    ApiConfig.ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n\n        rule {\n            extension {\n                object : Evaluable&lt;Context&gt;() {\n                    override fun matches(context: Context): Boolean =\n                        System.getenv(\"ENV\") == \"dev\"\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(\"https://dev.api.example.com\")\n\n        rule {\n            extension {\n                object : Evaluable&lt;Context&gt;() {\n                    override fun matches(context: Context): Boolean =\n                        System.getenv(\"ENV\") == \"staging\"\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(\"https://staging.api.example.com\")\n    }\n}\n\n// 3. Use it\nclass ApiClient(private val context: Context) {\n    fun getEndpoint(): String =\n        context.evaluate(ApiConfig.ENDPOINT)  // Environment handled automatically\n}\n</code></pre></p> <p>Benefits: -  Single flag name -  Environment logic centralized -  Zero null checks -  Testable by mocking context, not environment variables</p>"},{"location":"Migration/#example-3-complex-type-data-class","title":"Example 3: Complex Type (Data Class)","text":"<p>Before: <pre><code>class ThemeManager {\n    private val config: ConfigService\n\n    fun getTheme(): ThemeConfig {\n        val primaryColor = config.getString(\"theme_primary_color\") ?: \"#FFFFFF\"\n        val secondaryColor = config.getString(\"theme_secondary_color\") ?: \"#000000\"\n        val fontSize = config.getInt(\"theme_font_size\") ?: 14\n        val darkMode = config.getBoolean(\"theme_dark_mode\") ?: false\n\n        return ThemeConfig(primaryColor, secondaryColor, fontSize, darkMode)\n    }\n}\n</code></pre></p> <p>Issues: - 4 separate flags for one logical concept - 4 null checks - No guarantee all theme parts are consistent - Hard to A/B test complete themes</p> <p>After: <pre><code>// 1. Define the type\ndata class ThemeConfig(\n    val primaryColor: String,\n    val secondaryColor: String,\n    val fontSize: Int,\n    val darkMode: Boolean\n)\n\n// 2. Define single flag for entire theme\nenum class Theme(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    APP_THEME(\"app_theme\")\n}\n\n// 3. Configure complete themes atomically\nconfig {\n    Theme.APP_THEME with {\n        default(\n            ThemeConfig(\n                primaryColor = \"#FFFFFF\",\n                secondaryColor = \"#000000\",\n                fontSize = 14,\n                darkMode = false\n            )\n        )\n\n        // Entire theme for iOS\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\n            ThemeConfig(\n                primaryColor = \"#F5F5F5\",\n                secondaryColor = \"#1E1E1E\",\n                fontSize = 16,\n                darkMode = true\n            )\n        )\n\n        // Gradual rollout of new theme\n        rule {\n            platforms(Platform.ANDROID)\n            rollout = Rollout.of(25.0)  // 25% of Android users\n        }.implies(\n            ThemeConfig(\n                primaryColor = \"#E0E0E0\",\n                secondaryColor = \"#2C2C2C\",\n                fontSize = 15,\n                darkMode = true\n            )\n        )\n    }\n}\n\n// 4. Use it\nclass ThemeManager(private val context: Context) {\n    fun getTheme(): ThemeConfig =\n        context.evaluate(Theme.APP_THEME)  // Atomic, type-safe, non-null\n}\n</code></pre></p> <p>Benefits: -  Atomic theme updates -  Single flag for related config -  A/B testing entire themes -  Guaranteed consistency</p>"},{"location":"Migration/#example-4-context-dependent-flag","title":"Example 4: Context-Dependent Flag","text":"<p>Before: <pre><code>class ExportManager {\n    private val config: ConfigService\n    private val user: User\n\n    fun canExport(): Boolean {\n        val baseEnabled = config.getBoolean(\"export_enabled\") ?: false\n        val premiumOnly = config.getBoolean(\"export_premium_only\") ?: true\n\n        // Business logic scattered\n        return baseEnabled &amp;&amp; (!premiumOnly || user.tier == \"premium\")\n    }\n}\n</code></pre></p> <p>Issues: - Business logic mixed with config - Unclear what context is needed - Multiple flag lookups for one decision - String-based tier comparison</p> <p>After: <pre><code>// 1. Define context with business domain\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier\n) : Context\n\nenum class SubscriptionTier {\n    FREE, PROFESSIONAL, ENTERPRISE\n}\n\n// 2. Define flag with specific context\nenum class Features(override val key: String) : Conditional&lt;Boolean, AppContext&gt; {\n    DATA_EXPORT(\"export_enabled\")\n}\n\n// 3. Business logic in configuration\nconfig {\n    Features.DATA_EXPORT with {\n        default(false)\n\n        // Full rollout for enterprise\n        rule {\n            extension {\n                object : Evaluable&lt;AppContext&gt;() {\n                    override fun matches(context: AppContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(true)\n\n        // Gradual rollout for professional\n        rule {\n            extension {\n                object : Evaluable&lt;AppContext&gt;() {\n                    override fun matches(context: AppContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.PROFESSIONAL\n                    override fun specificity(): Int = 1\n                }\n            }\n            rollout = Rollout.of(50.0)  // 50% of professional users\n        }.implies(true)\n    }\n}\n\n// 4. Use it\nclass ExportManager(private val context: AppContext) {\n    fun canExport(): Boolean =\n        context.evaluate(Features.DATA_EXPORT)  // Business logic handled\n}\n</code></pre></p> <p>Benefits: -  Business logic declarative -  Context requirements explicit -  Type-safe tier enum -  Single source of truth</p>"},{"location":"Migration/#step-4-handle-gradual-rollouts","title":"Step 4: Handle Gradual Rollouts","text":""},{"location":"Migration/#before-manual-bucketing","title":"Before: Manual Bucketing","text":"<pre><code>// Scattered rollout logic\nfun isNewCheckoutEnabled(userId: String): Boolean {\n    val enabled = config.getBoolean(\"new_checkout\") ?: false\n    if (!enabled) return false\n\n    // Manual bucketing logic\n    val hash = userId.hashCode()\n    val bucket = (hash % 100).absoluteValue\n    return bucket &lt; 25  // 25% rollout\n}\n</code></pre> <p>Issues: - Bucketing logic duplicated - Hard to change rollout percentage - Not deterministic across platforms</p>"},{"location":"Migration/#after-built-in-rollouts","title":"After: Built-In Rollouts","text":"<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    NEW_CHECKOUT(\"new_checkout\")\n}\n\nconfig {\n    Features.NEW_CHECKOUT with {\n        default(false)\n\n        rule {\n            rollout = Rollout.of(25.0)  // 25% of users\n        }.implies(true)\n    }\n}\n\n// Usage: Automatic bucketing via context.stableId\nval enabled = context.evaluate(Features.NEW_CHECKOUT)\n</code></pre> <p>Rollout Features: -  SHA-256 based bucketing (deterministic) -  Independent buckets per flag (no correlation) -  StableId ensures consistency across sessions/platforms -  Change percentage in config, no code changes</p>"},{"location":"Migration/#step-5-organize-by-domain","title":"Step 5: Organize by Domain","text":""},{"location":"Migration/#before-flat-flag-namespace","title":"Before: Flat Flag Namespace","text":"<pre><code>// All flags in one place\nconfig.getBoolean(\"dark_mode\")\nconfig.getBoolean(\"premium_export\")\nconfig.getString(\"api_endpoint\")\nconfig.getBoolean(\"ios_new_checkout\")\n</code></pre>"},{"location":"Migration/#after-organized-enums","title":"After: Organized Enums","text":"<pre><code>// Group by domain\nenum class UiFeatures(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\")\n}\n\nenum class ExportFeatures(override val key: String)\n    : Conditional&lt;Boolean, AppContext&gt; {\n    PREMIUM_EXPORT(\"premium_export\")\n}\n\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\")\n}\n\n// Clear namespacing in usage\ncontext.evaluate(UiFeatures.DARK_MODE)\ncontext.evaluate(ExportFeatures.PREMIUM_EXPORT)\ncontext.evaluate(ApiConfig.ENDPOINT)\n</code></pre>"},{"location":"Migration/#step-6-testing-strategy","title":"Step 6: Testing Strategy","text":""},{"location":"Migration/#before-mocking-config-service","title":"Before: Mocking Config Service","text":"<pre><code>@Test\nfun `test dark mode enabled`() {\n    val mockConfig = mock&lt;ConfigService&gt;()\n    whenever(mockConfig.getBoolean(\"dark_mode\")).thenReturn(true)\n\n    val activity = SettingsActivity(mockConfig)\n    assertTrue(activity.isDarkModeEnabled())\n}\n</code></pre> <p>Issues: - Mock setup boilerplate - String literal duplication - Mocking framework dependency</p>"},{"location":"Migration/#after-simple-context-objects","title":"After: Simple Context Objects","text":"<pre><code>@Test\nfun `test dark mode enabled on iOS`() {\n    val context = TestContext(platform = Platform.IOS)\n\n    val enabled = context.evaluate(Features.DARK_MODE)\n\n    assertTrue(enabled)\n}\n\n// Reusable test context factory\nfun TestContext(\n    locale: AppLocale = AppLocale.EN_US,\n    platform: Platform = Platform.ANDROID,\n    appVersion: Version = Version(1, 0, 0),\n    stableId: StableId = StableId.of(\"test-user\"),\n    subscriptionTier: SubscriptionTier = SubscriptionTier.FREE\n) = AppContext(locale, platform, appVersion, stableId, subscriptionTier)\n</code></pre> <p>Benefits: -  No mocking needed -  Simple data class construction -  Type-safe test setup -  Reusable factories</p>"},{"location":"Migration/#step-7-configuration-management","title":"Step 7: Configuration Management","text":""},{"location":"Migration/#loading-from-json","title":"Loading from JSON","text":"<p>If you currently load config from a remote server:</p> <pre><code>// Before: String key-value pairs\nval json = \"\"\"\n{\n  \"dark_mode\": true,\n  \"api_endpoint\": \"https://api.prod\",\n  \"max_retries\": 5\n}\n\"\"\"\n</code></pre> <p>After: Type-safe snapshots</p> <pre><code>// 1. Define flags\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// 2. Export current config\nval snapshot = buildSnapshot {\n    Features.DARK_MODE with {\n        default(false)\n    }\n}\n\nval json = SnapshotSerializer.default.serialize(snapshot)\n\n// 3. Load from JSON\nval result = SnapshotSerializer.default.deserialize(json)\nwhen (result) {\n    is ParseResult.Success -&gt; FlagRegistry.load(result.value)\n    is ParseResult.Failure -&gt; logger.error(\"Config parse error: ${result.error}\")\n}\n\n// 4. Apply patches without full reload\nval patchJson = \"\"\"\n{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"rules\": [...],\n      \"default\": true\n    }\n  ]\n}\n\"\"\"\nSnapshotSerializer.default.applyPatchJson(currentConfig, patchJson)\n</code></pre> <p>Benefits: -  Type-safe deserialization -  Atomic config updates -  Patch support for incremental changes -  Parse errors caught before applying</p>"},{"location":"Migration/#common-migration-patterns","title":"Common Migration Patterns","text":""},{"location":"Migration/#pattern-1-feature-flag-conditional-boolean","title":"Pattern 1: Feature Flag \u2192 Conditional Boolean","text":"<pre><code>// Before\nif (config.getBoolean(\"new_feature\") == true) { }\n\n// After\nif (context.evaluate(Features.NEW_FEATURE)) { }\n</code></pre>"},{"location":"Migration/#pattern-2-environment-config-custom-evaluable","title":"Pattern 2: Environment Config \u2192 Custom Evaluable","text":"<pre><code>// Before\nval endpoint = when (System.getenv(\"ENV\")) {\n    \"dev\" -&gt; config.getString(\"dev_endpoint\")\n    else -&gt; config.getString(\"prod_endpoint\")\n}\n\n// After\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\")\n}\n\nconfig {\n    ApiConfig.ENDPOINT with {\n        default(\"https://api.prod\")\n        rule {\n            extension {\n                object : Evaluable&lt;Context&gt;() {\n                    override fun matches(context: Context) =\n                        System.getenv(\"ENV\") == \"dev\"\n                    override fun specificity() = 1\n                }\n            }\n        }.implies(\"https://api.dev\")\n    }\n}\n</code></pre>"},{"location":"Migration/#pattern-3-user-segmentation-context-extensions","title":"Pattern 3: User Segmentation \u2192 Context Extensions","text":"<pre><code>// Before\nfun isPremiumFeatureEnabled(user: User): Boolean {\n    val enabled = config.getBoolean(\"premium_feature\") ?: false\n    return enabled &amp;&amp; user.tier == \"premium\"\n}\n\n// After\ndata class AppContext(\n    // ... base fields\n    val subscriptionTier: SubscriptionTier\n) : Context\n\nenum class PremiumFeatures(override val key: String)\n    : Conditional&lt;Boolean, AppContext&gt; {\n    ADVANCED_ANALYTICS(\"premium_feature\")\n}\n\nconfig {\n    PremiumFeatures.ADVANCED_ANALYTICS with {\n        default(false)\n        rule {\n            extension {\n                object : Evaluable&lt;AppContext&gt;() {\n                    override fun matches(context: AppContext) =\n                        context.subscriptionTier == SubscriptionTier.PREMIUM\n                    override fun specificity() = 1\n                }\n            }\n        }.implies(true)\n    }\n}\n\n// Usage\nval enabled = context.evaluate(PremiumFeatures.ADVANCED_ANALYTICS)\n</code></pre>"},{"location":"Migration/#migration-checklist","title":"Migration Checklist","text":""},{"location":"Migration/#for-each-flag","title":"For Each Flag:","text":"<ul> <li>[ ] Identify type (Boolean, String, Int, custom)</li> <li>[ ] Determine context requirements</li> <li>[ ] Create enum definition</li> <li>[ ] Define default value</li> <li>[ ] Add rules for special cases</li> <li>[ ] Update call sites to use <code>context.evaluate()</code></li> <li>[ ] Remove null handling code</li> <li>[ ] Update tests to use simple context objects</li> <li>[ ] Verify no typos in flag names (IDE will show)</li> <li>[ ] Remove old string-based lookup</li> </ul>"},{"location":"Migration/#for-your-system","title":"For Your System:","text":"<ul> <li>[ ] Define base Context interface</li> <li>[ ] Create context factory functions</li> <li>[ ] Set up flag registration at app start</li> <li>[ ] Configure remote config deserialization (if needed)</li> <li>[ ] Create test context factories</li> <li>[ ] Update documentation</li> <li>[ ] Train team on new patterns</li> <li>[ ] Set deprecation timeline for old system</li> </ul>"},{"location":"Migration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Migration/#i-need-different-context-for-different-flags","title":"\"I need different context for different flags\"","text":"<p>Use multiple context types:</p> <pre><code>// Basic features use base context\nenum class BasicFeatures(override val key: String)\n    : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\n// Enterprise features require more context\nenum class EnterpriseFeatures(override val key: String)\n    : Conditional&lt;Boolean, EnterpriseContext&gt; {\n    BULK_EXPORT(\"bulk_export\")\n}\n</code></pre>"},{"location":"Migration/#my-flag-depends-on-runtime-state","title":"\"My flag depends on runtime state\"","text":"<p>Use custom Evaluable extensions:</p> <pre><code>config {\n    Features.PEAK_HOURS_MODE with {\n        default(false)\n        rule {\n            extension {\n                object : Evaluable&lt;Context&gt;() {\n                    override fun matches(context: Context): Boolean {\n                        val hour = LocalTime.now().hour\n                        return hour in 9..17  // 9 AM - 5 PM\n                    }\n                    override fun specificity() = 1\n                }\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Migration/#i-need-to-update-config-at-runtime","title":"\"I need to update config at runtime\"","text":"<p>Use atomic registry updates:</p> <pre><code>// Update entire config\nFlagRegistry.load(newSnapshot)\n\n// Or apply incremental patch\nSnapshotSerializer.default.applyPatchJson(currentSnapshot, patchJson)\n</code></pre>"},{"location":"Migration/#next-steps","title":"Next Steps","text":"<ol> <li>Quick Start Guide - Get your first flag running</li> <li>Error Prevention Reference - See all eliminated error classes</li> <li>Context Guide - Design your context types</li> <li>Builders Guide - Master the configuration DSL</li> </ol> <p>Remember: Migration can be gradual. Start with your most error-prone flags first!</p>"},{"location":"QuickStart/","title":"Quick Start Guide","text":"<p>Get your first type-safe feature flag running in 5 minutes.</p>"},{"location":"QuickStart/#installation","title":"Installation","text":"<pre><code>// build.gradle.kts\ndependencies {\n    implementation(\"io.amichne:konditional:1.0.0\")\n}\n</code></pre>"},{"location":"QuickStart/#your-first-type-safe-flag-2-minutes","title":"Your First Type-Safe Flag (2 Minutes)","text":""},{"location":"QuickStart/#step-1-define-your-flag","title":"Step 1: Define Your Flag","text":"<pre><code>import io.amichne.konditional.core.Conditional\nimport io.amichne.konditional.context.Context\n\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n</code></pre> <p>What this gives you:</p> <ul> <li>IDE auto-complete for <code>Features.DARK_MODE</code></li> <li>Compile error if you typo the name</li> <li>Type-safe: Always returns <code>Boolean</code>, never null</li> </ul>"},{"location":"QuickStart/#step-2-configure-the-flag","title":"Step 2: Configure the Flag","text":"<pre><code>import io.amichne.konditional.builders.config\n\nval configuration = config {\n    Features.DARK_MODE with {\n        default(false)  // Required - no nulls possible\n    }\n}\n</code></pre> <p>What this gives you:</p> <ul> <li>Compiler enforces default value</li> <li>Type-safe: <code>default(false)</code> must be Boolean</li> </ul>"},{"location":"QuickStart/#step-3-load-configuration","title":"Step 3: Load Configuration","text":"<pre><code>import io.amichne.konditional.registry.FlagRegistry\n\nFlagRegistry.load(configuration)\n</code></pre>"},{"location":"QuickStart/#step-4-evaluate-the-flag","title":"Step 4: Evaluate the Flag","text":"<pre><code>import io.amichne.konditional.context.basicContext\nimport io.amichne.konditional.context.evaluate\n\n// Create a context\nval context = basicContext(\n    platform = Platform.ANDROID,\n    stableId = StableId.of(\"user-123\")\n)\n\n// Evaluate the flag\nval isDarkMode: Boolean = context.evaluate(Features.DARK_MODE)\n\n// Use it\nif (isDarkMode) {\n    applyDarkTheme()\n}\n</code></pre> <p>What this gives you:</p> <ul> <li>Non-null result guaranteed</li> <li>Type-safe: <code>isDarkMode</code> is always <code>Boolean</code></li> </ul>"},{"location":"QuickStart/#before-after-comparison","title":"Before &amp; After Comparison","text":""},{"location":"QuickStart/#string-based-your-current-system","title":"String-Based (Your Current System)","text":"<pre><code>// Definition: Scattered string literals\nval enabled = config.getBoolean(\"dark_mode\")\n\n// Problems:\n// - Returns Boolean? (nullable)\n// - Typo \"dakr_mode\" compiles\n// - No IDE auto-complete\n// - ClassCastException if wrong type\n</code></pre>"},{"location":"QuickStart/#type-safe-konditional","title":"Type-Safe (Konditional)","text":"<pre><code>// Definition: Type-safe enum\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\nval enabled: Boolean = context.evaluate(Features.DARK_MODE)\n\n// Benefits:\n// - Returns Boolean (non-null)\n// - Typo won't compile\n// - Full IDE auto-complete\n// - Type mismatch is compile error\n</code></pre>"},{"location":"QuickStart/#adding-platform-specific-rules-3-minutes","title":"Adding Platform-Specific Rules (3 Minutes)","text":"<pre><code>config {\n    Features.DARK_MODE with {\n        default(false)  // Default for all platforms\n\n        // Enable on iOS only\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n}\n\n// Evaluation: Automatic platform handling\nval context = basicContext(\n    platform = Platform.IOS,\n    stableId = StableId.of(\"user-123\")\n)\n\nval enabled = context.evaluate(Features.DARK_MODE)\n// Returns: true (iOS rule matched)\n</code></pre> <p>What you get:</p> <ul> <li> <p>Platform logic declarative in config</p> </li> <li> <p>No if/when statements in application code</p> </li> <li> <p>Easy to test by changing context</p> </li> </ul>"},{"location":"QuickStart/#adding-gradual-rollout-2-minutes","title":"Adding Gradual Rollout (2 Minutes)","text":"<pre><code>config {\n    Features.DARK_MODE with {\n        default(false)\n\n        // 25% rollout on Android\n        rule {\n            platforms(Platform.ANDROID)\n            rollout = Rollout.of(25.0)  // 25% of users\n        }.implies(true)\n\n        // Full rollout on iOS\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n}\n\n// Evaluation: Automatic bucketing via stableId\nval context = basicContext(\n    platform = Platform.ANDROID,\n    stableId = StableId.of(\"user-123\")  // Deterministic bucketing\n)\n\nval enabled = context.evaluate(Features.DARK_MODE)\n// Returns: true or false based on SHA-256(stableId + flag_key)\n</code></pre> <p>What you get:</p> <ul> <li>Deterministic: Same user always gets same result</li> <li>Independent: Each flag has its own bucket</li> <li>Platform-stable: Works across JVM, Android, iOS</li> </ul>"},{"location":"QuickStart/#beyond-booleans-string-configuration","title":"Beyond Booleans: String Configuration","text":"<pre><code>// Define string flag\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\")\n}\n\n// Configure with environment-specific rules\nconfig {\n    ApiConfig.ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"https://api-ios.prod.example.com\")\n\n        rule {\n            platforms(Platform.ANDROID)\n        }.implies(\"https://api-android.prod.example.com\")\n    }\n}\n\n// Usage: Type-safe, non-null\nval endpoint: String = context.evaluate(ApiConfig.ENDPOINT)\nhttpClient.setBaseUrl(endpoint)\n</code></pre> <p>What you get:</p> <ul> <li>Type-safe: Always returns <code>String</code>, never null</li> <li>Platform-specific URLs declarative</li> <li>No string matching in application code</li> </ul>"},{"location":"QuickStart/#complex-types-data-classes","title":"Complex Types: Data Classes","text":"<pre><code>// Define your type\ndata class ThemeConfig(\n    val primaryColor: String,\n    val fontSize: Int,\n    val darkMode: Boolean\n)\n\n// Define flag for that type\nenum class Theme(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    APP_THEME(\"app_theme\")\n}\n\n// Configure complete themes\nconfig {\n    Theme.APP_THEME with {\n        default(\n            ThemeConfig(\n                primaryColor = \"#FFFFFF\",\n                fontSize = 14,\n                darkMode = false\n            )\n        )\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\n            ThemeConfig(\n                primaryColor = \"#000000\",\n                fontSize = 16,\n                darkMode = true\n            )\n        )\n    }\n}\n\n// Usage: Atomic, consistent theme\nval theme: ThemeConfig = context.evaluate(Theme.APP_THEME)\napplyTheme(theme.primaryColor, theme.fontSize, theme.darkMode)\n</code></pre> <p>What you get:</p> <ul> <li>Atomic updates: All theme values consistent</li> <li>Type-safe: Guaranteed ThemeConfig, never null</li> <li>No validation needed: Type enforces structure</li> </ul>"},{"location":"QuickStart/#custom-context-for-business-logic","title":"Custom Context for Business Logic","text":"<pre><code>// Define context with business domain\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier  // Custom field\n) : Context\n\nenum class SubscriptionTier {\n    FREE, PROFESSIONAL, ENTERPRISE\n}\n\n// Define flag requiring custom context\nenum class PremiumFeatures(override val key: String)\n    : Conditional&lt;Boolean, AppContext&gt; {  // \u2190 Requires AppContext\n    DATA_EXPORT(\"export_enabled\")\n}\n\n// Configure with custom logic\nconfig {\n    PremiumFeatures.DATA_EXPORT with {\n        default(false)\n\n        // Enable for enterprise tier\n        rule {\n            extension {\n                object : Evaluable&lt;AppContext&gt;() {\n                    override fun matches(context: AppContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(true)\n    }\n}\n\n// Usage: Type-safe context required\nval context = AppContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.ANDROID,\n    appVersion = Version(1, 0, 0),\n    stableId = StableId.of(\"user-123\"),\n    subscriptionTier = SubscriptionTier.ENTERPRISE\n)\n\nval canExport: Boolean = context.evaluate(PremiumFeatures.DATA_EXPORT)\n// Returns: true (enterprise tier matched)\n\n// Wrong context type won't compile:\nval basicContext: Context = basicContext(...)\nbasicContext.evaluate(PremiumFeatures.DATA_EXPORT)  // \u2717 Compile error\n</code></pre> <p>What you get:</p> <ul> <li>Business logic declarative in config</li> <li>Context requirements explicit in types</li> <li>Compiler enforces correct context</li> </ul>"},{"location":"QuickStart/#testing-simple-data-classes","title":"Testing: Simple Data Classes","text":"<pre><code>@Test\nfun `dark mode enabled on iOS`() {\n    // Create test context\n    val context = basicContext(\n        platform = Platform.IOS,\n        stableId = StableId.of(\"test-user\")\n    )\n\n    // Evaluate\n    val enabled = context.evaluate(Features.DARK_MODE)\n\n    // Assert\n    assertTrue(enabled)\n}\n\n@Test\nfun `dark mode disabled on Android`() {\n    val context = basicContext(\n        platform = Platform.ANDROID,\n        stableId = StableId.of(\"test-user\")\n    )\n\n    assertFalse(context.evaluate(Features.DARK_MODE))\n}\n\n// Reusable test context factory\nfun testContext(\n    platform: Platform = Platform.ANDROID,\n    tier: SubscriptionTier = SubscriptionTier.FREE\n) = AppContext(\n    locale = AppLocale.EN_US,\n    platform = platform,\n    appVersion = Version(1, 0, 0),\n    stableId = StableId.of(\"test-user\"),\n    subscriptionTier = tier\n)\n\n@Test\nfun `premium export enabled for enterprise`() {\n    val context = testContext(tier = SubscriptionTier.ENTERPRISE)\n    assertTrue(context.evaluate(PremiumFeatures.DATA_EXPORT))\n}\n</code></pre> <p>What you get:</p> <ul> <li>No mocking frameworks needed</li> <li>Simple data class construction</li> <li>Reusable test factories</li> </ul>"},{"location":"QuickStart/#common-patterns","title":"Common Patterns","text":""},{"location":"QuickStart/#multiple-flags-in-one-enum","title":"Multiple Flags in One Enum","text":"<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_CHECKOUT(\"new_checkout\"),\n    ANALYTICS(\"analytics_enabled\")\n}\n</code></pre>"},{"location":"QuickStart/#organizing-by-domain","title":"Organizing by Domain","text":"<pre><code>enum class UiFeatures(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\"),\n    NEW_NAVIGATION(\"new_navigation\")\n}\n\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\"),\n    TIMEOUT_URL(\"timeout_url\")\n}\n\nenum class Limits(override val key: String) : Conditional&lt;Int, Context&gt; {\n    MAX_RETRIES(\"max_retries\"),\n    BATCH_SIZE(\"batch_size\")\n}\n</code></pre>"},{"location":"QuickStart/#version-based-rules","title":"Version-Based Rules","text":"<pre><code>config {\n    Features.NEW_CHECKOUT with {\n        default(false)\n\n        rule {\n            versions { min(2, 0, 0) }  // Version 2.0.0+\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"QuickStart/#locale-based-rules","title":"Locale-Based Rules","text":"<pre><code>config {\n    Features.METRIC_UNITS with {\n        default(false)\n\n        rule {\n            locales(AppLocale.EN_GB, AppLocale.FR_FR)  // UK and France\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"QuickStart/#multiple-criteria","title":"Multiple Criteria","text":"<pre><code>config {\n    Features.PREMIUM_EXPORT with {\n        default(false)\n\n        // All conditions must match\n        rule {\n            platforms(Platform.IOS)\n            versions { min(2, 0, 0) }\n            locales(AppLocale.EN_US)\n            rollout = Rollout.of(50.0)  // 50% of eligible users\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"QuickStart/#rule-specificity-automatic-ordering","title":"Rule Specificity (Automatic Ordering)","text":"<p>Rules are evaluated most-specific first:</p> <pre><code>config {\n    Features.THEME with {\n        default(\"light\")\n\n        // Specificity = 2 (platform + locale) - checked first\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n        }.implies(\"dark-us-ios\")\n\n        // Specificity = 1 (platform only) - checked second\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"dark-ios\")\n\n        // Specificity = 1 (locale only) - checked third\n        rule {\n            locales(AppLocale.EN_US)\n        }.implies(\"light-us\")\n    }\n}\n\n// Context: iOS + EN_US\nval context = basicContext(\n    platform = Platform.IOS,\n    locale = AppLocale.EN_US\n)\n\nval theme = context.evaluate(Features.THEME)\n// Returns: \"dark-us-ios\" (most specific rule wins)\n</code></pre> <p>Specificity scoring: - Platform: +1 - Locale: +1 - Version: +1 - Custom extension: +1 - Total: 0-4</p>"},{"location":"QuickStart/#what-makes-this-type-safe","title":"What Makes This Type-Safe?","text":"Feature String-Based Konditional Null returns <code>Boolean?</code> <code>Boolean</code> (non-null) Type errors Runtime <code>ClassCastException</code> Compile error Typos Silent failure Compile error Refactoring Manual search-replace IDE symbol rename Auto-complete None Full IDE support Context requirements Invisible Explicit type parameter Testing Mock frameworks Simple data classes"},{"location":"QuickStart/#next-steps","title":"Next Steps","text":"<p>Now you've seen type safety in action. Go deeper:</p> <ol> <li>Why Type Safety - Understand the complete value proposition</li> <li>Error Prevention - See all eliminated error classes</li> <li>Migration Guide - Migrate your existing flags</li> <li>Context Guide - Design custom context types</li> <li>Builders Guide - Master the configuration DSL</li> <li>Rules Guide - Advanced targeting and rollouts</li> </ol>"},{"location":"QuickStart/#key-takeaways","title":"Key Takeaways","text":"<p>Define once, use safely everywhere Compiler catches errors, not users IDE provides full tooling support Business logic declarative in config No null checks, no type errors, no typos</p> <p>Core Principle: If it compiles, it works.</p>"},{"location":"RegistryAndConcurrency/","title":"Registry and Concurrency: Thread-Safe Flag Management","text":"<p>This document explains how Konditional achieves thread-safe configuration management without locks.</p>"},{"location":"RegistryAndConcurrency/#the-flagregistry-interface","title":"The FlagRegistry Interface","text":""},{"location":"RegistryAndConcurrency/#what-it-does","title":"What It Does","text":"<p><code>FlagRegistry</code> is the central storage for all flag configurations:</p> <pre><code>interface FlagRegistry {\n    // Load complete configuration (atomic replacement)\n    fun load(config: Konfig)\n\n    // Apply incremental patch\n    fun update(patch: KonfigPatch)\n\n    // Update single flag\n    fun &lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt; update(\n        definition: FlagDefinition&lt;S, T, C&gt;\n    )\n\n    // Read current configuration\n    fun konfig(): Konfig\n\n    // Lookup specific flag\n    fun &lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context&gt; featureFlag(\n        key: Feature&lt;S, T, C&gt;\n    ): FlagDefinition&lt;S, T, C&gt;?\n\n    // Read all flags\n    fun allFlags(): Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#default-implementation","title":"Default Implementation","text":"<p>Konditional provides a singleton registry backed by <code>AtomicReference</code>:</p> <pre><code>object FlagRegistry : FlagRegistry by SingletonFlagRegistry\n\ninternal class SingletonFlagRegistry : FlagRegistry {\n    private val konfigRef = AtomicReference&lt;Konfig&gt;(Konfig.EMPTY)\n\n    override fun load(config: Konfig) {\n        konfigRef.set(config)  // Atomic swap\n    }\n\n    override fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;? {\n        return konfigRef.get().flags[key]  // Lock-free read\n    }\n\n    // ... other methods\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#thread-safety-model","title":"Thread Safety Model","text":""},{"location":"RegistryAndConcurrency/#lock-free-reads","title":"Lock-Free Reads","text":"<p>The Problem with Locks:</p> <p>String-based systems often use locks: <pre><code>// Traditional approach: Lock-based\nclass ConfigService {\n    private val lock = ReentrantReadWriteLock()\n    private var config: Map&lt;String, Any&gt; = emptyMap()\n\n    fun getBoolean(key: String): Boolean? {\n        lock.readLock().lock()  // \u26a0\ufe0f Contention on reads\n        try {\n            return config[key] as? Boolean\n        } finally {\n            lock.readLock().unlock()\n        }\n    }\n\n    fun updateConfig(newConfig: Map&lt;String, Any&gt;) {\n        lock.writeLock().lock()  // \u26a0\ufe0f Blocks all reads\n        try {\n            config = newConfig\n        } finally {\n            lock.writeLock().unlock()\n        }\n    }\n}\n</code></pre></p> <p>Problems: - Read contention under high load - Write blocks all reads - Potential deadlocks - Performance overhead</p> <p>Konditional's Solution: AtomicReference</p> <pre><code>class SingletonFlagRegistry : FlagRegistry {\n    private val konfigRef = AtomicReference&lt;Konfig&gt;(Konfig.EMPTY)\n\n    override fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;? {\n        return konfigRef.get().flags[key]  // \u2713 Lock-free, no contention\n    }\n\n    override fun load(config: Konfig) {\n        konfigRef.set(config)  // \u2713 Atomic swap, lock-free\n    }\n}\n</code></pre> <p>Benefits: -  Zero lock contention -  Reads never block -  Writes don't block reads -  No deadlock possible -  Hardware-level atomic operations</p>"},{"location":"RegistryAndConcurrency/#immutable-data-structures","title":"Immutable Data Structures","text":"<p>All configuration data is immutable:</p> <pre><code>// Konfig: Immutable snapshot\ndata class Konfig(\n    val flags: Map&lt;Feature&lt;*, *, *&gt;, FlagDefinition&lt;*, *, *&gt;&gt;\n)  // Map is immutable (not MutableMap)\n\n// FlagDefinition: Immutable configuration\ndata class FlagDefinition&lt;S, T, C&gt;(\n    val feature: Feature&lt;S, T, C&gt;,\n    val defaultValue: T,                       // Immutable\n    val values: List&lt;ConditionalValue&lt;S, T, C&gt;&gt;,  // List is immutable\n    val isActive: Boolean,                     // Immutable\n    val salt: String                           // Immutable\n)\n\n// ConditionalValue: Immutable rule + value\ndata class ConditionalValue&lt;S, T, C&gt;(\n    val rule: Rule&lt;C&gt;,  // Immutable\n    val value: T        // Immutable\n)\n</code></pre> <p>Why immutability matters:</p> <pre><code>// Thread A: Reading configuration\nval definition = registry.featureFlag(Features.DARK_MODE)\nval result = definition?.evaluate(context)\n\n// Thread B: Updating configuration (concurrent)\nregistry.load(newConfig)\n\n// Thread A's definition reference remains valid\n// Sees consistent snapshot (either old or new, never partial)\n</code></pre> <p>Guarantee: Concurrent evaluations see either old configuration or new configuration, never a mix.</p>"},{"location":"RegistryAndConcurrency/#atomic-configuration-updates","title":"Atomic Configuration Updates","text":""},{"location":"RegistryAndConcurrency/#full-config-replacement","title":"Full Config Replacement","text":"<pre><code>// Build new configuration\nval newConfig = config {\n    Features.DARK_MODE with {\n        default(false)\n        rule { platforms(Platform.IOS) }.implies(true)\n    }\n    Features.NEW_CHECKOUT with {\n        default(false)\n        rule { rollout = Rollout.of(50.0) }.implies(true)\n    }\n}\n\n// Atomic swap\nFlagRegistry.load(newConfig)\n</code></pre> <p>What happens:</p> <pre><code>// Before: Old Konfig with old flags\nkonfigRef = AtomicReference(oldKonfig)\n\n// During: Atomic swap (single CPU instruction)\nkonfigRef.set(newKonfig)\n\n// After: New Konfig with new flags\nkonfigRef = AtomicReference(newKonfig)\n</code></pre> <p>Properties: -  Atomic: All flags update together -  Consistent: Readers see old OR new, never mixed -  Lock-free: No blocking -  Fast: Single memory write</p>"},{"location":"RegistryAndConcurrency/#incremental-patching","title":"Incremental Patching","text":"<p>For remote config updates, use patches:</p> <pre><code>val patchJson = \"\"\"\n{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"default\": true,\n      \"rules\": [...]\n    }\n  ],\n  \"removeKeys\": [\"deprecated_flag\"]\n}\n\"\"\"\n\n// Parse patch\nwhen (val result = SnapshotSerializer.default.deserializeKonfigPatch(patchJson)) {\n    is ParseResult.Success -&gt; {\n        // Apply atomically\n        FlagRegistry.update(result.value)\n    }\n    is ParseResult.Failure -&gt; {\n        logger.error(\"Patch failed: ${result.error}\")\n    }\n}\n</code></pre> <p>Patch application:</p> <pre><code>override fun update(patch: KonfigPatch) {\n    // Read current config (lock-free)\n    val current = konfigRef.get()\n\n    // Build new config from current + patch\n    val newFlags = current.flags.toMutableMap()\n    patch.addOrUpdate.forEach { newFlags[it.feature] = it }\n    patch.remove.forEach { newFlags.remove(it) }\n\n    val newKonfig = Konfig(newFlags.toMap())\n\n    // Atomic swap (lock-free)\n    konfigRef.set(newKonfig)\n}\n</code></pre> <p>Properties: -  Incremental: Only changed flags in patch -  Atomic: All patch changes applied together -  Type-safe: Parse errors caught before application</p>"},{"location":"RegistryAndConcurrency/#why-this-matters-string-based-vs-type-safe","title":"Why This Matters: String-Based vs. Type-Safe","text":""},{"location":"RegistryAndConcurrency/#string-based-system","title":"String-Based System","text":"<pre><code>class ConfigService {\n    private val lock = ReentrantReadWriteLock()\n    private var config: MutableMap&lt;String, Any&gt; = mutableMapOf()\n\n    fun getBoolean(key: String): Boolean? {\n        lock.readLock().lock()\n        try {\n            return config[key] as? Boolean\n        } finally {\n            lock.readLock().unlock()\n        }\n    }\n\n    fun updateFlag(key: String, value: Any) {\n        lock.writeLock().lock()  // \u26a0\ufe0f Blocks ALL reads\n        try {\n            config[key] = value\n        } finally {\n            lock.writeLock().unlock()\n        }\n    }\n}\n</code></pre> <p>Issues: - Write locks block reads (high latency during updates) - Mutable state = race conditions possible - Per-flag updates = inconsistent intermediate states - Type errors not caught until runtime</p>"},{"location":"RegistryAndConcurrency/#type-safe-system","title":"Type-Safe System","text":"<pre><code>class SingletonFlagRegistry : FlagRegistry {\n    private val konfigRef = AtomicReference&lt;Konfig&gt;(Konfig.EMPTY)\n\n    override fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;? {\n        return konfigRef.get().flags[key]  // Lock-free\n    }\n\n    override fun load(config: Konfig) {\n        konfigRef.set(config)  // Atomic, doesn't block reads\n    }\n}\n</code></pre> <p>Benefits: -  Lock-free reads (no contention) -  Immutable state (no race conditions) -  Atomic updates (consistent snapshots) -  Type errors caught at compile time</p>"},{"location":"RegistryAndConcurrency/#concurrency-guarantees","title":"Concurrency Guarantees","text":""},{"location":"RegistryAndConcurrency/#read-read-always-safe","title":"Read-Read: Always Safe","text":"<pre><code>// Thread A\nval result1 = context.evaluate(Features.DARK_MODE)\n\n// Thread B (concurrent)\nval result2 = context.evaluate(Features.DARK_MODE)\n\n// Both read from AtomicReference - lock-free, no contention\n</code></pre>"},{"location":"RegistryAndConcurrency/#read-write-safe-consistent-snapshots","title":"Read-Write: Safe, Consistent Snapshots","text":"<pre><code>// Thread A: Evaluating\nval definition = registry.featureFlag(Features.DARK_MODE)  // Read old or new\nval result = definition?.evaluate(context)                 // Consistent snapshot\n\n// Thread B: Updating (concurrent)\nFlagRegistry.load(newConfig)  // Atomic swap\n\n// Thread A's definition remains valid\n// Sees complete old config OR complete new config, never mixed\n</code></pre>"},{"location":"RegistryAndConcurrency/#write-write-last-write-wins","title":"Write-Write: Last Write Wins","text":"<pre><code>// Thread A\nFlagRegistry.load(configA)\n\n// Thread B (concurrent)\nFlagRegistry.load(configB)\n\n// Last write wins (AtomicReference semantics)\n// Final state: configA or configB (deterministic on platform)\n</code></pre> <p>Note: For complex write coordination, use external synchronization:</p> <pre><code>synchronized(updateLock) {\n    val current = FlagRegistry.konfig()\n    val updated = applyBusinessLogic(current)\n    FlagRegistry.load(updated)\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"RegistryAndConcurrency/#memory","title":"Memory","text":"<p>String-based system: <pre><code>// Mutable map = potential fragmentation\nprivate var config: MutableMap&lt;String, Any&gt; = mutableMapOf()\n\n// Updates modify in place\nconfig[\"key\"] = newValue  // Heap allocation, GC pressure\n</code></pre></p> <p>Konditional: <pre><code>// Immutable snapshots = structural sharing\nprivate val konfigRef = AtomicReference&lt;Konfig&gt;(...)\n\n// Updates create new snapshots (structural sharing)\nkonfigRef.set(newKonfig)  // Old snapshot GC'd when no references remain\n</code></pre></p> <p>Benefits: -  Structural sharing (maps share structure) -  Predictable GC (old snapshots collected together) -  No fragmentation</p>"},{"location":"RegistryAndConcurrency/#latency","title":"Latency","text":"Operation String-Based (Locks) Konditional (Lock-Free) Read 50-200 ns (uncontended lock) 5-10 ns (AtomicReference.get) Read (contended) 500-5000 ns (lock wait) 5-10 ns (no contention) Write 100-500 ns (lock acquire + release) 10-20 ns (AtomicReference.set) Write impact on reads Blocks reads (ms latency spike) No impact (lock-free) <p>Benchmarks (approximate, JVM):</p> <pre><code>@Benchmark\nfun readFlag_LockBased() {\n    // 50-200 ns/op (uncontended)\n    // 500-5000 ns/op (contended, 10 threads)\n    lockBasedConfig.getBoolean(\"dark_mode\")\n}\n\n@Benchmark\nfun readFlag_LockFree() {\n    // 5-10 ns/op (always, regardless of contention)\n    context.evaluate(Features.DARK_MODE)\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#throughput","title":"Throughput","text":"<p>String-based system: - Reads: ~5-10M ops/sec (uncontended), ~1M ops/sec (contended) - Writes: Block all reads</p> <p>Konditional: - Reads: ~100M+ ops/sec (scales linearly with cores) - Writes: Don't block reads</p>"},{"location":"RegistryAndConcurrency/#testing-thread-safety","title":"Testing Thread Safety","text":""},{"location":"RegistryAndConcurrency/#concurrent-reads","title":"Concurrent Reads","text":"<pre><code>@Test\nfun `concurrent reads are safe`() = runBlocking {\n    val registry = FlagRegistry.create()\n\n    config(registry) {\n        Features.DARK_MODE with { default(false) }\n    }\n\n    val context = basicContext()\n\n    // Launch 1000 concurrent reads\n    val results = (1..1000).map {\n        async(Dispatchers.Default) {\n            context.evaluate(Features.DARK_MODE, registry)\n        }\n    }.awaitAll()\n\n    // All return same value\n    assertTrue(results.all { it == false })\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#concurrent-reads-write","title":"Concurrent Reads + Write","text":"<pre><code>@Test\nfun `concurrent reads during write are safe`() = runBlocking {\n    val registry = FlagRegistry.create()\n\n    config(registry) {\n        Features.DARK_MODE with { default(false) }\n    }\n\n    val context = basicContext()\n\n    // Launch 1000 concurrent readers\n    val readerJobs = (1..1000).map {\n        launch(Dispatchers.Default) {\n            repeat(100) {\n                context.evaluate(Features.DARK_MODE, registry)\n            }\n        }\n    }\n\n    // Concurrent write\n    val writerJob = launch(Dispatchers.Default) {\n        repeat(10) {\n            config(registry) {\n                Features.DARK_MODE with { default(true) }\n            }\n            delay(10)\n        }\n    }\n\n    // Wait for completion (no exceptions = success)\n    readerJobs.joinAll()\n    writerJob.join()\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#custom-registry-implementations","title":"Custom Registry Implementations","text":""},{"location":"RegistryAndConcurrency/#when-to-implement-custom-registry","title":"When to Implement Custom Registry","text":"<p>Use cases: - Database-backed configuration - Distributed cache (Redis, Memcached) - Multi-tenant registries (per-tenant config) - Audit logging (track all config changes)</p>"},{"location":"RegistryAndConcurrency/#example-database-backed-registry","title":"Example: Database-Backed Registry","text":"<pre><code>class DatabaseBackedRegistry(\n    private val database: Database\n) : FlagRegistry {\n\n    private val konfigRef = AtomicReference&lt;Konfig&gt;(loadFromDb())\n\n    override fun load(config: Konfig) {\n        // Write to database\n        database.transaction {\n            deleteAllFlags()\n            config.flags.forEach { (feature, definition) -&gt;\n                insertFlag(feature, definition)\n            }\n        }\n\n        // Update in-memory cache\n        konfigRef.set(config)\n    }\n\n    override fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;? {\n        // Read from in-memory cache (lock-free)\n        return konfigRef.get().flags[key]\n    }\n\n    private fun loadFromDb(): Konfig {\n        return database.query {\n            val flags = selectAllFlags()\n            Konfig(flags.associateBy { it.feature })\n        }\n    }\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#example-multi-tenant-registry","title":"Example: Multi-Tenant Registry","text":"<pre><code>class TenantAwareFlagRegistry(\n    private val tenantProvider: () -&gt; TenantId\n) : FlagRegistry {\n\n    private val registries = ConcurrentHashMap&lt;TenantId, AtomicReference&lt;Konfig&gt;&gt;()\n\n    override fun featureFlag(key: Feature&lt;S, T, C&gt;): FlagDefinition&lt;S, T, C&gt;? {\n        val tenantId = tenantProvider()\n        val konfigRef = registries.computeIfAbsent(tenantId) {\n            AtomicReference(Konfig.EMPTY)\n        }\n        return konfigRef.get().flags[key]\n    }\n\n    override fun load(config: Konfig) {\n        val tenantId = tenantProvider()\n        val konfigRef = registries.computeIfAbsent(tenantId) {\n            AtomicReference(Konfig.EMPTY)\n        }\n        konfigRef.set(config)\n    }\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#best-practices","title":"Best Practices","text":""},{"location":"RegistryAndConcurrency/#do-use-immutable-snapshots","title":"Do: Use Immutable Snapshots","text":"<pre><code>// \u2713 Good: Build complete config, then load atomically\nval newConfig = config {\n    Features.DARK_MODE with { default(false) }\n    Features.NEW_CHECKOUT with { default(false) }\n}\nFlagRegistry.load(newConfig)\n</code></pre>"},{"location":"RegistryAndConcurrency/#dont-update-flags-one-by-one","title":"Don't: Update Flags One-By-One","text":"<pre><code>// \u2717 Bad: Multiple updates = multiple intermediate states\nFeatures.DARK_MODE.update { default(false) }\nFeatures.NEW_CHECKOUT.update { default(false) }\n// Between updates, config is inconsistent!\n</code></pre>"},{"location":"RegistryAndConcurrency/#do-handle-parse-errors-before-applying","title":"Do: Handle Parse Errors Before Applying","text":"<pre><code>// \u2713 Good: Parse, validate, then apply\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        FlagRegistry.load(result.value)  // Only apply if valid\n    }\n    is ParseResult.Failure -&gt; {\n        logger.error(\"Parse error: ${result.error}\")\n        // Don't apply bad config\n    }\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#dont-apply-unvalidated-config","title":"Don't: Apply Unvalidated Config","text":"<pre><code>// \u2717 Bad: Runtime errors if JSON invalid\nval config = parseJsonUnsafe(json)  // May throw\nFlagRegistry.load(config)            // May have wrong types\n</code></pre>"},{"location":"RegistryAndConcurrency/#do-use-test-registries-for-tests","title":"Do: Use Test Registries for Tests","text":"<pre><code>// \u2713 Good: Isolated registry per test\n@Test\nfun `test feature`() {\n    val testRegistry = FlagRegistry.create()\n\n    config(testRegistry) {\n        Features.DARK_MODE with { default(false) }\n    }\n\n    val result = context.evaluate(Features.DARK_MODE, testRegistry)\n\n    assertFalse(result)\n}\n</code></pre>"},{"location":"RegistryAndConcurrency/#summary-concurrency-guarantees","title":"Summary: Concurrency Guarantees","text":"Aspect Guarantee Read safety Lock-free, no contention, scales linearly Write safety Atomic updates, consistent snapshots Read-write interaction Writes don't block reads Data consistency Readers see complete old OR new config, never mixed Memory safety Immutable data, no race conditions Performance ~100M+ reads/sec, &lt;10ns latency <p>Core Principle: Thread safety through immutability and atomic references, not locks.</p>"},{"location":"RegistryAndConcurrency/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Understand the type system</li> <li>Evaluation - How flags are evaluated</li> <li>Serialization - Remote config and JSON handling</li> <li>Testing - Test patterns and factories</li> </ul>"},{"location":"Rules/","title":"Rules &amp; Evaluables","text":"<p>Rules define targeting criteria and rollout strategies for feature flags. The Konditional rule system is built on a composable architecture that separates standard targeting (platform, locale, version) from custom domain logic through the <code>Evaluable</code> abstraction.</p>"},{"location":"Rules/#rule-fundamentals","title":"Rule Fundamentals","text":"<p>A Rule specifies conditions that must be met for a particular value to be returned. Rules combine:</p> <ul> <li>Standard targeting criteria (locale, platform, version)</li> <li>Custom evaluation logic through extensions</li> <li>Rollout percentage for gradual deployment</li> <li>Optional documentation notes</li> </ul> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n    locales(AppLocale.EN_US, AppLocale.EN_CA)\n    versions {\n        min(2, 0, 0)\n        max(3, 0, 0)\n    }\n    rollout = Rollout.of(50.0)\n    note(\"Mobile-only feature, 50% gradual rollout\")\n}.implies(true)\n</code></pre>"},{"location":"Rules/#basic-targeting","title":"Basic Targeting","text":""},{"location":"Rules/#platform-targeting","title":"Platform Targeting","text":"<p>Target specific platforms where your application runs:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n}.implies(mobileValue)\n\nrule {\n    platforms(Platform.WEB)\n}.implies(webValue)\n\nrule {\n    platforms(Platform.SERVER)\n}.implies(backendValue)\n</code></pre> <p>Available platforms: - <code>Platform.IOS</code> - <code>Platform.ANDROID</code> - <code>Platform.WEB</code> - <code>Platform.DESKTOP</code> - <code>Platform.SERVER</code></p>"},{"location":"Rules/#locale-targeting","title":"Locale Targeting","text":"<p>Target users based on language and region:</p> <pre><code>rule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA, AppLocale.EN_GB)\n}.implies(englishValue)\n\nrule {\n    locales(AppLocale.FR_FR, AppLocale.FR_CA)\n}.implies(frenchValue)\n\nrule {\n    locales(AppLocale.ES_ES, AppLocale.ES_MX)\n}.implies(spanishValue)\n</code></pre>"},{"location":"Rules/#version-targeting","title":"Version Targeting","text":"<p>Target specific version ranges using semantic versioning:</p> <pre><code>// Minimum version only\nrule {\n    versions {\n        min(2, 0, 0)  // Version 2.0.0 or higher\n    }\n}.implies(newFeatureValue)\n\n// Maximum version only\nrule {\n    versions {\n        max(2, 0, 0)  // Version 2.0.0 or lower\n    }\n}.implies(legacyValue)\n\n// Version range\nrule {\n    versions {\n        min(1, 5, 0)  // &gt;= 1.5.0\n        max(2, 0, 0)  // &lt;= 2.0.0\n    }\n}.implies(transitionValue)\n\n// Exact version\nrule {\n    versions {\n        min(2, 1, 3)\n        max(2, 1, 3)\n    }\n}.implies(specificVersionValue)\n</code></pre>"},{"location":"Rules/#combined-targeting","title":"Combined Targeting","text":"<p>Combine multiple criteria - all must match:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n    locales(AppLocale.EN_US)\n    versions {\n        min(2, 0, 0)\n    }\n}.implies(mobileEnglishV2Value)\n</code></pre>"},{"location":"Rules/#rollouts","title":"Rollouts","text":"<p>Rollouts enable gradual feature deployment to a percentage of users who match the rule criteria.</p>"},{"location":"Rules/#basic-rollout","title":"Basic Rollout","text":"<pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(25.0)  // 25% of iOS users\n}.implies(true)\n</code></pre>"},{"location":"Rules/#rollout-characteristics","title":"Rollout Characteristics","text":"<p>Deterministic: The same user (identified by <code>stableId</code>) always gets the same rollout assignment.</p> <pre><code>val user1 = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version(2, 0, 0),\n    stableId = StableId.of(\"user-123\")\n)\n\n// This user will always get the same result\nval result1 = user1.evaluateSafe(feature)  // Deterministic\nval result2 = user1.evaluateSafe(feature)  // Same as result1\n</code></pre> <p>Independent: Each flag has its own bucketing space. A user in the 25% rollout for one feature is independent of their assignment in another feature.</p> <p>Stable: Changing a flag's configuration does not affect rollout assignments unless you change the salt.</p>"},{"location":"Rules/#rollout-strategies","title":"Rollout Strategies","text":""},{"location":"Rules/#gradual-rollout","title":"Gradual Rollout","text":"<p>Increase rollout percentage over time:</p> <pre><code>// Phase 1: 10%\nconfig {\n    MyFeature.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.of(10.0)\n        }.implies(true)\n    }\n}\n\n// Phase 2: 50%\nconfig {\n    MyFeature.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n\n// Phase 3: 100%\nconfig {\n    MyFeature.NEW_CHECKOUT with {\n        default(false)\n        rule {\n            rollout = Rollout.MAX  // or Rollout.of(100.0)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#canary-deployment","title":"Canary Deployment","text":"<p>Test with a small percentage before wider rollout:</p> <pre><code>config {\n    MyFeature.RISKY_FEATURE with {\n        default(false)\n\n        // Canary: 1% of production users\n        rule {\n            rollout = Rollout.of(1.0)\n            note(\"Canary deployment - monitoring for issues\")\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#segmented-rollout","title":"Segmented Rollout","text":"<p>Different rollout percentages for different segments:</p> <pre><code>config {\n    MyFeature.BETA_FEATURE with {\n        default(false)\n\n        // 100% rollout for internal users\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext) =\n                        context.organizationId == \"internal\"\n                    override fun specificity() = 1\n                }\n            }\n            rollout = Rollout.MAX\n        }.implies(true)\n\n        // 25% rollout for enterprise customers\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext) =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n                    override fun specificity() = 1\n                }\n            }\n            rollout = Rollout.of(25.0)\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#rollout-salt","title":"Rollout Salt","text":"<p>The salt affects hash-based bucketing. Changing the salt redistributes users across rollout buckets:</p> <pre><code>config {\n    MyFeature.EXPERIMENT with {\n        default(false)\n        salt(\"v1\")  // Initial salt\n\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n\n// Change salt to redistribute users\nconfig {\n    MyFeature.EXPERIMENT with {\n        default(false)\n        salt(\"v2\")  // Different salt = different buckets\n\n        rule {\n            rollout = Rollout.of(50.0)\n        }.implies(true)\n    }\n}\n</code></pre> <p>Use cases for changing salt: - Reset an A/B test with fresh user assignments - Fix biased rollout distributions - Run a new experiment on the same feature</p>"},{"location":"Rules/#rule-evaluation-order","title":"Rule Evaluation Order","text":"<p>Rules are evaluated in order of specificity (highest first). When multiple rules match, the first matching rule (by specificity) determines the value.</p>"},{"location":"Rules/#specificity-calculation","title":"Specificity Calculation","text":"<p>Specificity is the sum of specified constraints:</p> <pre><code>// Specificity = 0 (no constraints)\nrule {\n    rollout = Rollout.MAX\n}.implies(value)\n\n// Specificity = 1 (one constraint)\nrule {\n    platforms(Platform.IOS)\n}.implies(value)\n\n// Specificity = 2 (two constraints)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n}.implies(value)\n\n// Specificity = 3 (three constraints)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n}.implies(value)\n\n// Custom extensions add to specificity\nrule {\n    platforms(Platform.IOS)  // +1\n    extension {  // +1 (from extension's specificity())\n        object : Evaluable&lt;Context&gt;() {\n            override fun matches(context: Context) = /* custom logic */\n            override fun specificity() = 1\n        }\n    }\n}.implies(value)  // Total specificity = 2\n</code></pre>"},{"location":"Rules/#evaluation-example","title":"Evaluation Example","text":"<pre><code>config {\n    MyFeature.THEME with {\n        default(\"light\")\n\n        // Specificity = 2, evaluated first\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n        }.implies(\"dark-us\")\n\n        // Specificity = 1, evaluated second\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"dark-ios\")\n\n        // Specificity = 1, evaluated third (tie broken by note alphabetically)\n        rule {\n            locales(AppLocale.EN_US)\n        }.implies(\"light-us\")\n    }\n}\n\n// Context: iOS + EN_US\n// Matches both rule 1 (specificity 2) and rule 2 (specificity 1)\n// Returns \"dark-us\" (highest specificity wins)\nval context1 = Context(\n    platform = Platform.IOS,\n    locale = AppLocale.EN_US,\n    // ...\n)\ncontext1.evaluateSafe(MyFeature.THEME)  // \"dark-us\"\n\n// Context: iOS + FR_FR\n// Matches only rule 2 (specificity 1)\n// Returns \"dark-ios\"\nval context2 = Context(\n    platform = Platform.IOS,\n    locale = AppLocale.FR_FR,\n    // ...\n)\ncontext2.evaluateSafe(MyFeature.THEME)  // \"dark-ios\"\n</code></pre>"},{"location":"Rules/#custom-extensions","title":"Custom Extensions","text":"<p>Extensions allow domain-specific targeting beyond standard criteria using the <code>Evaluable</code> abstraction.</p>"},{"location":"Rules/#evaluable-interface","title":"Evaluable Interface","text":"<pre><code>abstract class Evaluable&lt;C : Context&gt; {\n    open fun matches(context: C): Boolean = true\n    open fun specificity(): Int = 0\n}\n</code></pre>"},{"location":"Rules/#basic-extension","title":"Basic Extension","text":"<pre><code>rule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n            override fun specificity(): Int = 1\n        }\n    }\n}.implies(enterpriseValue)\n</code></pre>"},{"location":"Rules/#complex-extensions","title":"Complex Extensions","text":"<p>Combine multiple conditions:</p> <pre><code>rule {\n    platforms(Platform.WEB)\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean {\n                val isPremium = context.subscriptionTier in setOf(\n                    SubscriptionTier.PROFESSIONAL,\n                    SubscriptionTier.ENTERPRISE\n                )\n                val isAdmin = context.userRole in setOf(\n                    UserRole.ADMIN,\n                    UserRole.OWNER\n                )\n                return isPremium &amp;&amp; isAdmin\n            }\n\n            override fun specificity(): Int = 2  // Two conditions checked\n        }\n    }\n}.implies(premiumAdminValue)\n</code></pre>"},{"location":"Rules/#reusable-extensions","title":"Reusable Extensions","text":"<p>Define extension classes for reuse:</p> <pre><code>class SubscriptionTierEvaluable(\n    private val allowedTiers: Set&lt;SubscriptionTier&gt;\n) : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier in allowedTiers\n\n    override fun specificity(): Int = 1\n}\n\nclass UserRoleEvaluable(\n    private val allowedRoles: Set&lt;UserRole&gt;\n) : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.userRole in allowedRoles\n\n    override fun specificity(): Int = 1\n}\n\n// Use in rules\nconfig {\n    MyFeature.ADMIN_PANEL with {\n        default(false)\n\n        rule {\n            extension {\n                UserRoleEvaluable(setOf(UserRole.ADMIN, UserRole.OWNER))\n            }\n        }.implies(true)\n    }\n\n    MyFeature.PREMIUM_FEATURES with {\n        default(false)\n\n        rule {\n            extension {\n                SubscriptionTierEvaluable(setOf(\n                    SubscriptionTier.PROFESSIONAL,\n                    SubscriptionTier.ENTERPRISE\n                ))\n            }\n        }.implies(true)\n    }\n}\n</code></pre>"},{"location":"Rules/#rule-composition","title":"Rule Composition","text":"<p>Rules compose base targeting with custom extensions. Both must match for the rule to match.</p> <pre><code>rule {\n    // Base targeting (BaseEvaluable)\n    platforms(Platform.WEB)\n    locales(AppLocale.EN_US)\n\n    // Custom extension\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext) =\n                context.organizationId == \"enterprise-123\"\n            override fun specificity() = 1\n        }\n    }\n\n    // Rollout (checked after matching)\n    rollout = Rollout.of(50.0)\n}.implies(value)\n</code></pre> <p>Evaluation order: 1. Base targeting matches (platform, locale, version) 2. Extension matches (custom logic) 3. Rollout eligibility (hash-based bucketing)</p> <p>All three must succeed for the rule to select its value.</p>"},{"location":"Rules/#rule-notes","title":"Rule Notes","text":"<p>Add documentation to rules for clarity:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(25.0)\n    note(\"Gradual rollout to iOS users - Phase 1 of mobile launch\")\n}.implies(true)\n\nrule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext) =\n                context.organizationId in setOf(\"beta-tester-1\", \"beta-tester-2\")\n            override fun specificity() = 1\n        }\n    }\n    note(\"Beta testing with specific partner organizations\")\n}.implies(betaValue)\n</code></pre> <p>Notes are useful for: - Explaining complex targeting logic - Tracking rollout phases - Documenting business decisions - Debugging evaluation behavior</p>"},{"location":"Rules/#empty-rule-semantics","title":"Empty Rule Semantics","text":"<p>Empty constraints match everything:</p> <pre><code>// Matches all contexts (no constraints)\nrule {\n    rollout = Rollout.MAX\n}.implies(defaultValue)\n\n// Matches all platforms (locales empty)\nrule {\n    locales(AppLocale.EN_US)\n}.implies(englishValue)\n\n// Matches all versions (versionRange unbounded)\nrule {\n    platforms(Platform.IOS)\n}.implies(iosValue)\n</code></pre> <p>This \"match all\" semantic is useful for default rules or broad targeting.</p>"},{"location":"Rules/#best-practices","title":"Best Practices","text":""},{"location":"Rules/#order-rules-by-specificity","title":"Order Rules by Specificity","text":"<p>While Konditional handles this automatically, thinking in terms of specificity helps design clearer rules:</p> <pre><code>config {\n    MyFeature.VALUE with {\n        default(\"default\")\n\n        // Most specific: platform + locale + version\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n            versions { min(2, 0, 0) }\n        }.implies(\"specific\")\n\n        // Medium specific: platform + locale\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n        }.implies(\"medium\")\n\n        // Least specific: platform only\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"broad\")\n    }\n}\n</code></pre>"},{"location":"Rules/#use-extensions-for-domain-logic","title":"Use Extensions for Domain Logic","text":"<p>Keep standard targeting for platform/locale/version and use extensions for business logic:</p> <pre><code>// Good: Separation of concerns\nrule {\n    platforms(Platform.WEB)  // Standard targeting\n    extension {  // Domain logic\n        SubscriptionTierEvaluable(setOf(SubscriptionTier.ENTERPRISE))\n    }\n}.implies(value)\n\n// Avoid: Mixing concerns in one place would require custom rule types\n</code></pre>"},{"location":"Rules/#document-complex-rules","title":"Document Complex Rules","text":"<p>Use notes for rules with non-obvious logic:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;Context&gt;() {\n            override fun matches(context: Context) = /* complex logic */\n            override fun specificity() = 3\n        }\n    }\n    rollout = Rollout.of(15.0)\n    note(\"Targeting high-value users for premium feature test - approved by PM on 2024-01-15\")\n}.implies(premiumValue)\n</code></pre>"},{"location":"Rules/#test-rule-evaluation","title":"Test Rule Evaluation","text":"<p>Create unit tests for complex rule logic:</p> <pre><code>@Test\nfun `enterprise users get premium features`() {\n    val context = EnterpriseContext(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(2, 0, 0),\n        stableId = StableId.of(\"test-user\"),\n        subscriptionTier = SubscriptionTier.ENTERPRISE,\n        // ...\n    )\n\n    val result = context.evaluateSafe(MyFeature.PREMIUM_FEATURE)\n    assertTrue(result is EvaluationResult.Success &amp;&amp; result.value == true)\n}\n</code></pre>"},{"location":"Rules/#next-steps","title":"Next Steps","text":"<ul> <li>Flags: Learn about feature flag registration</li> <li>Builders: Master the rule DSL</li> <li>Context: Understand custom context extensions</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"Serialization/","title":"Serialization","text":"<p>Konditional provides JSON serialization for feature flag configurations, enabling external configuration management, snapshot storage, and dynamic updates.</p>"},{"location":"Serialization/#overview","title":"Overview","text":"<p>The serialization system allows you to:</p> <ul> <li>Export flag configurations to JSON</li> <li>Import configurations from JSON</li> <li>Apply incremental patches to existing configurations</li> <li>Store configurations in databases or file systems</li> <li>Load configurations from remote servers</li> </ul>"},{"location":"Serialization/#snapshotserializer","title":"SnapshotSerializer","text":"<p>The <code>SnapshotSerializer</code> class handles all serialization operations.</p>"},{"location":"Serialization/#creating-a-serializer","title":"Creating a Serializer","text":"<pre><code>// Use default instance\nval serializer = SnapshotSerializer.default\n\n// Or create with custom Moshi instance\nval customMoshi = Moshi.Builder()\n    // ... custom configuration\n    .build()\nval serializer = SnapshotSerializer(customMoshi)\n</code></pre>"},{"location":"Serialization/#serializing-configurations","title":"Serializing Configurations","text":""},{"location":"Serialization/#basic-serialization","title":"Basic Serialization","text":"<p>Export a <code>Konfig</code> to JSON:</p> <pre><code>// Build configuration\nval konfig = buildSnapshot {\n    MyFeatures.DARK_MODE with {\n        default(false)\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n}\n\n// Serialize to JSON\nval json = SnapshotSerializer.default.serialize(konfig)\n</code></pre>"},{"location":"Serialization/#serializing-from-registry","title":"Serializing from Registry","text":"<p>Export the current registry state:</p> <pre><code>// Get current configuration\nval currentKonfig = FlagRegistry.konfig()\n\n// Serialize\nval json = SnapshotSerializer.default.serialize(currentKonfig)\n\n// Save to file\nFile(\"flags.json\").writeText(json)\n</code></pre>"},{"location":"Serialization/#deserializing-configurations","title":"Deserializing Configurations","text":""},{"location":"Serialization/#basic-deserialization","title":"Basic Deserialization","text":"<p>Import configuration from JSON:</p> <pre><code>val json = File(\"flags.json\").readText()\n\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        val konfig = result.value\n        FlagRegistry.load(konfig)\n        println(\"Configuration loaded successfully\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Failed to parse: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"Serialization/#error-handling","title":"Error Handling","text":"<p>The deserialization API returns <code>ParseResult</code> for explicit error handling:</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n\nsealed interface ParseError {\n    data class InvalidJson(val message: String) : ParseError\n    data class InvalidSnapshot(val message: String) : ParseError\n    data class UnsupportedVersion(val version: String) : ParseError\n}\n</code></pre> <p>Usage:</p> <pre><code>val result = SnapshotSerializer.default.deserialize(json)\n\nresult.fold(\n    onSuccess = { konfig -&gt;\n        FlagRegistry.load(konfig)\n    },\n    onFailure = { error -&gt;\n        when (error) {\n            is ParseError.InvalidJson -&gt; logError(\"Malformed JSON: ${error.message}\")\n            is ParseError.InvalidSnapshot -&gt; logError(\"Invalid snapshot: ${error.message}\")\n            is ParseError.UnsupportedVersion -&gt; logError(\"Unsupported version: ${error.version}\")\n        }\n    }\n)\n</code></pre>"},{"location":"Serialization/#json-format","title":"JSON Format","text":""},{"location":"Serialization/#snapshot-structure","title":"Snapshot Structure","text":"<pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"dark_mode\",\n      \"valueType\": \"BOOLEAN\",\n      \"defaultValue\": false,\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"rules\": [\n        {\n          \"locales\": [],\n          \"platforms\": [\"IOS\"],\n          \"versionRange\": {\n            \"type\": \"UNBOUNDED\"\n          },\n          \"rollout\": 100.0,\n          \"note\": \"iOS users get dark mode\",\n          \"value\": true\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"Serialization/#version-ranges","title":"Version Ranges","text":"<pre><code>// Unbounded (all versions)\n{\n  \"type\": \"UNBOUNDED\"\n}\n\n// Minimum bound (&gt;= 2.0.0)\n{\n  \"type\": \"MIN_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n\n// Maximum bound (&lt;= 3.0.0)\n{\n  \"type\": \"MAX_BOUND\",\n  \"max\": {\n    \"major\": 3,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n\n// Fully bound (&gt;= 2.0.0 and &lt;= 3.0.0)\n{\n  \"type\": \"MIN_AND_MAX_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  },\n  \"max\": {\n    \"major\": 3,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre>"},{"location":"Serialization/#value-types","title":"Value Types","text":"<pre><code>// Boolean\n{\n  \"valueType\": \"BOOLEAN\",\n  \"defaultValue\": false,\n  \"rules\": [\n    {\n      \"value\": true\n    }\n  ]\n}\n\n// String\n{\n  \"valueType\": \"STRING\",\n  \"defaultValue\": \"production\",\n  \"rules\": [\n    {\n      \"value\": \"staging\"\n    }\n  ]\n}\n\n// Integer\n{\n  \"valueType\": \"INTEGER\",\n  \"defaultValue\": 30,\n  \"rules\": [\n    {\n      \"value\": 60\n    }\n  ]\n}\n\n// Decimal\n{\n  \"valueType\": \"DECIMAL\",\n  \"defaultValue\": 0.5,\n  \"rules\": [\n    {\n      \"value\": 0.75\n    }\n  ]\n}\n\n// JSON Object\n{\n  \"valueType\": \"JSON\",\n  \"defaultValue\": {\n    \"baseUrl\": \"https://api.prod.example.com\",\n    \"timeout\": 30\n  },\n  \"rules\": [\n    {\n      \"value\": {\n        \"baseUrl\": \"https://api.staging.example.com\",\n        \"timeout\": 60\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"Serialization/#patches","title":"Patches","text":"<p>Apply incremental updates to configurations without replacing the entire snapshot.</p>"},{"location":"Serialization/#creating-patches","title":"Creating Patches","text":"<p>Patches are not directly created via DSL but through the internal serialization model. However, you can apply patches from JSON:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"new_feature\",\n      \"valueType\": \"BOOLEAN\",\n      \"defaultValue\": false,\n      \"isActive\": true,\n      \"salt\": \"v1\",\n      \"rules\": []\n    }\n  ],\n  \"removeKeys\": [\"old_feature\"]\n}\n</code></pre>"},{"location":"Serialization/#applying-patches","title":"Applying Patches","text":"<pre><code>// Get current configuration\nval currentKonfig = FlagRegistry.konfig()\n\n// Apply patch from JSON\nval patchJson = \"\"\"\n{\n  \"flags\": [...],\n  \"removeKeys\": [...]\n}\n\"\"\".trimIndent()\n\nwhen (val result = SnapshotSerializer.default.applyPatchJson(currentKonfig, patchJson)) {\n    is ParseResult.Success -&gt; {\n        val updatedKonfig = result.value\n        FlagRegistry.load(updatedKonfig)\n    }\n    is ParseResult.Failure -&gt; {\n        logError(\"Failed to apply patch: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"Serialization/#remote-configuration","title":"Remote Configuration","text":""},{"location":"Serialization/#loading-from-remote-server","title":"Loading from Remote Server","text":"<pre><code>class RemoteConfigLoader(\n    private val apiClient: HttpClient,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    suspend fun loadConfiguration(url: String): Result&lt;Konfig&gt; {\n        return try {\n            val json = apiClient.get(url).bodyAsText()\n            when (val result = serializer.deserialize(json)) {\n                is ParseResult.Success -&gt; Result.success(result.value)\n                is ParseResult.Failure -&gt; Result.failure(\n                    ConfigurationException(\"Parse error: ${result.error}\")\n                )\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n\n    suspend fun applyRemotePatch(patchUrl: String): Result&lt;Unit&gt; {\n        return try {\n            val patchJson = apiClient.get(patchUrl).bodyAsText()\n            val currentKonfig = FlagRegistry.konfig()\n\n            when (val result = serializer.applyPatchJson(currentKonfig, patchJson)) {\n                is ParseResult.Success -&gt; {\n                    FlagRegistry.load(result.value)\n                    Result.success(Unit)\n                }\n                is ParseResult.Failure -&gt; Result.failure(\n                    ConfigurationException(\"Patch error: ${result.error}\")\n                )\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>val loader = RemoteConfigLoader(httpClient)\n\n// Initial load\nloader.loadConfiguration(\"https://config.example.com/flags.json\")\n    .onSuccess { konfig -&gt;\n        FlagRegistry.load(konfig)\n        println(\"Configuration loaded\")\n    }\n    .onFailure { error -&gt;\n        logError(\"Failed to load configuration\", error)\n    }\n\n// Apply incremental update\nloader.applyRemotePatch(\"https://config.example.com/patches/123.json\")\n    .onSuccess {\n        println(\"Patch applied\")\n    }\n    .onFailure { error -&gt;\n        logError(\"Failed to apply patch\", error)\n    }\n</code></pre>"},{"location":"Serialization/#polling-for-updates","title":"Polling for Updates","text":"<pre><code>class ConfigurationPoller(\n    private val loader: RemoteConfigLoader,\n    private val pollIntervalMs: Long = 60_000\n) {\n    private var pollingJob: Job? = null\n\n    fun startPolling(configUrl: String, scope: CoroutineScope) {\n        pollingJob = scope.launch {\n            while (isActive) {\n                try {\n                    loader.loadConfiguration(configUrl)\n                        .onSuccess { konfig -&gt;\n                            FlagRegistry.load(konfig)\n                            logInfo(\"Configuration updated\")\n                        }\n                        .onFailure { error -&gt;\n                            logError(\"Poll failed\", error)\n                        }\n                } catch (e: Exception) {\n                    logError(\"Polling error\", e)\n                }\n\n                delay(pollIntervalMs)\n            }\n        }\n    }\n\n    fun stopPolling() {\n        pollingJob?.cancel()\n        pollingJob = null\n    }\n}\n</code></pre>"},{"location":"Serialization/#database-storage","title":"Database Storage","text":""},{"location":"Serialization/#storing-configurations","title":"Storing Configurations","text":"<pre><code>class ConfigurationRepository(\n    private val database: Database,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    fun saveConfiguration(name: String, konfig: Konfig) {\n        val json = serializer.serialize(konfig)\n        database.execute(\n            \"INSERT INTO configurations (name, json, updated_at) VALUES (?, ?, ?) \" +\n            \"ON CONFLICT (name) DO UPDATE SET json = ?, updated_at = ?\",\n            name, json, Instant.now(), json, Instant.now()\n        )\n    }\n\n    fun loadConfiguration(name: String): Konfig? {\n        val json = database.queryString(\n            \"SELECT json FROM configurations WHERE name = ?\",\n            name\n        ) ?: return null\n\n        return when (val result = serializer.deserialize(json)) {\n            is ParseResult.Success -&gt; result.value\n            is ParseResult.Failure -&gt; {\n                logError(\"Failed to deserialize configuration: ${result.error}\")\n                null\n            }\n        }\n    }\n\n    fun listConfigurations(): List&lt;String&gt; {\n        return database.queryList(\n            \"SELECT name FROM configurations ORDER BY name\"\n        )\n    }\n}\n</code></pre>"},{"location":"Serialization/#versioning-configurations","title":"Versioning Configurations","text":"<p>Track configuration versions:</p> <pre><code>data class VersionedConfiguration(\n    val version: Int,\n    val timestamp: Instant,\n    val konfig: Konfig,\n    val author: String,\n    val description: String\n)\n\nclass VersionedConfigurationRepository(\n    private val database: Database,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    fun saveVersion(config: VersionedConfiguration) {\n        val json = serializer.serialize(config.konfig)\n        database.execute(\n            \"\"\"\n            INSERT INTO configuration_versions\n            (version, timestamp, json, author, description)\n            VALUES (?, ?, ?, ?, ?)\n            \"\"\",\n            config.version,\n            config.timestamp,\n            json,\n            config.author,\n            config.description\n        )\n    }\n\n    fun loadVersion(version: Int): VersionedConfiguration? {\n        return database.queryOne(\n            \"\"\"\n            SELECT version, timestamp, json, author, description\n            FROM configuration_versions\n            WHERE version = ?\n            \"\"\",\n            version\n        ) { rs -&gt;\n            val json = rs.getString(\"json\")\n            when (val result = serializer.deserialize(json)) {\n                is ParseResult.Success -&gt; VersionedConfiguration(\n                    version = rs.getInt(\"version\"),\n                    timestamp = rs.getInstant(\"timestamp\"),\n                    konfig = result.value,\n                    author = rs.getString(\"author\"),\n                    description = rs.getString(\"description\")\n                )\n                is ParseResult.Failure -&gt; null\n            }\n        }\n    }\n\n    fun rollback(toVersion: Int) {\n        loadVersion(toVersion)?.let { config -&gt;\n            FlagRegistry.load(config.konfig)\n            logInfo(\"Rolled back to version $toVersion\")\n        }\n    }\n}\n</code></pre>"},{"location":"Serialization/#best-practices","title":"Best Practices","text":""},{"location":"Serialization/#validation","title":"Validation","text":"<p>Validate configurations after deserialization:</p> <pre><code>fun validateConfiguration(konfig: Konfig): List&lt;String&gt; {\n    val errors = mutableListOf&lt;String&gt;()\n\n    konfig.flags.forEach { (feature, definition) -&gt;\n        // Check for required flags\n        if (feature.key in requiredFlags &amp;&amp; !definition.isActive) {\n            errors.add(\"Required flag ${feature.key} is inactive\")\n        }\n\n        // Validate rollout percentages\n        definition.values.forEach { conditionalValue -&gt;\n            if (conditionalValue.rule.rollout.value !in 0.0..100.0) {\n                errors.add(\"Invalid rollout for ${feature.key}: ${conditionalValue.rule.rollout.value}\")\n            }\n        }\n    }\n\n    return errors\n}\n\n// Use validation\nwhen (val result = SnapshotSerializer.default.deserialize(json)) {\n    is ParseResult.Success -&gt; {\n        val errors = validateConfiguration(result.value)\n        if (errors.isEmpty()) {\n            FlagRegistry.load(result.value)\n        } else {\n            logError(\"Configuration validation failed: $errors\")\n        }\n    }\n    is ParseResult.Failure -&gt; logError(\"Parse error: ${result.error}\")\n}\n</code></pre>"},{"location":"Serialization/#backup-and-restore","title":"Backup and Restore","text":"<p>Implement backup mechanism:</p> <pre><code>class ConfigurationBackup(\n    private val backupDir: File,\n    private val serializer: SnapshotSerializer = SnapshotSerializer.default\n) {\n    fun backup(name: String = \"backup-${Instant.now().epochSecond}\") {\n        val konfig = FlagRegistry.konfig()\n        val json = serializer.serialize(konfig)\n        val backupFile = File(backupDir, \"$name.json\")\n        backupFile.writeText(json)\n        logInfo(\"Configuration backed up to ${backupFile.absolutePath}\")\n    }\n\n    fun restore(name: String): Boolean {\n        val backupFile = File(backupDir, \"$name.json\")\n        if (!backupFile.exists()) {\n            logError(\"Backup file not found: $name\")\n            return false\n        }\n\n        val json = backupFile.readText()\n        return when (val result = serializer.deserialize(json)) {\n            is ParseResult.Success -&gt; {\n                FlagRegistry.load(result.value)\n                logInfo(\"Configuration restored from $name\")\n                true\n            }\n            is ParseResult.Failure -&gt; {\n                logError(\"Failed to restore: ${result.error}\")\n                false\n            }\n        }\n    }\n\n    fun listBackups(): List&lt;String&gt; {\n        return backupDir.listFiles { file -&gt; file.extension == \"json\" }\n            ?.map { it.nameWithoutExtension }\n            ?.sorted()\n            ?: emptyList()\n    }\n}\n</code></pre>"},{"location":"Serialization/#testing-serialization","title":"Testing Serialization","text":"<p>Test serialization round-trips:</p> <pre><code>@Test\nfun `serialization round-trip preserves configuration`() {\n    val original = buildSnapshot {\n        MyFeatures.DARK_MODE with {\n            default(false)\n            rule {\n                platforms(Platform.IOS)\n                locales(AppLocale.EN_US)\n                versions {\n                    min(2, 0, 0)\n                }\n                rollout = Rollout.of(50.0)\n            }.implies(true)\n        }\n    }\n\n    // Serialize\n    val json = SnapshotSerializer.default.serialize(original)\n\n    // Deserialize\n    val result = SnapshotSerializer.default.deserialize(json)\n    assertTrue(result is ParseResult.Success)\n\n    val deserialized = (result as ParseResult.Success).value\n\n    // Compare\n    assertEquals(original.flags.size, deserialized.flags.size)\n    // ... additional assertions\n}\n</code></pre>"},{"location":"Serialization/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture: Understand how serialization fits into the overall design</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"WhyTypeSafety/","title":"Why Type Safety Matters","text":""},{"location":"WhyTypeSafety/#the-problem-string-based-configuration","title":"The Problem: String-Based Configuration","text":"<p>If your team currently uses string-based configuration or feature flags, you're likely experiencing these runtime errors regularly:</p> <pre><code>// Common string-based approach\nval enabled = config.getBoolean(\"dark_mode\")\nval endpoint = config.getString(\"api_endpoint\")\nval timeout = config.getInt(\"timeout_ms\")\n</code></pre>"},{"location":"WhyTypeSafety/#the-hidden-costs","title":"The Hidden Costs","text":"<p>Every string lookup carries six critical failure modes that your team deals with daily:</p> Error Type Example Impact Typos <code>\"dakr_mode\"</code> instead of <code>\"dark_mode\"</code> Silent failures, wrong defaults used Type Mismatches <code>getBoolean(\"timeout_ms\")</code> when it's an Int Runtime crashes or ClassCastException Null Handling <code>getString(\"endpoint\") ?: \"default\"</code> everywhere Defensive code bloat, missed edge cases Refactoring Breaks Rename <code>\"api_url\"</code> \u2192 <code>\"api_endpoint\"</code> Silent failures across codebase No Auto-Complete No IDE assistance for flag names Slow development, copy-paste errors Invisible Dependencies What context does <code>\"premium_feature\"</code> need? Runtime errors when context is wrong"},{"location":"WhyTypeSafety/#the-solution-compile-time-guarantees","title":"The Solution: Compile-Time Guarantees","text":"<p>Konditional eliminates all six failure modes by making errors impossible to represent in the type system.</p> <pre><code>//  Type-safe approach\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\nval enabled: Boolean = context.evaluate(Features.DARK_MODE)\n</code></pre>"},{"location":"WhyTypeSafety/#what-you-get","title":"What You Get","text":""},{"location":"WhyTypeSafety/#1-typos-become-compile-errors","title":"1. Typos Become Compile Errors","text":"<pre><code>// String-based: Compiles, fails at runtime\nif (config.getBoolean(\"dakr_mode\")) { }\n\n//  Type-safe: Won't compile\ncontext.evaluate(Features.DAKR_MODE)  // Compile error: Unresolved reference\n</code></pre>"},{"location":"WhyTypeSafety/#2-type-mismatches-are-impossible","title":"2. Type Mismatches Are Impossible","text":"<pre><code>// String-based: Runtime ClassCastException\nval timeout: Int = config.getBoolean(\"timeout_ms\")  // Compiles! \ud83d\udca3\n\n//  Type-safe: Compiler prevents this\nenum class Config(override val key: String) : Conditional&lt;Int, Context&gt; {\n    TIMEOUT_MS(\"timeout_ms\")\n}\n\nval timeout: Boolean = context.evaluate(Config.TIMEOUT_MS)  // \u2717 Type mismatch\nval timeout: Int = context.evaluate(Config.TIMEOUT_MS)      // \u2713 Correct\n</code></pre>"},{"location":"WhyTypeSafety/#3-no-more-null-checks","title":"3. No More Null Checks","text":"<pre><code>// String-based: Nullability everywhere\nval endpoint = config.getString(\"api_endpoint\") ?: \"https://default.com\"\nval timeout = config.getInt(\"timeout_ms\") ?: 5000\n\n//  Type-safe: Defaults enforced at definition\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\")\n}\n\nconfig {\n    ApiConfig.ENDPOINT with {\n        default(\"https://default.com\")  // Required at compile time\n    }\n}\n\n// Guaranteed non-null\nval endpoint: String = context.evaluate(ApiConfig.ENDPOINT)\n</code></pre>"},{"location":"WhyTypeSafety/#4-refactoring-is-safe","title":"4. Refactoring Is Safe","text":"<pre><code>// String-based: Rename breaks at runtime\nconfig.getBoolean(\"dark_mode\")  // Old name\nconfig.getBoolean(\"darkMode\")   // New name - silent failure\n\n//  Type-safe: IDE refactoring updates all references\nenum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")  // Rename symbol \u2192 all usages update\n}\n</code></pre>"},{"location":"WhyTypeSafety/#5-ide-auto-complete","title":"5. IDE Auto-Complete","text":"<pre><code>// String-based: No IDE help\nconfig.getBoolean(\"???\")  // What flags exist?\n\n//  Type-safe: Full IDE support\ncontext.evaluate(Features.  // IDE shows: DARK_MODE, NEW_CHECKOUT, PREMIUM_EXPORT\n</code></pre>"},{"location":"WhyTypeSafety/#6-context-requirements-are-explicit","title":"6. Context Requirements Are Explicit","text":"<pre><code>// String-based: Runtime error if wrong context\nval enabled = config.getBoolean(\"enterprise_analytics\")  // What context needed?\n\n//  Type-safe: Compiler enforces context type\ndata class EnterpriseContext(\n    val subscriptionTier: Tier,\n    // ... other enterprise fields\n) : Context\n\nenum class EnterpriseFeatures(override val key: String)\n    : Conditional&lt;Boolean, EnterpriseContext&gt; {  // \u2190 Type parameter\n    ADVANCED_ANALYTICS(\"enterprise_analytics\")\n}\n\nval basicContext: Context = // ...\nval enterpriseContext: EnterpriseContext = // ...\n\n// Compile error: Type mismatch\nbasicContext.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)  // \u2717\n\n// Compiles: Context type matches\nenterpriseContext.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)  // \u2713\n</code></pre>"},{"location":"WhyTypeSafety/#what-errors-are-completely-eliminated","title":"What Errors Are Completely Eliminated?","text":""},{"location":"WhyTypeSafety/#eliminated-runtime-errors","title":"Eliminated: Runtime Errors","text":"Error Class String-Based Type-Safe NullPointerException Missing flag returns <code>null</code> Default value required at compile time ClassCastException Wrong type getter used Generic type parameter enforced KeyNotFoundException Typo in flag name Enum reference or compile error Wrong Context Errors Flag needs enterprise context, basic context passed Context type parameter enforced Silent Wrong Defaults Typo returns <code>null</code>, default used silently No such code compiles"},{"location":"WhyTypeSafety/#new-guarantees-you-can-make","title":"New Guarantees You Can Make","text":"Statement Confidence \"This flag always returns a non-null value\" 100% - Compiler enforces default \"This flag's type matches the variable\" 100% - Generic type parameter checked \"This flag name exists\" 100% - Enum member or compile error \"This evaluation has the right context\" 100% - Type parameter enforced \"Refactoring updated all usages\" 100% - IDE symbol rename"},{"location":"WhyTypeSafety/#support-for-your-existing-types","title":"Support for Your Existing Types","text":"<p>Konditional isn't just for booleans. It supports:</p>"},{"location":"WhyTypeSafety/#primitive-types","title":"Primitive Types","text":"<pre><code>enum class Flags : Conditional&lt;Boolean, Context&gt; { ENABLED }\nenum class ApiConfig : Conditional&lt;String, Context&gt; { ENDPOINT }\nenum class Limits : Conditional&lt;Int, Context&gt; { MAX_RETRIES }\nenum class Thresholds : Conditional&lt;Double, Context&gt; { TIMEOUT_SECONDS }\n</code></pre>"},{"location":"WhyTypeSafety/#complex-data-classes","title":"Complex Data Classes","text":"<pre><code>data class ThemeConfig(\n    val primaryColor: String,\n    val fontSize: Int,\n    val darkMode: Boolean\n)\n\nenum class Theme(override val key: String) : Conditional&lt;ThemeConfig, Context&gt; {\n    APP_THEME(\"app_theme\")\n}\n\n// Type-safe configuration\nconfig {\n    Theme.APP_THEME with {\n        default(ThemeConfig(\"#FFFFFF\", 14, false))\n\n        rule {\n            platforms(Platform.IOS)\n        }.implies(ThemeConfig(\"#1E1E1E\", 16, true))\n    }\n}\n</code></pre>"},{"location":"WhyTypeSafety/#custom-domain-types","title":"Custom Domain Types","text":"<pre><code>@JvmInline\nvalue class UserId(val value: String)\n\nenum class UserConfig(override val key: String)\n    : Conditional&lt;UserId, Context&gt; {\n    ADMIN_ID(\"admin_user_id\")\n}\n</code></pre>"},{"location":"WhyTypeSafety/#the-parse-dont-validate-principle","title":"The \"Parse, Don't Validate\" Principle","text":"<p>Konditional follows the \"Parse, Don't Validate\" pattern:</p> <p>Invalid states are unrepresentable in the type system.</p> <pre><code>// String-based: Validation everywhere\nfun processConfig() {\n    val value = config.getString(\"threshold\")\n    if (value == null) throw ConfigException(\"Missing threshold\")\n\n    val parsed = value.toDoubleOrNull()\n    if (parsed == null) throw ConfigException(\"Invalid threshold\")\n\n    if (parsed &lt; 0 || parsed &gt; 100) throw ConfigException(\"Out of range\")\n\n    // Finally use it\n    applyThreshold(parsed)\n}\n\n//  Type-safe: Invalid states don't compile\nenum class Config(override val key: String) : Conditional&lt;Double, Context&gt; {\n    THRESHOLD(\"threshold\")\n}\n\nconfig {\n    Config.THRESHOLD with {\n        default(50.0)  // Guaranteed at compile time\n    }\n}\n\nfun processConfig() {\n    val value: Double = context.evaluate(Config.THRESHOLD)\n    applyThreshold(value)  // No validation needed!\n}\n</code></pre>"},{"location":"WhyTypeSafety/#real-world-impact","title":"Real-World Impact","text":""},{"location":"WhyTypeSafety/#before-string-based-system","title":"Before: String-Based System","text":"<pre><code>class FeatureManager(private val config: ConfigService) {\n    fun isDarkModeEnabled(): Boolean {\n        // Risk: Typo, null handling, wrong type\n        return config.getBoolean(\"dark_mode\") ?: false\n    }\n\n    fun getApiEndpoint(platform: String): String {\n        // Risk: String matching, multiple lookups, nulls\n        return when (platform) {\n            \"ios\" -&gt; config.getString(\"ios_api_endpoint\") ?: DEFAULT_IOS\n            \"android\" -&gt; config.getString(\"android_api_endpoint\") ?: DEFAULT_ANDROID\n            else -&gt; config.getString(\"api_endpoint\") ?: DEFAULT_GLOBAL\n        }\n    }\n\n    fun canExportData(userId: String, tier: String): Boolean {\n        // Risk: Business logic mixed with config, unclear requirements\n        val baseEnabled = config.getBoolean(\"export_enabled\") ?: false\n        val premiumOnly = config.getBoolean(\"export_premium_only\") ?: true\n\n        return baseEnabled &amp;&amp; (!premiumOnly || tier == \"premium\")\n    }\n}\n</code></pre> <p>Issues: - 6 different flags that could have typos - 6 null checks required - Business logic scattered across config lookups - No IDE help for flag names - Context requirements unclear - Testing requires mocking entire config service</p>"},{"location":"WhyTypeSafety/#after-type-safe-system","title":"After: Type-Safe System","text":"<pre><code>enum class Features(override val key: String) : Conditional&lt;Boolean, Context&gt; {\n    DARK_MODE(\"dark_mode\")\n}\n\nenum class ApiConfig(override val key: String) : Conditional&lt;String, Context&gt; {\n    ENDPOINT(\"api_endpoint\")\n}\n\ndata class EnterpriseContext(\n    val subscriptionTier: Tier,\n    // ... base context fields\n) : Context\n\nenum class EnterpriseFeatures(override val key: String)\n    : Conditional&lt;Boolean, EnterpriseContext&gt; {\n    DATA_EXPORT(\"export_enabled\")\n}\n\nclass FeatureManager(private val context: Context) {\n    fun isDarkModeEnabled(): Boolean =\n        context.evaluate(Features.DARK_MODE)  // \u2713 Type-safe, non-null\n\n    fun getApiEndpoint(): String =\n        context.evaluate(ApiConfig.ENDPOINT)  // \u2713 Platform handled in rules\n}\n\nclass EnterpriseFeatureManager(private val context: EnterpriseContext) {\n    fun canExportData(): Boolean =\n        context.evaluate(EnterpriseFeatures.DATA_EXPORT)  // \u2713 Business logic in rules\n}\n\n// Configuration defined separately\nconfig {\n    Features.DARK_MODE with {\n        default(false)\n        rule {\n            platforms(Platform.IOS)\n        }.implies(true)\n    }\n\n    ApiConfig.ENDPOINT with {\n        default(\"https://api.prod.example.com\")\n        rule {\n            platforms(Platform.IOS)\n        }.implies(\"https://api-ios.prod.example.com\")\n        rule {\n            platforms(Platform.ANDROID)\n        }.implies(\"https://api-android.prod.example.com\")\n    }\n\n    EnterpriseFeatures.DATA_EXPORT with {\n        default(false)\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == Tier.PREMIUM\n                    override fun specificity(): Int = 1\n                }\n            }\n        }.implies(true)\n    }\n}\n</code></pre> <p>Benefits: -  Zero null checks -  Zero type errors possible -  Full IDE auto-complete -  Business logic declarative in rules -  Context requirements explicit in types -  Testing uses simple context objects</p>"},{"location":"WhyTypeSafety/#next-steps","title":"Next Steps","text":"<p>Ready to eliminate runtime config errors from your codebase?</p> <ol> <li>Migration Guide - Step-by-step migration from string-based config</li> <li>Quick Start - Get running in 5 minutes</li> <li>Error Prevention Reference - Complete catalog of eliminated errors</li> </ol> <p>Key Principle: If it compiles, it works. No runtime configuration errors.</p>"}]}