{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"01-getting-started/","title":"Getting Started","text":"<p>Type-safe flags in 5 minutes. If it compiles, it works\u2014no runtime errors, no null checks, no string typos.</p>"},{"location":"01-getting-started/#why-konditional","title":"Why Konditional?","text":"<p>Most feature flag systems use runtime strings. Konditional uses compile-time properties instead.</p> Feature String-Based (Custom) Konditional Type Safety Exclusively booleans, drives branching explosion in reality Compile-time safety allows runtime usage without risk <code>feature { Features.FLAG }</code> Evaluation Hardcoded via boolean flows Dynamic and generic, maintaining rigor of type-checking Context Enum class with string keys Typed data classes with IDE autocomplete Performance Shared module forces full-rebuild at compile-time, unable to leverage cache Module changes to flags are not invalidating of task-graph for parent Organization Prefixing, shared single source by all Namespaces (compile-time isolated), with type-enforced boundaries, infitinitely divisible Errors Silent failures, null checks, type casting Guarnteed valid startup config, Update failures emerge before update, during parsing <p>Core benefits:  * No more invalid configurations, instead, compile errors. * First-class Gradle caching support * Modules own the feature flags they are concerned with * Unified, single-source, for all flagging * Your IDE knows everything. * Built to scale to multi-tenancy, seamlessly</p>"},{"location":"01-getting-started/#installation","title":"Installation","text":"<pre><code>// build.gradle.kts\ndependencies {\n    implementation(\"io.amichne:konditional:0.0.1\")\n}\n</code></pre>"},{"location":"01-getting-started/#your-first-flag","title":"Your First Flag","text":"<p>Define flags as properties. The compiler enforces types:</p> <pre><code>import io.amichne.konditional.core.features.FeatureContainer\nimport io.amichne.konditional.core.Namespace\nimport io.amichne.konditional.context.*\n\nobject AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            rollout { 50.0 }\n        } returns true\n    }\n}\n\n// Create context (required for evaluation)\nval context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n\n// Evaluate - returns Boolean, never null\nval enabled: Boolean = feature { AppFeatures.DARK_MODE }\n</code></pre> <p>vs String-Based Systems: <pre><code>// String-based - runtime lookup, can typo, type unknown\nval enabled = featureFlags.getBoolean(\"dark-mode\", false)  // No IDE help, typos fail silently\n\n// Konditional - compile-time property, autocomplete works\nval enabled = feature { AppFeatures.DARK_MODE }  // IDE knows it's Boolean\n</code></pre></p>"},{"location":"01-getting-started/#multiple-types","title":"Multiple Types","text":"<p>All primitives work out of the box:</p> <pre><code>object AppConfig : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.example.com\")\n    val MAX_RETRIES by int(default = 3)\n    val TIMEOUT by double(default = 30.0)\n}\n</code></pre> <p>Each flag is typed\u2014you can't accidentally treat a string as a boolean.</p>"},{"location":"01-getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"01-getting-started/#pattern-1-gradual-rollout","title":"Pattern 1: Gradual Rollout","text":"<p>Ship to 10% of users, then expand:</p> <pre><code>val NEW_CHECKOUT by boolean(default = false) {\n    rule {\n        platforms(Platform.ANDROID)\n        rollout { 10.0 }  // Start small\n    } returns true\n}\n\n// Later: increase to 50%\n// Same users stay enabled (deterministic SHA-256 bucketing)\n</code></pre>"},{"location":"01-getting-started/#pattern-2-platform-specific-config","title":"Pattern 2: Platform-Specific Config","text":"<p>Different values per platform:</p> <pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n    rule { platforms(Platform.WEB) } returns \"https://api-web.example.com\"\n}\n</code></pre>"},{"location":"01-getting-started/#pattern-3-ab-testing","title":"Pattern 3: A/B Testing","text":"<p>Split traffic 50/50:</p> <pre><code>val RECOMMENDATION_ALGO by string(default = \"collaborative\") {\n    rule { rollout { 50.0 } } returns \"content-based\"\n}\n// Same user always gets same variant (deterministic)\n</code></pre>"},{"location":"01-getting-started/#evaluation-methods","title":"Evaluation Methods","text":"<pre><code>// Simple evaluation with default\nval enabled = feature { AppFeatures.DARK_MODE }\n</code></pre>"},{"location":"01-getting-started/#organizing-by-teamdomain","title":"Organizing by Team/Domain","text":"<p>Use namespaces to isolate features:</p> <pre><code>object AuthFeatures : FeatureContainer&lt;Namespace.Authentication&gt;(\n    Namespace.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Namespace.Payments&gt;(\n    Namespace.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n}\n</code></pre> <p>Benefits: - Features can't collide across namespaces - Each team owns their namespace - Type system prevents cross-namespace access mistakes</p>"},{"location":"01-getting-started/#key-differentiators","title":"Key Differentiators","text":""},{"location":"01-getting-started/#1-compile-time-safety","title":"1. Compile-Time Safety","text":"<p>String-based: <code>getFlag(\"flag-name\")</code> \u2014 Typos fail at runtime (or silently return defaults) Konditional: <code>feature { Features.DARK_MODE }</code> \u2014 Typos fail at compile time</p>"},{"location":"01-getting-started/#2-offline-first-architecture","title":"2. Offline-First Architecture","text":"<p>String-based (LaunchDarkly/Statsig): Network call or cache required for evaluation Konditional: All evaluation happens locally. Zero network dependency.</p>"},{"location":"01-getting-started/#3-zero-allocation-evaluation","title":"3. Zero-Allocation Evaluation","text":"<p>String-based: HashMap lookups, type casting, object creation per evaluation Konditional: Immutable data structures, lock-free reads, no GC pressure</p>"},{"location":"01-getting-started/#4-type-safe-contexts","title":"4. Type-Safe Contexts","text":"<p>String-based: <code>context.put(\"tier\", \"enterprise\")</code> \u2014 String keys, Any values, no validation Konditional: <pre><code>data class EnterpriseContext(\n    // ... standard fields ...\n    val subscriptionTier: SubscriptionTier  // Enum, not string - compile-time validated\n) : Context\n</code></pre></p>"},{"location":"01-getting-started/#5-deterministic-rollouts","title":"5. Deterministic Rollouts","text":"<p>Most systems use hashing, but Konditional's SHA-256 bucketing is: - Platform-stable (same buckets on JVM, Android, iOS, Web) - Independent per flag (user in 50% of Flag A \u2260 in 50% of Flag B) - Salt-controllable (change salt to redistribute users)</p>"},{"location":"01-getting-started/#next-steps","title":"Next Steps","text":"<p>Just getting started? You're done! Start adding flags to your code.</p> <p>Need advanced targeting? See Targeting &amp; Rollouts for rules, specificity, and custom logic.</p> <p>Want custom contexts? See Core Concepts for extending Context with business data.</p> <p>Migrating from another system? See Migration Guide for concept mapping and adoption patterns.</p> <p>Loading remote configs? See Remote Configuration for JSON serialization.</p>"},{"location":"01-getting-started/#quick-reference","title":"Quick Reference","text":"<pre><code>// 1. Define features\nobject Features : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val FLAG by boolean(default = false) {\n        rule { platforms(Platform.IOS); rollout { 50.0 } } returns true\n    }\n}\n\n// 2. Create context\nval ctx = Context(locale, platform, version, stableId)\n\n// 3. Evaluate\nval value = feature { Features.FLAG }\n</code></pre> <p>That's it. Type-safe feature flags in 3 steps.</p>"},{"location":"02-migration/","title":"Migration Guide","text":"<p>Switch from string-based feature flags to compile-time safety. This guide maps concepts and shows adoption patterns.</p>"},{"location":"02-migration/#concept-mapping","title":"Concept Mapping","text":""},{"location":"02-migration/#string-based-systems-konditional","title":"String-Based Systems \u2192 Konditional","text":"Common Pattern (LaunchDarkly/Statsig/Custom) Konditional Key Difference <code>getFlag(\"flag-name\")</code> or <code>client.boolVariation(\"flag\", false)</code> <code>feature { Features.FLAG }</code> Compile-time property vs runtime string Context with <code>Map&lt;String, Any&gt;</code> attributes <code>Context</code> data class Typed fields vs HashMap Rules in dashboard or config files <code>rule { }</code> DSL (code) Version-controlled in code Percentage rollouts <code>rollout { 50.0 }</code> Same concept, local computation Segments/audiences/conditions Custom <code>extension { }</code> logic Type-safe predicates Projects/environments/namespaces <code>Namespace</code> Compile-time isolated Flag variations/treatments <code>rule {...} returns value</code> Type-safe values"},{"location":"02-migration/#specific-service-mappings","title":"Specific Service Mappings","text":"<p>LaunchDarkly: - <code>LDClient.boolVariation()</code> \u2192 <code>feature { Feature }</code> - <code>LDContext</code> \u2192 <code>Context</code> data class - Segments \u2192 <code>extension { Evaluable.factory { ... } }</code></p> <p>Statsig: - <code>statsig.getConfig()</code> \u2192 <code>feature { Feature }</code> - Dynamic Config \u2192 String/Int/Double features with rules - Feature Gates \u2192 Boolean features</p> <p>Custom String-Based: - <code>featureFlags[\"flag\"]</code> \u2192 <code>feature { Features.FLAG }</code> - String keys \u2192 Property delegation - Type casting \u2192 Compiler-enforced types</p>"},{"location":"02-migration/#code-comparison","title":"Code Comparison","text":""},{"location":"02-migration/#boolean-flag","title":"Boolean Flag","text":"<p>String-Based (LaunchDarkly example):</p> <pre><code>val client = LDClient(sdkKey)\nval context = LDContext.builder(\"user-123\")\n    .set(\"platform\", \"ios\")\n    .build()\n\nval enabled = client.boolVariation(\"dark-mode\", context, false)\n</code></pre> <p>String-Based (Statsig example):</p> <pre><code>val statsig = Statsig.initialize(sdkKey)\nval user = StatsigUser(\"user-123\")\n    .setCustom(mapOf(\"platform\" to \"ios\"))\n\nval enabled = statsig.checkGate(user, \"dark_mode\")\n</code></pre> <p>Konditional:</p> <pre><code>object Features : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n}\n\nval context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"1.0.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n\nval enabled = feature { Features.DARK_MODE }\n</code></pre> <p>Key differences:</p> <ul> <li>No SDK key or network needed (offline-first)</li> <li>StableId requires hex format (deterministic bucketing)</li> <li>Property access with IDE autocomplete</li> <li>Type safety: compiler knows <code>enabled</code> is <code>Boolean</code></li> </ul>"},{"location":"02-migration/#string-configuration","title":"String Configuration","text":"<p>String-Based (Custom implementation):</p> <pre><code>val config = ConfigManager.getInstance()\nval endpoint = when (config.getString(\"api-endpoint-variant\")) {\n    \"ios\" -&gt; \"https://api-ios.example.com\"\n    \"android\" -&gt; \"https://api-android.example.com\"\n    else -&gt; \"https://api.example.com\"\n}\n</code></pre> <p>String-Based (Statsig Dynamic Config):</p> <pre><code>val config = statsig.getConfig(user, \"api_config\")\nval endpoint = config.getString(\"endpoint\", \"https://api.example.com\")\n</code></pre> <p>Konditional:</p> <pre><code>object Config : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val API_ENDPOINT by string(default = \"https://api.example.com\") {\n        rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n        rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n    }\n}\n\nval endpoint = feature { Config.API_ENDPOINT }  // Type: String, never null\n</code></pre> <p>Key differences:</p> <ul> <li>No treatment-to-value mapping (direct type-safe values)</li> <li>Rules defined in code (version-controlled)</li> <li>Returns actual config value, not treatment name</li> </ul>"},{"location":"02-migration/#custom-attributes-context-fields","title":"Custom Attributes / Context Fields","text":"<p>String-Based (LaunchDarkly example):</p> <pre><code>val context = LDContext.builder(\"user-123\")\n    .set(\"tier\", \"enterprise\")  // String value, no validation\n    .set(\"organization\", \"acme-corp\")\n    .build()\n\n// In dashboard: target users where tier == \"enterprise\"\n</code></pre> <p>String-Based (Statsig example):</p> <pre><code>val user = StatsigUser(\"user-123\")\n    .setCustom(mapOf(\n        \"tier\" to \"enterprise\",  // String value, no validation\n        \"organization\" to \"acme-corp\"\n    ))\n</code></pre> <p>Konditional:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,  // Typed, not string\n    val organizationId: String\n) : Context\n\nobject PremiumFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val ADVANCED_ANALYTICS by boolean(default = false) {\n        rule {\n            extension {\n                Evaluable.factory { ctx: EnterpriseContext -&gt;\n                    ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n                }\n            }\n        } returns true\n    }\n}\n\nval ctx = EnterpriseContext(..., subscriptionTier = SubscriptionTier.ENTERPRISE, ...)\nval enabled = feature { PremiumFeatures.ADVANCED_ANALYTICS }\n</code></pre> <p>Key differences:</p> <ul> <li>Type-safe enum <code>SubscriptionTier</code> vs string \"enterprise\"</li> <li>Custom fields defined as properties (compiler-validated)</li> <li>Business logic in code (testable, refactorable)</li> </ul>"},{"location":"02-migration/#adoption-patterns","title":"Adoption Patterns","text":""},{"location":"02-migration/#pattern-1-gradual-recommended","title":"Pattern 1: Gradual (Recommended)","text":"<p>Run Konditional alongside your existing system, migrate flag-by-flag.</p> <p>Steps:</p> <ol> <li>Add Konditional dependency</li> <li>Define one flag in Konditional (mirror existing config)</li> <li>Evaluate both systems, log differences</li> <li>Once confident, switch to Konditional for that flag</li> <li>Repeat for remaining flags</li> <li>Remove old system dependency</li> </ol> <p>Example dual evaluation:</p> <pre><code>// Wrapper to compare both systems\nfun isEnabled(flagName: String, context: Context): Boolean {\n    // Existing system (LaunchDarkly example)\n    val oldResult = featureFlagClient.getBoolean(flagName, false)\n\n    // Konditional\n    val newResult = when (flagName) {\n        \"dark_mode\" -&gt; feature { Features.DARK_MODE }\n        else -&gt; null\n    }\n\n    if (newResult != null &amp;&amp; oldResult != newResult) {\n        logger.warn(\"Mismatch for $flagName: Old=$oldResult, New=$newResult\")\n    }\n\n    return oldResult  // Use old system until validated\n}\n</code></pre>"},{"location":"02-migration/#pattern-2-big-bang-faster-higher-risk","title":"Pattern 2: Big-Bang (Faster, Higher Risk)","text":"<p>Migrate all flags at once.</p> <p>Steps:</p> <ol> <li>Export all existing flags (from dashboard, config files, or database)</li> <li>Define equivalent Konditional features</li> <li>Test thoroughly in staging</li> <li>Deploy and monitor closely</li> <li>Roll back if issues arise</li> </ol> <p>Use when: You have comprehensive tests and can tolerate brief outages.</p>"},{"location":"02-migration/#pattern-3-new-features-only","title":"Pattern 3: New Features Only","text":"<p>Keep existing flags in your current system, use Konditional for new flags.</p> <p>Steps:</p> <ol> <li>Add Konditional for new features</li> <li>Gradually migrate old flags as time permits</li> <li>Eventually deprecate old system</li> </ol> <p>Use when: Migration isn't urgent, want to learn Konditional gradually.</p>"},{"location":"02-migration/#common-migration-challenges","title":"Common Migration Challenges","text":""},{"location":"02-migration/#challenge-1-stableid-format","title":"Challenge 1: StableId Format","text":"<p>String-based systems: User IDs can be any string (<code>\"user-123\"</code>, <code>\"alice@example.com\"</code>)</p> <p>Konditional: <code>StableId</code> must be valid hexadecimal (32+ characters)</p> <p>Solution: Hash your existing IDs:</p> <pre><code>fun userIdToStableId(userId: String): StableId {\n    val hash = MessageDigest.getInstance(\"SHA-256\")\n        .digest(userId.toByteArray())\n        .joinToString(\"\") { \"%02x\".format(it) }\n    return StableId.of(hash)\n}\n\nval stableId = userIdToStableId(\"user-123\")\n</code></pre>"},{"location":"02-migration/#challenge-2-dynamic-attributes","title":"Challenge 2: Dynamic Attributes","text":"<p>String-based systems: Attributes set at runtime (<code>context.set(\"key\", value)</code> or <code>Map&lt;String, Any&gt;</code>)</p> <p>Konditional: Context fields must be defined at compile time</p> <p>Solution: Create custom context with all possible fields:</p> <pre><code>data class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier?,  // Nullable if optional\n    val betaTester: Boolean,\n    val organizationId: String?\n) : Context\n</code></pre>"},{"location":"02-migration/#challenge-3-remote-configuration","title":"Challenge 3: Remote Configuration","text":"<p>String-based systems: Flags configured via dashboard/API, updated instantly</p> <p>Konditional: Flags defined in code, rules updated via UI or JSON</p> <p>Solution: Use UI with RBAC or JSON serialization for remote updates:</p> <pre><code>// Define flags in code with defaults\nobject Features : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n}\n\n// Load remote rules (doesn't change code, just rule configuration)\nval remoteJson = fetchFromServer(\"/flags.json\")\nwhen (val result = SnapshotSerializer.fromJson(remoteJson)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logger.error(\"Failed to load config\")\n}\n</code></pre>"},{"location":"02-migration/#challenge-4-rollout-redistribution","title":"Challenge 4: Rollout Redistribution","text":"<p>Issue: Users in 50% rollout in your old system won't match 50% in Konditional (different bucketing algorithms)</p> <p>Solution: Accept redistribution or use salt to align:</p> <ul> <li>Accept: Users may see different experience temporarily (most teams do this)</li> <li>Align: Adjust Konditional salt until distribution matches (trial-and-error, not recommended)</li> </ul> <p>Most teams accept redistribution since rollouts are temporary anyway.</p>"},{"location":"02-migration/#why-migrate","title":"Why Migrate?","text":""},{"location":"02-migration/#1-eliminate-runtime-errors","title":"1. Eliminate Runtime Errors","text":"<p>String-based:</p> <pre><code>getFlag(\"dark-mod\")  // Typo! Returns null or default silently\n</code></pre> <p>Konditional:</p> <pre><code>feature { Features.DARK_MOD }  // Compile error: unresolved reference\n</code></pre>"},{"location":"02-migration/#2-reduce-infrastructure-costs","title":"2. Reduce Infrastructure Costs","text":"<p>SaaS systems (LaunchDarkly/Statsig): Monthly fees scale with MAU/seat count</p> <p>Konditional: Zero infrastructure cost (runs locally)</p>"},{"location":"02-migration/#3-improve-performance","title":"3. Improve Performance","text":"<p>String-based: Network latency or cache lookup overhead, type casting</p> <p>Konditional: Zero network calls, O(n) local evaluation where n &lt; 10, zero allocation</p>"},{"location":"02-migration/#4-version-control-everything","title":"4. Version Control Everything","text":"<p>Dashboard-based systems: Flag rules live in UI (audit log separate from code)</p> <p>Konditional: Flags defined in code (Git history + UI with RBAC for rule updates)</p>"},{"location":"02-migration/#5-type-safety","title":"5. Type Safety","text":"<p>String-based: <code>getInt(\"flag\")</code> vs <code>getString(\"flag\")</code> \u2014 must remember type, can typo</p> <p>Konditional: Compiler knows the type, IDE autocomplete works, typos impossible</p>"},{"location":"02-migration/#decision-matrix","title":"Decision Matrix","text":"Factor Stick with Current System Migrate to Konditional Budget SaaS cost not a concern Want to eliminate SaaS fees Tech stack Multi-language (Java, Go, Python, Ruby, etc.) Kotlin/JVM only Type safety priority Low (runtime errors acceptable) High (critical for correctness) Offline support Not needed (always connected) Essential (mobile, edge computing) Integration effort Already integrated, working well Willing to invest migration time Control &amp; Compliance Prefer SaaS management Need self-hosted with RBAC control"},{"location":"02-migration/#next-steps","title":"Next Steps","text":"<p>Ready to migrate? Start with Getting Started to run your first Konditional flag.</p> <p>Need feature parity? See Targeting &amp; Rollouts for advanced rules matching most feature flag systems.</p> <p>Want to understand the model? See Core Concepts for deep dive into Features, Context, and Namespaces.</p>"},{"location":"03-core-concepts/","title":"Core Concepts","text":"<p>Design flags for your domain. This guide covers Features, Context, and Namespaces\u2014the building blocks of type-safe feature flags.</p>"},{"location":"03-core-concepts/#features","title":"Features","text":"<p>Features are type-safe flag definitions. Define them once, use them everywhere with compiler guarantees.</p>"},{"location":"03-core-concepts/#featurecontainer-pattern-recommended","title":"FeatureContainer Pattern (Recommended)","text":"<p>The delegation pattern gives you property access with zero boilerplate:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.example.com\")\n    val MAX_RETRIES by int(default = 3)\n    val TIMEOUT by double(default = 30.0)\n}\n\n// Property access, not method calls\nval enabled = feature { AppFeatures.DARK_MODE }  // Type: Boolean\nval endpoint = feature { AppFeatures.API_ENDPOINT }  // Type: String\n</code></pre> <p>What you get:</p> <ul> <li>Property names become flag keys automatically</li> <li>Type inference from default values</li> <li>IDE autocomplete</li> <li>Compile-time validation</li> </ul>"},{"location":"03-core-concepts/#supported-types","title":"Supported Types","text":"Type DSL Method Kotlin Type Example Default Boolean <code>boolean()</code> <code>Boolean</code> <code>false</code> String <code>string()</code> <code>String</code> <code>\"production\"</code> Integer <code>int()</code> <code>Int</code> <code>42</code> Decimal <code>double()</code> <code>Double</code> <code>3.14</code> Enum <code>enum&lt;E&gt;()</code> <code>E : Enum&lt;E&gt;</code> <code>LogLevel.INFO</code>"},{"location":"03-core-concepts/#enum-flags","title":"Enum Flags","text":"<p>For type-safe variants, use enums:</p> <pre><code>enum class LogLevel { DEBUG, INFO, WARN, ERROR }\nenum class Theme { LIGHT, DARK, AUTO }\n\nobject AppConfig : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val LOG_LEVEL by enum&lt;LogLevel, Context&gt;(default = LogLevel.INFO)\n    val THEME by enum&lt;Theme, Context&gt;(default = Theme.LIGHT)\n}\n\n// Type-safe evaluation\nval level: LogLevel = feature { AppConfig.LOG_LEVEL }\n</code></pre> <p>vs string-based systems:</p> <pre><code>// LaunchDarkly - strings, can typo\nval level = client.stringVariation(\"log-level\", \"info\")\nwhen (level) {\n    \"debug\" -&gt; ...\n    \"deubg\" -&gt; ...  // Typo! Never matches\n}\n\n// Konditional - compiler validates\nval level = feature { AppConfig.LOG_LEVEL }\nwhen (level) {\n    LogLevel.DEBUG -&gt; ...\n    LogLevel.DEUBG -&gt; ...  // Compile error\n}\n</code></pre>"},{"location":"03-core-concepts/#context","title":"Context","text":"<p>Context provides the evaluation environment. Every evaluation requires context\u2014it tells Konditional who is asking and where they are.</p>"},{"location":"03-core-concepts/#standard-fields","title":"Standard Fields","text":"<p>All contexts must have these four fields:</p> <pre><code>data class Context(\n    val locale: AppLocale,       // App language/region\n    val platform: Platform,      // Device type\n    val appVersion: Version,     // App version (semantic)\n    val stableId: StableId       // User/device identifier (hex)\n)\n</code></pre> <p>Example:</p> <pre><code>val context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n</code></pre>"},{"location":"03-core-concepts/#platform","title":"Platform","text":"<p>Where your code runs:</p> <pre><code>enum class Platform {\n    IOS,        // iOS apps\n    ANDROID,    // Android apps\n}\n</code></pre> <p>Use in rules:</p> <pre><code>rule { platforms(Platform.IOS, Platform.ANDROID) } returns mobileValue\n</code></pre>"},{"location":"03-core-concepts/#applocale","title":"AppLocale","text":"<p>User's language and region. 27 supported locales:</p> <pre><code>AppLocale.UNITED_STATES  // en-US\nAppLocale.CANADA         // en-CA\nAppLocale.UNITED_KINGDOM // en-GB\nAppLocale.FRANCE         // fr-FR\nAppLocale.JAPAN          // ja-JP\n// ... 22 more\n</code></pre> <p>Use in rules:</p> <pre><code>rule { locales(AppLocale.UNITED_STATES, AppLocale.CANADA) } returns \"en\" locale\n</code></pre>"},{"location":"03-core-concepts/#version","title":"Version","text":"<p>Semantic versioning (major.minor.patch):</p> <pre><code>val version = Version.parse(\"2.1.0\")  // ParseResult&lt;Version&gt;\nval version = Version.of(2, 1, 0)     // Direct construction\n</code></pre> <p>Use in rules for version targeting:</p> <pre><code>rule {\n    versions {\n        min(2, 0, 0)  // Minimum 2.0.0\n        max(3, 0, 0)  // Below 3.0.0\n    }\n} returns v2Feature\n</code></pre>"},{"location":"03-core-concepts/#stableid","title":"StableId","text":"<p>Stable user/device identifier for deterministic rollouts. Must be hexadecimal (32+ chars).</p> <pre><code>// Valid hex IDs\nval id1 = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\nval id2 = StableId.of(\"deadbeefcafebabe1234567890abcdef\")\n\n// Invalid - will throw\nval bad = StableId.of(\"user-123\")  // Not hex!\n</code></pre> <p>Convert existing IDs:</p> <pre><code>fun toStableId(userId: String): StableId {\n    val hash = MessageDigest.getInstance(\"SHA-256\")\n        .digest(userId.toByteArray())\n        .joinToString(\"\") { \"%02x\".format(it) }\n    return StableId.of(hash)\n}\n</code></pre> <p>Why hex? Ensures uniform distribution across rollout buckets (0-9999).</p>"},{"location":"03-core-concepts/#custom-contexts","title":"Custom Contexts","text":"<p>Extend Context with business-specific fields for advanced targeting.</p>"},{"location":"03-core-concepts/#enterprise-example","title":"Enterprise Example","text":"<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    // Custom fields\n    val subscriptionTier: SubscriptionTier,\n    val organizationId: String,\n    val userRole: UserRole,\n    val employeeCount: Int\n) : Context\n\nenum class SubscriptionTier { FREE, PRO, ENTERPRISE }\nenum class UserRole { VIEWER, EDITOR, ADMIN }\n\nobject PremiumFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            extension {\n                Evaluable.factory { ctx -&gt;\n                    ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                    ctx.employeeCount &gt; 100\n                }\n            }\n        } returns true\n    }\n}\n\n// Evaluation with custom context\nval ctx = EnterpriseContext(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.WEB,\n    appVersion = Version.parse(\"3.0.0\"),\n    stableId = StableId.of(\"...\"),\n    subscriptionTier = SubscriptionTier.ENTERPRISE,\n    organizationId = \"acme-corp\",\n    userRole = UserRole.ADMIN,\n    employeeCount = 500\n)\n\nval enabled = feature { PremiumFeatures.ADVANCED_ANALYTICS }  // true\n</code></pre>"},{"location":"03-core-concepts/#multi-tenant-example","title":"Multi-Tenant Example","text":"<pre><code>data class TenantContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val tenantId: String,\n    val featureAccess: Set&lt;String&gt;  // Purchased features\n) : Context\n\nobject SaasFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val PDF_EXPORT by boolean&lt;TenantContext&gt;(default = false) {\n        rule {\n            extension {\n                Evaluable.factory { ctx -&gt;\n                    \"pdf-export\" in ctx.featureAccess\n                }\n            }\n        } returns true\n    }\n}\n</code></pre> <p>Key principle: Custom contexts enable type-safe business logic in rules without hardcoding user IDs or organization names.</p>"},{"location":"03-core-concepts/#namespaces","title":"Namespaces","text":"<p>Namespaces isolate features by domain. Each namespace has its own registry\u2014features can't collide across namespaces.</p>"},{"location":"03-core-concepts/#built-in-namespaces","title":"Built-In Namespaces","text":"<pre><code>Namespace.Global            // Shared across app\nNamespace.Authentication    // Login, SSO, 2FA\nNamespace.Payments          // Billing, subscriptions\nNamespace.Messaging         // Chat, notifications\nNamespace.Search            // Search algorithms\nNamespace.Recommendations   // Personalization\n</code></pre>"},{"location":"03-core-concepts/#using-namespaces","title":"Using Namespaces","text":"<pre><code>object AuthFeatures : FeatureContainer&lt;Namespace.Authentication&gt;(\n    Namespace.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Namespace.Payments&gt;(\n    Namespace.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n    val STRIPE_INTEGRATION by boolean(default = true)\n}\n\n// Each namespace isolated\nNamespace.Authentication.load(authConfig)  // Only affects auth features\nNamespace.Payments.load(paymentConfig)     // Only affects payment features\n</code></pre>"},{"location":"03-core-concepts/#namespace-benefits","title":"Namespace Benefits","text":"Benefit What It Means Compile-time isolation Can't accidentally use wrong namespace's features Runtime isolation Separate registries, independent configurations Team ownership Clear boundaries (Auth team owns Authentication namespace) Independent deployment Update one namespace without affecting others"},{"location":"03-core-concepts/#custom-namespaces","title":"Custom Namespaces","text":"<p>For team-specific domains:</p> <pre><code>// Sealed class ensures compile-time exhaustiveness\nsealed class TeamNamespace(id: String) : Namespace.Domain(id) {\n    data object Recommendations : TeamNamespace(\"recommendations\")\n    data object Analytics : TeamNamespace(\"analytics\")\n}\n\nobject RecFeatures : FeatureContainer&lt;TeamNamespace.Recommendations&gt;(\n    TeamNamespace.Recommendations\n) {\n    val COLLABORATIVE_FILTERING by boolean(default = true)\n}\n</code></pre> <p>Why sealed? Governance\u2014new namespaces require code review and PR approval.</p>"},{"location":"03-core-concepts/#organizational-patterns","title":"Organizational Patterns","text":""},{"location":"03-core-concepts/#pattern-1-by-feature-domain","title":"Pattern 1: By Feature Domain","text":"<p>Organize containers by business capability:</p> <pre><code>object UserManagement : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val PROFILE_EDITING by boolean(default = true)\n    val ACCOUNT_DELETION by boolean(default = true)\n}\n\nobject ContentModeration : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val AUTO_MODERATION by boolean(default = false)\n    val MANUAL_REVIEW by boolean(default = true)\n}\n</code></pre>"},{"location":"03-core-concepts/#pattern-2-by-platform","title":"Pattern 2: By Platform","text":"<p>Separate mobile and web flags:</p> <pre><code>object MobileFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val OFFLINE_MODE by boolean(default = true)\n    val PUSH_NOTIFICATIONS by boolean(default = true)\n}\n\nobject WebFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DESKTOP_NOTIFICATIONS by boolean(default = false)\n    val PROGRESSIVE_WEB_APP by boolean(default = false)\n}\n</code></pre>"},{"location":"03-core-concepts/#pattern-3-by-team","title":"Pattern 3: By Team","text":"<p>Use namespaces for team isolation:</p> <pre><code>// Team 1: Growth\nobject GrowthFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val REFERRAL_PROGRAM by boolean(default = false)\n}\n\n// Team 2: Monetization\nobject MonetizationFeatures : FeatureContainer&lt;Namespace.Payments&gt;(\n    Namespace.Payments\n) {\n    val SUBSCRIPTION_UPSELL by boolean(default = true)\n}\n</code></pre>"},{"location":"03-core-concepts/#type-safety-in-action","title":"Type Safety in Action","text":"<p>Konditional's type system prevents entire classes of errors:</p>"},{"location":"03-core-concepts/#impossible-runtime-type-errors","title":"Impossible Runtime Type Errors","text":"<pre><code>// LaunchDarkly - wrong type method\nval retries = client.boolVariation(\"max-retries\", false)  // Oops! Should be int\nprocessWithRetries(retries)  // Type error at runtime\n\n// Konditional - compiler catches it\nobject Config : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val MAX_RETRIES by int(default = 3)\n}\nval retries = feature { Config.MAX_RETRIES }  // Type: Int, guaranteed\n</code></pre>"},{"location":"03-core-concepts/#impossible-context-mismatches","title":"Impossible Context Mismatches","text":"<pre><code>// Wrong context type\nval basicContext: Context = Context(...)\nfeature { PremiumFeatures.ADVANCED_ANALYTICS }  // Compile error!\n// Required: EnterpriseContext, Found: Context\n\n// Correct\nval enterpriseContext: EnterpriseContext = EnterpriseContext(...)\nfeature { PremiumFeatures.ADVANCED_ANALYTICS }  // \u2713\n</code></pre>"},{"location":"03-core-concepts/#impossible-namespace-collisions","title":"Impossible Namespace Collisions","text":"<pre><code>// Can't mix features across namespaces\nNamespace.Authentication.load(paymentConfig)  // Compile error!\n// Type mismatch\n</code></pre>"},{"location":"03-core-concepts/#best-practices","title":"Best Practices","text":""},{"location":"03-core-concepts/#1-use-featurecontainer-for-everything","title":"1. Use FeatureContainer for Everything","text":"<p>Unless you have a specific reason (like enum-based patterns), FeatureContainer delegation is the best API.</p>"},{"location":"03-core-concepts/#2-design-contexts-for-your-domain","title":"2. Design Contexts for Your Domain","text":"<p>Don't stuff everything into one mega-context. Create focused contexts:</p> <pre><code>// Good - focused\ndata class ShoppingContext(..., val cartTotal: Double) : Context\ndata class CheckoutContext(..., val paymentMethod: PaymentMethod) : Context\n\n// Bad - kitchen sink\ndata class AppContext(..., val cartTotal: Double?, val paymentMethod: PaymentMethod?, ...) : Context\n</code></pre>"},{"location":"03-core-concepts/#3-organize-by-teamdomain","title":"3. Organize by Team/Domain","text":"<p>Use namespaces to reflect your org structure. Each team should own a namespace.</p>"},{"location":"03-core-concepts/#4-start-simple-extend-later","title":"4. Start Simple, Extend Later","text":"<p>Begin with basic Context, add custom fields only when needed:</p> <pre><code>// Start\nval context = Context(locale, platform, version, stableId)\n\n// Later, when needed\ndata class CustomContext(..., val newField: String) : Context\n</code></pre>"},{"location":"03-core-concepts/#5-use-enums-for-variants","title":"5. Use Enums for Variants","text":"<p>Don't use strings when enums make sense:</p> <pre><code>// Bad\nval THEME by string(default = \"light\")  // Can typo \"lite\"\n\n// Good\nenum class Theme { LIGHT, DARK }\nval THEME by enum&lt;Theme, Context&gt;(default = Theme.LIGHT)\n</code></pre>"},{"location":"03-core-concepts/#next-steps","title":"Next Steps","text":"<p>Need advanced targeting? See Targeting &amp; Rollouts for rules, specificity, and rollout strategies.</p> <p>Want to evaluate flags? See Evaluation for evaluation methods and error handling.</p> <p>Loading from JSON? See Remote Configuration for serialization.</p>"},{"location":"04-targeting-rollouts/","title":"Targeting &amp; Rollouts","text":"<p>Ship safely with precise control. Rules let you target specific users and roll out features gradually.</p>"},{"location":"04-targeting-rollouts/#basic-targeting","title":"Basic Targeting","text":"<p>Target users by platform, locale, or version using simple, readable criteria.</p>"},{"location":"04-targeting-rollouts/#platform-targeting","title":"Platform Targeting","text":"<pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n    rule { platforms(Platform.WEB) } returns \"https://api-web.example.com\"\n}\n</code></pre> <p>Multiple platforms (OR logic):</p> <pre><code>rule { platforms(Platform.IOS, Platform.ANDROID) } returns \"mobile value\"\n</code></pre>"},{"location":"04-targeting-rollouts/#locale-targeting","title":"Locale Targeting","text":"<pre><code>val WELCOME_MESSAGE by string(default = \"Hello!\") {\n    rule { locales(AppLocale.UNITED_STATES, AppLocale.CANADA) } returns \"Welcome!\"\n    rule { locales(AppLocale.FRANCE) } returns \"Bienvenue!\"\n    rule { locales(AppLocale.JAPAN) } returns \"\u3088\u3046\u3053\u305d!\"\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#version-targeting","title":"Version Targeting","text":"<p>Target users on specific version ranges:</p> <pre><code>val NEW_UI by boolean(default = false) {\n    rule {\n        versions { min(2, 0, 0) }  // Version &gt;= 2.0.0\n    } returns true\n}\n\nval LEGACY_SUPPORT by boolean(default = false) {\n    rule {\n        versions { max(2, 0, 0) }  // Version &lt; 2.0.0\n    } returns true\n}\n\nval TRANSITION_FEATURE by boolean(default = false) {\n    rule {\n        versions {\n            min(1, 5, 0)  // &gt;= 1.5.0\n            max(2, 0, 0)  // &lt; 2.0.0\n        }\n    } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#combining-criteria","title":"Combining Criteria","text":"<p>All criteria must match (AND logic):</p> <pre><code>val PREMIUM_FEATURE by boolean(default = false) {\n    rule {\n        platforms(Platform.IOS, Platform.ANDROID)  // Must be mobile\n        locales(AppLocale.UNITED_STATES)          // AND US locale\n        versions { min(2, 0, 0) }                  // AND version &gt;= 2.0.0\n        rollout { 50.0 }                           // AND in 50% bucket\n    } returns true\n}\n</code></pre> <p>Flow:</p> <pre><code>flowchart LR\n    Context[User Context] --&gt; Platform{Platform&lt;br/&gt;iOS or Android?}\n    Platform --&gt;|No| Skip[Skip rule]\n    Platform --&gt;|Yes| Locale{Locale&lt;br/&gt;US?}\n    Locale --&gt;|No| Skip\n    Locale --&gt;|Yes| Version{Version&lt;br/&gt; &gt;= 2.0.0?}\n    Version --&gt;|No| Skip\n    Version --&gt;|Yes| Rollout{In 50%&lt;br/&gt;bucket?}\n    Rollout --&gt;|No| Skip\n    Rollout --&gt;|Yes| Match[Rule matches!]\n\n    style Match fill:#c8e6c9\n    style Skip fill:#ffcdd2</code></pre>"},{"location":"04-targeting-rollouts/#rollout-strategies","title":"Rollout Strategies","text":"<p>Deploy features incrementally using deterministic percentage-based rollouts.</p>"},{"location":"04-targeting-rollouts/#gradual-rollout","title":"Gradual Rollout","text":"<p>Start small, expand over time:</p> <pre><code>// Day 1: 10% of users\nval NEW_CHECKOUT by boolean(default = false) {\n    rule { rollout { 10.0 } } returns true\n}\n\n// Day 3: 50% (includes original 10%)\nval NEW_CHECKOUT by boolean(default = false) {\n    rule { rollout { 50.0 } } returns true\n}\n\n// Day 7: 100% (everyone)\nval NEW_CHECKOUT by boolean(default = false) {\n    rule { rollout { 100.0 } } returns true\n}\n</code></pre> <p>Key property: Same users stay enabled (deterministic bucketing).</p>"},{"location":"04-targeting-rollouts/#segmented-rollout","title":"Segmented Rollout","text":"<p>Different percentages for different segments:</p> <pre><code>val BETA_FEATURE by boolean&lt;EnterpriseContext&gt;(default = false) {\n    // 100% for internal users\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt; ctx.organizationId == \"internal\" }\n        }\n    } returns true\n\n    // 50% for enterprise customers\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n            }\n        }\n        rollout { 50.0 }\n    } returns true\n\n    // 10% for everyone else\n    rule { rollout { 10.0 } } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#platform-specific-rollout","title":"Platform-Specific Rollout","text":"<p>Roll out to platforms independently:</p> <pre><code>val NEW_FEATURE by boolean(default = false) {\n    rule {\n        platforms(Platform.ANDROID)\n        rollout { 100.0 }  // 100% Android\n    } returns true\n\n    rule {\n        platforms(Platform.IOS)\n        rollout { 25.0 }  // 25% iOS (testing)\n    } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#rollout-bucketing","title":"Rollout Bucketing","text":"<p>Konditional uses SHA-256 hashing for deterministic user bucketing.</p>"},{"location":"04-targeting-rollouts/#how-it-works","title":"How It Works","text":"<pre><code>flowchart LR\n    Salt[Salt: 'v1'] --&gt; Hash\n    Key[Flag Key] --&gt; Hash\n    StableId[User StableId] --&gt; Hash\n\n    Hash[SHA-256 Hash] --&gt; Mod[Modulo 10,000]\n    Mod --&gt; Bucket[Bucket: 0-9999]\n    Bucket --&gt; Compare{Bucket &lt;&lt;br/&gt;threshold?}\n\n    Compare --&gt;|Yes| Enabled[User Enabled]\n    Compare --&gt;|No| Disabled[User Disabled]\n\n    style Enabled fill:#c8e6c9\n    style Disabled fill:#ffcdd2</code></pre> <p>Algorithm:</p> <pre><code>fun bucket(flagKey: String, stableId: StableId, salt: String): Int {\n    val input = \"$salt:$flagKey:${stableId.id}\"\n    val hash = SHA256(input)\n    val intValue = hash.take(4).toInt()\n    return intValue % 10_000  // 0-9999 (0.01% granularity)\n}\n\n// Check if user is in rollout\nval threshold = (rollout.value * 100).toInt()  // 50.0 \u2192 5000\nval userBucket = bucket(\"dark_mode\", user.stableId, \"v1\")\nval enabled = userBucket &lt; threshold\n</code></pre>"},{"location":"04-targeting-rollouts/#bucketing-properties","title":"Bucketing Properties","text":"Property Benefit Deterministic Same user always gets same bucket Independent Each flag has separate bucketing (user in 50% of Flag A \u2260 50% of Flag B) Platform-stable Same bucket on JVM, Android, iOS, Web Redistributable Change salt to reassign buckets Fine-grained 0.01% granularity (10,000 buckets)"},{"location":"04-targeting-rollouts/#salt-based-redistribution","title":"Salt-Based Redistribution","text":"<p>Change salt to redistribute users:</p> <pre><code>// Original\nval EXPERIMENT by boolean(default = false) {\n    salt(\"v1\")\n    rule { rollout { 50.0 } } returns true\n}\n\n// New bucketing (different 50% of users)\nval EXPERIMENT by boolean(default = false) {\n    salt(\"v2\")  // Changed!\n    rule { rollout { 50.0 } } returns true\n}\n</code></pre> <p>Use cases:</p> <ul> <li>Reset A/B test for new experiment</li> <li>Fix skewed distribution</li> <li>Run same flag with different user sample</li> </ul>"},{"location":"04-targeting-rollouts/#specificity-rule-ordering","title":"Specificity &amp; Rule Ordering","text":"<p>When multiple rules match, the most specific rule wins. Rules are auto-sorted by specificity (highest first).</p>"},{"location":"04-targeting-rollouts/#specificity-calculation","title":"Specificity Calculation","text":"<pre><code>specificity = (platforms specified? 1 : 0)\n            + (locales specified? 1 : 0)\n            + (versions specified? 1 : 0)\n            + extension.specificity()\n</code></pre>"},{"location":"04-targeting-rollouts/#examples","title":"Examples","text":"<pre><code>val VALUE by string(default = \"default\") {\n    // Specificity = 3 (platform + locale + version)\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.UNITED_STATES)\n        versions { min(2, 0, 0) }\n    } returns \"very-specific\"\n\n    // Specificity = 2 (platform + locale)\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.UNITED_STATES)\n    } returns \"medium-specific\"\n\n    // Specificity = 1 (platform only)\n    rule {\n        platforms(Platform.IOS)\n    } returns \"general\"\n\n    // Specificity = 0 (no constraints)\n    rule { } returns \"catch-all\"\n}\n</code></pre> <p>Evaluation order:</p> <pre><code>graph TD\n    Start[User: iOS, US, v2.1.0] --&gt; S3[\"Specificity 3:&lt;br/&gt;iOS + US + v2.0+&lt;br/&gt;\u2192 'very-specific'\"]\n\n    S3 --&gt;|Matches| Return3[Return 'very-specific']\n    S3 --&gt;|Doesn't match| S2[\"Specificity 2:&lt;br/&gt;iOS + US&lt;br/&gt;\u2192 'medium-specific'\"]\n\n    S2 --&gt;|Matches| Return2[Return 'medium-specific']\n    S2 --&gt;|Doesn't match| S1[\"Specificity 1:&lt;br/&gt;iOS&lt;br/&gt;\u2192 'general'\"]\n\n    S1 --&gt;|Matches| Return1[Return 'general']\n    S1 --&gt;|Doesn't match| S0[\"Specificity 0:&lt;br/&gt;(no constraints)&lt;br/&gt;\u2192 'catch-all'\"]\n\n    S0 --&gt; Default[Return 'catch-all']\n\n    style S3 fill:#4caf50\n    style Return3 fill:#c8e6c9</code></pre> <p>Key insight: More specific rules override general rules automatically.</p>"},{"location":"04-targeting-rollouts/#custom-targeting-logic","title":"Custom Targeting Logic","text":"<p>Use <code>extension { }</code> for business logic beyond platform/locale/version.</p>"},{"location":"04-targeting-rollouts/#simple-extension","title":"Simple Extension","text":"<pre><code>val PREMIUM_FEATURE by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n            }\n        }\n    } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#complex-extension","title":"Complex Extension","text":"<p>Combine multiple business conditions:</p> <pre><code>val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        platforms(Platform.WEB)  // Technical constraint\n        extension {              // Business logic\n            object : Evaluable&lt;EnterpriseContext&gt; {\n                override fun matches(ctx: EnterpriseContext) =\n                    ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                    ctx.employeeCount &gt; 100 &amp;&amp;\n                    ctx.userRole == UserRole.ADMIN\n\n                override fun specificity() = 3  // Three conditions\n            }\n        }\n    } returns true\n}\n</code></pre> <p>Extension specificity adds to total:</p> <pre><code>Total = platform (1) + extension (3) = 4\n</code></pre>"},{"location":"04-targeting-rollouts/#reusable-evaluables","title":"Reusable Evaluables","text":"<p>Create evaluable classes for common patterns:</p> <pre><code>class SubscriptionTierEvaluable(\n    private val allowedTiers: Set&lt;SubscriptionTier&gt;\n) : Evaluable&lt;EnterpriseContext&gt; {\n    override fun matches(ctx: EnterpriseContext) =\n        ctx.subscriptionTier in allowedTiers\n\n    override fun specificity() = 1\n}\n\n// Reuse across features\nval FEATURE_A by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            SubscriptionTierEvaluable(setOf(SubscriptionTier.ENTERPRISE))\n        }\n    } returns true\n}\n\nval FEATURE_B by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            SubscriptionTierEvaluable(setOf(\n                SubscriptionTier.PRO,\n                SubscriptionTier.ENTERPRISE\n            ))\n        }\n    } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#best-practices","title":"Best Practices","text":""},{"location":"04-targeting-rollouts/#1-start-with-small-rollouts","title":"1. Start with Small Rollouts","text":"<p>Begin with 10%, monitor metrics, then expand:</p> <pre><code>// Phase 1: Canary\nrule { rollout { 10.0 } } returns true\n\n// Phase 2: Expand (if metrics look good)\nrule { rollout { 50.0 } } returns true\n\n// Phase 3: Full rollout\nrule { rollout { 100.0 } } returns true\n</code></pre>"},{"location":"04-targeting-rollouts/#2-use-specificity-to-your-advantage","title":"2. Use Specificity to Your Advantage","text":"<p>Write rules from most to least specific:</p> <pre><code>// Good - clear intent\nrule { platforms(Platform.IOS); locales(AppLocale.UNITED_STATES) } returns \"ios-us\"\nrule { platforms(Platform.IOS) } returns \"ios-all\"\nrule { } returns \"default\"\n\n// Also works, but less clear\nrule { } returns \"default\"\nrule { platforms(Platform.IOS) } returns \"ios-all\"\nrule { platforms(Platform.IOS); locales(AppLocale.UNITED_STATES) } returns \"ios-us\"\n</code></pre>"},{"location":"04-targeting-rollouts/#3-document-non-obvious-rules","title":"3. Document Non-Obvious Rules","text":"<p>Use <code>note()</code> for complex targeting:</p> <pre><code>rule {\n    platforms(Platform.ANDROID)\n    versions { min(1, 9, 0); max(2, 1, 0) }\n    rollout { 15.0 }\n    note(\"Workaround for Android bug #1234 - affects v1.9.0-2.0.x\")\n} returns workaroundValue\n</code></pre>"},{"location":"04-targeting-rollouts/#4-keep-rule-count-low","title":"4. Keep Rule Count Low","text":"<p>Fewer rules = faster evaluation:</p> <pre><code>// Good: 2-3 rules\nval FEATURE by boolean(default = false) {\n    rule { platforms(Platform.IOS) } returns true\n    rule { versions { min(2, 0, 0) } } returns true\n}\n\n// Avoid: 20+ rules (consider redesigning with custom context)\n</code></pre>"},{"location":"04-targeting-rollouts/#5-test-rollout-distribution","title":"5. Test Rollout Distribution","text":"<p>Verify rollouts distribute evenly:</p> <pre><code>@Test\nfun `50 percent rollout distributes correctly`() {\n    val sampleSize = 1000\n    val enabled = (0 until sampleSize).count { i -&gt;\n        val ctx = Context(..., stableId = StableId.of(\"user-$i\"))\n        feature { Features.ROLLOUT_FLAG }\n    }\n\n    val percentage = (enabled.toDouble() / sampleSize) * 100\n    assertTrue(percentage in 48.0..52.0)  // \u00b12% variance\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#common-patterns","title":"Common Patterns","text":""},{"location":"04-targeting-rollouts/#pattern-1-kill-switch","title":"Pattern 1: Kill Switch","text":"<p>Emergency disable without deployment:</p> <pre><code>val PAYMENT_PROCESSING by boolean(default = true)\n// Can be set to false via remote JSON update\n</code></pre>"},{"location":"04-targeting-rollouts/#pattern-2-ab-test","title":"Pattern 2: A/B Test","text":"<p>Split users 50/50:</p> <pre><code>val RECOMMENDATION_ALGO by string(default = \"collaborative\") {\n    salt(\"experiment-2024-q1\")\n    rule { rollout { 50.0 } } returns \"content-based\"\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#pattern-3-beta-program","title":"Pattern 3: Beta Program","text":"<p>100% for beta users, 0% for others:</p> <pre><code>val BETA_FEATURE by boolean&lt;AppContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt; ctx.betaTester }\n        }\n    } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#next-steps","title":"Next Steps","text":"<p>Need to evaluate flags? See Evaluation for evaluation methods and flow.</p> <p>Want remote updates? See Remote Configuration for JSON serialization.</p> <p>Understanding the basics? See Core Concepts for Features, Context, and Namespaces.</p>"},{"location":"05-evaluation/","title":"Evaluation","text":"<p>Predictable results, graceful errors. This guide covers evaluation methods, evaluation flow, and error handling.</p>"},{"location":"05-evaluation/#evaluation-methods","title":"Evaluation Methods","text":"<p>Choose based on your error handling needs.</p>"},{"location":"05-evaluation/#feature-recommended","title":"feature { } - Recommended","text":"<p>Simple evaluation within a ContextAware scope:</p> <pre><code>// Within a ContextAware + FeatureAware scope\nval darkMode = feature { Features.DARK_MODE }\napplyDarkMode(darkMode)  // Always non-null\n</code></pre> <p>Use when:</p> <ul> <li>You have sensible defaults</li> <li>Error details don't matter</li> <li>You want the most concise API</li> </ul> <p>Most common choice for production code.</p>"},{"location":"05-evaluation/#featuresafe-explicit-error-handling","title":"featureSafe { } - Explicit Error Handling","text":"<p>Returns explicit result type with all failure modes:</p> <pre><code>when (val result = featureSafe { Features.DARK_MODE }) {\n    is EvaluationResult.Success -&gt; {\n        val value: Boolean = result.value\n        applyDarkMode(value)\n    }\n    is EvaluationResult.FlagNotFound -&gt; {\n        logWarning(\"Flag ${result.key} not registered\")\n        applyDarkMode(false)  // Fallback\n    }\n    is EvaluationResult.EvaluationError -&gt; {\n        logError(\"Evaluation failed\", result.error)\n        applyDarkMode(false)  // Fallback\n    }\n}\n</code></pre> <p>Use when:</p> <ul> <li>You need robust error handling</li> <li>Different failures require different actions</li> <li>Production systems with logging/monitoring</li> </ul>"},{"location":"05-evaluation/#evaluation-flow","title":"Evaluation Flow","text":"<p>Understanding how evaluation works helps debug unexpected behavior.</p>"},{"location":"05-evaluation/#step-by-step-process","title":"Step-by-Step Process","text":"<pre><code>flowchart TD\n    Start[Context Created] --&gt; Lookup[Registry Lookup]\n    Lookup --&gt; Found{Flag Found?}\n    Found --&gt;|No| NotFound[Return FlagNotFound]\n    Found --&gt;|Yes| Active{Flag Active?}\n    Active --&gt;|No| Default1[Return Default]\n    Active --&gt;|Yes| Rules[Get Rules&lt;br/&gt;Sorted by Specificity]\n\n    Rules --&gt; NextRule{Next Rule}\n    NextRule --&gt;|No more| Default2[Return Default]\n    NextRule --&gt;|Has rule| Match{Rule&lt;br/&gt;Matches?}\n\n    Match --&gt;|No| NextRule\n    Match --&gt;|Yes| Rollout{In Rollout&lt;br/&gt;Bucket?}\n\n    Rollout --&gt;|No| NextRule\n    Rollout --&gt;|Yes| ReturnValue[Return Rule Value]\n\n    style Start fill:#e1f5ff\n    style ReturnValue fill:#c8e6c9\n    style Default1 fill:#fff3cd\n    style Default2 fill:#fff3cd\n    style NotFound fill:#f8d7da</code></pre>"},{"location":"05-evaluation/#1-registry-lookup","title":"1. Registry Lookup","text":"<pre><code>val flag = namespace.featureFlag(Features.DARK_MODE)\nif (flag == null) {\n    return EvaluationResult.FlagNotFound(key)\n}\n</code></pre> <p>Flag must be registered in namespace. Cross-namespace lookups fail.</p>"},{"location":"05-evaluation/#2-flag-activity-check","title":"2. Flag Activity Check","text":"<pre><code>if (!flag.isActive) {\n    return defaultValue\n}\n</code></pre> <p>Inactive flags always return default (kill switch behavior).</p>"},{"location":"05-evaluation/#3-rule-iteration-by-specificity","title":"3. Rule Iteration (by Specificity)","text":"<p>Rules pre-sorted by specificity (highest first):</p> <pre><code>for (rule in rulesSortedBySpecificity) {\n    if (rule.matches(context)) {\n        return rule.value  // First match wins\n    }\n}\n</code></pre>"},{"location":"05-evaluation/#4-rule-matching","title":"4. Rule Matching","text":"<p>All criteria must match (AND logic):</p> <pre><code>// Platform check\nif (rule.platforms.isNotEmpty() &amp;&amp; context.platform !in rule.platforms) {\n    return false\n}\n\n// Locale check\nif (rule.locales.isNotEmpty() &amp;&amp; context.locale !in rule.locales) {\n    return false\n}\n\n// Version check\nif (!rule.versionRange.contains(context.appVersion)) {\n    return false\n}\n\n// Custom extension\nif (!rule.extension.matches(context)) {\n    return false\n}\n</code></pre> <p>Empty constraint sets match everything (no platforms = all platforms).</p>"},{"location":"05-evaluation/#5-rollout-bucketing","title":"5. Rollout Bucketing","text":"<p>Finally, check if user is in rollout bucket:</p> <pre><code>val bucket = stableBucket(flagKey, context.stableId, salt)\nval threshold = (rollout.value * 100).toInt()\nif (bucket &gt;= threshold) {\n    return false  // Not in bucket\n}\n</code></pre>"},{"location":"05-evaluation/#6-value-resolution","title":"6. Value Resolution","text":"<p>If all checks pass, return rule's value. Otherwise, continue to next rule or return default.</p>"},{"location":"05-evaluation/#error-handling","title":"Error Handling","text":"<p>Konditional follows \"parse, don't validate\" principle\u2014errors are values, not exceptions.</p>"},{"location":"05-evaluation/#evaluationresult","title":"EvaluationResult","text":"<p>Sealed interface with three cases:</p> <pre><code>sealed interface EvaluationResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : EvaluationResult&lt;T&gt;\n    data class FlagNotFound(val key: String) : EvaluationResult&lt;Nothing&gt;\n    data class EvaluationError(val key: String, val error: Throwable) : EvaluationResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"05-evaluation/#utility-methods","title":"Utility Methods","text":"<pre><code>// Transform success value\nresult.map { value -&gt; value.toString() }\n\n// Fold to single type\nresult.fold(\n    onSuccess = { value -&gt; \"Value: $value\" },\n    onFlagNotFound = { \"Not found: $it\" },\n    onEvaluationError = { key, error -&gt; \"Error in $key: ${error.message}\" }\n)\n\n// Get or else\nresult.getOrElse { fallback }\nresult.getOrNull()\nresult.getOrDefault(fallback)\n</code></pre>"},{"location":"05-evaluation/#parseresult","title":"ParseResult","text":"<p>For parsing operations (Version, JSON):</p> <pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n\nsealed class ParseError {\n    data class InvalidVersion(val raw: String, val message: String) : ParseError()\n    // ... other parse errors\n}\n</code></pre> <p>Example:</p> <pre><code>when (val result = Version.parse(\"2.1.0\")) {\n    is ParseResult.Success -&gt; use(result.value)\n    is ParseResult.Failure -&gt; logError(result.error.toString())\n}\n</code></pre>"},{"location":"05-evaluation/#performance","title":"Performance","text":""},{"location":"05-evaluation/#time-complexity","title":"Time Complexity","text":"<ul> <li>Registry lookup: O(1) hash table</li> <li>Rule iteration: O(n) where n = number of rules (typically &lt; 10)</li> <li>Rollout bucketing: O(1) SHA-256 hash</li> <li>Total: O(n) where n is small</li> </ul> <p>Typical flags have 1-5 rules, so evaluation is effectively O(1).</p>"},{"location":"05-evaluation/#space-complexity","title":"Space Complexity","text":"<ul> <li>Zero allocations during evaluation</li> <li>All data structures pre-allocated and immutable</li> <li>No string concatenation (except bucketing hash input)</li> </ul> <p>Memory per flag: ~200-500 bytes (FlagDefinition + rules + strings)</p>"},{"location":"05-evaluation/#concurrency","title":"Concurrency","text":"<p>Lock-free reads: No synchronization required for evaluation.</p> <pre><code>// Multiple threads evaluating concurrently\nthread1: feature { Features.DARK_MODE }  // No lock\nthread2: feature { Features.DARK_MODE }  // No lock\n</code></pre> <p>Atomic updates: Registry uses <code>AtomicReference</code> for configuration snapshots.</p> <pre><code>Namespace.Global.load(newConfig)  // Atomic swap\n// Readers see either old or new, never partial\n</code></pre> <p>Scalability: Throughput scales linearly with CPU cores (no contention).</p>"},{"location":"05-evaluation/#thread-safety","title":"Thread Safety","text":""},{"location":"05-evaluation/#lock-free-evaluation","title":"Lock-Free Evaluation","text":"<pre><code>// Safe concurrent evaluation\nval threads = (1..100).map {\n    thread {\n        repeat(1000) {\n            val value = feature { Features.DARK_MODE }\n            processValue(value)\n        }\n    }\n}\n</code></pre> <p>How it works:</p> <ul> <li>Immutable data structures (<code>FlagDefinition</code>, rules)</li> <li>AtomicReference for registry</li> <li>Readers see consistent snapshot</li> </ul>"},{"location":"05-evaluation/#atomic-updates","title":"Atomic Updates","text":"<pre><code>// Thread 1: Updating\nNamespace.Global.load(newConfig)\n\n// Thread 2: Reading during update\nval value = feature { Features.DARK_MODE }\n// Sees old OR new, never mixed\n</code></pre> <p>Guarantees:</p> <ul> <li>Updates are atomic (all-or-nothing)</li> <li>No torn reads</li> <li>No race conditions</li> </ul>"},{"location":"05-evaluation/#testing-evaluation","title":"Testing Evaluation","text":""},{"location":"05-evaluation/#test-rule-matching","title":"Test Rule Matching","text":"<pre><code>@Test\nfun `iOS users in US get dark mode`() {\n    val context = Context(\n        locale = AppLocale.UNITED_STATES,\n        platform = Platform.IOS,\n        appVersion = Version.parse(\"2.1.0\"),\n        stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n    )\n\n    val result = featureSafe { Features.DARK_MODE }\n    assertTrue(result is EvaluationResult.Success &amp;&amp; result.value)\n}\n</code></pre>"},{"location":"05-evaluation/#test-determinism","title":"Test Determinism","text":"<pre><code>@Test\nfun `evaluation is deterministic`() {\n    val context = Context(...)\n\n    val results = (1..100).map {\n        feature { Features.DARK_MODE }\n    }\n\n    assertTrue(results.distinct().size == 1, \"Non-deterministic!\")\n}\n</code></pre>"},{"location":"05-evaluation/#test-rollout-distribution","title":"Test Rollout Distribution","text":"<pre><code>@Test\nfun `50 percent rollout distributes correctly`() {\n    val sampleSize = 10_000\n    val enabled = (0 until sampleSize).count { i -&gt;\n        val ctx = Context(\n            ...\n            stableId = StableId.of(\"user-$i\")\n        )\n        feature { Features.ROLLOUT_FLAG }\n    }\n\n    val percentage = (enabled.toDouble() / sampleSize) * 100\n    assertTrue(percentage in 48.0..52.0)  // \u00b12% variance\n}\n</code></pre>"},{"location":"05-evaluation/#best-practices","title":"Best Practices","text":""},{"location":"05-evaluation/#1-prefer-feature","title":"1. Prefer feature { }","text":"<p>For most production code:</p> <pre><code>// Good - simple, clear\nval enabled = feature { Features.DARK_MODE }\n\n// Good - when error handling matters\nwhen (val result = featureSafe { Features.DARK_MODE }) {\n    is EvaluationResult.Success -&gt; use(result.value)\n    else -&gt; logAndFallback()\n}\n</code></pre>"},{"location":"05-evaluation/#2-cache-contexts","title":"2. Cache Contexts","text":"<p>Create once, reuse for multiple evaluations:</p> <pre><code>// Good\nval context = createUserContext(user)\nval darkMode = feature { Features.DARK_MODE }\nval apiEndpoint = feature { Config.API_ENDPOINT }\nval maxRetries = feature { Config.MAX_RETRIES }\n\n// Avoid\ncreateUserContext(user) // then evaluate elsewhere\n</code></pre>"},{"location":"05-evaluation/#3-test-with-specific-contexts","title":"3. Test with Specific Contexts","text":"<p>Create test contexts for specific scenarios:</p> <pre><code>fun testContext(\n    platform: Platform = Platform.IOS,\n    locale: AppLocale = AppLocale.UNITED_STATES,\n    version: String = \"1.0.0\",\n    stableId: String = \"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\"\n) = Context(\n    locale = locale,\n    platform = platform,\n    appVersion = Version.parse(version),\n    stableId = StableId.of(stableId)\n)\n\n@Test\nfun testTargeting() {\n    val iosContext = testContext(platform = Platform.IOS)\n    assertTrue(feature { Features.IOS_ONLY })\n\n    val androidContext = testContext(platform = Platform.ANDROID)\n    assertFalse(feature { Features.IOS_ONLY })\n}\n</code></pre>"},{"location":"05-evaluation/#guarantees","title":"Guarantees","text":"Aspect Guarantee Type safety Return type matches flag definition (compile-time) Determinism Same inputs always produce same outputs Specificity Most specific matching rule always wins Bucketing SHA-256 ensures independent, stable buckets Performance O(n) where n = rules per flag (&lt; 10) Thread safety Lock-free reads, immutable data Null safety Never returns null (with OrDefault methods) <p>Core principle: If it compiles, evaluation is correct and deterministic.</p>"},{"location":"05-evaluation/#next-steps","title":"Next Steps","text":"<p>Loading remote configs? See Remote Configuration for JSON serialization.</p> <p>Building targeting rules? See Targeting &amp; Rollouts for rules and specificity.</p> <p>Understanding the basics? See Core Concepts for Features and Context.</p>"},{"location":"06-remote-config/","title":"Remote Configuration","text":"<p>Update flags without redeployment. Konditional provides UI-based management with RBAC or JSON-based configuration for dynamic rule updates.</p>"},{"location":"06-remote-config/#why-remote-configuration","title":"Why Remote Configuration?","text":"<p>Konditional flags are defined in code (type-safe), but rules can be updated via UI or JSON for dynamic updates:</p> <pre><code>// Flags defined in code (type-safe, version-controlled)\nobject Features : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.example.com\")\n}\n\n// Rules loaded from JSON (updatable without deployment)\nval remoteJson = fetchFromServer(\"/flags.json\")\nwhen (val result = SnapshotSerializer.fromJson(remoteJson)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logger.error(\"Failed to load: ${result.error}\")\n}\n</code></pre> <p>Key distinction:</p> <ul> <li>Flag definitions live in code (compile-time safety, version-controlled)</li> <li>Flag rules can be updated via UI (RBAC-controlled) or JSON (runtime flexibility)</li> </ul>"},{"location":"06-remote-config/#json-serialization","title":"JSON Serialization","text":""},{"location":"06-remote-config/#export-configuration","title":"Export Configuration","text":"<pre><code>// Serialize current configuration\nval config = Namespace.Global.configuration()\nval json = SnapshotSerializer.serialize(config)\n\n// Save to file\nFile(\"flags.json\").writeText(json)\n</code></pre> <p>Example output:</p> <pre><code>{\n  \"flags\": {\n    \"dark_mode\": {\n      \"default\": false,\n      \"active\": true,\n      \"salt\": \"v1\",\n      \"rules\": [\n        {\n          \"platforms\": [\"IOS\"],\n          \"rollout\": 50.0,\n          \"value\": true\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"06-remote-config/#import-configuration","title":"Import Configuration","text":"<pre><code>// Load from file\nval json = File(\"flags.json\").readText()\n\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; {\n        Namespace.Global.load(result.value)\n        logger.info(\"Configuration loaded successfully\")\n    }\n    is ParseResult.Failure -&gt; {\n        logger.error(\"Parse failed: ${result.error}\")\n        // Keep existing configuration\n    }\n}\n</code></pre>"},{"location":"06-remote-config/#patch-updates","title":"Patch Updates","text":"<p>Apply incremental changes without full replacement:</p> <pre><code>val currentConfig = Namespace.Global.configuration()\n\n// Patch JSON contains only changed flags\nval patchJson = \"\"\"\n{\n  \"dark_mode\": {\n    \"rules\": [{\n      \"platforms\": [\"IOS\", \"ANDROID\"],\n      \"rollout\": 100.0,\n      \"value\": true\n    }]\n  }\n}\n\"\"\"\n\nwhen (val result = SnapshotSerializer.applyPatchJson(currentConfig, patchJson)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logger.error(\"Patch failed: ${result.error}\")\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Smaller payloads</li> <li>Partial updates (other flags unchanged)</li> <li>Reduced risk (only changed flags affected)</li> </ul>"},{"location":"06-remote-config/#storage-patterns","title":"Storage Patterns","text":""},{"location":"06-remote-config/#pattern-1-file-based","title":"Pattern 1: File-Based","text":"<p>Store configurations as local files:</p> <pre><code>class FileConfigLoader(private val filePath: String) {\n    fun load(): Configuration? {\n        val file = File(filePath)\n        if (!file.exists()) return null\n\n        val json = file.readText()\n        return when (val result = SnapshotSerializer.fromJson(json)) {\n            is ParseResult.Success -&gt; result.value\n            is ParseResult.Failure -&gt; {\n                logger.error(\"Failed to parse $filePath: ${result.error}\")\n                null\n            }\n        }\n    }\n\n    fun save(config: Configuration) {\n        val json = SnapshotSerializer.serialize(config)\n        File(filePath).writeText(json)\n    }\n}\n\n// Usage\nval loader = FileConfigLoader(\"/etc/app/flags.json\")\nloader.load()?.let { Namespace.Global.load(it) }\n</code></pre> <p>Use cases:</p> <ul> <li>Desktop applications</li> <li>Server-side with local config files</li> <li>Docker containers with mounted volumes</li> </ul>"},{"location":"06-remote-config/#pattern-2-database","title":"Pattern 2: Database","text":"<p>Store in database for multi-instance consistency:</p> <pre><code>class DbConfigLoader(private val db: Database) {\n    fun load(namespace: String): Configuration? {\n        val json = db.query(\"SELECT config FROM flag_configs WHERE namespace = ?\", namespace)\n            .firstOrNull()\n            ?: return null\n\n        return when (val result = SnapshotSerializer.fromJson(json)) {\n            is ParseResult.Success -&gt; result.value\n            is ParseResult.Failure -&gt; null\n        }\n    }\n\n    fun save(namespace: String, config: Configuration) {\n        val json = SnapshotSerializer.serialize(config)\n        db.execute(\n            \"INSERT INTO flag_configs (namespace, config) VALUES (?, ?) ON CONFLICT (namespace) DO UPDATE SET config = ?\",\n            namespace, json, json\n        )\n    }\n}\n</code></pre> <p>Use cases:</p> <ul> <li>Multi-instance servers (shared config)</li> <li>Audit trail (store updates in DB)</li> <li>Versioning (store historical configs)</li> </ul>"},{"location":"06-remote-config/#pattern-3-cloud-storage","title":"Pattern 3: Cloud Storage","text":"<p>Fetch from S3, CloudFront CDN, etc.:</p> <pre><code>class CloudConfigLoader(private val httpClient: HttpClient) {\n    suspend fun load(url: String): Configuration? {\n        val json = try {\n            httpClient.get(url).bodyAsText()\n        } catch (e: Exception) {\n            logger.error(\"Failed to fetch $url\", e)\n            return null\n        }\n\n        return when (val result = SnapshotSerializer.fromJson(json)) {\n            is ParseResult.Success -&gt; result.value\n            is ParseResult.Failure -&gt; null\n        }\n    }\n}\n\n// Usage\nval loader = CloudConfigLoader(client)\nlaunch {\n    val config = loader.load(\"https://cdn.example.com/flags.json\")\n    config?.let { Namespace.Global.load(it) }\n}\n</code></pre> <p>Use cases:</p> <ul> <li>Mobile apps (fetch on launch)</li> <li>Edge computing (CDN-backed configs)</li> <li>Global deployments (region-specific endpoints)</li> </ul>"},{"location":"06-remote-config/#update-strategies","title":"Update Strategies","text":""},{"location":"06-remote-config/#strategy-1-polling","title":"Strategy 1: Polling","text":"<p>Periodically check for updates:</p> <pre><code>class PollingConfigUpdater(\n    private val loader: CloudConfigLoader,\n    private val url: String,\n    private val intervalMs: Long = 60_000  // 1 minute\n) {\n    fun start() {\n        timer(period = intervalMs) {\n            runBlocking {\n                val config = loader.load(url)\n                config?.let {\n                    Namespace.Global.load(it)\n                    logger.info(\"Configuration updated\")\n                }\n            }\n        }\n    }\n}\n\n// Usage\nval updater = PollingConfigUpdater(loader, \"https://api.example.com/flags.json\")\nupdater.start()\n</code></pre> <p>Pros: Simple, reliable Cons: Latency (up to poll interval), unnecessary requests</p>"},{"location":"06-remote-config/#strategy-2-streamingpush","title":"Strategy 2: Streaming/Push","text":"<p>Server pushes updates to clients:</p> <pre><code>class StreamingConfigUpdater(private val wsClient: WebSocketClient) {\n    fun connect(url: String) {\n        wsClient.connect(url) { message -&gt;\n            when (val result = SnapshotSerializer.fromJson(message)) {\n                is ParseResult.Success -&gt; {\n                    Namespace.Global.load(result.value)\n                    logger.info(\"Configuration updated via WebSocket\")\n                }\n                is ParseResult.Failure -&gt; logger.error(\"Invalid config: ${result.error}\")\n            }\n        }\n    }\n}\n</code></pre> <p>Pros: Instant updates, efficient Cons: More complex, requires WebSocket infrastructure</p>"},{"location":"06-remote-config/#strategy-3-on-demand","title":"Strategy 3: On-Demand","text":"<p>Load on app launch or user action:</p> <pre><code>suspend fun updateConfiguration() {\n    val json = httpClient.get(\"https://api.example.com/flags.json\").bodyAsText()\n    when (val result = SnapshotSerializer.fromJson(json)) {\n        is ParseResult.Success -&gt; {\n            Namespace.Global.load(result.value)\n            showToast(\"Configuration updated\")\n        }\n        is ParseResult.Failure -&gt; showError(\"Update failed\")\n    }\n}\n\n// Usage\n// On app launch\nlifecycleScope.launch {\n    updateConfiguration()\n}\n\n// Or on button click\nbutton.setOnClickListener {\n    lifecycleScope.launch { updateConfiguration() }\n}\n</code></pre> <p>Pros: User-controlled, simple Cons: Requires user action</p>"},{"location":"06-remote-config/#dsl-quick-reference","title":"DSL Quick Reference","text":""},{"location":"06-remote-config/#boolean-flags","title":"Boolean Flags","text":"<pre><code>val FLAG by boolean(default = false) {\n    salt(\"v1\")\n    active { true }\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.UNITED_STATES)\n        versions { min(2, 0, 0) }\n        rollout { 50.0 }\n        note(\"iOS US users, v2+, 50%\")\n    } returns true\n}\n</code></pre>"},{"location":"06-remote-config/#string-flags","title":"String Flags","text":"<pre><code>val CONFIG by string(default = \"default\") {\n    rule { platforms(Platform.IOS) } returns \"ios-value\"\n    rule { platforms(Platform.ANDROID) } returns \"android-value\"\n}\n</code></pre>"},{"location":"06-remote-config/#integerdouble-flags","title":"Integer/Double Flags","text":"<pre><code>val MAX_RETRIES by int(default = 3) {\n    rule { platforms(Platform.WEB) } returns 5\n}\n\nval TIMEOUT by double(default = 30.0) {\n    rule { platforms(Platform.MOBILE) } returns 60.0\n}\n</code></pre>"},{"location":"06-remote-config/#custom-logic","title":"Custom Logic","text":"<pre><code>val PREMIUM by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n            }\n        }\n    } returns true\n}\n</code></pre>"},{"location":"06-remote-config/#best-practices","title":"Best Practices","text":""},{"location":"06-remote-config/#1-validate-after-loading","title":"1. Validate After Loading","text":"<p>Always check parse results:</p> <pre><code>when (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; {\n        // Optionally validate business rules\n        if (validateConfig(result.value)) {\n            Namespace.Global.load(result.value)\n        } else {\n            logger.error(\"Configuration failed validation\")\n        }\n    }\n    is ParseResult.Failure -&gt; logger.error(\"Parse failed: ${result.error}\")\n}\n</code></pre>"},{"location":"06-remote-config/#2-cache-configurations","title":"2. Cache Configurations","text":"<p>Avoid repeated network calls:</p> <pre><code>class CachedConfigLoader(\n    private val remoteLoader: CloudConfigLoader,\n    private val cacheFile: File\n) {\n    suspend fun load(url: String): Configuration? {\n        // Try cache first\n        if (cacheFile.exists()) {\n            val cached = loadFromFile(cacheFile)\n            if (cached != null) return cached\n        }\n\n        // Fetch from remote\n        val config = remoteLoader.load(url)\n        config?.let { saveToFile(it, cacheFile) }\n        return config\n    }\n}\n</code></pre>"},{"location":"06-remote-config/#3-handle-load-failures-gracefully","title":"3. Handle Load Failures Gracefully","text":"<p>Keep existing configuration on failure:</p> <pre><code>val currentConfig = Namespace.Global.configuration()  // Backup\n\nwhen (val result = loadRemoteConfig()) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; {\n        logger.error(\"Failed to load remote config, keeping current\")\n        // currentConfig still in effect\n    }\n}\n</code></pre>"},{"location":"06-remote-config/#4-version-your-configurations","title":"4. Version Your Configurations","text":"<p>Track changes over time:</p> <pre><code>{\n  \"version\": \"2024-01-15T10:30:00Z\",\n  \"flags\": { ... }\n}\n</code></pre>"},{"location":"06-remote-config/#5-use-patches-for-incremental-updates","title":"5. Use Patches for Incremental Updates","text":"<p>Send only changes, not full configs:</p> <pre><code>// Small patch JSON\nval patch = \"\"\"{\"dark_mode\": {\"rules\": [...]}}\"\"\"\n\n// Apply to current config\nSnapshotSerializer.applyPatchJson(currentConfig, patch)\n</code></pre>"},{"location":"06-remote-config/#common-patterns","title":"Common Patterns","text":""},{"location":"06-remote-config/#pattern-kill-switch","title":"Pattern: Kill Switch","text":"<p>Remotely disable feature without deployment:</p> <pre><code>{\n  \"payment_processing\": {\n    \"active\": false,\n    \"default\": false\n  }\n}\n</code></pre>"},{"location":"06-remote-config/#pattern-gradual-rollout","title":"Pattern: Gradual Rollout","text":"<p>Increase rollout percentage over time:</p> <pre><code>// Day 1\n{\"new_feature\": {\"rules\": [{\"rollout\": 10.0, \"value\": true}]}}\n\n// Day 3\n{\"new_feature\": {\"rules\": [{\"rollout\": 50.0, \"value\": true}]}}\n\n// Day 7\n{\"new_feature\": {\"rules\": [{\"rollout\": 100.0, \"value\": true}]}}\n</code></pre>"},{"location":"06-remote-config/#pattern-platform-specific-config","title":"Pattern: Platform-Specific Config","text":"<p>Different settings per platform:</p> <pre><code>{\n  \"api_endpoint\": {\n    \"default\": \"https://api.example.com\",\n    \"rules\": [\n      {\n        \"platforms\": [\"IOS\"],\n        \"value\": \"https://api-ios.example.com\"\n      },\n      {\n        \"platforms\": [\"ANDROID\"],\n        \"value\": \"https://api-android.example.com\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"06-remote-config/#next-steps","title":"Next Steps","text":"<p>Just getting started? See Getting Started for your first flag.</p> <p>Need advanced targeting? See Targeting &amp; Rollouts for rules and specificity.</p> <p>Understanding evaluation? See Evaluation for evaluation methods and flow.</p>"},{"location":"venv/lib/python3.14/site-packages/backrefs-5.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/idna-3.11.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/markdown-3.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip-25.2.dist-info/licenses/src/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}