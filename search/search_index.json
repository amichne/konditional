{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"01-getting-started/","title":"Getting Started","text":"<p>Konditional is a Kotlin feature-flag DSL designed to make configuration typed, deterministic, and non-null. The core claim is precise: statically-defined flags have compile-time type correctness, and evaluation is total (you always get a value back).</p>"},{"location":"01-getting-started/#why-konditional-and-what-it-actually-guarantees","title":"Why Konditional (and what it actually guarantees)","text":"<p>Most flag systems are stringly-typed: a string key selects a value and the caller chooses a \u201ctyped getter\u201d. That architecture creates three failure modes that are syntactically valid but semantically wrong at runtime: key typos, type mismatches, and null propagation.</p> <p>Konditional changes the failure surface by binding identity and type at definition time via Kotlin properties:</p> <ul> <li>No string keys at call sites: flags are accessed as properties (typos become compile errors).</li> <li>No casts at call sites: the return type flows from the flag definition (mismatched types become compile errors).</li> <li>No nulls from evaluation: defaults are required, so evaluation has a total return path.</li> </ul> <pre><code>flowchart LR\n  Def[\"Flag defined as a property\"] --&gt; Bound[\"Key + type bound at compile-time\"]\n  Bound --&gt; Eval[\"Evaluation\"]\n  Eval --&gt;|Rule matches| Value[\"Rule value\"]\n  Eval --&gt;|No match| Default[\"Declared default\"]\n  style Bound fill:#e1f5ff\n  style Default fill:#fff3cd\n  style Value fill:#c8e6c9</code></pre>"},{"location":"01-getting-started/#installation","title":"Installation","text":"<pre><code>// build.gradle.kts\ndependencies {\n    implementation(\"io.amichne:konditional:0.0.1\")\n}\n</code></pre>"},{"location":"01-getting-started/#your-first-flag","title":"Your first flag","text":"<p>Define a flag as a delegated property in a <code>FeatureContainer</code> bound to a <code>Namespace</code>:</p> <pre><code>import io.amichne.konditional.core.Namespace\nimport io.amichne.konditional.core.features.FeatureContainer\nimport io.amichne.konditional.context.*\n\nobject AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            rollout { 50.0 }\n        } returns true\n    }\n}\n\nval context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n\nval enabled: Boolean = feature { AppFeatures.DARK_MODE }\n</code></pre> <p>Notes: - Konditional models evaluation as context-dependent; examples assume you are evaluating within a context-aware scope. - <code>feature { ... }</code> returns the flag\u2019s declared Kotlin type and never returns null.</p>"},{"location":"01-getting-started/#a-small-api-surface-intentionally","title":"A small API surface, intentionally","text":"<p>Supported value types (out of the box):</p> Type DSL Method Kotlin Type Example Default Boolean <code>boolean()</code> <code>Boolean</code> <code>false</code> String <code>string()</code> <code>String</code> <code>\"production\"</code> Integer <code>int()</code> <code>Int</code> <code>42</code> Decimal <code>double()</code> <code>Double</code> <code>3.14</code> Enum <code>enum&lt;E&gt;()</code> <code>E : Enum&lt;E&gt;</code> <code>LogLevel.INFO</code>"},{"location":"01-getting-started/#common-patterns","title":"Common patterns","text":""},{"location":"01-getting-started/#gradual-rollout-deterministic","title":"Gradual rollout (deterministic)","text":"<pre><code>val NEW_CHECKOUT by boolean(default = false) {\n    rule {\n        platforms(Platform.ANDROID)\n        rollout { 10.0 }\n    } returns true\n}\n</code></pre> <p>Konditional\u2019s rollouts are deterministic: the same <code>(stableId, flagKey, salt)</code> yields the same bucket assignment.</p>"},{"location":"01-getting-started/#platform-specific-configuration","title":"Platform-specific configuration","text":"<pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n    rule { platforms(Platform.WEB) } returns \"https://api-web.example.com\"\n}\n</code></pre>"},{"location":"01-getting-started/#variants-via-enums-not-strings","title":"Variants via enums (not strings)","text":"<pre><code>enum class Theme { LIGHT, DARK }\n\nval THEME by enum&lt;Theme, Context&gt;(default = Theme.LIGHT)\n</code></pre>"},{"location":"01-getting-started/#namespaces-scale-ownership-not-prefixes","title":"Namespaces scale ownership, not prefixes","text":"<p>Konditional provides <code>Namespace.Global</code>. If you need isolation boundaries beyond global, define your own namespaces in your codebase (consumer-defined), then bind <code>FeatureContainer</code>s to them.</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val APPLE_PAY by boolean(default = false)\n}\n</code></pre>"},{"location":"01-getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Learn the building blocks: \"Core Concepts\"</li> <li>Write targeting rules and understand rollouts: \"Targeting &amp; Rollouts\"</li> <li>Understand evaluation order and determinism: \"Evaluation\"</li> <li>Add runtime-validated JSON configuration: \"Remote Configuration\"</li> <li>Understand the exact trust boundary: \"Theory\"</li> </ul>"},{"location":"02-migration/","title":"Migration Guide","text":"<p>This guide maps the conceptual shift from string-based flags to Konditional\u2019s typed, property-based model. It focuses on what changes at the definition site, at the call site, and at the trust boundary (runtime JSON).</p>"},{"location":"02-migration/#the-core-mapping","title":"The core mapping","text":"<p>String-based flag systems typically have: - a string key (<code>\"dark-mode\"</code>) - a typed getter chosen by the caller (<code>getBoolean</code>, <code>getString</code>, \u2026) - an untyped context (often string keys and <code>Any</code> values)</p> <p>Konditional replaces those with: - a property (the property name becomes the key) - a declared type (from the delegate: <code>boolean</code>, <code>string</code>, <code>int</code>, <code>double</code>, <code>enum</code>) - a typed <code>Context</code> (and optionally domain-specific context data classes)</p> <pre><code>flowchart LR\n  A[\"String key\"] --&gt; B[\"Property name\"]\n  C[\"Typed getter\"] --&gt; D[\"Type flows from definition\"]\n  E[\"Untyped context map\"] --&gt; F[\"Typed Context data\"]</code></pre>"},{"location":"02-migration/#step-by-step-adoption-incremental","title":"Step-by-step adoption (incremental)","text":""},{"location":"02-migration/#0-start-with-one-container","title":"0. Start with one container","text":"<pre><code>object Features : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n}\n</code></pre>"},{"location":"02-migration/#1-replace-call-sites-first-value-safety","title":"1. Replace call sites first (value safety)","text":"<pre><code>val enabled: Boolean = feature { Features.DARK_MODE }\n</code></pre> <p>What you gain immediately: - key typos are eliminated at the call site (there is no string key) - return type is concrete (no cast; <code>Boolean</code> is enforced) - evaluation is non-null (default is required)</p>"},{"location":"02-migration/#2-introduce-typed-context-targeting-rollouts","title":"2. Introduce typed context (targeting + rollouts)","text":"<pre><code>val context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n</code></pre> <p><code>stableId</code> is the stable input used for deterministic rollout bucketing (see \"Targeting &amp; Rollouts\").</p>"},{"location":"02-migration/#3-add-rules-after-defaults-exist-behavior-safety","title":"3. Add rules after defaults exist (behavior safety)","text":"<pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n}\n</code></pre>"},{"location":"02-migration/#migrating-context-maps-to-typed-contexts","title":"Migrating \u201ccontext maps\u201d to typed contexts","text":"<p>If your current system uses string keys (<code>\"tier\"</code>, <code>\"role\"</code>, \u2026), move that information into a custom context:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val employeeCount: Int\n) : Context\n\nenum class SubscriptionTier { FREE, PRO, ENTERPRISE }\n\nval ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                    ctx.employeeCount &gt; 100\n            }\n        }\n    } returns true\n}\n</code></pre> <p>Result: business targeting logic becomes type-checked and refactor-safe.</p>"},{"location":"02-migration/#namespaces-replace-prefixes","title":"Namespaces replace prefixes","text":"<p>Instead of <code>\"auth.dark-mode\"</code> / <code>\"payments.dark-mode\"</code> style prefixes, use namespace isolation:</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val APPLE_PAY by boolean(default = false)\n}\n</code></pre> <p>Each namespace has its own registry and independent configuration lifecycle.</p>"},{"location":"02-migration/#when-you-need-runtime-configuration-remote-json","title":"When you need runtime configuration (remote JSON)","text":"<p>Konditional supports JSON configuration as a validated boundary:</p> <pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Parse failed: ${result.error}\")\n}\n</code></pre> <p>The guarantee is intentionally qualified: JSON is not \u201calways safe\u201d; instead, invalid JSON is rejected before it can affect evaluation.</p>"},{"location":"02-migration/#next-steps","title":"Next steps","text":"<ul> <li>Learn the primitives: \"Core Concepts\"</li> <li>Understand rule evaluation and determinism: \"Evaluation\"</li> <li>Operate remote config safely: \"Remote Configuration\"</li> </ul>"},{"location":"03-core-concepts/","title":"Core Concepts","text":"<p>Konditional\u2019s public surface is intentionally small. Understanding three primitives\u2014Features, Context, and Namespaces\u2014is enough to reason about correctness, organization, and runtime behavior.</p> <pre><code>flowchart TD\n  N[\"Namespace\"] --&gt; R[\"Registry\"]\n  C[\"FeatureContainer\"] --&gt; R\n  C --&gt; F[\"Feature (typed)\"]\n  F --&gt; D[\"Default (required)\"]\n  F --&gt; Rules[\"Rules\"]\n  Rules --&gt; Rule[\"rule { ... } returns value\"]\n  Rule --&gt; Criteria[\"platforms/locales/versions/rollout/extension\"]\n  X[\"Context\"] --&gt; Rule</code></pre>"},{"location":"03-core-concepts/#features","title":"Features","text":"<p>A feature is a typed configuration value with an optional rule set. You define features as delegated properties in a <code>FeatureContainer</code>:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.example.com\")\n    val MAX_RETRIES by int(default = 3)\n    val TIMEOUT by double(default = 30.0)\n}\n\nval enabled: Boolean = feature { AppFeatures.DARK_MODE }\nval endpoint: String = feature { AppFeatures.API_ENDPOINT }\n</code></pre> <p>What this buys you: - Property name becomes the key (no string keys at call sites) - Type flows from the delegate (<code>boolean</code> \u2192 <code>Boolean</code>, etc.) - Non-null evaluation (default is required)</p>"},{"location":"03-core-concepts/#supported-types","title":"Supported types","text":"Type DSL Method Kotlin Type Example Default Boolean <code>boolean()</code> <code>Boolean</code> <code>false</code> String <code>string()</code> <code>String</code> <code>\"production\"</code> Integer <code>int()</code> <code>Int</code> <code>42</code> Decimal <code>double()</code> <code>Double</code> <code>3.14</code> Enum <code>enum&lt;E&gt;()</code> <code>E : Enum&lt;E&gt;</code> <code>LogLevel.INFO</code>"},{"location":"03-core-concepts/#enums-instead-of-strings","title":"Enums instead of strings","text":"<pre><code>enum class LogLevel { DEBUG, INFO, WARN, ERROR }\nenum class Theme { LIGHT, DARK, AUTO }\n\nobject AppConfig : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val LOG_LEVEL by enum&lt;LogLevel, Context&gt;(default = LogLevel.INFO)\n    val THEME by enum&lt;Theme, Context&gt;(default = Theme.LIGHT)\n}\n\nval level: LogLevel = feature { AppConfig.LOG_LEVEL }\n</code></pre> <p>Because variants are enum values, invalid variants cannot compile.</p>"},{"location":"03-core-concepts/#rules","title":"Rules","text":"<p>Rules are a typed mapping from a set of criteria to a concrete return value:</p> <pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n}\n</code></pre> <p>Criteria you can compose (within a single rule): - <code>platforms(...)</code> - <code>locales(...)</code> - <code>versions { min(...); max(...) }</code> - <code>rollout { percent }</code> - <code>extension { ... }</code> for custom predicates</p> <p>Within a rule, criteria combine as AND: all specified criteria must match for the rule to match.</p>"},{"location":"03-core-concepts/#custom-predicates-via-extension","title":"Custom predicates via <code>extension { }</code>","text":"<p>To keep business targeting logic typed (not string-based), define a custom <code>Context</code> and use <code>extension { }</code>:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val employeeCount: Int\n) : Context\n\nenum class SubscriptionTier { FREE, PRO, ENTERPRISE }\n\nobject PremiumFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            extension {\n                Evaluable.factory { ctx -&gt;\n                    ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                        ctx.employeeCount &gt; 100\n                }\n            }\n        } returns true\n    }\n}\n</code></pre> <p>Because the feature is parameterized with <code>EnterpriseContext</code>, <code>ctx</code> is strongly typed inside the predicate.</p>"},{"location":"03-core-concepts/#context","title":"Context","text":"<p>Context provides evaluation inputs: it tells Konditional who is asking and where they are.</p> <p>Standard fields (the minimum required by the rule DSL):</p> <pre><code>data class Context(\n    val locale: AppLocale,\n    val platform: Platform,\n    val appVersion: Version,\n    val stableId: StableId\n)\n</code></pre>"},{"location":"03-core-concepts/#stableid-deterministic-rollouts","title":"StableId (deterministic rollouts)","text":"<p><code>stableId</code> is a stable identifier used for deterministic bucketing. It must be hex (32+ chars):</p> <pre><code>val id = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n</code></pre> <p>If you have an existing user ID, hash it into hex:</p> <pre><code>fun toStableId(userId: String): StableId {\n    val hash = MessageDigest.getInstance(\"SHA-256\")\n        .digest(userId.toByteArray())\n        .joinToString(\"\") { \"%02x\".format(it) }\n    return StableId.of(hash)\n}\n</code></pre>"},{"location":"03-core-concepts/#namespaces","title":"Namespaces","text":"<p>Namespaces are isolation boundaries: each namespace has its own registry and independent configuration lifecycle. Konditional provides <code>Namespace.Global</code>. If you need more isolation boundaries, define your own namespaces (consumer-defined) and bind containers to them.</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val APPLE_PAY by boolean(default = false)\n    val STRIPE_INTEGRATION by boolean(default = true)\n}\n\nAppDomain.Auth.load(authConfig)\nAppDomain.Payments.load(paymentConfig)\n</code></pre>"},{"location":"03-core-concepts/#custom-namespaces-governance","title":"Custom namespaces (governance)","text":"<pre><code>sealed class TeamDomain(id: String) : Namespace(id) {\n    data object Recommendations : TeamDomain(\"recommendations\")\n    data object Analytics : TeamDomain(\"analytics\")\n}\n\nobject RecFeatures : FeatureContainer&lt;TeamDomain.Recommendations&gt;(TeamDomain.Recommendations) {\n    val COLLABORATIVE_FILTERING by boolean(default = true)\n}\n</code></pre>"},{"location":"03-core-concepts/#type-safety-in-action-what-becomes-impossible","title":"Type safety in action (what becomes impossible)","text":""},{"location":"03-core-concepts/#wrong-value-type-at-call-site","title":"Wrong value type at call site","text":"<pre><code>object Config : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val MAX_RETRIES by int(default = 3)\n}\n\nval retries: Int = feature { Config.MAX_RETRIES }\n</code></pre>"},{"location":"03-core-concepts/#wrong-context-type-for-a-feature","title":"Wrong context type for a feature","text":"<pre><code>val basicContext: Context = Context(...)\nfeature { PremiumFeatures.ADVANCED_ANALYTICS } // Compile error (requires EnterpriseContext)\n</code></pre>"},{"location":"03-core-concepts/#cross-namespace-misuse","title":"Cross-namespace misuse","text":"<pre><code>AppDomain.Auth.load(paymentConfig) // Compile error (type mismatch)\n</code></pre>"},{"location":"03-core-concepts/#next-steps","title":"Next steps","text":"<ul> <li>Understand rule composition and rollouts: \"Targeting &amp; Rollouts\"</li> <li>Understand evaluation order and determinism: \"Evaluation\"</li> <li>Understand the runtime JSON boundary: \"Remote Configuration\"</li> </ul>"},{"location":"04-targeting-rollouts/","title":"Targeting &amp; Rollouts","text":"<p>Rules let you target specific contexts and roll out behavior safely. A rule is a typed mapping:</p> <pre><code>criteria(context) -&gt; returns value\n</code></pre> <p>Two properties define how rules behave: - AND semantics within a rule: all specified criteria must match. - Specificity ordering across rules: the most specific matching rule wins.</p>"},{"location":"04-targeting-rollouts/#criteria-you-can-combine","title":"Criteria you can combine","text":""},{"location":"04-targeting-rollouts/#platform","title":"Platform","text":"<pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n    rule { platforms(Platform.WEB) } returns \"https://api-web.example.com\"\n}\n</code></pre> <p>Multiple platforms combine as OR:</p> <pre><code>rule { platforms(Platform.IOS, Platform.ANDROID) } returns \"mobile value\"\n</code></pre>"},{"location":"04-targeting-rollouts/#locale","title":"Locale","text":"<pre><code>val WELCOME_MESSAGE by string(default = \"Hello!\") {\n    rule { locales(AppLocale.UNITED_STATES, AppLocale.CANADA) } returns \"Welcome!\"\n    rule { locales(AppLocale.FRANCE) } returns \"Bienvenue!\"\n    rule { locales(AppLocale.JAPAN) } returns \"\u3088\u3046\u3053\u305d!\"\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#version-ranges","title":"Version ranges","text":"<pre><code>val NEW_UI by boolean(default = false) {\n    rule { versions { min(2, 0, 0) } } returns true\n}\n</code></pre> <pre><code>val LEGACY_SUPPORT by boolean(default = false) {\n    rule { versions { max(2, 0, 0) } } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#percentage-rollout","title":"Percentage rollout","text":"<pre><code>val NEW_CHECKOUT by boolean(default = false) {\n    rule { rollout { 10.0 } } returns true\n}\n</code></pre> <p>Rollouts are deterministic: the same <code>(stableId, flagKey, salt)</code> produces the same bucket assignment.</p>"},{"location":"04-targeting-rollouts/#custom-predicates-via-extension","title":"Custom predicates via <code>extension { }</code>","text":"<pre><code>val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                    ctx.employeeCount &gt; 100\n            }\n        }\n    } returns true\n}\n</code></pre>"},{"location":"04-targeting-rollouts/#and-semantics-inside-a-rule","title":"AND semantics inside a rule","text":"<p>All criteria in a rule must match:</p> <pre><code>val PREMIUM_FEATURE by boolean(default = false) {\n    rule {\n        platforms(Platform.IOS, Platform.ANDROID)\n        locales(AppLocale.UNITED_STATES)\n        versions { min(2, 0, 0) }\n        rollout { 50.0 }\n    } returns true\n}\n</code></pre> <pre><code>flowchart LR\n  Ctx[\"Context\"] --&gt; P{Platform match?}\n  P --&gt;|No| Skip[\"Rule fails\"]\n  P --&gt;|Yes| L{Locale match?}\n  L --&gt;|No| Skip\n  L --&gt;|Yes| V{Version match?}\n  V --&gt;|No| Skip\n  V --&gt;|Yes| R{Rollout bucket in range?}\n  R --&gt;|No| Skip\n  R --&gt;|Yes| Win[\"Rule matches\"]\n  style Win fill:#c8e6c9\n  style Skip fill:#ffcdd2</code></pre>"},{"location":"04-targeting-rollouts/#specificity-which-rule-wins","title":"Specificity: which rule wins","text":"<p>Konditional orders rules by specificity before evaluating them. Specificity is the count of criteria present on a rule:</p> <pre><code>specificity(rule):\n  +1 if platforms is set\n  +1 if locales is set\n  +1 if versions has bounds\n  +1 if rollout is set\n</code></pre> <p>Rules are evaluated in descending specificity; the first rule whose criteria all match determines the value. If no rules match, the default is returned.</p> <pre><code>flowchart TD\n  Rules[\"Rule set\"] --&gt; Sort[\"Sort by specificity (desc)\"]\n  Sort --&gt; Loop[\"Evaluate rules in order\"]\n  Loop --&gt;|First match| Value[\"Return rule value\"]\n  Loop --&gt;|No match| Default[\"Return default\"]\n  style Value fill:#c8e6c9\n  style Default fill:#fff3cd</code></pre>"},{"location":"04-targeting-rollouts/#deterministic-rollout-bucketing-sha-256","title":"Deterministic rollout bucketing (SHA-256)","text":"<p>Rollouts are computed locally. The bucketing input is stable and per-flag:</p> <pre><code>input = \"$stableId:$flagKey:$salt\"\nhash = SHA256(input)\npercentage = (hash % 10000) / 100.0   // [\"0.00, 100.00)\n</code></pre> <p>This yields three operational properties: - Deterministic: same inputs \u2192 same bucket - Per-flag isolation: changing one flag does not affect other flags\u2019 buckets - Salt-controlled redistribution: changing <code>salt</code> re-buckets users for that flag</p> <pre><code>flowchart LR\n  Id[stableId\"] --&gt; In[\"stableId:flagKey:salt\"]\n  Key[\"flagKey\"] --&gt; In\n  Salt[\"salt\"] --&gt; In\n  In --&gt; H[\"SHA-256\"]\n  H --&gt; M[\"mod 10,000\"]\n  M --&gt; P[\"percentage 0.00..99.99\"]\n  P --&gt; T{&lt; rollout % ?}\n  T --&gt;|Yes| Enabled[\"In rollout\"]\n  T --&gt;|No| Disabled[\"Out of rollout\"]\n  style Enabled fill:#c8e6c9\n  style Disabled fill:#ffcdd2</code></pre>"},{"location":"04-targeting-rollouts/#next-steps","title":"Next steps","text":"<ul> <li>Understand evaluation flow and performance: \"Evaluation\"</li> <li>Understand the compile-time vs runtime boundary: \"Theory\"</li> </ul>"},{"location":"05-evaluation/","title":"Evaluation","text":"<p>Konditional evaluation is designed to be predictable: - Total: evaluation always returns a value (rule value or default). - Deterministic: the same inputs produce the same outputs. - Non-null: defaults are required, so evaluation does not return <code>T?</code>.</p>"},{"location":"05-evaluation/#feature-recommended","title":"<code>feature { }</code> (recommended)","text":"<p>Concise evaluation inside a context-aware scope:</p> <pre><code>val darkMode = feature { Features.DARK_MODE }\napplyDarkMode(darkMode)\n</code></pre> <p>Use this when: - defaults are meaningful - you want the smallest call-site surface</p>"},{"location":"05-evaluation/#evaluation-flow-what-happens","title":"Evaluation flow (what happens)","text":"<pre><code>flowchart TD\n  Start[\"Context available\"] --&gt; Lookup[\"Registry lookup\"]\n  Lookup --&gt; Active{Flag active?}\n  Active --&gt;|No| Default1[\"Return default\"]\n  Active --&gt;|Yes| Sort[\"Sort rules by specificity\"]\n  Sort --&gt; Next{Next rule?}\n  Next --&gt;|No| Default2[\"Return default\"]\n  Next --&gt;|Yes| Match{All criteria match?}\n  Match --&gt;|No| Next\n  Match --&gt;|Yes| Roll{Rollout passes?}\n  Roll --&gt;|No| Next\n  Roll --&gt;|Yes| Value[\"Return rule value\"]\n  style Default1 fill:#fff3cd\n  style Default2 fill:#fff3cd\n  style Value fill:#c8e6c9</code></pre>"},{"location":"05-evaluation/#rule-matching-and-semantics","title":"Rule matching (AND semantics)","text":"<p>All specified criteria must match; empty constraint sets match everything.</p> <pre><code>for (rule in rulesSortedBySpecificity) {\n    if (rule.matches(context)) {\n        return rule.value\n    }\n}\nreturn default\n</code></pre>"},{"location":"05-evaluation/#specificity-ordering-most-specific-wins","title":"Specificity ordering (most specific wins)","text":"<p>Rules are sorted by the number of criteria present (platforms/locales/versions/rollout). This makes \u201cmore targeted\u201d rules win over \u201cmore general\u201d rules.</p>"},{"location":"05-evaluation/#performance-model","title":"Performance model","text":"<p>The evaluation path is designed to be constant-time in typical usage: - Registry lookup: O(1) - Rule iteration: O(n) where n is rules per flag (typically small) - Rollout bucketing: O(1) SHA-256 hash</p> <p>Space model: - no allocations during evaluation - immutable, pre-built rule structures</p>"},{"location":"05-evaluation/#concurrency-model","title":"Concurrency model","text":"<p>Evaluation is designed for concurrent reads: - Lock-free reads: evaluation does not require synchronization. - Atomic updates: configuration updates swap the active snapshot atomically (<code>Namespace.load</code>).</p> <pre><code>// Thread 1\nNamespace.Global.load(newConfig)\n\n// Thread 2 (during update)\nval value = feature { Features.DARK_MODE } // sees old OR new, never a mixed state\n</code></pre>"},{"location":"05-evaluation/#testing-evaluation","title":"Testing evaluation","text":""},{"location":"05-evaluation/#rule-matching","title":"Rule matching","text":"<pre><code>@Test\nfun `iOS users in US get dark mode`() {\n    val context = Context(\n        locale = AppLocale.UNITED_STATES,\n        platform = Platform.IOS,\n        appVersion = Version.parse(\"2.1.0\"),\n        stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n    )\n\n    val enabled = feature { Features.DARK_MODE }\n    assertTrue(enabled)\n}\n</code></pre>"},{"location":"05-evaluation/#determinism","title":"Determinism","text":"<pre><code>@Test\nfun `evaluation is deterministic`() {\n    val context = Context(...)\n    val results = (1..100).map { feature { Features.DARK_MODE } }\n    assertTrue(results.distinct().size == 1, \"Non-deterministic!\")\n}\n</code></pre>"},{"location":"05-evaluation/#rollout-distribution-statistical-sanity-check","title":"Rollout distribution (statistical sanity check)","text":"<pre><code>@Test\nfun `50 percent rollout distributes correctly`() {\n    val sampleSize = 10_000\n    val enabled = (0 until sampleSize).count { i -&gt;\n        val ctx = Context(\n            ...,\n            stableId = StableId.of(i.toString(16).padStart(32, '0'))\n        )\n        feature { Features.ROLLOUT_FLAG }\n    }\n\n    val percentage = (enabled.toDouble() / sampleSize) * 100\n    assertTrue(percentage in 48.0..52.0)\n}\n</code></pre>"},{"location":"05-evaluation/#guarantees-and-boundaries","title":"Guarantees (and boundaries)","text":"Aspect Guarantee Boundary Type safety return type matches definition compile-time for statically-defined flags Non-null evaluation never returns null relies on required defaults Determinism same inputs \u2192 same outputs excludes malformed runtime JSON (see remote config) Updates atomic swap of configuration correctness depends on using <code>Namespace.load</code>"},{"location":"05-evaluation/#next-steps","title":"Next steps","text":"<ul> <li>Understand rollouts and bucketing inputs: \"Targeting &amp; Rollouts\"</li> <li>Add runtime-validated JSON configuration: \"Remote Configuration\"</li> </ul>"},{"location":"06-remote-config/","title":"Remote Configuration","text":"<p>Konditional supports dynamic configuration via JSON, but treats JSON as a trust boundary: - compile-time guarantees apply to statically-defined flags and rules - runtime JSON is accepted only after validation (<code>ParseResult.Success</code>), otherwise rejected (<code>ParseResult.Failure</code>)</p>"},{"location":"06-remote-config/#the-lifecycle-end-to-end","title":"The lifecycle (end-to-end)","text":"<pre><code>flowchart LR\n  Code[\"Flags defined in code\"] --&gt; Snap[\"SnapshotSerializer.serialize(...)\"]\n  Snap --&gt; Json[\"JSON snapshot\"]\n  Json --&gt; Parse[\"SnapshotSerializer.fromJson(json)\"]\n  Parse --&gt;|Success| Load[\"Namespace.load(snapshot)\"]\n  Parse --&gt;|Failure| Reject[\"Keep last-known-good + log\"]\n  Load --&gt; Eval[\"Evaluation uses active snapshot\"]\n  style Load fill:#c8e6c9\n  style Reject fill:#ffcdd2</code></pre>"},{"location":"06-remote-config/#exporting-configuration","title":"Exporting configuration","text":"<pre><code>val json = SnapshotSerializer.serialize(Namespace.Global.configuration())\n</code></pre> <p>Use this when you want to externalize a namespace\u2019s current configuration state into JSON for storage or transport.</p>"},{"location":"06-remote-config/#loading-configuration-validated-boundary","title":"Loading configuration (validated boundary)","text":"<pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre> <p>The contract is explicit: - Success means you have a type-correct, internally consistent snapshot representation (validated at the boundary). - Failure means the payload is rejected before it can affect evaluation.</p>"},{"location":"06-remote-config/#incremental-updates-via-patching","title":"Incremental updates via patching","text":"<pre><code>when (val result = SnapshotSerializer.applyPatchJson(currentConfig, patchJson)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; handleError(result.error)\n}\n</code></pre> <p>This supports applying incremental JSON updates, then atomically swapping the active configuration via <code>Namespace.load</code>.</p>"},{"location":"06-remote-config/#error-handling-model-parseresult","title":"Error handling model (<code>ParseResult</code>)","text":"<p>Remote configuration is designed to force explicit handling of invalid input:</p> <pre><code>sealed class ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;()\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;()\n}\n</code></pre> <p>Operationally, treat failures as non-fatal: keep last-known-good configuration, log for alerting, and retry on the next update.</p>"},{"location":"06-remote-config/#hot-reload-semantics-atomicity","title":"Hot-reload semantics (atomicity)","text":"<p><code>Namespace.load(newConfiguration)</code> applies updates with atomic replacement semantics: - readers see either the old snapshot or the new snapshot - readers never see a partially-applied configuration</p> <p>This aligns with the evaluation model documented in \"Evaluation\".</p>"},{"location":"06-remote-config/#whats-validated-and-what-is-not","title":"What\u2019s validated (and what is not)","text":"<p>Validated at the boundary: - JSON syntax validity - schema/structure validity - value type checking against declared feature types</p> <p>Not validated by the type system: - semantic correctness (e.g., whether 50% is the intended rollout) - business correctness (e.g., whether the targeted segment is correct)</p>"},{"location":"06-remote-config/#integration-patterns","title":"Integration patterns","text":""},{"location":"06-remote-config/#polling","title":"Polling","text":"<pre><code>while (running) {\n    val json = fetchFromServer()\n    when (val result = SnapshotSerializer.fromJson(json)) {\n        is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n        is ParseResult.Failure -&gt; log.error(\"Config parse failed: ${result.error}\")\n    }\n    delay(pollInterval)\n}\n</code></pre>"},{"location":"06-remote-config/#push-based-streams","title":"Push-based (streams)","text":"<pre><code>configStream.collect { json -&gt;\n    when (val result = SnapshotSerializer.fromJson(json)) {\n        is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n        is ParseResult.Failure -&gt; log.error(\"Config parse failed: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"06-remote-config/#where-kontracts-fits","title":"Where Kontracts fits","text":"<p>Konditional uses Kontracts (a standalone, zero-dependency JSON Schema DSL) for schema validation of configuration payloads.</p>"},{"location":"06-remote-config/#next-steps","title":"Next steps","text":"<ul> <li>Understand the \u201cif it compiles\u201d claim boundary: \"Theory\"</li> <li>Understand bucketing determinism inputs: \"Targeting &amp; Rollouts\"</li> </ul>"},{"location":"07-theory/","title":"Theory: What \u201cIf it compiles, it works\u201d means","text":"<p>Konditional\u2019s core claim is intentionally narrow and testable: for statically-defined flags and rules, the compiler enforces type correctness and evaluation is non-null. When configuration crosses the JSON boundary, correctness is established via validation and explicit error handling (<code>ParseResult</code>), not via compile-time guarantees.</p> <pre><code>flowchart LR\n    Code[\"Flags + rules defined in code\"] --&gt; CT[\"Compile-time guarantees\"]\n    CT --&gt; Eval[\"Evaluation returns typed, non-null values\"]\n    Json[\"JSON payload\"] --&gt; RT[\"Runtime validation boundary\"]\n    RT --&gt;|Success| Load[\"Namespace.load(snapshot)\"]\n    RT --&gt;|Failure| Reject[\"Reject before evaluation\"]\n    style CT fill: #e1f5ff\n    style RT fill: #fff3cd\n    style Reject fill: #ffcdd2</code></pre>"},{"location":"07-theory/#the-three-failures-of-stringly-typed-flags","title":"The three failures of stringly-typed flags","text":"<p>Traditional flag systems are stringly-typed: a string key selects a value and the caller chooses a typed getter. That architecture introduces three classes of runtime failure:</p> <ol> <li>Key mismatch: <code>\"dark_mode\"</code> vs <code>\"darkMode\"</code> silently returns a default or null.</li> <li>Type mismatch: retrieving a boolean flag as a string is syntactically valid but semantically wrong.</li> <li>Null propagation: missing configurations surface as <code>null</code> and leak into business logic.</li> </ol> <p>Konditional targets this gap: prevent categories of runtime failure by moving key/type binding into the type system.</p>"},{"location":"07-theory/#mechanism-1-property-delegation-binds-identity-type","title":"Mechanism 1: Property delegation binds identity + type","text":"<p>Flags are delegated properties in a <code>FeatureContainer</code>:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val darkMode by boolean(default = false)\n    val timeout by double(default = 30.0)\n    val maxRetries by int(default = 3)\n}\n</code></pre> <p>Because the delegate (<code>boolean</code>, <code>double</code>, <code>int</code>, \u2026) determines the type parameter, the compiler knows the declared type at the definition site and carries it forward.</p> <p>Guarantee: the declared type of a feature is statically known and cannot drift without code changes the compiler re-checks.</p>"},{"location":"07-theory/#mechanism-2-rule-return-types-are-constrained","title":"Mechanism 2: Rule return types are constrained","text":"<p>Rules must return a value of the feature\u2019s declared type:</p> <pre><code>val timeout by double(default = 30.0) {\n    rule { platforms(Platform.ANDROID) } returns 45.0\n}\n</code></pre> <p>Guarantee: statically-defined rule return values are type-checked at compile time.</p> <p>Boundary: this applies to rules defined in code; JSON-loaded configurations are validated at the parse boundary.</p>"},{"location":"07-theory/#mechanism-3-evaluation-site-preserves-the-concrete-type","title":"Mechanism 3: Evaluation site preserves the concrete type","text":"<p>Evaluation preserves the type parameter from definition to usage:</p> <pre><code>val isDarkMode: Boolean = feature { AppFeatures.darkMode }\nval timeout: Double = feature { AppFeatures.timeout }\n</code></pre> <p>Guarantee: no casts are required at call sites; incompatible assignments are compile errors.</p>"},{"location":"07-theory/#mechanism-4-required-defaults-eliminate-nulls","title":"Mechanism 4: Required defaults eliminate nulls","text":"<p>Every feature requires a default:</p> <pre><code>val darkMode by boolean(default = false)\n</code></pre> <p>Guarantee: evaluation is total\u2014if no rules match, the default is returned\u2014and does not return null.</p>"},{"location":"07-theory/#mechanism-5-namespace-isolation-is-structural","title":"Mechanism 5: Namespace isolation is structural","text":"<p>Containers are bound to a namespace type, and namespaces have separate registries:</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) { ... }\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) { ... }\n</code></pre> <p>Guarantee: feature key collisions across namespaces cannot occur (separate registries bound at the type level).</p> <p>Boundary: defining conflicting keys within the same namespace is a design error that can be detected at runtime during registration.</p>"},{"location":"07-theory/#the-trust-boundary-runtime-json","title":"The trust boundary: runtime JSON","text":"<p>When configuration is loaded from JSON, compile-time guarantees necessarily end. Konditional establishes correctness at the boundary:</p> <pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Parse failed: ${result.error}\")\n}\n</code></pre> <p>The guarantee is qualified:</p> <ul> <li> <p>Guaranteed: invalid JSON is detected and rejected before it can affect evaluation.</p> </li> <li> <p>Not guaranteed: Semantic correctness of the configuration (rollout percentage, targeting intent, business   correctness).</p> </li> </ul>"},{"location":"07-theory/#summary-what-is-guaranteed-vs-what-is-not","title":"Summary: what is guaranteed vs what is not","text":"Claim Guarantee level Mechanism No typos in flag keys Compile-time property access, not strings Return type matches definition Compile-time generic type propagation Rule return types are correct Compile-time constrained rule DSL Evaluation is never null Compile-time required defaults Namespace isolation Compile-time type-bound containers + separate registries Remote config type safety Runtime (validated boundary) <code>ParseResult.Success</code> / <code>Failure</code> Semantic correctness of configs Not guaranteed human/process responsibility"},{"location":"07-theory/#next-steps","title":"Next steps","text":"<ul> <li>See the runtime boundary mechanics: \"Remote Configuration\"</li> <li>See deterministic behavior and concurrency claims in practice: \"Evaluation\"</li> </ul>"},{"location":"onboarding-flow-legacy-enums/","title":"Konditional: Engineer Pitch Deck (vs Enum + Boolean \u201cCapabilities\u201d)","text":"<p>This document compares Konditional against a common \u201cmodern legacy\u201d pattern: - flags are enums (so keys are compile-time) - flags evaluate to Boolean only - each domain owns its own hierarchy (account flags, card flags, etc.) - evaluation logic is inline per hierarchy (context-specific checks live next to the enum)</p> <p>Konditional\u2019s thesis is narrower and more structural: bind flag identity + value type to Kotlin properties, centralize evaluation semantics (rules + specificity + deterministic rollouts), and treat remote JSON as a validated trust boundary.</p>"},{"location":"onboarding-flow-legacy-enums/#baseline-what-the-enumboolean-approach-already-does-well","title":"Baseline: what the enum/boolean approach already does well","text":"<p>Enum-based capabilities solve one real problem: - No string keys at call sites: <code>Capability.DARK_MODE</code> can\u2019t be mistyped.</p> <p>If all you need is \u201cfeature on/off\u201d with hand-written business logic per domain, this can be a reasonable starting point.</p>"},{"location":"onboarding-flow-legacy-enums/#the-pressure-points-why-boolean-only-enums-dont-scale","title":"The pressure points (why boolean-only enums don\u2019t scale)","text":""},{"location":"onboarding-flow-legacy-enums/#1-boolean-only-turns-configuration-into-control-flow","title":"1) \u201cBoolean-only\u201d turns configuration into control-flow","text":"<p>Once you need variants (not just on/off), code tends to devolve into branching: - multiple booleans (\u201cA enabled\u201d, \u201cB enabled\u201d, \u201cC enabled\u201d) - switch statements on user cohorts - ad-hoc precedence rules</p> <p>Konditional\u2019s public surface explicitly supports typed values (Boolean/String/Int/Double/Enum) so you can model variants and thresholds as configuration, not control-flow.</p>"},{"location":"onboarding-flow-legacy-enums/#2-multiple-hierarchies-duplicate-semantics","title":"2) Multiple hierarchies duplicate semantics","text":"<p>With per-domain enums (account/card/merchant/etc.), the same targeting concepts get reimplemented repeatedly: - \u201cplatform/iOS only\u201d - \u201cversion &gt;= 2.0.0\u201d - \u201croll out to 10%\u201d - \u201cinternal users only\u201d</p> <p>This is not a key-typo issue; it\u2019s a semantics/consistency issue.</p>"},{"location":"onboarding-flow-legacy-enums/#3-no-shared-deterministic-rollout-primitive","title":"3) No shared, deterministic rollout primitive","text":"<p>Most enum-based systems eventually add \u201cpercent rollout\u201d logic, but it tends to be: - inconsistent across domains - not obviously deterministic - hard to reason about or test uniformly</p> <p>Konditional makes deterministic bucketing a first-class concept.</p>"},{"location":"onboarding-flow-legacy-enums/#visual-legacy-vs-konditional","title":"Visual: legacy vs Konditional","text":""},{"location":"onboarding-flow-legacy-enums/#legacy-model-many-trees-many-evaluators","title":"Legacy model: many trees, many evaluators","text":"<pre><code>flowchart TB\n  subgraph Account[\"Account capability tree\"]\n    A1[\"enum AccountCapability\"] --&gt; AE[\"isEnabled(account, ...)\"]\n  end\n\n  subgraph Card[\"Card capability tree\"]\n    C1[\"enum CardCapability\"] --&gt; CE[\"isEnabled(card, ...)\"]\n  end\n\n  subgraph Merchant[\"Merchant capability tree\"]\n    M1[\"enum MerchantCapability\"] --&gt; ME[\"isEnabled(merchant, ...)\"]\n  end\n\n  AE --&gt; Code[\"Branching logic in features\"]\n  CE --&gt; Code\n  ME --&gt; Code</code></pre>"},{"location":"onboarding-flow-legacy-enums/#konditional-model-one-evaluation-semantics-typed-contexts","title":"Konditional model: one evaluation semantics, typed contexts","text":"<pre><code>flowchart TB\n  subgraph Namespaces[\"Namespace (Global + consumer-defined)\"]\n    N[\"Namespace\"] --&gt; R[\"Registry\"]\n  end\n\n  subgraph Flags[\"FeatureContainer-bound flags\"]\n    FC[\"FeatureContainer&lt;M&gt;\"] --&gt; F[\"Feature&lt;T, C, M&gt;\"]\n    F --&gt; D[\"Default (required)\"]\n    F --&gt; Rules[\"Rules\"]\n  end\n\n  subgraph Runtime[\"Runtime\"]\n    Ctx[\"Context (typed)\"] --&gt; Rules\n    Rules --&gt; Eval[\"Deterministic evaluation&lt;br/&gt;+ specificity ordering\"]\n    Eval --&gt; Out[\"Typed result\"]\n  end\n\n  N --&gt; FC\n  R --&gt; Eval</code></pre>"},{"location":"onboarding-flow-legacy-enums/#what-you-gain-by-switching-to-konditional","title":"What you gain by switching to Konditional","text":""},{"location":"onboarding-flow-legacy-enums/#0-you-keep-what-enums-gave-you-no-call-site-string-keys","title":"0) You keep what enums gave you (no call-site string keys)","text":"<p>Call sites stay property-based and refactor-safe:</p> <pre><code>val enabled: Boolean = feature { AppFeatures.DARK_MODE }\n</code></pre> <p>No string key appears at the call site.</p>"},{"location":"onboarding-flow-legacy-enums/#1-typed-configuration-beyond-booleans","title":"1) Typed configuration beyond booleans","text":"<p>Model \u201cvariants\u201d as values:</p> <pre><code>val RECOMMENDATION_ALGO by string(default = \"collaborative\") {\n    rule { rollout { 50.0 } } returns \"content-based\"\n}\n</code></pre> <p>Model thresholds as values:</p> <pre><code>val MAX_RETRIES by int(default = 3) {\n    rule { platforms(Platform.WEB) } returns 5\n}\n</code></pre> <p>If you want variant safety, use enums:</p> <pre><code>enum class Theme { LIGHT, DARK }\nval THEME by enum&lt;Theme, Context&gt;(default = Theme.LIGHT)\n</code></pre>"},{"location":"onboarding-flow-legacy-enums/#2-one-targeting-language-instead-of-n-bespoke-evaluators","title":"2) One targeting language (instead of N bespoke evaluators)","text":"<p>Konditional provides a single rule DSL with well-defined semantics: - criteria are AND-ed within a rule - rules are ordered by specificity (more targeted wins) - default is the final fallback</p> <pre><code>val PREMIUM_FEATURE by boolean(default = false) {\n    rule {\n        platforms(Platform.IOS, Platform.ANDROID)\n        locales(AppLocale.UNITED_STATES)\n        versions { min(2, 0, 0) }\n        rollout { 50.0 }\n    } returns true\n}\n</code></pre> <p>This replaces \u201cper-hierarchy ad-hoc precedence\u201d with a deterministic, explainable model.</p>"},{"location":"onboarding-flow-legacy-enums/#3-context-stays-explicit-and-type-safe-even-for-inline-domain-context","title":"3) Context stays explicit and type-safe (even for \u201cinline\u201d domain context)","text":"<p>If your legacy system has \u201ccard-specific\u201d and \u201caccount-specific\u201d evaluation, Konditional maps that to typed contexts:</p> <pre><code>data class AccountContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier\n) : Context\n\nenum class SubscriptionTier { FREE, PRO, ENTERPRISE }\n\nval ENTERPRISE_ONLY by boolean&lt;AccountContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt; ctx.subscriptionTier == SubscriptionTier.ENTERPRISE }\n        }\n    } returns true\n}\n</code></pre> <p>The \u201cinline context\u201d becomes typed data, and rule predicates are type-checked.</p>"},{"location":"onboarding-flow-legacy-enums/#4-deterministic-rollouts-are-built-in-testable-and-consistent","title":"4) Deterministic rollouts are built-in, testable, and consistent","text":"<p>Konditional\u2019s rollout bucketing is based on stable inputs and SHA-256, so it is deterministic by construction.</p> <pre><code>flowchart LR\n  In[\"stableId + flagKey + salt\"] --&gt; H[\"SHA-256\"] --&gt; Bucket[\"bucket\"] --&gt; Compare{&lt; rollout % ?}\n  Compare --&gt;|Yes| Enabled\n  Compare --&gt;|No| Disabled</code></pre> <p>This gives you a single, shared rollout primitive across all domains.</p>"},{"location":"onboarding-flow-legacy-enums/#5-total-evaluation-no-null-propagation","title":"5) Total evaluation (no null propagation)","text":"<p>Defaults are required, which makes evaluation total: - rule matches \u2192 rule value - no match \u2192 default</p> <p>This is a structural property, not a convention.</p>"},{"location":"onboarding-flow-legacy-enums/#6-namespaces-when-you-need-them-consumer-defined-global-when-you-dont","title":"6) Namespaces when you need them (consumer-defined), Global when you don\u2019t","text":"<p>If your current \u201cmultiple hierarchies\u201d are really about ownership/isolation, namespaces encode that structurally. Konditional ships <code>Namespace.Global</code>; you define additional ones if desired:</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Account : AppDomain(\"account\")\n    data object Card : AppDomain(\"card\")\n}\n</code></pre>"},{"location":"onboarding-flow-legacy-enums/#7-remote-config-is-a-boundary-with-explicit-failure-handling","title":"7) Remote config is a boundary with explicit failure handling","text":"<p>Enums can avoid typos in code, but as soon as external config enters the system, you still need a boundary. Konditional makes that boundary explicit:</p> <pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Parse failed: ${result.error}\")\n}\n</code></pre> <p>Contract: - <code>Success</code> \u2192 validated, type-correct internal snapshot (safe to apply) - <code>Failure</code> \u2192 rejected before it can affect evaluation</p>"},{"location":"onboarding-flow-legacy-enums/#practical-migration-shape-from-enum-capabilities","title":"Practical migration shape (from enum capabilities)","text":"<ol> <li>Mirror existing enum booleans as <code>boolean(default = ...)</code> features in a container.</li> <li>Move shared targeting semantics into rules (<code>platforms/locales/versions/rollout</code>), eliminating duplicated evaluators.</li> <li>Convert \u201cvariants\u201d from multiple booleans into typed values (<code>string/int/enum</code>).</li> <li>If you need isolation/ownership boundaries, introduce consumer-defined namespaces; otherwise keep everything in <code>Namespace.Global</code>.</li> <li>If you need remote config, treat JSON as an external boundary and rely on <code>ParseResult</code> handling.</li> </ol>"},{"location":"onboarding-flow/","title":"Konditional: Engineer Pitch Deck","text":"<p>Konditional is a Kotlin feature-flag DSL that makes configuration typed, deterministic, and non-null. It is designed to reduce runtime failure modes by binding flag identity and value types to Kotlin properties, and by treating dynamic JSON as a validated trust boundary.</p>"},{"location":"onboarding-flow/#the-problem-stringly-typed-flags-fail-in-ways-the-compiler-cant-see","title":"The problem: stringly-typed flags fail in ways the compiler can\u2019t see","text":"<p>Traditional systems typically combine: - a string key (<code>\"dark-mode\"</code>) - a typed getter chosen by the caller (<code>getBoolean</code>, <code>getString</code>, \u2026)</p> <p>That creates three classes of failures that are syntactically valid but semantically wrong: 1. Key mismatch (typos) \u2192 silent defaults / nulls 2. Type mismatch \u2192 wrong \u201cgetter\u201d compiles, fails logically at runtime 3. Null propagation \u2192 missing config becomes <code>null</code> in business logic</p> <p>Konditional moves key/type binding into Kotlin\u2019s type system for statically-defined flags, and makes JSON a validated boundary.</p>"},{"location":"onboarding-flow/#konditional-in-60-seconds","title":"Konditional in 60 seconds","text":"<pre><code>flowchart LR\n  Def[\"Define flags as properties\"] --&gt; Bound[\"Key + type bound at compile-time\"]\n  Bound --&gt; Eval[\"Evaluate using Context\"]\n  Eval --&gt;|Rule matches| Value[\"Rule value\"]\n  Eval --&gt;|No match| Default[\"Required default\"]\n\n  Json[\"Remote JSON\"] --&gt; Parse[\"Parse + validate\"]\n  Parse --&gt;|Success| Load[\"Namespace.load(snapshot)\"]\n  Parse --&gt;|Failure| Reject[\"Reject + keep last-known-good\"]\n\n  Load --&gt; Eval\n  style Bound fill:#e1f5ff\n  style Default fill:#fff3cd\n  style Value fill:#c8e6c9\n  style Reject fill:#ffcdd2</code></pre>"},{"location":"onboarding-flow/#the-minimal-api-surface","title":"The minimal API surface","text":""},{"location":"onboarding-flow/#0-define-a-container-a-namespace-bound-registry-owner","title":"0. Define a container (a namespace-bound registry owner)","text":"<pre><code>object AppFeatures : FeatureContainer&lt;Namespace.Global&gt;(Namespace.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.example.com\")\n    val MAX_RETRIES by int(default = 3)\n    val TIMEOUT by double(default = 30.0)\n}\n</code></pre>"},{"location":"onboarding-flow/#1-provide-evaluation-context","title":"1. Provide evaluation context","text":"<pre><code>val context = Context(\n    locale = AppLocale.UNITED_STATES,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6\")\n)\n</code></pre>"},{"location":"onboarding-flow/#2-evaluate-typed-non-null","title":"2. Evaluate (typed, non-null)","text":"<pre><code>val enabled: Boolean = feature { AppFeatures.DARK_MODE }\nval endpoint: String = feature { AppFeatures.API_ENDPOINT }\n</code></pre>"},{"location":"onboarding-flow/#targeting-rules-typed-mappings-from-criteria-value","title":"Targeting rules (typed mappings from criteria \u2192 value)","text":"<p>Rules combine criteria with AND semantics within a rule; across rules, higher specificity wins.</p> <pre><code>val API_ENDPOINT by string(default = \"https://api.example.com\") {\n    rule { platforms(Platform.IOS) } returns \"https://api-ios.example.com\"\n    rule { platforms(Platform.ANDROID) } returns \"https://api-android.example.com\"\n}\n</code></pre> <pre><code>val PREMIUM_FEATURE by boolean(default = false) {\n    rule {\n        platforms(Platform.IOS, Platform.ANDROID)\n        locales(AppLocale.UNITED_STATES)\n        versions { min(2, 0, 0) }\n        rollout { 50.0 }\n    } returns true\n}\n</code></pre> <p>Custom targeting logic stays type-safe via <code>extension { }</code>:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val employeeCount: Int\n) : Context\n\nenum class SubscriptionTier { FREE, PRO, ENTERPRISE }\n\nval ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            Evaluable.factory { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                    ctx.employeeCount &gt; 100\n            }\n        }\n    } returns true\n}\n</code></pre>"},{"location":"onboarding-flow/#deterministic-rollouts-local-bucketing","title":"Deterministic rollouts (local bucketing)","text":"<p>Rollouts are deterministic: the same <code>(stableId, flagKey, salt)</code> yields the same bucket assignment.</p> <pre><code>flowchart LR\n  Id[\"stableId\"] --&gt; In[\"stableId:flagKey:salt\"]\n  Key[\"flagKey\"] --&gt; In\n  Salt[\"salt\"] --&gt; In\n  In --&gt; H[\"SHA-256\"]\n  H --&gt; M[\"mod 10,000\"]\n  M --&gt; P[\"percentage 0.00..99.99\"]\n  P --&gt; T{&lt; rollout % ?}\n  T --&gt;|Yes| Enabled[\"In rollout\"]\n  T --&gt;|No| Disabled[\"Out of rollout\"]\n  style Enabled fill:#c8e6c9\n  style Disabled fill:#ffcdd2</code></pre>"},{"location":"onboarding-flow/#namespaces-global-is-built-in-isolation-is-consumer-defined","title":"Namespaces: Global is built-in; isolation is consumer-defined","text":"<p>Konditional ships <code>Namespace.Global</code>. If you need isolation boundaries (team/domain registries), define your own namespaces:</p> <pre><code>sealed class AppDomain(id: String) : Namespace(id) {\n    data object Auth : AppDomain(\"auth\")\n    data object Payments : AppDomain(\"payments\")\n}\n\nobject AuthFeatures : FeatureContainer&lt;AppDomain.Auth&gt;(AppDomain.Auth) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;AppDomain.Payments&gt;(AppDomain.Payments) {\n    val APPLE_PAY by boolean(default = false)\n}\n</code></pre> <p>This keeps the library\u2019s defaults simple while still allowing compile-time isolation and independent config lifecycles when you opt in.</p>"},{"location":"onboarding-flow/#remote-configuration-validated-boundary-not-compile-time-magic","title":"Remote configuration: validated boundary, not \u201ccompile-time magic\u201d","text":"<pre><code>val json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Namespace.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Parse failed: ${result.error}\")\n}\n</code></pre> <p>Contract: - <code>ParseResult.Success</code> means the payload was validated into a typed internal snapshot before being applied. - <code>ParseResult.Failure</code> means the payload is rejected before it can affect evaluation.</p>"},{"location":"onboarding-flow/#what-is-guaranteed-vs-what-is-not","title":"What is guaranteed vs what is not","text":"Claim Guarantee level Mechanism No call-site string keys Compile-time property access (refactor-safe) Return type matches definition Compile-time generic type propagation Rule return types are correct Compile-time constrained rule DSL Evaluation is never null Compile-time required defaults JSON config is type-safe Runtime (validated boundary) <code>ParseResult</code> + schema/type checks Semantic correctness Not guaranteed authoring/process responsibility"},{"location":"onboarding-flow/#adoption-path-practical","title":"Adoption path (practical)","text":"<ol> <li>Start with <code>Namespace.Global</code> and a single <code>FeatureContainer</code>.</li> <li>Replace call sites with <code>feature { Container.FLAG }</code> to eliminate key/type drift.</li> <li>Add rules (<code>platforms</code>, <code>locales</code>, <code>versions</code>, <code>rollout</code>) and custom context + <code>extension { }</code> when needed.</li> <li>If you need remote config, export/load snapshots and treat parse failures as \u201ckeep last-known-good\u201d.</li> </ol>"},{"location":"venv/lib/python3.14/site-packages/backrefs-5.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/idna-3.11.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/markdown-3.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip-25.2.dist-info/licenses/src/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}