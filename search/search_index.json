{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Konditional","text":"<p>Type-safe, deterministic feature flags for Kotlin.</p>"},{"location":"#overview","title":"Overview","text":"<p>Konditional is a type-safe feature flag library that eliminates runtime errors through compile-time guarantees. Define flags with strong typing, evaluate them deterministically, and organize them by domain using the Taxonomy system.</p> <p>Core Principles:</p> <ul> <li>Type Safety First: Generic type parameters eliminate runtime type errors</li> <li>Deterministic: Same inputs always produce same outputs</li> <li>Zero Dependencies: Pure Kotlin with Moshi for JSON serialization only</li> <li>Thread-Safe: Lock-free reads with atomic updates</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import io.amichne.konditional.core.features.FeatureContainer\nimport io.amichne.konditional.core.Taxonomy\nimport io.amichne.konditional.context.*\n\n// Define features\nobject AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            rollout { 50.0 }\n        } implies true\n    }\n}\n\n// Evaluate\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"user-123\")\n)\n\nval enabled: Boolean = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#features","title":"Features","text":"<p>Features are type-safe flag definitions. Use <code>FeatureContainer</code> delegation for the most ergonomic API:</p> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val BOOLEAN_FLAG by boolean(default = false)\n    val STRING_FLAG by string(default = \"production\")\n    val INT_FLAG by int(default = 42)\n    val DOUBLE_FLAG by double(default = 3.14)\n}\n</code></pre> <p>The delegation pattern provides:</p> <ul> <li>Property access instead of method calls</li> <li>Type inference from default values</li> <li>Automatic registration with taxonomy</li> <li>Inline rule configuration</li> </ul> <p>See Features for enum-based patterns and custom contexts.</p>"},{"location":"#context","title":"Context","text":"<p>Context provides the evaluation environment. All evaluations require four standard fields:</p> <pre><code>data class Context(\n    val locale: AppLocale,       // User's locale (EN_US, FR_FR, etc.)\n    val platform: Platform,      // Platform (IOS, ANDROID, WEB)\n    val appVersion: Version,     // Semantic version (2.1.0)\n    val stableId: StableId       // Stable user ID for bucketing\n)\n</code></pre> <p>Extend Context with custom fields for business logic:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,  // Custom field\n    val organizationId: String                // Custom field\n) : Context\n</code></pre> <p>See Context for custom contexts and polymorphism.</p>"},{"location":"#rules","title":"Rules","text":"<p>Rules define targeting criteria. All criteria must match for a rule to apply:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)  // Must be mobile\n    locales(AppLocale.EN_US)                   // AND English US\n    versions {\n        min(2, 0, 0)                           // AND version &gt;= 2.0.0\n    }\n    rollout { 50.0 }                           // AND in 50% bucket\n} implies true\n</code></pre> <p>Rules are automatically sorted by specificity (most specific first):</p> <pre><code>// Specificity = 2 (platform + locale) - evaluated first\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n} implies \"specific-value\"\n\n// Specificity = 1 (platform only) - evaluated second\nrule {\n    platforms(Platform.IOS)\n} implies \"general-value\"\n</code></pre> <p>See Rules for advanced targeting and custom evaluables.</p>"},{"location":"#taxonomy","title":"Taxonomy","text":"<p>Taxonomy provides isolation between feature domains:</p> <pre><code>// Global taxonomy for shared features\nobject GlobalFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val MAINTENANCE_MODE by boolean(default = false)\n}\n\n// Domain-specific taxonomies\nobject AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Compile-time isolation: Features type-bound to taxonomy</li> <li>Runtime isolation: Each taxonomy has separate registry</li> <li>Organization: Clear ownership boundaries</li> </ul> <p>See Registry for taxonomy management and registry operations.</p>"},{"location":"#evaluation","title":"Evaluation","text":""},{"location":"#evaluation-methods","title":"Evaluation Methods","text":"<p>Choose based on your error handling needs:</p> <pre><code>// Safe: Returns EvaluationResult&lt;T&gt;\nval result: EvaluationResult&lt;Boolean&gt; = context.evaluateSafe(MyFeatures.FLAG)\nwhen (result) {\n    is EvaluationResult.Success -&gt; use(result.value)\n    is EvaluationResult.FlagNotFound -&gt; logWarning(\"Flag not found\")\n    is EvaluationResult.EvaluationError -&gt; logError(\"Evaluation failed\", result.error)\n}\n\n// Convenient: Returns null on failure\nval value: Boolean? = context.evaluateOrNull(MyFeatures.FLAG)\n\n// Default: Returns default value on failure\nval value: Boolean = context.evaluateOrDefault(MyFeatures.FLAG, default = false)\n\n// Unsafe: Throws exception on failure (use sparingly)\nval value: Boolean = context.evaluateOrThrow(MyFeatures.FLAG)\n</code></pre> <p>See Evaluation for evaluation flow and specificity ordering.</p> <p>See Results for EvaluationResult and ParseResult error handling patterns.</p>"},{"location":"#deterministic-bucketing","title":"Deterministic Bucketing","text":"<p>Rollout bucketing is deterministic and independent per flag:</p> <pre><code>// SHA-256 based bucketing\nfun bucket(flagKey: String, stableId: StableId, salt: String): Int {\n    val hash = SHA256(\"$salt:$flagKey:${stableId.id}\")\n    return hash.take(4).toInt() % 10_000  // 0-9999 range (0.01% granularity)\n}\n</code></pre> <p>Properties:</p> <ul> <li>Deterministic: Same user always gets same bucket</li> <li>Independent: Each flag has separate bucketing space</li> <li>Platform-stable: Consistent across JVM/Android/iOS/Web</li> <li>Redistributable: Change salt to reassign buckets</li> </ul>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#inline-configuration","title":"Inline Configuration","text":"<p>Configure rules directly in the delegation:</p> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val EXPERIMENT by boolean(default = false) {\n        // Salt affects bucketing (change to redistribute)\n        salt(\"v2\")\n\n        // Rule with multiple criteria\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US, AppLocale.EN_CA)\n            versions {\n                min(2, 0, 0)\n                max(3, 0, 0)\n            }\n            rollout { 25.0 }\n            note(\"iOS English speakers, v2.x, 25% rollout\")\n        } implies true\n\n        // Fallback rule for all iOS users\n        rule {\n            platforms(Platform.IOS)\n        } implies false\n    }\n}\n</code></pre> <p>See Configuration for complete DSL reference.</p>"},{"location":"#serialization","title":"Serialization","text":"<p>Export and import configurations as JSON:</p> <pre><code>// Serialize current configuration\nval json = SnapshotSerializer.serialize(Taxonomy.Global.konfig())\nFile(\"flags.json\").writeText(json)\n\n// Deserialize and load\nval json = File(\"flags.json\").readText()\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; Taxonomy.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Parse failed: ${result.error}\")\n}\n\n// Apply incremental patch\nwhen (val result = SnapshotSerializer.applyPatchJson(currentKonfig, patchJson)) {\n    is ParseResult.Success -&gt; Taxonomy.Global.load(result.value)\n    is ParseResult.Failure -&gt; logError(\"Patch failed: ${result.error}\")\n}\n</code></pre> <p>See Serialization for JSON format, remote configuration, and database persistence.</p>"},{"location":"#value-types","title":"Value Types","text":"<p>Konditional supports four primitive types and data classes:</p> <pre><code>object MyFlags : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    // Primitives\n    val BOOLEAN_FLAG by boolean(default = false)\n    val STRING_FLAG by string(default = \"value\")\n    val INT_FLAG by int(default = 42)\n    val DOUBLE_FLAG by double(default = 3.14)\n}\n</code></pre> <p>For complex types, use data classes (automatically serialized as JSON):</p> <pre><code>data class ThemeConfig(\n    val primaryColor: String,\n    val fontSize: Int,\n    val darkMode: Boolean\n)\n\nobject MyThemes : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    // Data classes work automatically\n    val APP_THEME by jsonObject(\n        default = ThemeConfig(\n            primaryColor = \"#FFFFFF\",\n            fontSize = 14,\n            darkMode = false\n        )\n    )\n}\n</code></pre>"},{"location":"#thread-safety","title":"Thread Safety","text":"<p>Konditional is designed for concurrent access without locks:</p> <p>Lock-Free Reads: Flag evaluation requires no synchronization. Multiple threads can evaluate flags concurrently without contention.</p> <p>Atomic Updates: Registry updates use <code>AtomicReference</code> for atomic snapshots. Readers see either old or new configuration, never partial updates.</p> <p>Immutable Data: <code>Konfig</code> and <code>FlagDefinition</code> are immutable. Once created, they cannot be modified.</p> <p>Independent Evaluations: Each evaluation is stateless and independent. No shared mutable state during evaluation.</p>"},{"location":"#type-safety-guarantees","title":"Type Safety Guarantees","text":"Guarantee How Konditional Enforces It Non-null returns Default value required at definition time Correct type Generic type parameters enforce value type Correct context Context type parameter enforced by compiler Valid rollout Rollout.of() validates 0.0-100.0 range Valid version Version.parse() validates semantic versioning Valid stable ID StableId.of() validates hexadecimal format Supported types Only Boolean, String, Int, Double, and data classes allowed <p>Core Principle: If it compiles, the types are correct. No runtime type errors.</p>"},{"location":"#documentation-guide","title":"Documentation Guide","text":"<p>Getting Started:</p> <ol> <li>Quick Start - Get running in 5 minutes</li> </ol> <p>Core Concepts:</p> <ol> <li>Features - Feature definition patterns</li> <li>Context - Evaluation contexts</li> <li>Evaluation - Flag evaluation mechanics</li> </ol> <p>Configuration:</p> <ol> <li>Configuration - DSL reference</li> <li>Rules - Targeting and rollouts</li> </ol> <p>Advanced:</p> <ol> <li>Serialization - JSON import/export</li> <li>Registry - Taxonomy and registry management</li> <li>Results - Error handling patterns</li> </ol>"},{"location":"#common-use-cases","title":"Common Use Cases","text":""},{"location":"#feature-flags","title":"Feature Flags","text":"<p>Gradual rollout of new features:</p> <pre><code>val NEW_CHECKOUT by boolean(default = false) {\n    rule {\n        platforms(Platform.ANDROID)\n        rollout { 10.0 }  // Start with 10%\n    } implies true\n}\n</code></pre>"},{"location":"#configuration-management","title":"Configuration Management","text":"<p>Environment-specific configuration:</p> <pre><code>val API_ENDPOINT by string(default = \"https://api.prod.example.com\") {\n    rule {\n        platforms(Platform.WEB)\n    } implies \"https://api-staging.example.com\"\n}\n</code></pre>"},{"location":"#ab-testing","title":"A/B Testing","text":"<p>Split traffic for experiments:</p> <pre><code>val RECOMMENDATION_ALGORITHM by string(default = \"collaborative\") {\n    rule {\n        rollout { 50.0 }  // 50/50 split\n    } implies \"content-based\"\n}\n</code></pre>"},{"location":"#kill-switches","title":"Kill Switches","text":"<p>Emergency feature disable:</p> <pre><code>val PAYMENT_PROCESSING by boolean(default = true) {\n    // Can be updated remotely via JSON to disable instantly\n}\n</code></pre>"},{"location":"#performance","title":"Performance","text":"<p>Evaluation Complexity: O(n) where n = number of rules per flag (typically &lt; 10)</p> <p>Memory: Zero allocations during evaluation. All data structures are pre-allocated and immutable.</p> <p>Concurrency: Lock-free reads. No thread contention during evaluation.</p> <p>Bucketing: O(1) SHA-256 hash computation per rollout evaluation.</p>"},{"location":"#best-practices","title":"Best Practices","text":"<p>Use FeatureContainer delegation: Simplest and most ergonomic API for most use cases.</p> <p>Organize by domain: Use Taxonomy to separate features by team or business domain.</p> <p>Start with small rollouts: Begin with 10% rollout, increase gradually after monitoring.</p> <p>Document with note(): Add context to rules explaining why they exist.</p> <p>Use evaluateOrDefault: Provides failsafe behavior without exception handling.</p> <p>Version your salts: Track salt changes to understand bucketing redistribution.</p> <p>Test with custom contexts: Create test contexts with specific values to verify rule logic.</p> <p>Validate after deserialization: Check rollout ranges and required flags after loading JSON.</p>"},{"location":"#migration-path","title":"Migration Path","text":"<p>Migrating from string-based configuration systems:</p> <ol> <li>Inventory existing flags: Document all current flags and their types</li> <li>Define features: Create FeatureContainer with current defaults</li> <li>Run in parallel: Evaluate both systems, compare results</li> <li>Migrate incrementally: Move flags one by one</li> <li>Deprecate old system: Remove string-based system after full migration</li> </ol>"},{"location":"#next-steps","title":"Next Steps","text":"<p>New to Konditional? Start with Quick Start</p> <p>Need to define features? See Features</p> <p>Building targeting rules? See Rules</p> <p>Loading remote config? See Serialization</p> <p>Organizing by team? See Registry</p>"},{"location":"Configuration/","title":"Configuration","text":"<p>Konditional provides a type-safe DSL for configuring feature flags using the <code>FeatureContainer</code> delegation pattern. This guide covers the complete configuration API from a user perspective.</p>"},{"location":"Configuration/#overview","title":"Overview","text":"<p>Configuration in Konditional happens through property delegation within a <code>FeatureContainer</code>. Features are automatically registered and configured when you access them for the first time.</p> <p>Two main approaches:</p> <ol> <li>FeatureContainer delegation (recommended): Inline configuration with automatic registration</li> <li>Manual configuration: Explicit configuration using the <code>update()</code> method (advanced)</li> </ol> <p>This guide focuses on the FeatureContainer delegation approach, which provides the most ergonomic API.</p>"},{"location":"Configuration/#featurecontainer-organization-and-auto-registration","title":"FeatureContainer: Organization and Auto-Registration","text":"<p><code>FeatureContainer</code> is an abstract base class for organizing related feature flags with automatic registration.</p> <pre><code>import io.amichne.konditional.core.features.FeatureContainer\nimport io.amichne.konditional.core.Taxonomy\n\nobject AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.example.com\")\n    val MAX_RETRIES by int(default = 3)\n    val TIMEOUT_SECONDS by double(default = 30.0)\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Automatic registration: Features register themselves on first access</li> <li>Type inference: Default value determines the feature type</li> <li>Single taxonomy declaration: No need to repeat taxonomy on every feature</li> <li>Mixed types: Combine Boolean, String, Int, and Double features in one container</li> <li>Complete enumeration: <code>allFeatures()</code> provides runtime access to all features</li> </ul>"},{"location":"Configuration/#delegation-methods","title":"Delegation Methods","text":"<p>FeatureContainer provides four delegation methods for different value types:</p>"},{"location":"Configuration/#boolean","title":"boolean()","text":"<p>Creates a Boolean feature with optional configuration:</p> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            rollout { 50.0 }\n        } implies true\n    }\n}\n</code></pre> <p>Signature: <pre><code>protected fun &lt;C : Context&gt; boolean(\n    default: Boolean,\n    flagScope: FlagScope&lt;BooleanEncodeable, Boolean, C, M&gt;.() -&gt; Unit = {}\n): ReadOnlyProperty&lt;FeatureContainer&lt;M&gt;, BooleanFeature&lt;C, M&gt;&gt;\n</code></pre></p> <p>Parameters: - <code>default</code>: Default value (required) - <code>flagScope</code>: DSL configuration block (optional)</p>"},{"location":"Configuration/#string","title":"string()","text":"<p>Creates a String feature with optional configuration:</p> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val API_ENDPOINT by string(default = \"https://api.prod.example.com\") {\n        rule {\n            platforms(Platform.ANDROID)\n        } implies \"https://api-android.example.com\"\n    }\n}\n</code></pre> <p>Signature: <pre><code>protected fun &lt;C : Context&gt; string(\n    default: String,\n    stringScope: FlagScope&lt;StringEncodeable, String, C, M&gt;.() -&gt; Unit = {}\n): ReadOnlyProperty&lt;FeatureContainer&lt;M&gt;, StringFeature&lt;C, M&gt;&gt;\n</code></pre></p>"},{"location":"Configuration/#int","title":"int()","text":"<p>Creates an Int feature with optional configuration:</p> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val MAX_RETRY_COUNT by int(default = 3) {\n        rule {\n            platforms(Platform.IOS)\n        } implies 5\n    }\n}\n</code></pre> <p>Signature: <pre><code>protected fun &lt;C : Context&gt; int(\n    default: Int,\n    integerScope: FlagScope&lt;IntEncodeable, Int, C, M&gt;.() -&gt; Unit = {}\n): ReadOnlyProperty&lt;FeatureContainer&lt;M&gt;, IntFeature&lt;C, M&gt;&gt;\n</code></pre></p>"},{"location":"Configuration/#double","title":"double()","text":"<p>Creates a Double feature with optional configuration:</p> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val TRANSACTION_FEE by double(default = 0.029) {\n        rule {\n            platforms(Platform.WEB)\n        } implies 0.019\n    }\n}\n</code></pre> <p>Signature: <pre><code>protected fun &lt;C : Context&gt; double(\n    default: Double,\n    decimalScope: FlagScope&lt;DecimalEncodeable, Double, C, M&gt;.() -&gt; Unit = {}\n): ReadOnlyProperty&lt;FeatureContainer&lt;M&gt;, DoubleFeature&lt;C, M&gt;&gt;\n</code></pre></p>"},{"location":"Configuration/#flagscope-dsl","title":"FlagScope DSL","text":"<p>The <code>FlagScope</code> interface defines the configuration API for individual feature flags.</p>"},{"location":"Configuration/#default","title":"default()","text":"<p>Sets the default value returned when no rules match:</p> <pre><code>val MY_FLAG by boolean(default = false) {\n    default(false)  // Explicit (redundant in this case)\n}\n</code></pre> <p>Note: When using delegation, the <code>default</code> parameter is automatically applied. You rarely need to call <code>default()</code> explicitly within the configuration block.</p>"},{"location":"Configuration/#salt","title":"salt()","text":"<p>Sets the hash salt for rollout bucketing:</p> <pre><code>val EXPERIMENT by boolean(default = false) {\n    salt(\"v1\")  // Change to \"v2\" to redistribute users\n\n    rule {\n        rollout { 50.0 }\n    } implies true\n}\n</code></pre> <p>Use cases: - Initial experiments: Start with \"v1\" - Re-randomization: Change to \"v2\", \"v3\", etc. to redistribute users - Independent bucketing: Different salts create independent rollout buckets</p> <p>Important: Changing the salt redistributes all users across rollout buckets for that flag.</p>"},{"location":"Configuration/#rule","title":"rule()","text":"<p>Defines a targeting rule with a DSL configuration block:</p> <pre><code>val MY_FLAG by boolean(default = false) {\n    rule {\n        platforms(Platform.IOS, Platform.ANDROID)\n        locales(AppLocale.EN_US)\n        rollout { 50.0 }\n    } implies true\n}\n</code></pre> <p>Returns: A <code>Rule&lt;C&gt;</code> object that must be associated with a value using <code>implies</code></p> <p>Signature: <pre><code>fun rule(build: RuleScope&lt;C&gt;.() -&gt; Unit): Rule&lt;C&gt;\n</code></pre></p>"},{"location":"Configuration/#implies-infix","title":"implies (infix)","text":"<p>Associates a rule with its return value:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n} implies true\n</code></pre> <p>Type safety: The value type must match the feature's declared type.</p> <pre><code>val BOOLEAN_FLAG by boolean(default = false) {\n    rule { platforms(Platform.IOS) } implies true    // \u2713 Valid\n    rule { platforms(Platform.WEB) } implies \"true\"  // \u2717 Compile error\n}\n</code></pre> <p>Signature: <pre><code>infix fun Rule&lt;C&gt;.implies(value: T)\n</code></pre></p>"},{"location":"Configuration/#rulescope-dsl","title":"RuleScope DSL","text":"<p>The <code>RuleScope</code> interface defines targeting criteria for rules.</p>"},{"location":"Configuration/#platforms","title":"platforms()","text":"<p>Specify which platforms the rule applies to:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n} implies mobileValue\n</code></pre> <p>Available platforms: - <code>Platform.IOS</code> - <code>Platform.ANDROID</code> - <code>Platform.WEB</code> - <code>Platform.DESKTOP</code> - <code>Platform.SERVER</code></p> <p>Empty platforms: Matches all platforms</p>"},{"location":"Configuration/#locales","title":"locales()","text":"<p>Specify which locales the rule applies to:</p> <pre><code>rule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA, AppLocale.EN_GB)\n} implies englishValue\n</code></pre> <p>Common locales: - <code>AppLocale.EN_US</code> (English - US) - <code>AppLocale.EN_GB</code> (English - UK) - <code>AppLocale.FR_FR</code> (French - France) - <code>AppLocale.DE_DE</code> (German - Germany) - <code>AppLocale.ES_ES</code> (Spanish - Spain) - <code>AppLocale.JA_JP</code> (Japanese - Japan) - <code>AppLocale.ZH_CN</code> (Chinese - China)</p> <p>Empty locales: Matches all locales</p>"},{"location":"Configuration/#versions","title":"versions()","text":"<p>Specify version range using <code>VersionRangeScope</code>:</p> <pre><code>rule {\n    versions {\n        min(2, 0, 0)  // &gt;= 2.0.0\n        max(3, 0, 0)  // &lt; 3.0.0\n    }\n} implies value\n</code></pre> <p>Version range patterns:</p> <pre><code>// Minimum only\nversions { min(2, 0, 0) }  // 2.0.0 or higher\n\n// Maximum only\nversions { max(1, 9, 9) }  // 1.9.9 or lower\n\n// Both (range)\nversions {\n    min(1, 5, 0)\n    max(2, 0, 0)\n}\n\n// Exact version\nversions {\n    min(2, 1, 3)\n    max(2, 1, 3)\n}\n</code></pre>"},{"location":"Configuration/#rollout","title":"rollout()","text":"<p>Set gradual rollout percentage (0-100):</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout { 50.0 }  // 50% of iOS users\n} implies true\n</code></pre> <p>Common values:</p> <pre><code>rollout { 0.0 }    // 0% - effectively disabled\nrollout { 10.0 }   // 10% - canary/pilot\nrollout { 25.0 }   // 25% - limited rollout\nrollout { 50.0 }   // 50% - A/B test\nrollout { 100.0 }  // 100% - full rollout\n</code></pre> <p>Rollout characteristics: - Deterministic: Same user (by <code>stableId</code>) always gets same assignment - Independent: Each flag has its own bucketing space - Stable: Assignments don't change unless salt changes</p>"},{"location":"Configuration/#extension","title":"extension()","text":"<p>Add custom evaluation logic using <code>Evaluable</code>:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n            override fun specificity(): Int = 1\n        }\n    }\n} implies true\n</code></pre> <p>Use cases: - Business logic targeting (subscription tier, organization ID, etc.) - Complex conditional logic - Custom user segmentation</p>"},{"location":"Configuration/#note","title":"note()","text":"<p>Add human-readable documentation to rules:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout { 10.0 }\n    note(\"iOS canary deployment - Phase 1\")\n} implies true\n</code></pre> <p>Best practices: - Document purpose and intent - Include tracking IDs for experiments - Note ownership and duration - Explain complex targeting logic</p>"},{"location":"Configuration/#versionrangescope-dsl","title":"VersionRangeScope DSL","text":"<p>The <code>VersionRangeScope</code> interface defines version constraint configuration.</p>"},{"location":"Configuration/#min","title":"min()","text":"<p>Set minimum version (inclusive):</p> <pre><code>versions {\n    min(2, 0, 0)  // Version 2.0.0 or higher\n}\n</code></pre> <p>Signature: <pre><code>fun min(major: Int, minor: Int = 0, patch: Int = 0)\n</code></pre></p> <p>Examples: <pre><code>min(2)           // &gt;= 2.0.0\nmin(2, 5)        // &gt;= 2.5.0\nmin(2, 5, 3)     // &gt;= 2.5.3\n</code></pre></p>"},{"location":"Configuration/#max","title":"max()","text":"<p>Set maximum version (exclusive):</p> <pre><code>versions {\n    max(3, 0, 0)  // Below version 3.0.0\n}\n</code></pre> <p>Signature: <pre><code>fun max(major: Int, minor: Int = 0, patch: Int = 0)\n</code></pre></p> <p>Examples: <pre><code>max(3)           // &lt; 3.0.0\nmax(2, 9)        // &lt; 2.9.0\nmax(2, 9, 99)    // &lt; 2.9.99\n</code></pre></p>"},{"location":"Configuration/#complete-configuration-examples","title":"Complete Configuration Examples","text":""},{"location":"Configuration/#simple-boolean-flag","title":"Simple Boolean Flag","text":"<pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n            rollout { 50.0 }\n            note(\"Mobile dark mode, 50% rollout\")\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Configuration/#multi-platform-with-different-values","title":"Multi-Platform with Different Values","text":"<pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val API_ENDPOINT by string(default = \"https://api.example.com\") {\n        rule {\n            platforms(Platform.IOS)\n        } implies \"https://api-ios.example.com\"\n\n        rule {\n            platforms(Platform.ANDROID)\n        } implies \"https://api-android.example.com\"\n\n        rule {\n            platforms(Platform.WEB)\n        } implies \"https://api-web.example.com\"\n    }\n}\n</code></pre>"},{"location":"Configuration/#version-based-feature-rollout","title":"Version-Based Feature Rollout","text":"<pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val NEW_UI by boolean(default = false) {\n        // Full rollout for version 3.0.0+\n        rule {\n            versions { min(3, 0, 0) }\n        } implies true\n\n        // 50% rollout for version 2.5.0 - 2.9.9\n        rule {\n            versions {\n                min(2, 5, 0)\n                max(3, 0, 0)\n            }\n            rollout { 50.0 }\n        } implies true\n\n        // 10% canary for version 2.0.0 - 2.4.9\n        rule {\n            versions {\n                min(2, 0, 0)\n                max(2, 5, 0)\n            }\n            rollout { 10.0 }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Configuration/#custom-context-with-business-logic","title":"Custom Context with Business Logic","text":"<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val organizationId: String\n) : Context\n\nenum class SubscriptionTier { FREE, PROFESSIONAL, ENTERPRISE }\n\nobject PremiumFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n        // Enterprise customers: 100% rollout\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n                    override fun specificity(): Int = 1\n                }\n            }\n            note(\"Full rollout for enterprise customers\")\n        } implies true\n\n        // Professional customers: 50% rollout\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.PROFESSIONAL\n\n                    override fun specificity(): Int = 1\n                }\n            }\n            rollout { 50.0 }\n            note(\"50% rollout for professional tier\")\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Configuration/#multi-criteria-targeting","title":"Multi-Criteria Targeting","text":"<pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val PREMIUM_FEATURE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n            locales(AppLocale.EN_US, AppLocale.EN_CA)\n            versions {\n                min(2, 0, 0)\n                max(3, 0, 0)\n            }\n            rollout { 25.0 }\n            note(\"Mobile English NA users, v2.x, 25% rollout\")\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Configuration/#gradual-rollout-strategy","title":"Gradual Rollout Strategy","text":"<pre><code>object ExperimentFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val NEW_CHECKOUT by boolean(default = false) {\n        salt(\"v1\")  // Change to re-randomize\n\n        // Phase 1: Internal testing (use custom context)\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.organizationId == \"internal\"\n                    override fun specificity(): Int = 2\n                }\n            }\n            note(\"Phase 1: Internal testing\")\n        } implies true\n\n        // Phase 2: 10% canary\n        rule {\n            rollout { 10.0 }\n            note(\"Phase 2: 10% canary\")\n        } implies true\n\n        // Later: Increase to 50%, then 100%\n        // Update configuration dynamically or through config management\n    }\n}\n</code></pre>"},{"location":"Configuration/#type-safety-in-configuration","title":"Type Safety in Configuration","text":"<p>The DSL enforces type safety at compile time:</p>"},{"location":"Configuration/#value-type-checking","title":"Value Type Checking","text":"<pre><code>val BOOLEAN_FLAG by boolean(default = false) {\n    rule { platforms(Platform.IOS) } implies true    // \u2713 Valid\n    rule { platforms(Platform.WEB) } implies \"true\"  // \u2717 Type mismatch\n}\n\nval STRING_FLAG by string(default = \"default\") {\n    rule { platforms(Platform.IOS) } implies \"ios-value\"  // \u2713 Valid\n    rule { platforms(Platform.WEB) } implies true         // \u2717 Type mismatch\n}\n</code></pre>"},{"location":"Configuration/#context-type-checking","title":"Context Type Checking","text":"<pre><code>data class CustomContext(/* ... */) : Context\n\nval CUSTOM_FLAG by boolean&lt;CustomContext&gt;(default = false) {\n    rule {\n        extension {\n            // Must use CustomContext, not base Context\n            object : Evaluable&lt;CustomContext&gt;() {  // \u2713 Correct type\n                override fun matches(context: CustomContext) = true\n                override fun specificity() = 1\n            }\n        }\n    } implies true\n}\n</code></pre>"},{"location":"Configuration/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"Configuration/#organizing-features-by-domain","title":"Organizing Features by Domain","text":"<p>Use separate containers for different domains:</p> <pre><code>object AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n    val GOOGLE_PAY by boolean(default = false)\n    val TRANSACTION_LIMIT by double(default = 10000.0)\n}\n\nobject MessagingFeatures : FeatureContainer&lt;Taxonomy.Domain.Messaging&gt;(\n    Taxonomy.Domain.Messaging\n) {\n    val PUSH_NOTIFICATIONS by boolean(default = true)\n    val EMAIL_DIGEST by boolean(default = false)\n}\n</code></pre> <p>Benefits: - Clear ownership boundaries - Isolation between teams - Independent configuration management - Type-safe taxonomy enforcement</p>"},{"location":"Configuration/#extracting-complex-rules","title":"Extracting Complex Rules","text":"<p>Create reusable <code>Evaluable</code> classes:</p> <pre><code>class EnterpriseCustomerRule : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n    override fun specificity(): Int = 1\n}\n\nclass ProfessionalCustomerRule : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier == SubscriptionTier.PROFESSIONAL\n\n    override fun specificity(): Int = 1\n}\n\nobject PremiumFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val FEATURE_A by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            extension { EnterpriseCustomerRule() }\n        } implies true\n    }\n\n    val FEATURE_B by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            extension { EnterpriseCustomerRule() }\n        } implies true\n    }\n}\n</code></pre> <p>Benefits: - Reusability across multiple flags - Easier testing - Cleaner configuration DSL - Type-safe composition</p>"},{"location":"Configuration/#named-configuration-values","title":"Named Configuration Values","text":"<p>Extract complex values into named constants:</p> <pre><code>object ApiConfig : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    private val PROD_ENDPOINT = \"https://api.prod.example.com\"\n    private val STAGING_ENDPOINT = \"https://api.staging.example.com\"\n    private val DEV_ENDPOINT = \"https://api.dev.example.com\"\n\n    val API_ENDPOINT by string(default = PROD_ENDPOINT) {\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext) =\n                        context.organizationId.startsWith(\"staging-\")\n                    override fun specificity() = 1\n                }\n            }\n        } implies STAGING_ENDPOINT\n\n        rule {\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext) =\n                        context.organizationId == \"internal\"\n                    override fun specificity() = 2\n                }\n            }\n        } implies DEV_ENDPOINT\n    }\n}\n</code></pre>"},{"location":"Configuration/#exporting-configurations","title":"Exporting Configurations","text":""},{"location":"Configuration/#konfig-method","title":"konfig() Method","text":"<p>Get a snapshot of the current configuration:</p> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val FLAG_A by boolean(default = false)\n    val FLAG_B by string(default = \"default\")\n}\n\n// Get configuration snapshot\nval snapshot = Taxonomy.Global.konfig()\n\n// Serialize to JSON\nval json = SnapshotSerializer.serialize(snapshot)\n\n// Load into another registry (testing)\ntestRegistry.load(snapshot)\n</code></pre> <p>Use cases: - Exporting current configuration state - Testing with isolated registries - Configuration auditing - External configuration management - Snapshot comparisons</p>"},{"location":"Configuration/#allfeatures-method","title":"allFeatures() Method","text":"<p>Enumerate all features in a container:</p> <pre><code>val features = MyFeatures.allFeatures()\nfeatures.forEach { feature -&gt;\n    println(\"Feature: ${feature.key}\")\n}\n</code></pre> <p>Use cases: - Configuration validation - Documentation generation - Feature inventory auditing - Testing all features</p>"},{"location":"Configuration/#dsl-reference-table","title":"DSL Reference Table","text":""},{"location":"Configuration/#scope-hierarchy","title":"Scope Hierarchy","text":"Scope Parent Scope Available Methods FeatureContainer - <code>boolean()</code>, <code>string()</code>, <code>int()</code>, <code>double()</code>, <code>allFeatures()</code> FlagScope Delegation block <code>default()</code>, <code>salt()</code>, <code>rule()</code>, <code>implies</code> RuleScope <code>rule { }</code> <code>platforms()</code>, <code>locales()</code>, <code>versions()</code>, <code>rollout()</code>, <code>extension()</code>, <code>note()</code> VersionRangeScope <code>versions { }</code> <code>min()</code>, <code>max()</code>"},{"location":"Configuration/#flagscope-methods","title":"FlagScope Methods","text":"Method Description Required <code>default(value: T)</code> Set default value No* <code>salt(value: String)</code> Set rollout salt No <code>rule(build: RuleScope&lt;C&gt;.() -&gt; Unit)</code> Define targeting rule No <code>infix fun Rule&lt;C&gt;.implies(value: T)</code> Associate rule with value Yes** <p>* Required when not using delegation parameter ** Required for each <code>rule()</code> call</p>"},{"location":"Configuration/#rulescope-methods","title":"RuleScope Methods","text":"Method Description Default <code>platforms(vararg ps: Platform)</code> Target specific platforms All platforms <code>locales(vararg appLocales: AppLocale)</code> Target specific locales All locales <code>versions(build: VersionRangeScope.() -&gt; Unit)</code> Target version range All versions <code>rollout(function: () -&gt; Number)</code> Set rollout percentage 100.0 <code>extension(function: () -&gt; Evaluable&lt;C&gt;)</code> Add custom targeting No extension <code>note(text: String)</code> Add documentation note No note"},{"location":"Configuration/#versionrangescope-methods","title":"VersionRangeScope Methods","text":"Method Description <code>min(major: Int, minor: Int = 0, patch: Int = 0)</code> Set minimum version (inclusive) <code>max(major: Int, minor: Int = 0, patch: Int = 0)</code> Set maximum version (exclusive)"},{"location":"Configuration/#best-practices","title":"Best Practices","text":""},{"location":"Configuration/#1-use-featurecontainer-delegation","title":"1. Use FeatureContainer Delegation","text":"<p>Prefer delegation over manual configuration:</p> <pre><code>// \u2713 Recommended\nobject MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false)\n}\n\n// \u2717 Avoid (manual configuration)\nenum class MyFeatures : BooleanFeature&lt;Context, Taxonomy.Global&gt; {\n    DARK_MODE(\"dark_mode\");\n    override val module = Taxonomy.Global\n}\n</code></pre>"},{"location":"Configuration/#2-organize-by-feature-area","title":"2. Organize by Feature Area","text":"<p>Separate configurations into dedicated containers:</p> <pre><code>// \u2713 Clear organization\nobject UIFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) { }\nobject ApiFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) { }\nobject ExperimentFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) { }\n\n// \u2717 Everything in one container\nobject AllFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val UI_DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"\")\n    val EXPERIMENT_A by boolean(default = false)\n    // ... 100 more features\n}\n</code></pre>"},{"location":"Configuration/#3-use-named-values-for-clarity","title":"3. Use Named Values for Clarity","text":"<p>Extract complex values:</p> <pre><code>// \u2713 Clear and reusable\nprivate val PRODUCTION_ENDPOINT = \"https://api.prod.example.com\"\nval API_URL by string(default = PRODUCTION_ENDPOINT)\n\n// \u2717 Magic strings\nval API_URL by string(default = \"https://api.prod.example.com\")\n</code></pre>"},{"location":"Configuration/#4-document-rules-with-note","title":"4. Document Rules with note()","text":"<p>Add context to complex rules:</p> <pre><code>// \u2713 Well documented\nrule {\n    platforms(Platform.IOS)\n    rollout { 10.0 }\n    note(\"EXP-1234: iOS canary for new checkout - Q1 2025 - Owner: payments-team\")\n} implies true\n\n// \u2717 No context\nrule {\n    platforms(Platform.IOS)\n    rollout { 10.0 }\n} implies true\n</code></pre>"},{"location":"Configuration/#5-maintain-salt-hygiene","title":"5. Maintain Salt Hygiene","text":"<p>Document salt changes:</p> <pre><code>// \u2713 Documented salt changes\nval EXPERIMENT by boolean(default = false) {\n    salt(\"v2\")  // v2: Re-randomized 2025-01-15 to fix skewed distribution\n    // ...\n}\n\n// \u2717 Unexplained salt changes\nval EXPERIMENT by boolean(default = false) {\n    salt(\"abc123xyz\")\n    // ...\n}\n</code></pre>"},{"location":"Configuration/#6-extract-reusable-evaluables","title":"6. Extract Reusable Evaluables","text":"<p>Create classes for common logic:</p> <pre><code>// \u2713 Reusable and testable\nclass PremiumTierRule : Evaluable&lt;EnterpriseContext&gt;() {\n    override fun matches(context: EnterpriseContext) =\n        context.subscriptionTier == SubscriptionTier.PREMIUM ||\n        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n    override fun specificity() = 1\n}\n\n// \u2717 Duplicated logic\nval FEATURE_A by boolean&lt;EnterpriseContext&gt;(default = false) {\n    rule {\n        extension {\n            object : Evaluable&lt;EnterpriseContext&gt;() {\n                override fun matches(context: EnterpriseContext) =\n                    context.subscriptionTier == SubscriptionTier.PREMIUM ||\n                    context.subscriptionTier == SubscriptionTier.ENTERPRISE\n                override fun specificity() = 1\n            }\n        }\n    } implies true\n}\n</code></pre>"},{"location":"Configuration/#7-validate-configurations","title":"7. Validate Configurations","text":"<p>Use <code>allFeatures()</code> for validation:</p> <pre><code>fun validateAllFeaturesConfigured() {\n    val configuredKeys = loadConfigurationKeys()  // From external source\n    val declaredKeys = MyFeatures.allFeatures().map { it.key }.toSet()\n    val missing = declaredKeys - configuredKeys\n\n    require(missing.isEmpty()) {\n        \"Missing configuration for features: $missing\"\n    }\n}\n</code></pre>"},{"location":"Configuration/#8-use-specific-rollout-values","title":"8. Use Specific Rollout Values","text":"<p>Prefer common percentages for consistency:</p> <pre><code>// \u2713 Standard increments\nrollout { 10.0 }   // Canary\nrollout { 25.0 }   // Limited\nrollout { 50.0 }   // A/B test\nrollout { 100.0 }  // Full rollout\n\n// \u2717 Arbitrary percentages\nrollout { 17.3 }\nrollout { 42.7 }\n</code></pre>"},{"location":"Configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Features: Feature definition patterns and type aliases</li> <li>Rules: Advanced targeting and rule evaluation</li> <li>Context: Custom contexts and polymorphism</li> <li>Evaluation: Flag evaluation mechanics and result handling</li> <li>Serialization: JSON export/import for configurations</li> <li>Registry: Taxonomy and registry management</li> </ul>"},{"location":"Context/","title":"Context: Evaluation Environment","text":"<p>The <code>Context</code> interface defines the evaluation environment for feature flags. It provides the standard targeting dimensions that determine which rules match and which values are returned during flag evaluation.</p>"},{"location":"Context/#overview","title":"Overview","text":"<p>Every feature flag evaluation requires a <code>Context</code> instance. The context represents the current execution environment, including user preferences, platform information, application version, and a stable identifier for deterministic rollouts.</p> <pre><code>import io.amichne.konditional.context.*\n\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4\")\n)\n\nval isDarkMode = context.evaluate(AppFeatures.DARK_MODE)\n</code></pre> <p>Key characteristics: - Immutable: Context instances should never change after creation - Thread-safe: Safe to share across threads - Lightweight: Contains only essential targeting information - Extensible: Can be extended with custom fields for domain-specific targeting</p>"},{"location":"Context/#context-interface","title":"Context Interface","text":"<p>The base <code>Context</code> interface defines four required properties:</p> <pre><code>interface Context {\n    val locale: AppLocale\n    val platform: Platform\n    val appVersion: Version\n    val stableId: StableId\n}\n</code></pre>"},{"location":"Context/#required-properties","title":"Required Properties","text":"Property Type Purpose <code>locale</code> <code>AppLocale</code> User's language and regional settings <code>platform</code> <code>Platform</code> Platform where the app is running <code>appVersion</code> <code>Version</code> Semantic version of the application <code>stableId</code> <code>StableId</code> Unique identifier for deterministic bucketing"},{"location":"Context/#creating-context-instances","title":"Creating Context Instances","text":""},{"location":"Context/#factory-function","title":"Factory Function","text":"<p>The simplest way to create a context is using the companion object factory:</p> <pre><code>val context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4\")\n)\n</code></pre> <p>This creates an anonymous implementation of the <code>Context</code> interface. It's perfect for quick use, testing, and simple applications.</p>"},{"location":"Context/#data-class-implementation","title":"Data Class Implementation","text":"<p>For production applications, define a data class:</p> <pre><code>data class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n\nval context = AppContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4\")\n)\n</code></pre> <p>Benefits of data classes: - <code>copy()</code> for creating modified instances - Structural equality for testing - <code>toString()</code> for debugging - Named properties improve clarity</p>"},{"location":"Context/#context-components","title":"Context Components","text":""},{"location":"Context/#platform","title":"Platform","text":"<p>The <code>Platform</code> enum identifies where your application is running:</p> <pre><code>enum class Platform {\n    IOS,      // iOS devices (iPhone, iPad)\n    ANDROID,  // Android devices\n    WEB       // Web browsers\n}\n</code></pre> <p>Usage: <pre><code>val context = Context(\n    platform = Platform.IOS,\n    // ... other properties\n)\n</code></pre></p> <p>Common patterns: <pre><code>// Platform-specific targeting\nrule {\n    platforms(Platform.IOS, Platform.ANDROID)\n} implies mobileValue\n\n// Single platform\nrule {\n    platforms(Platform.WEB)\n} implies webValue\n</code></pre></p>"},{"location":"Context/#applocale","title":"AppLocale","text":"<p>The <code>AppLocale</code> enum represents language and regional settings:</p> <pre><code>enum class AppLocale {\n    EN_US,  // English (United States)\n    ES_US,  // Spanish (United States)\n    EN_CA,  // English (Canada)\n    HI_IN   // Hindi (India)\n}\n</code></pre> <p>Usage: <pre><code>val context = Context(\n    locale = AppLocale.EN_US,\n    // ... other properties\n)\n</code></pre></p> <p>Locale-based targeting: <pre><code>// Multiple locales\nrule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA)\n} implies englishValue\n\n// Single locale\nrule {\n    locales(AppLocale.HI_IN)\n} implies hindiValue\n</code></pre></p> <p>Note: Add new locales to the enum as your application expands to new markets.</p>"},{"location":"Context/#version","title":"Version","text":"<p>The <code>Version</code> class represents semantic versioning (major.minor.patch):</p> <pre><code>data class Version(\n    val major: Int,\n    val minor: Int,\n    val patch: Int\n) : Comparable&lt;Version&gt;\n</code></pre>"},{"location":"Context/#creating-versions","title":"Creating Versions","text":"<p>Direct construction: <pre><code>val version = Version(2, 1, 0)  // Version 2.1.0\n</code></pre></p> <p>Using factory method: <pre><code>val version = Version.of(2, 1, 0)  // Version 2.1.0\n</code></pre></p> <p>Parsing from string: <pre><code>val version = Version.parse(\"2.1.0\")  // Version 2.1.0\nval version = Version.parse(\"2.1\")    // Version 2.1.0\nval version = Version.parse(\"2\")      // Version 2.0.0\n</code></pre></p> <p>Default version: <pre><code>val default = Version.default  // Version(-1, -1, -1)\n</code></pre></p>"},{"location":"Context/#version-comparison","title":"Version Comparison","text":"<p><code>Version</code> implements <code>Comparable&lt;Version&gt;</code>, enabling natural ordering:</p> <pre><code>val v1 = Version(2, 0, 0)\nval v2 = Version(2, 1, 0)\nval v3 = Version(3, 0, 0)\n\nprintln(v1 &lt; v2)   // true\nprintln(v2 &lt;= v2)  // true\nprintln(v3 &gt; v2)   // true\n\n// Use in version ranges\nrule {\n    versions {\n        min(2, 0, 0)  // &gt;= 2.0.0\n        max(3, 0, 0)  // &lt;= 3.0.0\n    }\n} implies newFeatureValue\n</code></pre> <p>Comparison logic: 1. Compare major versions first 2. If equal, compare minor versions 3. If equal, compare patch versions</p>"},{"location":"Context/#stableid","title":"StableId","text":"<p>The <code>StableId</code> represents a unique, stable identifier used for deterministic rollout bucketing:</p> <pre><code>sealed interface StableId {\n    val id: String\n    val hexId: HexId\n}\n</code></pre>"},{"location":"Context/#creating-stableids","title":"Creating StableIds","text":"<pre><code>// From user ID\nval stableId = StableId.of(\"a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4\")\n\n// From UUID (convert to hex first)\nval uuid = UUID.randomUUID()\nval stableId = StableId.of(uuid.toString().replace(\"-\", \"\"))\n\n// From any unique identifier\nval stableId = StableId.of(userId.toHexString())\n</code></pre>"},{"location":"Context/#validation","title":"Validation","text":"<p><code>StableId.of()</code> validates that the input is a valid hexadecimal string:</p> <pre><code>// Valid - hex string\nStableId.of(\"abc123\")  // OK\n\n// Invalid - not hex\nStableId.of(\"xyz123\")  // Throws IllegalArgumentException\n\n// Invalid - empty\nStableId.of(\"\")        // Throws IllegalArgumentException\n</code></pre> <p>Requirements: - Must be a valid hexadecimal string (0-9, a-f, A-F) - Must be non-empty - Should be consistent for the same user/device across sessions</p>"},{"location":"Context/#best-practices","title":"Best Practices","text":"<p>Choose the right identifier level:</p> <pre><code>// User-level: Same user sees same experience across devices\nval stableId = StableId.of(userId)\n\n// Device-level: Different devices see different experiences\nval stableId = StableId.of(deviceId)\n\n// Session-level: Different sessions see different experiences\nval stableId = StableId.of(sessionId)\n\n// Anonymous: For logged-out users\nval anonymousId = getOrCreateAnonymousId()  // Store in localStorage/cookies\nval stableId = StableId.of(anonymousId)\n</code></pre> <p>Identifier requirements: - Persistent: Survives app restarts and sessions - Unique: Different users/devices have different IDs - Consistent: Same user/device always has the same ID - Stable: Doesn't change over time</p> <p>What NOT to use: - Timestamps (changes every request) - Random values (not stable) - Sensitive data (hashed in logs) - IP addresses (changes with network)</p>"},{"location":"Context/#rollout","title":"Rollout","text":"<p>The <code>Rollout</code> value class represents a percentage (0-100%) for gradual feature deployment.</p>"},{"location":"Context/#creating-rollouts","title":"Creating Rollouts","text":"<p>From Double: <pre><code>val rollout = Rollout.of(50.0)   // 50%\nval rollout = Rollout.of(25.5)   // 25.5%\nval rollout = Rollout.of(100.0)  // 100%\n</code></pre></p> <p>From Int: <pre><code>val rollout = Rollout.of(50)   // 50%\nval rollout = Rollout.of(100)  // 100%\n</code></pre></p> <p>From String: <pre><code>val rollout = Rollout.of(\"50.0\")   // 50%\nval rollout = Rollout.of(\"75\")     // 75%\n</code></pre></p> <p>From another Rollout: <pre><code>val rollout1 = Rollout.of(50.0)\nval rollout2 = Rollout.of(rollout1)  // Copy\n</code></pre></p>"},{"location":"Context/#constants","title":"Constants","text":"<pre><code>val max = Rollout.MAX          // 100%\nval default = Rollout.default  // 100%\n</code></pre>"},{"location":"Context/#range-validation","title":"Range Validation","text":"<p>Rollout percentages must be between 0.0 and 100.0:</p> <pre><code>Rollout.of(0.0)    // OK - 0%\nRollout.of(50.0)   // OK - 50%\nRollout.of(100.0)  // OK - 100%\nRollout.of(150.0)  // Throws IllegalArgumentException\nRollout.of(-10.0)  // Throws IllegalArgumentException\n</code></pre>"},{"location":"Context/#usage-in-rules","title":"Usage in Rules","text":"<pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(25.0)  // 25% of iOS users\n} implies true\n\nrule {\n    rollout = Rollout.MAX  // 100% of all users\n} implies true\n</code></pre>"},{"location":"Context/#how-rollouts-work","title":"How Rollouts Work","text":"<p>Rollout bucketing is deterministic and flag-specific:</p> <ol> <li>Hash the combination of <code>salt + flagKey + stableId</code> using SHA-256</li> <li>Map hash to bucket (0-9999)</li> <li>Compare bucket to rollout percentage \u00d7 100</li> </ol> <pre><code>// Example: 50% rollout\n// User with stableId \"abc123\" \u2192 bucket 4752\n// 4752 &lt; 5000 (50% \u00d7 100) \u2192 User is in rollout \u2713\n\n// Same user, different flag \u2192 different bucket\n// Different deterministic hash per flag\n</code></pre> <p>Key properties: - Deterministic: Same user always sees same experience for a flag - Independent: Each flag buckets users independently - Uniform: Users distributed evenly across buckets - Stable: Bucketing doesn't change unless salt changes</p> <p>Gradual rollout strategy: <pre><code>// Week 1: 10%\nrollout = Rollout.of(10.0)\n\n// Week 2: 25%\nrollout = Rollout.of(25.0)\n\n// Week 3: 50%\nrollout = Rollout.of(50.0)\n\n// Week 4: 100%\nrollout = Rollout.MAX\n</code></pre></p> <p>Users in the 10% bucket stay enabled as you increase to 25%, 50%, and 100%.</p>"},{"location":"Context/#custom-context-extensions","title":"Custom Context Extensions","text":"<p>One of Konditional's most powerful features is the ability to extend <code>Context</code> with domain-specific fields. This enables targeting based on your business logic.</p>"},{"location":"Context/#extension-pattern","title":"Extension Pattern","text":"<pre><code>data class EnterpriseContext(\n    // Required base properties\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n\n    // Custom enterprise fields\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val userRole: UserRole\n) : Context\n\nenum class SubscriptionTier { BASIC, PREMIUM, ENTERPRISE }\nenum class UserRole { EDITOR, ADMIN, OWNER }\n</code></pre>"},{"location":"Context/#using-custom-contexts-with-features","title":"Using Custom Contexts with Features","text":"<p>Define features that require your custom context:</p> <pre><code>object EnterpriseFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val advanced_analytics by boolean&lt;EnterpriseContext&gt;(default = false)\n    val custom_branding by boolean&lt;EnterpriseContext&gt;(default = false)\n    val api_access by boolean&lt;EnterpriseContext&gt;(default = false)\n}\n</code></pre>"},{"location":"Context/#custom-rules-with-extensions","title":"Custom Rules with Extensions","text":"<p>Create custom <code>Evaluable</code> implementations that access your context fields:</p> <pre><code>data class EnterpriseRule(\n    val requiredTier: SubscriptionTier? = null,\n    val requiredRole: UserRole? = null\n) : Evaluable&lt;EnterpriseContext&gt; {\n    override fun matches(context: EnterpriseContext): Boolean =\n        (requiredTier == null || context.subscriptionTier &gt;= requiredTier) &amp;&amp;\n        (requiredRole == null || context.userRole &gt;= requiredRole)\n}\n\n// Configure feature with custom rule\nEnterpriseFeatures.advanced_analytics.update {\n    default(false)\n    rule {\n        extension {\n            EnterpriseRule(requiredTier = SubscriptionTier.ENTERPRISE)\n        }\n    } implies true\n}\n</code></pre>"},{"location":"Context/#common-extension-patterns","title":"Common Extension Patterns","text":""},{"location":"Context/#multi-tenancy-context","title":"Multi-Tenancy Context","text":"<pre><code>data class TenantContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val tenantId: String,\n    val tenantRegion: String,\n    val planFeatures: Set&lt;String&gt;\n) : Context\n</code></pre>"},{"location":"Context/#experimentation-context","title":"Experimentation Context","text":"<pre><code>data class ExperimentContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val experimentGroups: Set&lt;String&gt;,\n    val sessionId: String\n) : Context\n</code></pre>"},{"location":"Context/#user-context","title":"User Context","text":"<pre><code>data class UserContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val userId: String,\n    val isAuthenticated: Boolean,\n    val accountAge: Duration,\n    val subscriptionStatus: SubscriptionStatus\n) : Context\n</code></pre>"},{"location":"Context/#context-polymorphism","title":"Context Polymorphism","text":"<p>Konditional's type system enforces context requirements at compile time through generic type parameters.</p>"},{"location":"Context/#type-safety-guarantees","title":"Type Safety Guarantees","text":"<pre><code>// Feature requiring base Context\nobject AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean&lt;Context&gt;(default = false)\n}\n\n// Feature requiring EnterpriseContext\nobject EnterpriseFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false)\n}\n</code></pre>"},{"location":"Context/#evaluation-type-safety","title":"Evaluation Type Safety","text":"<pre><code>// Base context\nval baseContext: Context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.WEB,\n    appVersion = Version.parse(\"2.0.0\"),\n    stableId = StableId.of(\"abc123def456abc123def456abc123de\")\n)\n\n// Can evaluate features requiring Context\nbaseContext.evaluate(AppFeatures.DARK_MODE)  // \u2713 OK\n\n// Cannot evaluate features requiring EnterpriseContext\n// baseContext.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)  // \u2717 Compile error!\n</code></pre>"},{"location":"Context/#subtype-polymorphism","title":"Subtype Polymorphism","text":"<p>Extended contexts can evaluate base context features:</p> <pre><code>// Enterprise context (extends Context)\nval enterpriseContext: EnterpriseContext = EnterpriseContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.WEB,\n    appVersion = Version.parse(\"2.0.0\"),\n    stableId = StableId.of(\"abc123def456abc123def456abc123de\"),\n    organizationId = \"org-123\",\n    subscriptionTier = SubscriptionTier.ENTERPRISE,\n    userRole = UserRole.ADMIN\n)\n\n// Can evaluate base Context features (covariance)\nenterpriseContext.evaluate(AppFeatures.DARK_MODE)  // \u2713 OK\n\n// Can evaluate EnterpriseContext features\nenterpriseContext.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)  // \u2713 OK\n</code></pre> <p>Why this works: <code>EnterpriseContext</code> is a subtype of <code>Context</code>, so it can be used wherever <code>Context</code> is required.</p>"},{"location":"Context/#context-patterns-and-best-practices","title":"Context Patterns and Best Practices","text":""},{"location":"Context/#immutability","title":"Immutability","text":"<p>Always use immutable data classes with <code>val</code> properties:</p> <pre><code>// Good: Immutable\ndata class AppContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId\n) : Context\n\n// Bad: Mutable - NOT thread-safe\nclass MutableContext(\n    override var locale: AppLocale,\n    override var platform: Platform,\n    override var appVersion: Version,\n    override var stableId: StableId\n) : Context  // Don't do this!\n</code></pre>"},{"location":"Context/#context-factories","title":"Context Factories","text":"<p>Create factory functions for common context construction patterns:</p> <pre><code>object ContextFactory {\n    fun fromRequest(request: HttpRequest): AppContext =\n        AppContext(\n            locale = parseLocale(request.headers[\"Accept-Language\"]),\n            platform = parsePlatform(request.headers[\"User-Agent\"]),\n            appVersion = parseVersion(request.headers[\"X-App-Version\"]),\n            stableId = StableId.of(\n                request.cookies[\"user_id\"] ?: generateAnonymousId()\n            )\n        )\n\n    fun fromUser(user: User, device: Device): AppContext =\n        AppContext(\n            locale = user.preferredLocale,\n            platform = device.platform,\n            appVersion = device.appVersion,\n            stableId = StableId.of(user.id)\n        )\n\n    fun forTesting(\n        locale: AppLocale = AppLocale.EN_US,\n        platform: Platform = Platform.WEB,\n        version: String = \"1.0.0\",\n        userId: String = \"test-user\"\n    ): AppContext =\n        AppContext(\n            locale = locale,\n            platform = platform,\n            appVersion = Version.parse(version),\n            stableId = StableId.of(userId.md5())\n        )\n}\n</code></pre>"},{"location":"Context/#context-builders","title":"Context Builders","text":"<p>For complex contexts with many fields, consider a builder pattern:</p> <pre><code>class EnterpriseContextBuilder {\n    private var locale: AppLocale = AppLocale.EN_US\n    private var platform: Platform = Platform.WEB\n    private var appVersion: Version = Version(1, 0, 0)\n    private var stableId: StableId? = null\n    private var organizationId: String? = null\n    private var subscriptionTier: SubscriptionTier = SubscriptionTier.BASIC\n    private var userRole: UserRole = UserRole.EDITOR\n\n    fun locale(locale: AppLocale) = apply { this.locale = locale }\n    fun platform(platform: Platform) = apply { this.platform = platform }\n    fun version(version: Version) = apply { this.appVersion = version }\n    fun stableId(id: String) = apply { this.stableId = StableId.of(id) }\n    fun organization(id: String) = apply { this.organizationId = id }\n    fun tier(tier: SubscriptionTier) = apply { this.subscriptionTier = tier }\n    fun role(role: UserRole) = apply { this.userRole = role }\n\n    fun build(): EnterpriseContext =\n        EnterpriseContext(\n            locale = locale,\n            platform = platform,\n            appVersion = appVersion,\n            stableId = checkNotNull(stableId) { \"stableId is required\" },\n            organizationId = checkNotNull(organizationId) { \"organizationId is required\" },\n            subscriptionTier = subscriptionTier,\n            userRole = userRole\n        )\n}\n\n// Usage\nval context = EnterpriseContextBuilder()\n    .locale(AppLocale.EN_US)\n    .platform(Platform.WEB)\n    .version(Version.parse(\"2.0.0\"))\n    .stableId(\"abc123def456abc123def456abc123de\")\n    .organization(\"org-123\")\n    .tier(SubscriptionTier.ENTERPRISE)\n    .role(UserRole.ADMIN)\n    .build()\n</code></pre>"},{"location":"Context/#default-test-contexts","title":"Default Test Contexts","text":"<p>Create reusable test contexts to reduce boilerplate:</p> <pre><code>object TestContexts {\n    val default = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n    )\n\n    val mobile = default.copy(platform = Platform.IOS)\n    val android = default.copy(platform = Platform.ANDROID)\n    val web = default.copy(platform = Platform.WEB)\n\n    fun withVersion(version: String) = default.copy(\n        appVersion = Version.parse(version)\n    )\n\n    fun withStableId(id: String) = default.copy(\n        stableId = StableId.of(id)\n    )\n}\n\n// Usage in tests\n@Test\nfun `test iOS behavior`() {\n    val result = TestContexts.mobile.evaluate(Features.MOBILE_FEATURE)\n    assertTrue(result)\n}\n</code></pre>"},{"location":"Context/#context-middleware","title":"Context Middleware","text":"<p>Extract context from HTTP requests consistently:</p> <pre><code>class FeatureFlagMiddleware : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val request = chain.request()\n        val context = extractContext(request)\n\n        // Store in thread-local or request scope\n        ContextHolder.set(context)\n\n        return chain.proceed(request)\n    }\n\n    private fun extractContext(request: Request): AppContext =\n        AppContext(\n            locale = parseLocale(request.header(\"Accept-Language\")),\n            platform = parsePlatform(request.header(\"User-Agent\")),\n            appVersion = parseVersion(request.header(\"X-App-Version\") ?: \"1.0.0\"),\n            stableId = StableId.of(\n                request.cookie(\"user_id\") ?: generateAnonymousId()\n            )\n        )\n}\n</code></pre>"},{"location":"Context/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"Context/#using-non-stable-ids","title":"Using Non-Stable IDs","text":"<pre><code>// Bad: Timestamp changes every request\nval stableId = StableId.of(System.currentTimeMillis().toString(16))\n\n// Bad: Random value is not stable\nval stableId = StableId.of(UUID.randomUUID().toString().replace(\"-\", \"\"))\n\n// Good: Persistent user ID\nval stableId = StableId.of(userId.md5())\n\n// Good: Persistent device ID\nval stableId = StableId.of(deviceId)\n</code></pre>"},{"location":"Context/#mutable-context","title":"Mutable Context","text":"<pre><code>// Bad: Mutable properties break thread safety\nvar currentContext = Context(...)\ncurrentContext = newContext  // Race condition!\n\n// Good: Immutable with new instances\nval context1 = Context(...)\nval context2 = context1.copy(platform = Platform.ANDROID)\n</code></pre>"},{"location":"Context/#missing-hex-validation","title":"Missing Hex Validation","text":"<pre><code>// Bad: Not hex - throws exception at runtime\nStableId.of(\"not-a-hex-string\")\n\n// Good: Validate before creating StableId\nfun createStableId(id: String): StableId =\n    StableId.of(id.md5())  // Convert to hex first\n</code></pre>"},{"location":"Context/#forgetting-context-requirements","title":"Forgetting Context Requirements","text":"<pre><code>// Bad: Can't evaluate enterprise feature with base context\nval baseContext: Context = Context(...)\n// baseContext.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)  // Compile error!\n\n// Good: Use correct context type\nval enterpriseContext: EnterpriseContext = EnterpriseContext(...)\nenterpriseContext.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)  // OK\n</code></pre>"},{"location":"Context/#examples","title":"Examples","text":""},{"location":"Context/#basic-context-creation","title":"Basic Context Creation","text":"<pre><code>import io.amichne.konditional.context.*\n\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4\")\n)\n\nval result = context.evaluate(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"Context/#custom-enterprise-context","title":"Custom Enterprise Context","text":"<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val userRole: UserRole\n) : Context\n\nenum class SubscriptionTier { BASIC, PREMIUM, ENTERPRISE }\nenum class UserRole { EDITOR, ADMIN, OWNER }\n\nval context = EnterpriseContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.WEB,\n    appVersion = Version.parse(\"2.0.0\"),\n    stableId = StableId.of(\"abc123def456abc123def456abc123de\"),\n    organizationId = \"org-456\",\n    subscriptionTier = SubscriptionTier.ENTERPRISE,\n    userRole = UserRole.ADMIN\n)\n\nval hasAnalytics = context.evaluate(EnterpriseFeatures.advanced_analytics)\n</code></pre>"},{"location":"Context/#multi-platform-context-factory","title":"Multi-Platform Context Factory","text":"<pre><code>object PlatformContext {\n    fun forIOS(userId: String, version: String) = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version.parse(version),\n        stableId = StableId.of(userId)\n    )\n\n    fun forAndroid(userId: String, version: String) = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.ANDROID,\n        appVersion = Version.parse(version),\n        stableId = StableId.of(userId)\n    )\n\n    fun forWeb(sessionId: String, version: String = \"1.0.0\") = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version.parse(version),\n        stableId = StableId.of(sessionId)\n    )\n}\n\n// Usage\nval iosContext = PlatformContext.forIOS(\"user-123\", \"2.1.0\")\nval webContext = PlatformContext.forWeb(\"session-abc\")\n</code></pre>"},{"location":"Context/#testing-with-contexts","title":"Testing with Contexts","text":"<pre><code>class FeatureFlagTest {\n    private fun ctx(\n        locale: AppLocale = AppLocale.EN_US,\n        platform: Platform = Platform.IOS,\n        version: String = \"1.0.0\",\n        idHex: String = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n    ) = Context(locale, platform, Version.parse(version), StableId.of(idHex))\n\n    @Test\n    fun `Given iOS context, When evaluating mobile feature, Then returns true`() {\n        val context = ctx(platform = Platform.IOS)\n        val result = context.evaluate(Features.MOBILE_FEATURE)\n        assertTrue(result)\n    }\n\n    @Test\n    fun `Given version 2_0_0, When evaluating new feature, Then returns true`() {\n        val context = ctx(version = \"2.0.0\")\n        val result = context.evaluate(Features.NEW_FEATURE)\n        assertTrue(result)\n    }\n}\n</code></pre>"},{"location":"Context/#next-steps","title":"Next Steps","text":"<ul> <li>Rules: Learn how rules use context for targeting</li> <li>Evaluation: Understand how context flows through evaluation</li> <li>Quick Start: Get started with your first feature flag</li> <li>Overview: Complete API overview</li> </ul> <p>Related Topics: - Platform Targeting: See Rules - Version Ranges: See Rules - Rollout Bucketing: See Evaluation - Custom Evaluables: See Rules</p>"},{"location":"Evaluation/","title":"Evaluation: Flag Evaluation Mechanics","text":"<p>This document explains how Konditional evaluates feature flags, from context creation through rule matching to value resolution. Understanding the evaluation flow helps you write effective targeting rules and debug unexpected behavior.</p>"},{"location":"Evaluation/#overview","title":"Overview","text":"<p>Feature flag evaluation is the process of determining which value to return for a given context. Konditional's evaluation engine:</p> <ul> <li>Deterministic: Same context always produces same value</li> <li>Type-safe: Returns exactly the declared type, never null</li> <li>Lock-free: Multiple threads can evaluate concurrently without contention</li> <li>Fast: O(n) complexity where n = number of rules (typically &lt; 10)</li> </ul> <p>The evaluation process follows a precise flow: context validation \u2192 registry lookup \u2192 flag activity check \u2192 rule matching \u2192 rollout bucketing \u2192 value resolution.</p>"},{"location":"Evaluation/#evaluation-methods","title":"Evaluation Methods","text":"<p>Konditional provides four evaluation methods, each with different error handling semantics. Choose based on your application's needs.</p>"},{"location":"Evaluation/#evaluatesafe-explicit-error-handling","title":"evaluateSafe() - Explicit Error Handling","text":"<p>Recommended for most use cases. Returns a typed result that distinguishes between success, flag not found, and evaluation errors:</p> <pre><code>val result: EvaluationResult&lt;Boolean&gt; = context.evaluateSafe(AppFeatures.DARK_MODE)\n\nwhen (result) {\n    is EvaluationResult.Success -&gt; {\n        val value: Boolean = result.value\n        applyDarkMode(value)\n    }\n    is EvaluationResult.FlagNotFound -&gt; {\n        logWarning(\"Flag not registered: ${result.key}\")\n        applyDarkMode(false)  // Fallback\n    }\n    is EvaluationResult.EvaluationError -&gt; {\n        logError(\"Evaluation failed for ${result.key}\", result.error)\n        applyDarkMode(false)  // Fallback\n    }\n}\n</code></pre> <p>Benefits: - Explicit error handling without exceptions - Distinguish between \"flag not found\" and \"evaluation error\" - Type-safe pattern matching - Easy to adapt to custom error types via <code>fold()</code></p> <p>Use when: - You need to handle different error cases differently - You're building production systems with robust error handling - You want explicit control over failure behavior</p>"},{"location":"Evaluation/#evaluateornull-nullable-fallback","title":"evaluateOrNull() - Nullable Fallback","text":"<p>Returns the value on success, null on any failure:</p> <pre><code>val darkMode: Boolean? = context.evaluateOrNull(AppFeatures.DARK_MODE)\n\nif (darkMode != null) {\n    applyDarkMode(darkMode)\n} else {\n    // Flag not found or evaluation failed\n    applyDarkMode(false)\n}\n\n// Or use safe call operator\ncontext.evaluateOrNull(AppFeatures.DARK_MODE)?.let { applyDarkMode(it) }\n</code></pre> <p>Use when: - You don't need to distinguish between error types - Null is an acceptable fallback - You're working in nullable-friendly contexts</p>"},{"location":"Evaluation/#evaluateordefault-default-value-fallback","title":"evaluateOrDefault() - Default Value Fallback","text":"<p>Returns the value on success, a provided default on any failure:</p> <pre><code>val darkMode: Boolean = context.evaluateOrDefault(\n    key = AppFeatures.DARK_MODE,\n    default = false\n)\n\napplyDarkMode(darkMode)  // Always non-null\n</code></pre> <p>Benefits: - Simplest API - no error handling needed - Non-null return guaranteed - Explicit default value documents expected fallback</p> <p>Use when: - You have a sensible default value - You don't need error details - You want the most concise API</p>"},{"location":"Evaluation/#evaluateorthrow-exception-based","title":"evaluateOrThrow() - Exception-Based","text":"<p>Returns the value on success, throws exception on failure:</p> <pre><code>try {\n    val darkMode: Boolean = context.evaluateOrThrow(AppFeatures.DARK_MODE)\n    applyDarkMode(darkMode)\n} catch (e: FlagNotFoundException) {\n    logError(\"Flag not registered\", e)\n} catch (e: FlagEvaluationException) {\n    logError(\"Evaluation failed\", e)\n}\n</code></pre> <p>Throws: - <code>FlagNotFoundException</code> - Flag not registered - <code>FlagEvaluationException</code> - Evaluation error (wraps underlying exception)</p> <p>Use sparingly! Prefer <code>evaluateSafe()</code> for explicit error handling.</p> <p>Use when: - Flag not existing is a programmer error (should never happen in production) - You're in an exception-based codebase - You want fail-fast behavior during development</p>"},{"location":"Evaluation/#evaluation-flow","title":"Evaluation Flow","text":"<p>The evaluation process follows a deterministic sequence of steps:</p> <pre><code>flowchart TD\n    Start[Context Created] --&gt; Lookup[Registry Lookup]\n    Lookup --&gt; Found{Flag Found?}\n    Found --&gt;|No| NotFound[Return EvaluationResult.FlagNotFound]\n    Found --&gt;|Yes| Active{Flag Active?}\n    Active --&gt;|No| Default1[Return Default Value]\n    Active --&gt;|Yes| Rules[Get Rules&lt;br/&gt;Sorted by Specificity]\n\n    Rules --&gt; NextRule{Next Rule}\n    NextRule --&gt;|No more rules| Default2[Return Default Value]\n    NextRule --&gt;|Has rule| MatchBase{Base Criteria&lt;br/&gt;Match?}\n\n    MatchBase --&gt;|No| NextRule\n    MatchBase --&gt;|Yes| MatchExt{Extension&lt;br/&gt;Matches?}\n\n    MatchExt --&gt;|No| NextRule\n    MatchExt --&gt;|Yes| Rollout{In Rollout&lt;br/&gt;Bucket?}\n\n    Rollout --&gt;|No| NextRule\n    Rollout --&gt;|Yes| ReturnValue[Return Rule Value]\n\n    style Start fill:#e1f5ff\n    style ReturnValue fill:#d4edda\n    style Default1 fill:#fff3cd\n    style Default2 fill:#fff3cd\n    style NotFound fill:#f8d7da</code></pre>"},{"location":"Evaluation/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<p>1. Registry Lookup</p> <pre><code>val flag = key.module.featureFlag(key)\nif (flag == null) {\n    return EvaluationResult.FlagNotFound(key.key)\n}\n</code></pre> <p>The flag must be registered in the correct taxonomy's registry. Cross-taxonomy lookups will not find the flag.</p> <p>2. Flag Activity Check</p> <pre><code>if (!flag.isActive) {\n    return defaultValue\n}\n</code></pre> <p>Inactive flags always return the default value, regardless of rules. This provides a kill switch for flags.</p> <p>3. Rule Iteration (by Specificity)</p> <p>Rules are pre-sorted by specificity (highest first). Evaluation iterates in specificity order:</p> <pre><code>for (conditionalValue in rulesSortedBySpecificity) {\n    if (ruleMatches(conditionalValue.rule, context)) {\n        return conditionalValue.value  // First match wins\n    }\n}\n</code></pre> <p>4. Base Criteria Matching</p> <p>All base criteria must match (AND logic):</p> <pre><code>// Platform check (if specified)\nif (rule.platforms.isNotEmpty() &amp;&amp; context.platform !in rule.platforms) {\n    return false  // Skip this rule\n}\n\n// Locale check (if specified)\nif (rule.locales.isNotEmpty() &amp;&amp; context.locale !in rule.locales) {\n    return false  // Skip this rule\n}\n\n// Version check (if specified)\nif (!rule.versionRange.contains(context.appVersion)) {\n    return false  // Skip this rule\n}\n</code></pre> <p>Empty constraint sets match everything (e.g., no platforms specified = all platforms match).</p> <p>5. Extension Matching</p> <p>If the rule has custom extension logic, it must also match:</p> <pre><code>if (!rule.extension.matches(context)) {\n    return false  // Skip this rule\n}\n</code></pre> <p>6. Rollout Bucketing</p> <p>Finally, the context must fall into the rollout bucket:</p> <pre><code>if (!isInRolloutBucket(context.stableId, rollout)) {\n    return false  // Skip this rule\n}\n</code></pre> <p>7. Value Resolution</p> <p>If all checks pass, return the rule's value. Otherwise, continue to next rule or return default.</p>"},{"location":"Evaluation/#rule-matching-logic","title":"Rule Matching Logic","text":"<p>Rules use AND logic - all specified criteria must match for the rule to match.</p>"},{"location":"Evaluation/#base-matching","title":"Base Matching","text":"<p>Standard targeting criteria from <code>BaseEvaluable</code>:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)  // Must be iOS OR Android\n    locales(AppLocale.EN_US, AppLocale.EN_CA)  // AND English (US or Canada)\n    versions {\n        min(2, 0, 0)  // AND version &gt;= 2.0.0\n    }\n}.implies(true)\n</code></pre> <p>Constraint behavior: - Empty set: Matches all (e.g., no platforms = all platforms) - Non-empty set: Context value must be in set (OR within the set) - Multiple constraints: All constraints must match (AND across constraints)</p>"},{"location":"Evaluation/#extension-matching","title":"Extension Matching","text":"<p>Custom targeting logic via <code>Evaluable</code>:</p> <pre><code>rule {\n    platforms(Platform.WEB)  // Base: must be web\n    extension {              // AND extension must match\n        object : Evaluable&lt;EnterpriseContext&gt;() {\n            override fun matches(context: EnterpriseContext): Boolean =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                context.organizationId.startsWith(\"partner-\")\n\n            override fun specificity(): Int = 2  // Two constraints\n        }\n    }\n}.implies(premiumValue)\n</code></pre> <p>Both must match: Base criteria AND extension logic.</p>"},{"location":"Evaluation/#rollout-matching","title":"Rollout Matching","text":"<p>After all criteria match, rollout determines final eligibility:</p> <pre><code>rule {\n    platforms(Platform.IOS)  // Must match\n    locales(AppLocale.EN_US) // Must match\n    rollout = Rollout.of(25.0)  // AND must be in 25% bucket\n}.implies(true)\n</code></pre> <p>Rollout is evaluated last (after all other criteria) to avoid unnecessary bucketing computation.</p>"},{"location":"Evaluation/#specificity-ordering","title":"Specificity Ordering","text":"<p>Rules are automatically sorted by specificity (most specific first). When multiple rules match, the highest-specificity rule wins.</p>"},{"location":"Evaluation/#specificity-calculation","title":"Specificity Calculation","text":"<pre><code>specificity = baseSpecificity + extensionSpecificity\n</code></pre> <p>Base specificity (0-3): - Platform constraint: +1 - Locale constraint: +1 - Version constraint: +1</p> <p>Extension specificity: Value returned by <code>extension.specificity()</code></p>"},{"location":"Evaluation/#specificity-examples","title":"Specificity Examples","text":"<pre><code>// Specificity = 0 (no constraints)\nrule {\n    rollout = Rollout.MAX\n}.implies(defaultValue)\n\n// Specificity = 1 (platform only)\nrule {\n    platforms(Platform.IOS)\n}.implies(iosValue)\n\n// Specificity = 2 (platform + locale)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n}.implies(iosEnglishValue)\n\n// Specificity = 3 (platform + locale + version)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n}.implies(iosEnglishV2Value)\n\n// Specificity = 4 (platform + locale + version + extension)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n    extension {\n        object : Evaluable&lt;Context&gt;() {\n            override fun matches(context: Context) = true\n            override fun specificity() = 1  // +1 to total\n        }\n    }\n}.implies(verySpecificValue)\n</code></pre>"},{"location":"Evaluation/#evaluation-order-visualization","title":"Evaluation Order Visualization","text":"<pre><code>flowchart TD\n    Context[Context: iOS, EN_US, v2.1.0] --&gt; Eval[Evaluation]\n\n    Eval --&gt; Rule1[\"Rule 1: Specificity = 3&lt;br/&gt;platforms(IOS)&lt;br/&gt;locales(EN_US)&lt;br/&gt;versions &gt;= 2.0.0&lt;br/&gt;\u2192 'specific'\"]\n\n    Rule1 --&gt;|Matches| Return1[Return 'specific']\n\n    Rule1 --&gt;|Doesn't Match| Rule2[\"Rule 2: Specificity = 2&lt;br/&gt;platforms(IOS)&lt;br/&gt;locales(EN_US)&lt;br/&gt;\u2192 'medium'\"]\n\n    Rule2 --&gt;|Matches| Return2[Return 'medium']\n\n    Rule2 --&gt;|Doesn't Match| Rule3[\"Rule 3: Specificity = 1&lt;br/&gt;platforms(IOS)&lt;br/&gt;\u2192 'broad'\"]\n\n    Rule3 --&gt;|Matches| Return3[Return 'broad']\n\n    Rule3 --&gt;|Doesn't Match| Default[Return Default]\n\n    style Rule1 fill:#d4edda\n    style Return1 fill:#d4edda</code></pre> <p>Key insight: More specific rules are tried first, ensuring precise targeting overrides general targeting.</p>"},{"location":"Evaluation/#rollout-bucketing-algorithm","title":"Rollout Bucketing Algorithm","text":"<p>Rollout bucketing determines which percentage of users see a feature. Konditional uses SHA-256-based hashing for deterministic, stable bucketing.</p>"},{"location":"Evaluation/#algorithm","title":"Algorithm","text":"<pre><code>fun bucket(flagKey: String, stableId: StableId, salt: String): Int {\n    // 1. Create hash input\n    val input = \"$salt:$flagKey:${stableId.id}\"\n\n    // 2. SHA-256 hash\n    val hash: ByteArray = SHA256(input.toBytes())\n\n    // 3. Take first 4 bytes as 32-bit integer\n    val intValue: Int = (\n        (hash[0] &amp; 0xFF) &lt;&lt; 24 |\n        (hash[1] &amp; 0xFF) &lt;&lt; 16 |\n        (hash[2] &amp; 0xFF) &lt;&lt; 8  |\n        (hash[3] &amp; 0xFF)\n    )\n\n    // 4. Modulo 10,000 for 0.01% granularity\n    return intValue % 10_000  // 0-9999\n}\n\nfun isInRollout(bucket: Int, rollout: Rollout): Boolean {\n    val threshold = (rollout.value * 100).roundToInt()  // 25.0 \u2192 2500\n    return bucket &lt; threshold\n}\n</code></pre>"},{"location":"Evaluation/#bucketing-properties","title":"Bucketing Properties","text":"<p>Deterministic</p> <p>Same inputs always produce same bucket:</p> <pre><code>val user1 = StableId.of(\"abc123\")\nbucket(\"dark_mode\", user1, \"v1\")  // Always returns same value (e.g., 4234)\nbucket(\"dark_mode\", user1, \"v1\")  // 4234 again\nbucket(\"dark_mode\", user1, \"v1\")  // 4234 again\n</code></pre> <p>Independent per Flag</p> <p>Each flag has its own bucketing space:</p> <pre><code>val user = StableId.of(\"abc123\")\nbucket(\"dark_mode\", user, \"v1\")      // 4234 \u2192 In 50% rollout \u2713\nbucket(\"new_checkout\", user, \"v1\")   // 7821 \u2192 NOT in 50% rollout \u2717\n</code></pre> <p>Same user can be in different buckets for different flags.</p> <p>Salt-Dependent</p> <p>Changing salt redistributes users:</p> <pre><code>val user = StableId.of(\"abc123\")\nbucket(\"dark_mode\", user, \"v1\")  // 4234 \u2192 In 50% rollout \u2713\nbucket(\"dark_mode\", user, \"v2\")  // 1256 \u2192 Still in 50% rollout \u2713\nbucket(\"dark_mode\", user, \"v2\")  // 1256 (deterministic with new salt)\n</code></pre> <p>Use salt changes to: - Reset A/B tests - Fix biased distributions - Run new experiments on the same flag</p> <p>Platform-Stable</p> <p>SHA-256 produces identical results across platforms: - JVM (Java 17+) - Android - Kotlin/Native (iOS, Desktop) - Kotlin/JS (Web)</p> <p>Same user gets same experience everywhere.</p>"},{"location":"Evaluation/#granularity","title":"Granularity","text":"<p>Bucketing uses 0-9999 range (10,000 buckets), providing 0.01% granularity:</p> <pre><code>Rollout.of(0.01)   // 1 in 10,000 users\nRollout.of(0.5)    // 50 in 10,000 users\nRollout.of(1.0)    // 100 in 10,000 users (1%)\nRollout.of(25.0)   // 2,500 in 10,000 users (25%)\nRollout.of(50.0)   // 5,000 in 10,000 users (50%)\nRollout.of(100.0)  // All users (no bucketing check)\n</code></pre>"},{"location":"Evaluation/#edge-cases","title":"Edge Cases","text":"<p>0% Rollout</p> <pre><code>Rollout.of(0.0)  // No users match (short-circuits bucketing)\n</code></pre> <p>Evaluation skips bucketing computation and returns false immediately.</p> <p>100% Rollout</p> <pre><code>Rollout.MAX  // All users match (short-circuits bucketing)\n</code></pre> <p>Evaluation skips bucketing computation and returns true immediately.</p>"},{"location":"Evaluation/#type-safety-guarantees","title":"Type Safety Guarantees","text":"<p>Konditional's type system ensures correct types at every stage of evaluation.</p>"},{"location":"Evaluation/#compile-time-type-safety","title":"Compile-Time Type Safety","text":"<p>Value type enforcement:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false)\n}\n\n// Compiler infers return type\nval darkMode: Boolean = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n//            \u2191 Type guaranteed by AppFeatures.DARK_MODE's type parameter\n\n// Compile error: type mismatch\nval darkMode: String = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n//            \u2717 Type error: Required Boolean, found String\n</code></pre> <p>Context type enforcement:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier\n) : Context\n\nobject PremiumFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    // This feature requires EnterpriseContext\n    val DATA_EXPORT by boolean(default = false)\n}\n\nval basicContext: Context = Context(...)\n// Type error: EnterpriseContext required\nbasicContext.evaluateOrDefault(PremiumFeatures.DATA_EXPORT, false)  // \u2717\n\nval enterpriseContext: EnterpriseContext = EnterpriseContext(...)\nenterpriseContext.evaluateOrDefault(PremiumFeatures.DATA_EXPORT, false)  // \u2713\n</code></pre>"},{"location":"Evaluation/#runtime-type-safety","title":"Runtime Type Safety","text":"<p>Non-null guarantees:</p> <pre><code>// evaluateOrDefault() always returns T, never null\nval value: Boolean = context.evaluateOrDefault(AppFeatures.DARK_MODE, false)  // Never null\n\n// evaluateSafe() wraps value in Success, never null\nwhen (val result = context.evaluateSafe(AppFeatures.DARK_MODE)) {\n    is EvaluationResult.Success -&gt; {\n        val value: Boolean = result.value  // Never null\n    }\n    // ...\n}\n</code></pre> <p>No type coercion:</p> <p>Traditional systems allow runtime type errors:</p> <pre><code>// String-based system\nconfig.set(\"retries\", \"not a number\")  // \u2713 Compiles\nval retries: Int = config.getInt(\"retries\")  // \ud83d\udca3 Runtime error or default\n</code></pre> <p>Konditional makes this impossible:</p> <pre><code>object AppConfig : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val RETRIES by int(default = 3)\n}\n\n// \u2717 Compile error: Required Int, found String\nval RETRIES by int(default = \"not a number\")\n</code></pre>"},{"location":"Evaluation/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"Evaluation/#time-complexity","title":"Time Complexity","text":"<p>Evaluation: O(n) where n = number of rules per flag</p> <pre><code>// Worst case: iterate all rules\nfor (rule in rulesSortedBySpecificity) {  // O(n)\n    if (matches(rule)) {  // O(1) per rule\n        return rule.value\n    }\n}\n</code></pre> <p>Typical flags have 1-5 rules, so evaluation is effectively O(1) in practice.</p> <p>Registry lookup: O(1) hash table lookup</p> <p>Rollout bucketing: O(1) SHA-256 hash + modulo</p> <p>Total: O(n) where n is typically &lt; 10</p>"},{"location":"Evaluation/#space-complexity","title":"Space Complexity","text":"<p>Zero allocations during evaluation</p> <p>All data structures are pre-allocated and immutable: - Rules sorted once at configuration time - No intermediate objects created - No string concatenation (except for bucketing hash input)</p> <p>Memory footprint per flag: ~200-500 bytes</p> <ul> <li>FlagDefinition overhead: ~100 bytes</li> <li>Per-rule overhead: ~50-100 bytes</li> <li>Strings (key, notes): variable</li> </ul>"},{"location":"Evaluation/#concurrency-performance","title":"Concurrency Performance","text":"<p>Lock-free reads: No synchronization required</p> <pre><code>// Multiple threads evaluating concurrently\nthread1: context.evaluateOrDefault(AppFeatures.DARK_MODE, false)  // No lock\nthread2: context.evaluateOrDefault(AppFeatures.DARK_MODE, false)  // No lock\nthread3: context.evaluateOrDefault(AppFeatures.DARK_MODE, false)  // No lock\n</code></pre> <p>Atomic updates: Registry updates use <code>AtomicReference</code></p> <pre><code>// Update sees either old or new configuration atomically\nTaxonomy.Global.load(newKonfig)  // Atomic swap\n</code></pre> <p>Scalability: Evaluation throughput scales linearly with CPU cores (no contention).</p>"},{"location":"Evaluation/#thread-safety","title":"Thread Safety","text":"<p>Konditional is designed for concurrent access without locks.</p>"},{"location":"Evaluation/#lock-free-reads","title":"Lock-Free Reads","text":"<p>Flag evaluation requires no synchronization:</p> <pre><code>// Safe concurrent evaluation\nval threads = (1..100).map { threadId -&gt;\n    thread {\n        repeat(1000) {\n            val value = context.evaluateOrDefault(AppFeatures.DARK_MODE, false)\n            processValue(value)\n        }\n    }\n}\nthreads.forEach { it.join() }\n</code></pre> <p>How it works: - Immutable data structures (<code>FlagDefinition</code>, <code>Konfig</code>) - AtomicReference for registry snapshot - Readers see consistent snapshot (old or new, never partial)</p>"},{"location":"Evaluation/#atomic-updates","title":"Atomic Updates","text":"<p>Registry updates are atomic:</p> <pre><code>// Thread 1: Updating configuration\nTaxonomy.Global.load(newKonfig)  // Atomic swap\n\n// Thread 2: Reading during update\nval value = context.evaluateOrDefault(AppFeatures.DARK_MODE, false)  // Sees old OR new, never mixed\n</code></pre> <p>Guarantees: - Updates are atomic (all-or-nothing) - Readers never see partial updates - No torn reads</p>"},{"location":"Evaluation/#independent-evaluations","title":"Independent Evaluations","text":"<p>Each evaluation is stateless:</p> <pre><code>// No shared mutable state\nfun evaluateOrDefault(key: Feature, default: T): T {\n    // Only reads from immutable data structures\n    // No writes, no locks, no shared state\n    return flag.evaluate(context) ?: default\n}\n</code></pre> <p>Benefits: - No race conditions - No deadlocks - Predictable performance</p>"},{"location":"Evaluation/#testing-evaluation","title":"Testing Evaluation","text":""},{"location":"Evaluation/#unit-testing-rules","title":"Unit Testing Rules","text":"<p>Test that rules evaluate correctly for different contexts:</p> <pre><code>@Test\nfun `iOS users in EN_US locale get dark mode`() {\n    // Arrange\n    val context = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version.parse(\"2.1.0\"),\n        stableId = StableId.of(\"test-user\")\n    )\n\n    // Act\n    val result = context.evaluateSafe(AppFeatures.DARK_MODE)\n\n    // Assert\n    assertTrue(result is EvaluationResult.Success &amp;&amp; result.value == true)\n}\n\n@Test\nfun `Android users get default value`() {\n    val context = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.ANDROID,\n        appVersion = Version.parse(\"2.1.0\"),\n        stableId = StableId.of(\"test-user\")\n    )\n\n    val result = context.evaluateSafe(AppFeatures.DARK_MODE)\n\n    assertTrue(result is EvaluationResult.Success &amp;&amp; result.value == false)\n}\n</code></pre>"},{"location":"Evaluation/#testing-rollouts","title":"Testing Rollouts","text":"<p>Test rollout distribution over many users:</p> <pre><code>@Test\nfun `50 percent rollout distributes correctly`() {\n    // Test over many users\n    val sampleSize = 10_000\n    val enabledCount = (0 until sampleSize).count { i -&gt;\n        val context = Context(\n            locale = AppLocale.EN_US,\n            platform = Platform.IOS,\n            appVersion = Version.parse(\"1.0.0\"),\n            stableId = StableId.of(\"user-$i\")\n        )\n        context.evaluateOrDefault(AppFeatures.ROLLOUT_FLAG, default = false)\n    }\n\n    // Assert approximately 50% (allow 2% variance)\n    val percentage = (enabledCount.toDouble() / sampleSize) * 100\n    assertTrue(percentage in 48.0..52.0, \"Got $percentage%, expected ~50%\")\n}\n</code></pre>"},{"location":"Evaluation/#testing-determinism","title":"Testing Determinism","text":"<p>Verify same context always returns same value:</p> <pre><code>@Test\nfun `evaluation is deterministic`() {\n    val context = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version.parse(\"2.1.0\"),\n        stableId = StableId.of(\"user-123\")\n    )\n\n    // Evaluate many times\n    val results = (1..100).map {\n        context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n    }\n\n    // All results must be identical\n    assertTrue(results.distinct().size == 1, \"Non-deterministic evaluation\")\n}\n</code></pre>"},{"location":"Evaluation/#testing-specificity-order","title":"Testing Specificity Order","text":"<p>Verify higher specificity rules take precedence:</p> <pre><code>@Test\nfun `more specific rules override general rules`() {\n    object TestFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n        val VALUE by string(default = \"default\") {\n            // Specificity = 1 (general)\n            rule {\n                platforms(Platform.IOS)\n            } implies \"ios-general\"\n\n            // Specificity = 2 (specific)\n            rule {\n                platforms(Platform.IOS)\n                locales(AppLocale.EN_US)\n            } implies \"ios-english-specific\"\n        }\n    }\n\n    // Context matches both rules\n    val context = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.IOS,\n        appVersion = Version.parse(\"1.0.0\"),\n        stableId = StableId.of(\"user-123\")\n    )\n\n    // Higher specificity wins\n    val result = context.evaluateOrDefault(TestFeatures.VALUE, default = \"\")\n    assertEquals(\"ios-english-specific\", result)\n}\n</code></pre>"},{"location":"Evaluation/#best-practices","title":"Best Practices","text":""},{"location":"Evaluation/#choose-the-right-evaluation-method","title":"Choose the Right Evaluation Method","text":"<p>For production code: <pre><code>// Use evaluateSafe for explicit error handling\nwhen (val result = context.evaluateSafe(AppFeatures.DARK_MODE)) {\n    is EvaluationResult.Success -&gt; process(result.value)\n    is EvaluationResult.FlagNotFound -&gt; logWarning(\"Flag not found\")\n    is EvaluationResult.EvaluationError -&gt; logError(\"Evaluation failed\", result.error)\n}\n</code></pre></p> <p>For simple cases: <pre><code>// Use evaluateOrDefault for concise code with sensible defaults\nval enabled = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n</code></pre></p> <p>Avoid evaluateOrThrow unless flag not existing is a programmer error.</p>"},{"location":"Evaluation/#keep-rule-count-low","title":"Keep Rule Count Low","text":"<p>Each flag iterates rules until match. Keep rules minimal:</p> <pre><code>// \u2713 Good: 2-3 rules\nval FEATURE by boolean(default = false) {\n    rule { platforms(Platform.IOS) } implies true\n    rule { versions { min(2, 0, 0) } } implies true\n}\n\n// \u2717 Avoid: Too many rules\nval FEATURE by boolean(default = false) {\n    // 20+ rules = slower evaluation\n}\n</code></pre> <p>If you have many rules, consider redesigning with custom context fields and extension logic.</p>"},{"location":"Evaluation/#use-specificity-to-your-advantage","title":"Use Specificity to Your Advantage","text":"<p>Write rules from most to least specific. While Konditional sorts automatically, this mental model makes configurations clearer:</p> <pre><code>val VALUE by string(default = \"default\") {\n    // Most specific (evaluated first)\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.EN_US)\n        versions { min(2, 0, 0) }\n    } implies \"ios-en-v2\"\n\n    // Less specific (evaluated second)\n    rule {\n        platforms(Platform.IOS)\n    } implies \"ios-all\"\n}\n</code></pre>"},{"location":"Evaluation/#cache-contexts-when-possible","title":"Cache Contexts When Possible","text":"<p>Creating contexts is cheap, but reusing them is cheaper:</p> <pre><code>// \u2713 Good: Create once, reuse for multiple evaluations\nval context = createUserContext(user)\nval darkMode = context.evaluateOrDefault(AppFeatures.DARK_MODE, false)\nval apiEndpoint = context.evaluateOrDefault(AppConfig.API_ENDPOINT, \"default\")\nval maxRetries = context.evaluateOrDefault(AppConfig.MAX_RETRIES, 3)\n\n// \u2717 Avoid: Recreating context for each evaluation\ncreateUserContext(user).evaluateOrDefault(AppFeatures.DARK_MODE, false)\ncreateUserContext(user).evaluateOrDefault(AppConfig.API_ENDPOINT, \"default\")\ncreateUserContext(user).evaluateOrDefault(AppConfig.MAX_RETRIES, 3)\n</code></pre>"},{"location":"Evaluation/#test-rollout-distributions","title":"Test Rollout Distributions","text":"<p>When using rollouts, verify distribution over sample population:</p> <pre><code>@Test\nfun `rollout distribution is balanced`() {\n    val sampleSize = 5000\n    val enabledCount = (0 until sampleSize).count { i -&gt;\n        val ctx = Context(\n            locale = AppLocale.EN_US,\n            platform = Platform.IOS,\n            appVersion = Version.parse(\"1.0.0\"),\n            stableId = StableId.of(\"user-$i\")\n        )\n        ctx.evaluateOrDefault(AppFeatures.ROLLOUT_FLAG, false)\n    }\n\n    val percentage = (enabledCount.toDouble() / sampleSize) * 100\n    // Expected 25%, allow 2% variance\n    assertTrue(percentage in 23.0..27.0)\n}\n</code></pre>"},{"location":"Evaluation/#document-complex-rules","title":"Document Complex Rules","text":"<p>Use <code>note()</code> to explain non-obvious targeting:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout = Rollout.of(15.0)\n    note(\"Targeting high-value iOS users - approved by PM on 2024-01-15\")\n} implies true\n</code></pre> <p>Notes appear in serialized JSON and help with debugging.</p>"},{"location":"Evaluation/#examples","title":"Examples","text":""},{"location":"Evaluation/#example-1-simple-boolean-flag","title":"Example 1: Simple Boolean Flag","text":"<pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS, Platform.ANDROID)\n            rollout = Rollout.of(50.0)\n        } implies true\n    }\n}\n\n// Evaluation\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"user-abc123\")\n)\n\nval isDarkMode = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n\nif (isDarkMode) {\n    applyDarkTheme()\n} else {\n    applyLightTheme()\n}\n</code></pre>"},{"location":"Evaluation/#example-2-multi-rule-configuration","title":"Example 2: Multi-Rule Configuration","text":"<pre><code>object ApiConfig : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val ENDPOINT by string(default = \"https://api.prod.example.com\") {\n        // Specificity = 2: iOS + version\n        rule {\n            platforms(Platform.IOS)\n            versions { min(3, 0, 0) }\n        } implies \"https://api-v3-ios.example.com\"\n\n        // Specificity = 1: iOS only\n        rule {\n            platforms(Platform.IOS)\n        } implies \"https://api-ios.example.com\"\n\n        // Specificity = 1: Android only\n        rule {\n            platforms(Platform.ANDROID)\n        } implies \"https://api-android.example.com\"\n    }\n}\n\n// iOS v3.0.0 \u2192 \"https://api-v3-ios.example.com\" (highest specificity)\n// iOS v2.0.0 \u2192 \"https://api-ios.example.com\" (medium specificity)\n// Android \u2192 \"https://api-android.example.com\" (medium specificity)\n// Web \u2192 \"https://api.prod.example.com\" (default)\n</code></pre>"},{"location":"Evaluation/#example-3-gradual-rollout-strategy","title":"Example 3: Gradual Rollout Strategy","text":"<pre><code>object NewFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val NEW_CHECKOUT by boolean(default = false) {\n        salt(\"v1\")  // Change to redistribute users\n\n        rule {\n            platforms(Platform.ANDROID)\n            rollout = Rollout.of(10.0)  // Start with 10%\n            note(\"Phase 1: Initial Android rollout\")\n        } implies true\n    }\n}\n\n// Phase 1: 10% of Android users\n// Monitor metrics, then increase:\n\nobject NewFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val NEW_CHECKOUT by boolean(default = false) {\n        salt(\"v1\")\n\n        rule {\n            platforms(Platform.ANDROID)\n            rollout = Rollout.of(50.0)  // Increased to 50%\n            note(\"Phase 2: Expanded Android rollout\")\n        } implies true\n    }\n}\n\n// Phase 2: 50% of Android users\n// Users in initial 10% stay enabled (deterministic bucketing)\n</code></pre>"},{"location":"Evaluation/#example-4-custom-context-extension","title":"Example 4: Custom Context Extension","text":"<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val organizationId: String,\n) : Context\n\nenum class SubscriptionTier { FREE, PROFESSIONAL, ENTERPRISE }\n\nobject PremiumFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val DATA_EXPORT by boolean(default = false) {\n        rule {\n            platforms(Platform.WEB)\n            extension {\n                object : Evaluable&lt;EnterpriseContext&gt;() {\n                    override fun matches(context: EnterpriseContext): Boolean =\n                        context.subscriptionTier == SubscriptionTier.ENTERPRISE\n\n                    override fun specificity(): Int = 1\n                }\n            }\n        } implies true\n    }\n}\n\n// Evaluation\nval context = EnterpriseContext(\n    locale = AppLocale.EN_US,\n    platform = Platform.WEB,\n    appVersion = Version.parse(\"1.0.0\"),\n    stableId = StableId.of(\"user-123\"),\n    subscriptionTier = SubscriptionTier.ENTERPRISE,\n    organizationId = \"acme-corp\"\n)\n\nval canExport = context.evaluateOrDefault(PremiumFeatures.DATA_EXPORT, default = false)\n</code></pre>"},{"location":"Evaluation/#example-5-ab-testing","title":"Example 5: A/B Testing","text":"<pre><code>object Experiments : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val RECOMMENDATION_ALGORITHM by string(default = \"collaborative\") {\n        salt(\"experiment-2024-01\")  // Unique salt for this experiment\n\n        rule {\n            rollout = Rollout.of(50.0)  // 50/50 split\n            note(\"A/B test: collaborative vs content-based recommendations\")\n        } implies \"content-based\"\n    }\n}\n\n// 50% of users get \"collaborative\" (default)\n// 50% of users get \"content-based\" (rule)\n// Assignment is stable per user across sessions\n</code></pre>"},{"location":"Evaluation/#summary-evaluation-guarantees","title":"Summary: Evaluation Guarantees","text":"Aspect Guarantee Type safety Return type matches flag definition, enforced at compile time Determinism Same inputs always produce same output Specificity Most specific matching rule always wins Bucketing SHA-256 ensures independent, stable buckets per flag Performance O(n) where n = rules per flag (typically &lt; 10) Thread safety Lock-free reads, immutable data Null safety Never returns null, default value guaranteed <p>Core Principle: Evaluation is deterministic, type-safe, and performant.</p>"},{"location":"Evaluation/#next-steps","title":"Next Steps","text":"<ul> <li>Results - Deep dive into EvaluationResult and error handling patterns</li> <li>Rules - Master advanced targeting and custom evaluables</li> <li>Context - Design custom contexts for business logic</li> <li>Configuration - Complete DSL reference</li> <li>Registry - Taxonomy and concurrency management</li> <li>Overview - Back to API overview</li> </ul>"},{"location":"Features/","title":"Feature Definition","text":"<p>Features are the core building blocks of Konditional. They define the flags you want to evaluate, their value types, and which taxonomy they belong to. This document covers the two patterns for defining features, their type parameters, and best practices for organizing your feature flags.</p>"},{"location":"Features/#overview","title":"Overview","text":"<p>A Feature represents a configurable flag with a specific value type. Konditional provides two patterns for defining features:</p> <ol> <li>FeatureContainer Pattern (Recommended): Property delegation with automatic registration</li> <li>Enum Pattern (Alternative): Manual enum-based implementation</li> </ol> <p>Both patterns provide the same type safety guarantees and evaluation behavior. Choose based on your organizational needs.</p>"},{"location":"Features/#featurecontainer-pattern-recommended","title":"FeatureContainer Pattern (Recommended)","text":"<p>The <code>FeatureContainer</code> pattern uses Kotlin's property delegation to provide a clean, declarative syntax for defining features with minimal boilerplate.</p>"},{"location":"Features/#basic-usage","title":"Basic Usage","text":"<pre><code>object PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false)\n    val GOOGLE_PAY by boolean&lt;Context&gt;(default = false)\n    val MAX_CARDS by int&lt;Context&gt;(default = 5)\n    val API_ENDPOINT by string&lt;Context&gt;(default = \"https://api.example.com\")\n    val TRANSACTION_FEE by double&lt;Context&gt;(default = 0.029)\n}\n</code></pre>"},{"location":"Features/#delegation-methods","title":"Delegation Methods","text":"<p>FeatureContainer provides four delegation methods, one for each supported primitive type:</p>"},{"location":"Features/#booleandefault-flagscope","title":"<code>boolean(default, flagScope)</code>","text":"<p>Creates a Boolean feature flag.</p> <pre><code>val DARK_MODE by boolean&lt;Context&gt;(default = false) {\n    rule {\n        platforms(Platform.IOS, Platform.ANDROID)\n    } implies true\n}\n</code></pre> <p>Parameters: - <code>default: Boolean</code> - The default value for this feature (required) - <code>flagScope</code> - DSL block for configuring rules, rollouts, and targeting (optional)</p> <p>Returns: <code>BooleanFeature&lt;C, M&gt;</code></p>"},{"location":"Features/#stringdefault-stringscope","title":"<code>string(default, stringScope)</code>","text":"<p>Creates a String feature flag.</p> <pre><code>val API_ENDPOINT by string&lt;Context&gt;(default = \"https://api.prod.com\") {\n    rule {\n        platforms(Platform.WEB)\n    } implies \"https://api.staging.com\"\n}\n</code></pre> <p>Parameters: - <code>default: String</code> - The default value for this feature (required) - <code>stringScope</code> - DSL block for configuring rules, rollouts, and targeting (optional)</p> <p>Returns: <code>StringFeature&lt;C, M&gt;</code></p>"},{"location":"Features/#intdefault-integerscope","title":"<code>int(default, integerScope)</code>","text":"<p>Creates an Int feature flag.</p> <pre><code>val MAX_RETRIES by int&lt;Context&gt;(default = 3) {\n    rule {\n        platforms(Platform.ANDROID)\n        rollout = Rollout.of(50.0)\n    } implies 5\n}\n</code></pre> <p>Parameters: - <code>default: Int</code> - The default value for this feature (required) - <code>integerScope</code> - DSL block for configuring rules, rollouts, and targeting (optional)</p> <p>Returns: <code>IntFeature&lt;C, M&gt;</code></p>"},{"location":"Features/#doubledefault-decimalscope","title":"<code>double(default, decimalScope)</code>","text":"<p>Creates a Double feature flag.</p> <pre><code>val TRANSACTION_FEE by double&lt;Context&gt;(default = 0.029) {\n    rule {\n        platforms(Platform.WEB)\n    } implies 0.019\n}\n</code></pre> <p>Parameters: - <code>default: Double</code> - The default value for this feature (required) - <code>decimalScope</code> - DSL block for configuring rules, rollouts, and targeting (optional)</p> <p>Returns: <code>DoubleFeature&lt;C, M&gt;</code></p>"},{"location":"Features/#property-delegation-pattern","title":"Property Delegation Pattern","text":"<p>FeatureContainer uses Kotlin's property delegation (<code>by</code>) to automatically:</p> <ol> <li>Capture the property name as the feature key</li> <li>Create the feature on first access (lazy initialization)</li> <li>Register the feature in the container's feature list</li> <li>Apply configuration from the DSL block</li> </ol> <pre><code>object MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    // Property name \"NEW_CHECKOUT\" becomes the feature key\n    val NEW_CHECKOUT by boolean&lt;Context&gt;(default = false) {\n        // Configuration is automatically applied to Taxonomy.Global\n        rule {\n            platforms(Platform.WEB)\n        } implies true\n    }\n}\n\n// Feature key is \"NEW_CHECKOUT\" (derived from property name)\nprintln(MyFeatures.NEW_CHECKOUT.key) // \"NEW_CHECKOUT\"\n</code></pre> <p>Key behaviors: - Features are created lazily when first accessed - Configuration is applied atomically when the feature is created - Property name must be a valid Kotlin identifier (no spaces, special characters) - Use uppercase snake_case convention for consistency</p>"},{"location":"Features/#allfeatures-method","title":"<code>allFeatures()</code> Method","text":"<p>FeatureContainer provides complete enumeration of all features in the container:</p> <pre><code>val all: List&lt;Feature&lt;*, *, *, Taxonomy.Domain.Payments&gt;&gt; =\n    PaymentFeatures.allFeatures()\n\nall.forEach { feature -&gt;\n    println(\"Feature: ${feature.key}\")\n}\n// Output:\n// Feature: APPLE_PAY\n// Feature: GOOGLE_PAY\n// Feature: MAX_CARDS\n// Feature: API_ENDPOINT\n// Feature: TRANSACTION_FEE\n</code></pre> <p>Use cases: - Validation: Ensure all features are configured - Testing: Iterate over all features for comprehensive tests - Auditing: Generate inventory of all features - Documentation: Auto-generate feature lists</p> <p>Important notes: - Features are only added to the list when their property is accessed - The list contains features that have been accessed at least once - For guaranteed completeness, access all properties before calling <code>allFeatures()</code></p>"},{"location":"Features/#benefits-over-enum-pattern","title":"Benefits Over Enum Pattern","text":"Feature FeatureContainer Enum Pattern Mixed types Multiple types in one container Single type per enum Boilerplate Minimal (taxonomy declared once) High (module override per entry) Enumeration Automatic via <code>allFeatures()</code> Manual tracking required Configuration Inline with declaration Separate config block IDE support Full autocomplete and refactoring Full autocomplete and refactoring"},{"location":"Features/#example-mixed-type-container","title":"Example: Mixed Type Container","text":"<pre><code>object AppConfig : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    // Boolean toggles\n    val DARK_MODE by boolean&lt;Context&gt;(default = false)\n    val ANALYTICS_ENABLED by boolean&lt;Context&gt;(default = true)\n\n    // String configuration\n    val API_ENDPOINT by string&lt;Context&gt;(default = \"https://api.prod.com\")\n    val LOG_LEVEL by string&lt;Context&gt;(default = \"INFO\")\n\n    // Numeric configuration\n    val MAX_RETRIES by int&lt;Context&gt;(default = 3)\n    val TIMEOUT_SECONDS by int&lt;Context&gt;(default = 30)\n    val TRANSACTION_FEE by double&lt;Context&gt;(default = 0.029)\n}\n\n// All features in one place, different types\nval allConfig = AppConfig.allFeatures()\nprintln(\"Total config entries: ${allConfig.size}\") // 7\n</code></pre>"},{"location":"Features/#enum-pattern-alternative","title":"Enum Pattern (Alternative)","text":"<p>The enum pattern uses manual enum definitions implementing specific feature interfaces. This pattern is useful when:</p> <ul> <li>All features in a group have the same value type</li> <li>You want exhaustive when-expressions</li> <li>You need backwards compatibility with existing enum-based code</li> </ul>"},{"location":"Features/#feature-interfaces","title":"Feature Interfaces","text":"<p>Konditional provides four type-specific feature interfaces:</p>"},{"location":"Features/#booleanfeaturec-m","title":"<code>BooleanFeature&lt;C, M&gt;</code>","text":"<p>For Boolean feature flags (on/off toggles):</p> <pre><code>enum class FeatureToggles(override val key: String) :\n    BooleanFeature&lt;Context, Taxonomy.Global&gt; {\n\n    DARK_MODE(\"dark_mode\"),\n    NEW_UI(\"new_ui\"),\n    BETA_FEATURES(\"beta_features\");\n\n    override val module = Taxonomy.Global\n}\n</code></pre>"},{"location":"Features/#stringfeaturec-m","title":"<code>StringFeature&lt;C, M&gt;</code>","text":"<p>For String configuration values:</p> <pre><code>enum class StringConfig(override val key: String) :\n    StringFeature&lt;Context, Taxonomy.Global&gt; {\n\n    API_ENDPOINT(\"api_endpoint\"),\n    LOG_LEVEL(\"log_level\"),\n    THEME_NAME(\"theme_name\");\n\n    override val module = Taxonomy.Global\n}\n</code></pre>"},{"location":"Features/#intfeaturec-m","title":"<code>IntFeature&lt;C, M&gt;</code>","text":"<p>For Integer numeric values:</p> <pre><code>enum class NumericConfig(override val key: String) :\n    IntFeature&lt;Context, Taxonomy.Global&gt; {\n\n    MAX_RETRIES(\"max_retries\"),\n    TIMEOUT_SECONDS(\"timeout_seconds\"),\n    BATCH_SIZE(\"batch_size\");\n\n    override val module = Taxonomy.Global\n}\n</code></pre>"},{"location":"Features/#doublefeaturec-m","title":"<code>DoubleFeature&lt;C, M&gt;</code>","text":"<p>For Double precision numeric values:</p> <pre><code>enum class DecimalConfig(override val key: String) :\n    DoubleFeature&lt;Context, Taxonomy.Global&gt; {\n\n    TRANSACTION_FEE(\"transaction_fee\"),\n    DISCOUNT_RATE(\"discount_rate\"),\n    TAX_RATE(\"tax_rate\");\n\n    override val module = Taxonomy.Global\n}\n</code></pre>"},{"location":"Features/#enum-pattern-implementation","title":"Enum Pattern Implementation","text":"<p>Each enum must:</p> <ol> <li>Implement one of the four feature interfaces</li> <li>Override <code>key</code> with the feature identifier</li> <li>Override <code>module</code> with the taxonomy</li> </ol> <pre><code>enum class PaymentFeatures(override val key: String) :\n    BooleanFeature&lt;Context, Taxonomy.Domain.Payments&gt; {\n\n    APPLE_PAY(\"apple_pay\"),\n    GOOGLE_PAY(\"google_pay\"),\n    CARD_ON_FILE(\"card_on_file\");\n\n    override val module = Taxonomy.Domain.Payments\n}\n</code></pre>"},{"location":"Features/#configuration-separate","title":"Configuration (Separate)","text":"<p>With the enum pattern, configuration is done separately from declaration:</p> <pre><code>// Declaration (above)\nenum class PaymentFeatures(...) : BooleanFeature&lt;...&gt; { ... }\n\n// Configuration (separate)\nTaxonomy.Domain.Payments.config {\n    PaymentFeatures.APPLE_PAY with {\n        default(false)\n        rule {\n            platforms(Platform.IOS)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Features/#when-to-use-enum-pattern","title":"When to Use Enum Pattern","text":"<p>Choose enum pattern when: - All features have the same value type (all Boolean, all String, etc.) - You need exhaustive when-expressions over features - You're working with existing enum-based code - You prefer separation between declaration and configuration</p> <p>Choose FeatureContainer when: - You have mixed types (Boolean, String, Int in same group) - You want inline configuration with declaration - You need automatic enumeration via <code>allFeatures()</code> - You want minimal boilerplate</p>"},{"location":"Features/#type-parameters-explained","title":"Type Parameters Explained","text":"<p>All feature definitions use four generic type parameters:</p>"},{"location":"Features/#type-parameter-reference","title":"Type Parameter Reference","text":"<pre><code>Feature&lt;S : EncodableValue&lt;T&gt;, T : Any, C : Context, M : Taxonomy&gt;\n</code></pre> Parameter Meaning Examples Purpose S EncodableValue wrapper <code>BooleanEncodeable</code>, <code>StringEncodeable</code> Internal serialization type (automatically inferred) T Actual value type <code>Boolean</code>, <code>String</code>, <code>Int</code>, <code>Double</code> The type returned by <code>evaluate()</code> C Context type <code>Context</code>, <code>EnterpriseContext</code> Evaluation context required M Taxonomy (module) <code>Taxonomy.Global</code>, <code>Taxonomy.Domain.Payments</code> Namespace and registry isolation"},{"location":"Features/#understanding-s-encodablevalue","title":"Understanding S (EncodableValue)","text":"<p>The <code>S</code> parameter wraps the actual value type for serialization. You rarely interact with it directly:</p> <pre><code>// These are equivalent type declarations\nBooleanFeature&lt;Context, Taxonomy.Global&gt;\nFeature&lt;EncodableValue.BooleanEncodeable, Boolean, Context, Taxonomy.Global&gt;\n\nStringFeature&lt;Context, Taxonomy.Global&gt;\nFeature&lt;EncodableValue.StringEncodeable, String, Context, Taxonomy.Global&gt;\n\nIntFeature&lt;Context, Taxonomy.Global&gt;\nFeature&lt;EncodableValue.IntEncodeable, Int, Context, Taxonomy.Global&gt;\n\nDoubleFeature&lt;Context, Taxonomy.Global&gt;\nFeature&lt;EncodableValue.DecimalEncodeable, Double, Context, Taxonomy.Global&gt;\n</code></pre> <p>You typically use the simplified interfaces (<code>BooleanFeature</code>, <code>StringFeature</code>, etc.) instead of specifying <code>S</code> manually.</p>"},{"location":"Features/#understanding-t-value-type","title":"Understanding T (Value Type)","text":"<p>The <code>T</code> parameter determines what type <code>evaluate()</code> returns:</p> <pre><code>val DARK_MODE: BooleanFeature&lt;Context, Taxonomy.Global&gt; = // ...\nval enabled: Boolean = context.evaluate(DARK_MODE)\n//            ^^^^^^^ T = Boolean\n\nval API_URL: StringFeature&lt;Context, Taxonomy.Global&gt; = // ...\nval url: String = context.evaluate(API_URL)\n//       ^^^^^^ T = String\n\nval MAX_RETRIES: IntFeature&lt;Context, Taxonomy.Global&gt; = // ...\nval retries: Int = context.evaluate(MAX_RETRIES)\n//           ^^^ T = Int\n\nval FEE_RATE: DoubleFeature&lt;Context, Taxonomy.Global&gt; = // ...\nval fee: Double = context.evaluate(FEE_RATE)\n//       ^^^^^^ T = Double\n</code></pre> <p>Supported primitive types: - <code>Boolean</code> - true/false toggles - <code>String</code> - text configuration - <code>Int</code> - integer values - <code>Double</code> - decimal values</p>"},{"location":"Features/#understanding-c-context-type","title":"Understanding C (Context Type)","text":"<p>The <code>C</code> parameter specifies what context information is required for evaluation:</p> <pre><code>// Basic context (standard fields)\nval DARK_MODE by boolean&lt;Context&gt;(default = false)\ncontext.evaluate(DARK_MODE) // Requires Context\n\n// Custom context (additional fields)\nval ENTERPRISE_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false)\nenterpriseContext.evaluate(ENTERPRISE_ANALYTICS) // Requires EnterpriseContext\n\n// Type safety prevents misuse\nbasicContext.evaluate(ENTERPRISE_ANALYTICS) // \u274c Compile error!\n</code></pre> <p>See Custom Context with Features for details.</p>"},{"location":"Features/#understanding-m-taxonomy","title":"Understanding M (Taxonomy)","text":"<p>The <code>M</code> parameter binds features to their taxonomy, providing isolation:</p> <pre><code>object CoreFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val KILL_SWITCH by boolean&lt;Context&gt;(default = false)\n}\n// KILL_SWITCH.module == Taxonomy.Global\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false)\n}\n// APPLE_PAY.module == Taxonomy.Domain.Payments\n</code></pre> <p>Benefits of taxonomy isolation: - Different teams can use the same feature keys without collision - Each taxonomy has its own registry instance - Compile-time enforcement prevents cross-taxonomy access - Independent deployment and versioning</p>"},{"location":"Features/#custom-context-with-features","title":"Custom Context with Features","text":"<p>Features can require specific context types beyond the standard <code>Context</code> interface.</p>"},{"location":"Features/#defining-custom-context","title":"Defining Custom Context","text":"<pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    // Custom fields\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val seatCount: Int\n) : Context\n\nenum class SubscriptionTier {\n    STARTER, PROFESSIONAL, ENTERPRISE\n}\n</code></pre>"},{"location":"Features/#features-requiring-custom-context","title":"Features Requiring Custom Context","text":""},{"location":"Features/#featurecontainer-pattern","title":"FeatureContainer Pattern","text":"<pre><code>object EnterpriseFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    // Requires EnterpriseContext\n    val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            // Can access EnterpriseContext fields\n            custom { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n            }\n        } implies true\n    }\n\n    val BULK_EXPORT by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            custom { ctx -&gt; ctx.seatCount &gt;= 50 }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Features/#enum-pattern","title":"Enum Pattern","text":"<pre><code>enum class EnterpriseFeatures(override val key: String) :\n    BooleanFeature&lt;EnterpriseContext, Taxonomy.Global&gt; {\n\n    ADVANCED_ANALYTICS(\"advanced_analytics\"),\n    BULK_EXPORT(\"bulk_export\"),\n    CUSTOM_BRANDING(\"custom_branding\");\n\n    override val module = Taxonomy.Global\n}\n</code></pre>"},{"location":"Features/#type-safety-with-custom-context","title":"Type Safety with Custom Context","text":"<p>The compiler enforces context type requirements:</p> <pre><code>val enterpriseCtx: EnterpriseContext = // ...\nval basicCtx: Context = // ...\n\n// \u2705 Correct: EnterpriseContext provided\nenterpriseCtx.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)\n\n// \u274c Compile error: Context is not EnterpriseContext\nbasicCtx.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)\n\n// \u2705 Standard features work with both\nenterpriseCtx.evaluate(CoreFeatures.DARK_MODE)\nbasicCtx.evaluate(CoreFeatures.DARK_MODE)\n</code></pre>"},{"location":"Features/#polymorphic-context-usage","title":"Polymorphic Context Usage","text":"<p>Custom contexts are subypes of <code>Context</code>, enabling polymorphic usage:</p> <pre><code>fun evaluateFeature(ctx: Context, feature: BooleanFeature&lt;Context, Taxonomy.Global&gt;): Boolean {\n    return ctx.evaluate(feature)\n}\n\n// Works with both\nval basic = Context(...)\nval enterprise = EnterpriseContext(...)\n\nevaluateFeature(basic, CoreFeatures.DARK_MODE)\nevaluateFeature(enterprise, CoreFeatures.DARK_MODE)\n\n// But enterprise-specific features require EnterpriseContext\nfun evaluateEnterpriseFeature(\n    ctx: EnterpriseContext,\n    feature: BooleanFeature&lt;EnterpriseContext, Taxonomy.Global&gt;\n): Boolean {\n    return ctx.evaluate(feature)\n}\n</code></pre>"},{"location":"Features/#organizational-patterns","title":"Organizational Patterns","text":""},{"location":"Features/#single-container-per-taxonomy","title":"Single Container per Taxonomy","text":"<p>Organize features by functional area using one container per taxonomy:</p> <pre><code>object CoreFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val KILL_SWITCH by boolean&lt;Context&gt;(default = false)\n    val MAINTENANCE_MODE by boolean&lt;Context&gt;(default = false)\n    val API_VERSION by string&lt;Context&gt;(default = \"v1\")\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false)\n    val GOOGLE_PAY by boolean&lt;Context&gt;(default = false)\n    val MAX_TRANSACTION by int&lt;Context&gt;(default = 10000)\n}\n\nobject MessagingFeatures : FeatureContainer&lt;Taxonomy.Domain.Messaging&gt;(\n    Taxonomy.Domain.Messaging\n) {\n    val PUSH_NOTIFICATIONS by boolean&lt;Context&gt;(default = true)\n    val EMAIL_ENABLED by boolean&lt;Context&gt;(default = true)\n    val MAX_MESSAGE_LENGTH by int&lt;Context&gt;(default = 500)\n}\n</code></pre>"},{"location":"Features/#multiple-containers-per-taxonomy","title":"Multiple Containers per Taxonomy","text":"<p>For large domains, split features across multiple containers sharing a taxonomy:</p> <pre><code>// All share Taxonomy.Domain.Payments\nobject CheckoutFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val GUEST_CHECKOUT by boolean&lt;Context&gt;(default = false)\n    val ONE_CLICK_BUY by boolean&lt;Context&gt;(default = false)\n}\n\nobject PaymentMethodFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false)\n    val GOOGLE_PAY by boolean&lt;Context&gt;(default = false)\n    val CRYPTO_PAYMENTS by boolean&lt;Context&gt;(default = false)\n}\n\nobject FraudDetectionFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val RISK_SCORING by boolean&lt;Context&gt;(default = true)\n    val MANUAL_REVIEW_THRESHOLD by int&lt;Context&gt;(default = 1000)\n}\n</code></pre> <p>All features share the same registry since they use the same taxonomy.</p>"},{"location":"Features/#grouped-by-type-enum-pattern","title":"Grouped by Type (Enum Pattern)","text":"<p>When using enums, group by both domain and type:</p> <pre><code>// Payment domain - Boolean features\nenum class PaymentToggles(override val key: String) :\n    BooleanFeature&lt;Context, Taxonomy.Domain.Payments&gt; {\n    APPLE_PAY(\"apple_pay\"),\n    GOOGLE_PAY(\"google_pay\");\n    override val module = Taxonomy.Domain.Payments\n}\n\n// Payment domain - String config\nenum class PaymentConfig(override val key: String) :\n    StringFeature&lt;Context, Taxonomy.Domain.Payments&gt; {\n    API_ENDPOINT(\"api_endpoint\"),\n    PROVIDER_NAME(\"provider_name\");\n    override val module = Taxonomy.Domain.Payments\n}\n\n// Payment domain - Numeric limits\nenum class PaymentLimits(override val key: String) :\n    IntFeature&lt;Context, Taxonomy.Domain.Payments&gt; {\n    MAX_TRANSACTION(\"max_transaction\"),\n    DAILY_LIMIT(\"daily_limit\");\n    override val module = Taxonomy.Domain.Payments\n}\n</code></pre>"},{"location":"Features/#best-practices","title":"Best Practices","text":""},{"location":"Features/#1-use-featurecontainer-for-new-code","title":"1. Use FeatureContainer for New Code","text":"<p>For new projects and features, prefer <code>FeatureContainer</code> over enum pattern:</p> <pre><code>// \u2705 Recommended: FeatureContainer\nobject MyFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val FEATURE_A by boolean&lt;Context&gt;(default = false)\n    val CONFIG_B by string&lt;Context&gt;(default = \"default\")\n    val LIMIT_C by int&lt;Context&gt;(default = 100)\n}\n\n// \u26a0\ufe0f  Alternative: Enum pattern (more boilerplate)\nenum class MyFeatures(override val key: String) :\n    BooleanFeature&lt;Context, Taxonomy.Global&gt; {\n    FEATURE_A(\"feature_a\");\n    override val module = Taxonomy.Global\n}\n</code></pre>"},{"location":"Features/#2-choose-meaningful-property-names","title":"2. Choose Meaningful Property Names","text":"<p>Property names become feature keys automatically:</p> <pre><code>// \u2705 Good: Clear, descriptive names\nobject Features : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean&lt;Context&gt;(default = false)\n    val NEW_CHECKOUT_FLOW by boolean&lt;Context&gt;(default = false)\n    val API_ENDPOINT by string&lt;Context&gt;(default = \"https://api.prod.com\")\n}\n\n// \u274c Avoid: Ambiguous or inconsistent names\nobject Features : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val f1 by boolean&lt;Context&gt;(default = false)  // Not descriptive\n    val darkMode by boolean&lt;Context&gt;(default = false)  // Inconsistent casing\n}\n</code></pre> <p>Conventions: - Use SCREAMING_SNAKE_CASE for consistency - Be descriptive (prefer <code>NEW_CHECKOUT_FLOW</code> over <code>NCF</code>) - Avoid abbreviations unless universally understood</p>"},{"location":"Features/#3-provide-defaults-for-all-features","title":"3. Provide Defaults for All Features","text":"<p>Always specify default values to ensure non-null returns:</p> <pre><code>// \u2705 Good: Default provided\nval DARK_MODE by boolean&lt;Context&gt;(default = false)\n\n// \u274c Won't compile: Default is required\nval DARK_MODE by boolean&lt;Context&gt;() // Missing default parameter\n</code></pre>"},{"location":"Features/#4-group-related-features","title":"4. Group Related Features","text":"<p>Organize features by functional area or team ownership:</p> <pre><code>// \u2705 Good: Features grouped by domain\nobject AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SSO_ENABLED by boolean&lt;Context&gt;(default = false)\n    val MFA_REQUIRED by boolean&lt;Context&gt;(default = false)\n    val PASSWORD_MIN_LENGTH by int&lt;Context&gt;(default = 8)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false)\n    val MAX_TRANSACTION by int&lt;Context&gt;(default = 10000)\n}\n\n// \u274c Avoid: Unrelated features mixed together\nobject Features : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val SSO_ENABLED by boolean&lt;Context&gt;(default = false)\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false)\n    val DARK_MODE by boolean&lt;Context&gt;(default = false)\n    // ... unrelated features\n}\n</code></pre>"},{"location":"Features/#5-use-appropriate-taxonomies","title":"5. Use Appropriate Taxonomies","text":"<p>Choose taxonomies that match your organizational structure:</p> <pre><code>// \u2705 Global: System-wide features\nobject CoreFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val KILL_SWITCH by boolean&lt;Context&gt;(default = false)\n    val MAINTENANCE_MODE by boolean&lt;Context&gt;(default = false)\n}\n\n// \u2705 Domain: Team-specific features\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false)\n}\n</code></pre>"},{"location":"Features/#6-leverage-allfeatures-for-validation","title":"6. Leverage <code>allFeatures()</code> for Validation","text":"<p>Use feature enumeration to ensure complete configuration:</p> <pre><code>fun validateConfiguration() {\n    val allFeatures = PaymentFeatures.allFeatures()\n    val configuredKeys = loadConfiguredKeysFromRemote()\n\n    val missingKeys = allFeatures.map { it.key }.toSet() - configuredKeys\n\n    if (missingKeys.isNotEmpty()) {\n        logger.warn(\"Features not configured remotely: $missingKeys\")\n    }\n}\n</code></pre>"},{"location":"Features/#7-document-complex-features","title":"7. Document Complex Features","text":"<p>Add KDoc comments for features with complex behavior:</p> <pre><code>object Features : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    /**\n     * Enables the new checkout flow with improved UX.\n     *\n     * Rollout plan:\n     * - Phase 1: 10% web users (Week 1)\n     * - Phase 2: 50% web users (Week 2)\n     * - Phase 3: 100% all platforms (Week 3)\n     *\n     * @since 2.5.0\n     * @see CheckoutService\n     */\n    val NEW_CHECKOUT by boolean&lt;Context&gt;(default = false) {\n        rule {\n            platforms(Platform.WEB)\n            rollout = Rollout.of(10.0)\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Features/#8-keep-feature-keys-stable","title":"8. Keep Feature Keys Stable","text":"<p>Feature keys are used for persistence and remote configuration:</p> <pre><code>// \u2705 Good: Stable key even if property name changes\nenum class Features(override val key: String) : BooleanFeature&lt;...&gt; {\n    DARK_MODE(\"dark_mode\")  // Key stays \"dark_mode\" even if renamed\n}\n\n// \u26a0\ufe0f  FeatureContainer: Property name IS the key\nobject Features : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean&lt;Context&gt;(default = false)\n    // Key is \"DARK_MODE\" - renaming property breaks persistence!\n}\n</code></pre> <p>If you need stable keys independent of property names, use the enum pattern or maintain a mapping.</p>"},{"location":"Features/#9-test-all-features","title":"9. Test All Features","text":"<p>Leverage <code>allFeatures()</code> for comprehensive testing:</p> <pre><code>@Test\nfun `all features evaluate successfully`() {\n    val testContext = Context(\n        locale = AppLocale.EN_US,\n        platform = Platform.WEB,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"12345678901234567890123456789012\")\n    )\n\n    PaymentFeatures.allFeatures().forEach { feature -&gt;\n        val result = testContext.evaluateSafe(feature)\n        assertTrue(result is EvaluationResult.Success,\n            \"Feature ${feature.key} failed evaluation\")\n    }\n}\n</code></pre>"},{"location":"Features/#examples","title":"Examples","text":""},{"location":"Features/#complete-featurecontainer-example","title":"Complete FeatureContainer Example","text":"<pre><code>/**\n * Payment processing feature flags.\n *\n * This container manages all payment-related features including\n * payment methods, fraud detection, and transaction limits.\n */\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    // Payment method toggles\n    val APPLE_PAY by boolean&lt;Context&gt;(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            versions(FullyBound(Version(2, 0, 0), Version(3, 0, 0)))\n            rollout = Rollout.of(25.0)\n        } implies true\n    }\n\n    val GOOGLE_PAY by boolean&lt;Context&gt;(default = false) {\n        rule {\n            platforms(Platform.ANDROID)\n        } implies true\n    }\n\n    // Configuration\n    val PAYMENT_PROVIDER by string&lt;Context&gt;(default = \"stripe\") {\n        rule {\n            platforms(Platform.WEB)\n        } implies \"braintree\"\n    }\n\n    // Numeric limits\n    val MAX_TRANSACTION by int&lt;Context&gt;(default = 10000) {\n        rule {\n            locales(AppLocale.EN_US)\n        } implies 50000\n    }\n\n    val TRANSACTION_FEE by double&lt;Context&gt;(default = 0.029) {\n        rule {\n            platforms(Platform.WEB)\n            rollout = Rollout.of(50.0)\n        } implies 0.019\n    }\n}\n\n// Usage\nfun processPayment(context: Context, amount: Int) {\n    val maxTransaction = context.evaluate(PaymentFeatures.MAX_TRANSACTION)\n    require(amount &lt;= maxTransaction) {\n        \"Transaction exceeds limit: $maxTransaction\"\n    }\n\n    val fee = context.evaluate(PaymentFeatures.TRANSACTION_FEE)\n    val total = amount + (amount * fee)\n\n    val provider = context.evaluate(PaymentFeatures.PAYMENT_PROVIDER)\n    paymentService.charge(provider, total)\n}\n\n// Validation\nfun validatePaymentConfig() {\n    val features = PaymentFeatures.allFeatures()\n    println(\"Payment features configured: ${features.size}\")\n\n    features.forEach { feature -&gt;\n        println(\"- ${feature.key}: ${feature::class.simpleName}\")\n    }\n}\n</code></pre>"},{"location":"Features/#complete-enum-pattern-example","title":"Complete Enum Pattern Example","text":"<pre><code>// Declaration\nenum class PaymentFeatures(override val key: String) :\n    BooleanFeature&lt;Context, Taxonomy.Domain.Payments&gt; {\n\n    APPLE_PAY(\"apple_pay\"),\n    GOOGLE_PAY(\"google_pay\"),\n    CRYPTO_PAYMENTS(\"crypto_payments\");\n\n    override val module = Taxonomy.Domain.Payments\n}\n\nenum class PaymentConfig(override val key: String) :\n    StringFeature&lt;Context, Taxonomy.Domain.Payments&gt; {\n\n    PAYMENT_PROVIDER(\"payment_provider\");\n\n    override val module = Taxonomy.Domain.Payments\n}\n\nenum class PaymentLimits(override val key: String) :\n    IntFeature&lt;Context, Taxonomy.Domain.Payments&gt; {\n\n    MAX_TRANSACTION(\"max_transaction\");\n\n    override val module = Taxonomy.Domain.Payments\n}\n\n// Configuration\nTaxonomy.Domain.Payments.config {\n    PaymentFeatures.APPLE_PAY with {\n        default(false)\n        rule {\n            platforms(Platform.IOS)\n        } implies true\n    }\n\n    PaymentConfig.PAYMENT_PROVIDER with {\n        default(\"stripe\")\n        rule {\n            platforms(Platform.WEB)\n        } implies \"braintree\"\n    }\n\n    PaymentLimits.MAX_TRANSACTION with {\n        default(10000)\n        rule {\n            locales(AppLocale.EN_US)\n        } implies 50000\n    }\n}\n</code></pre>"},{"location":"Features/#custom-context-example","title":"Custom Context Example","text":"<pre><code>// Custom context with additional fields\ndata class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val organizationId: String,\n    val subscriptionTier: SubscriptionTier,\n    val seatCount: Int,\n    val customDomain: String?\n) : Context\n\nenum class SubscriptionTier {\n    STARTER, PROFESSIONAL, ENTERPRISE\n}\n\n// Features requiring custom context\nobject EnterpriseFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val ADVANCED_ANALYTICS by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            custom { ctx -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                ctx.seatCount &gt;= 50\n            }\n        } implies true\n    }\n\n    val CUSTOM_BRANDING by boolean&lt;EnterpriseContext&gt;(default = false) {\n        rule {\n            custom { ctx -&gt; ctx.customDomain != null }\n        } implies true\n    }\n\n    val API_RATE_LIMIT by int&lt;EnterpriseContext&gt;(default = 100) {\n        rule {\n            custom { ctx -&gt; ctx.subscriptionTier == SubscriptionTier.ENTERPRISE }\n        } implies 10000\n\n        rule {\n            custom { ctx -&gt; ctx.subscriptionTier == SubscriptionTier.PROFESSIONAL }\n        } implies 1000\n    }\n}\n\n// Usage\nfun generateReport(ctx: EnterpriseContext) {\n    if (ctx.evaluate(EnterpriseFeatures.ADVANCED_ANALYTICS)) {\n        analyticsService.generateAdvancedReport(ctx.organizationId)\n    } else {\n        analyticsService.generateBasicReport(ctx.organizationId)\n    }\n}\n</code></pre>"},{"location":"Features/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration DSL: Learn how to configure features with the DSL</li> <li>Rule Evaluation: Understand targeting and rule matching</li> <li>Context: Deep dive into evaluation contexts</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"QuickStart/","title":"Quick Start Guide","text":"<p>Get your first type-safe feature flag running in 5 minutes.</p>"},{"location":"QuickStart/#installation","title":"Installation","text":"<pre><code>// build.gradle.kts\ndependencies {\n    implementation(\"io.amichne:konditional:0.0.1\")\n}\n</code></pre>"},{"location":"QuickStart/#your-first-feature-flag","title":"Your First Feature Flag","text":""},{"location":"QuickStart/#step-1-define-your-features","title":"Step 1: Define Your Features","text":"<p>Use the <code>FeatureContainer</code> delegation pattern for the simplest approach:</p> <pre><code>import io.amichne.konditional.core.features.FeatureContainer\nimport io.amichne.konditional.core.Taxonomy\n\nobject AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false)\n}\n</code></pre> <p>What this gives you:</p> <ul> <li>Property access: <code>AppFeatures.DARK_MODE</code></li> <li>Type-safe: Always returns <code>Boolean</code>, never null</li> <li>Compile-time validation: Typos become compile errors</li> </ul>"},{"location":"QuickStart/#step-2-configure-rules-optional","title":"Step 2: Configure Rules (Optional)","text":"<p>Add targeting rules within the delegation:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            rollout { 50.0 }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"QuickStart/#step-3-evaluate-the-flag","title":"Step 3: Evaluate the Flag","text":"<p>Create a context and evaluate:</p> <pre><code>import io.amichne.konditional.context.*\n\n// Create evaluation context\nval context = Context(\n    locale = AppLocale.EN_US,\n    platform = Platform.IOS,\n    appVersion = Version.parse(\"2.1.0\"),\n    stableId = StableId.of(\"user-123\")\n)\n\n// Evaluate the flag\nval isDarkMode = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n\n// Use it\nif (isDarkMode) {\n    applyDarkTheme()\n}\n</code></pre> <p>What you get:</p> <ul> <li>Non-null result guaranteed (via <code>evaluateOrDefault</code>)</li> <li>Type-safe: <code>isDarkMode</code> is always <code>Boolean</code></li> <li>Deterministic: Same context always returns same value</li> </ul>"},{"location":"QuickStart/#common-patterns","title":"Common Patterns","text":""},{"location":"QuickStart/#multiple-flag-types","title":"Multiple Flag Types","text":"<p>Define different value types in the same container:</p> <pre><code>object AppConfig : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false)\n    val API_ENDPOINT by string(default = \"https://api.prod.example.com\")\n    val MAX_RETRIES by int(default = 3)\n    val TIMEOUT_SECONDS by double(default = 30.0)\n}\n</code></pre>"},{"location":"QuickStart/#platform-specific-values","title":"Platform-Specific Values","text":"<p>Configure different values for different platforms:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val API_ENDPOINT by string(default = \"https://api.example.com\") {\n        rule {\n            platforms(Platform.IOS)\n        } implies \"https://api-ios.example.com\"\n\n        rule {\n            platforms(Platform.ANDROID)\n        } implies \"https://api-android.example.com\"\n    }\n}\n</code></pre>"},{"location":"QuickStart/#gradual-rollout","title":"Gradual Rollout","text":"<p>Deploy features gradually using rollout percentages:</p> <pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val NEW_CHECKOUT by boolean(default = false) {\n        rule {\n            platforms(Platform.ANDROID)\n            rollout { 25.0 }  // 25% of Android users\n        } implies true\n    }\n}\n</code></pre> <p>Rollout characteristics:</p> <ul> <li>Deterministic: Same user always gets same result</li> <li>Independent: Each flag buckets users independently</li> <li>Stable: SHA-256 based bucketing</li> </ul>"},{"location":"QuickStart/#combining-criteria","title":"Combining Criteria","text":"<p>Rules support multiple targeting criteria (all must match):</p> <pre><code>object PremiumFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val ADVANCED_ANALYTICS by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            locales(AppLocale.EN_US)\n            versions {\n                min(2, 0, 0)  // Version 2.0.0 or higher\n            }\n            rollout { 50.0 }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"QuickStart/#evaluation-methods","title":"Evaluation Methods","text":"<p>Konditional provides multiple evaluation methods for different error handling needs:</p> <pre><code>// Safe evaluation with Result type\nval result: EvaluationResult&lt;Boolean&gt; = context.evaluateSafe(AppFeatures.DARK_MODE)\nwhen (result) {\n    is EvaluationResult.Success -&gt; println(\"Value: ${result.value}\")\n    is EvaluationResult.FlagNotFound -&gt; println(\"Flag not found\")\n    is EvaluationResult.EvaluationError -&gt; println(\"Error: ${result.error}\")\n}\n\n// Null on failure\nval value: Boolean? = context.evaluateOrNull(AppFeatures.DARK_MODE)\n\n// Default on failure\nval value: Boolean = context.evaluateOrDefault(AppFeatures.DARK_MODE, default = false)\n\n// Throw exception on failure (use sparingly)\nval value: Boolean = context.evaluateOrThrow(AppFeatures.DARK_MODE)\n</code></pre>"},{"location":"QuickStart/#organizing-features-by-domain","title":"Organizing Features by Domain","text":"<p>Use Taxonomy to organize features by team or domain:</p> <pre><code>object AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n    val GOOGLE_PAY by boolean(default = false)\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Isolation: Features don't collide across taxonomies</li> <li>Organization: Clear ownership boundaries</li> <li>Type safety: Compile-time taxonomy enforcement</li> </ul>"},{"location":"QuickStart/#next-steps","title":"Next Steps","text":"<p>Now that you have basic flags running, explore:</p> <ul> <li>Overview: Complete API overview and core concepts</li> <li>Features: All feature definition patterns</li> <li>Context: Evaluation contexts and custom extensions</li> <li>Rules: Advanced targeting and rollouts</li> <li>Evaluation: Deep dive into flag evaluation</li> <li>Configuration: Complete DSL reference</li> <li>Results: Error handling with EvaluationResult</li> <li>Serialization: Export/import configurations as JSON</li> <li>Registry: Taxonomy and registry management</li> </ul>"},{"location":"QuickStart/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>FeatureContainer delegation: Simplest way to define features</li> <li>Context required: All evaluations need locale, platform, version, stableId</li> <li>Multiple evaluation methods: Choose based on error handling needs</li> <li>Type safety: If it compiles, the types are correct</li> <li>Deterministic: Same inputs always produce same outputs</li> </ul>"},{"location":"Registry/","title":"Registry: Taxonomy-Based Flag Organization","text":"<p>This document explains Konditional's registry system, which provides compile-time and runtime isolation for feature flags through taxonomies.</p>"},{"location":"Registry/#overview","title":"Overview","text":"<p>Konditional organizes feature flags using taxonomies - isolated namespaces that provide:</p> <ul> <li>Compile-time isolation: Features are type-bound to their taxonomy</li> <li>Runtime isolation: Each taxonomy has its own flag registry</li> <li>Governance: All taxonomies enumerated in one sealed hierarchy</li> <li>Direct operations: Taxonomies implement <code>ModuleRegistry</code>, eliminating <code>.registry</code> access</li> </ul> <pre><code>// Features are bound to specific taxonomies\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n}\n\n// Evaluate using the bound taxonomy\nval isEnabled = context.evaluate(PaymentFeatures.APPLE_PAY)\n\n// Or query the taxonomy directly\nval definition = Taxonomy.Domain.Payments.featureFlag(PaymentFeatures.APPLE_PAY)\n</code></pre>"},{"location":"Registry/#taxonomy-system","title":"Taxonomy System","text":""},{"location":"Registry/#what-is-a-taxonomy","title":"What Is a Taxonomy?","text":"<p>A <code>Taxonomy</code> is a sealed class hierarchy that defines organizational boundaries for feature flags.</p> <p>Key characteristics:</p> <ul> <li>Unique ID: Each taxonomy has a string identifier</li> <li>Isolated registry: Each taxonomy maintains its own registry instance</li> <li>ModuleRegistry operations: Taxonomies provide direct access to registry methods</li> <li>Sealed hierarchy: All taxonomies must be defined in the sealed class</li> </ul>"},{"location":"Registry/#taxonomy-types","title":"Taxonomy Types","text":"<p>Konditional provides two taxonomy categories:</p>"},{"location":"Registry/#global-taxonomy","title":"Global Taxonomy","text":"<p>The <code>Taxonomy.Global</code> taxonomy contains shared flags accessible to all teams:</p> <pre><code>data object Global : Taxonomy(\"global\")\n</code></pre> <p>Use for: - System-wide kill switches - Maintenance mode flags - Cross-cutting feature toggles - Common infrastructure flags</p> <p>Example:</p> <pre><code>object CoreFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val KILL_SWITCH by boolean(default = false)\n    val MAINTENANCE_MODE by boolean(default = false)\n    val DEBUG_LOGGING by boolean(default = false)\n}\n</code></pre>"},{"location":"Registry/#domain-taxonomies","title":"Domain Taxonomies","text":"<p>Domain taxonomies provide isolated namespaces for functional areas:</p> <pre><code>sealed class Domain(id: String) : Taxonomy(id) {\n    data object Authentication : Domain(\"auth\")\n    data object Payments : Domain(\"payments\")\n    data object Messaging : Domain(\"messaging\")\n    data object Search : Domain(\"search\")\n    data object Recommendations : Domain(\"recommendations\")\n}\n</code></pre> <p>Each domain taxonomy provides:</p> <ul> <li>Independent registry instance (runtime isolation)</li> <li>Type-bound features (compile-time isolation)</li> <li>Independent serialization/deployment</li> <li>No cross-taxonomy flag access</li> </ul> <p>Example:</p> <pre><code>object AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n    val BIOMETRIC_AUTH by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n    val GOOGLE_PAY by boolean(default = false)\n    val CRYPTO_PAYMENTS by boolean(default = false)\n}\n</code></pre>"},{"location":"Registry/#adding-new-taxonomies","title":"Adding New Taxonomies","text":"<p>To add a new domain taxonomy, add an object to the <code>Domain</code> sealed class:</p> <pre><code>sealed class Domain(id: String) : Taxonomy(id) {\n    // ... existing domains ...\n\n    data object Analytics : Domain(\"analytics\")\n    data object Notifications : Domain(\"notifications\")\n}\n</code></pre> <p>The sealed hierarchy ensures:</p> <ul> <li>No taxonomy ID collisions at compile time</li> <li>Exhaustive when-expressions</li> <li>IDE autocomplete for all taxonomies</li> <li>Central visibility of all modules</li> </ul>"},{"location":"Registry/#moduleregistry-interface","title":"ModuleRegistry Interface","text":"<p><code>ModuleRegistry</code> defines the contract for managing feature flag configurations:</p> <pre><code>interface ModuleRegistry {\n    fun load(config: Konfig)\n    fun konfig(): Konfig\n    fun &lt;S, T, C, M&gt; featureFlag(key: Feature&lt;S, T, C, M&gt;): FlagDefinition&lt;S, T, C, M&gt;?\n    fun allFlags(): Map&lt;Feature&lt;*, *, *, *&gt;, FlagDefinition&lt;*, *, *, *&gt;&gt;\n}\n</code></pre>"},{"location":"Registry/#core-operations","title":"Core Operations","text":""},{"location":"Registry/#loading-configuration","title":"Loading Configuration","text":"<p>Load a complete flag configuration snapshot:</p> <pre><code>// Create a Konfig (typically from JSON deserialization)\nval konfig = TaxonomySnapshotSerializer.deserialize&lt;Taxonomy.Domain.Payments&gt;(jsonString)\n\n// Load into taxonomy's registry\nwhen (konfig) {\n    is ParseResult.Success -&gt; Taxonomy.Domain.Payments.load(konfig.value)\n    is ParseResult.Failure -&gt; logger.error(\"Failed to load: ${konfig.error}\")\n}\n</code></pre> <p>Properties:</p> <ul> <li>Atomic: Entire configuration replaces current state in one operation</li> <li>Thread-safe: Backed by <code>AtomicReference</code> for lock-free updates</li> <li>Consistent: Readers see complete old OR new config, never partial state</li> </ul>"},{"location":"Registry/#retrieving-current-state","title":"Retrieving Current State","text":"<p>Get the current configuration snapshot:</p> <pre><code>val currentConfig = Taxonomy.Domain.Payments.konfig()\n\n// Inspect flags\ncurrentConfig.flags.forEach { (feature, definition) -&gt;\n    println(\"${feature.key}: default=${definition.defaultValue}, active=${definition.isActive}\")\n}\n</code></pre> <p>Use cases:</p> <ul> <li>Serialization to JSON</li> <li>State inspection</li> <li>Debugging</li> <li>Configuration export</li> </ul>"},{"location":"Registry/#querying-individual-flags","title":"Querying Individual Flags","text":"<p>Retrieve a specific flag definition:</p> <pre><code>val definition = Taxonomy.Domain.Payments.featureFlag(PaymentFeatures.APPLE_PAY)\n\nif (definition != null) {\n    println(\"Default: ${definition.defaultValue}\")\n    println(\"Active: ${definition.isActive}\")\n    println(\"Rules: ${definition.values.size}\")\n}\n</code></pre> <p>Returns: <code>FlagDefinition&lt;S, T, C, M&gt;?</code> - null if flag not found</p>"},{"location":"Registry/#querying-all-flags","title":"Querying All Flags","text":"<p>Retrieve all flags from a taxonomy:</p> <pre><code>val allFlags = Taxonomy.Domain.Payments.allFlags()\n\nallFlags.forEach { (feature, definition) -&gt;\n    println(\"${feature.key}: ${definition.defaultValue}\")\n}\n</code></pre>"},{"location":"Registry/#factory-function","title":"Factory Function","text":"<p>Create new registry instances for testing:</p> <pre><code>companion object {\n    operator fun invoke(konfig: Konfig = Konfig(emptyMap())): ModuleRegistry\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `test feature behavior`() {\n    // Create isolated registry for testing\n    val testRegistry = ModuleRegistry()\n\n    // Note: Direct registry usage is for advanced cases\n    // Prefer using Taxonomy instances in production\n}\n</code></pre>"},{"location":"Registry/#konfig-immutable-configuration-snapshot","title":"Konfig: Immutable Configuration Snapshot","text":"<p><code>Konfig</code> is an immutable data class representing a complete registry state at a point in time.</p>"},{"location":"Registry/#characteristics","title":"Characteristics","text":"<p>Immutable: - Cannot be modified after creation - Thread-safe for concurrent reads - Safe to share across threads</p> <p>Snapshot Semantics: - Represents state at a point in time - Remains consistent even if registry is updated - Enables consistent multi-flag evaluations</p>"},{"location":"Registry/#usage-patterns","title":"Usage Patterns","text":""},{"location":"Registry/#exporting-configuration","title":"Exporting Configuration","text":"<pre><code>// Get current state\nval konfig = Taxonomy.Domain.Payments.konfig()\n\n// Serialize to JSON\nval json = TaxonomySnapshotSerializer.serialize(konfig)\n\n// Save to file or send over network\nFile(\"payment-config.json\").writeText(json)\n</code></pre>"},{"location":"Registry/#importing-configuration","title":"Importing Configuration","text":"<pre><code>// Read from file\nval json = File(\"payment-config.json\").readText()\n\n// Deserialize\nval result = TaxonomySnapshotSerializer.deserialize&lt;Taxonomy.Domain.Payments&gt;(json)\n\nwhen (result) {\n    is ParseResult.Success -&gt; {\n        // Load into registry\n        Taxonomy.Domain.Payments.load(result.value)\n        println(\"Loaded ${result.value.flags.size} flags\")\n    }\n    is ParseResult.Failure -&gt; {\n        logger.error(\"Parse error: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"Registry/#consistent-multi-flag-evaluation","title":"Consistent Multi-Flag Evaluation","text":"<pre><code>// Get snapshot\nval snapshot = Taxonomy.Domain.Payments.konfig()\n\n// Evaluate multiple flags against same snapshot\n// (even if registry is updated concurrently)\nval applePayDef = snapshot.flags[PaymentFeatures.APPLE_PAY]\nval googlePayDef = snapshot.flags[PaymentFeatures.GOOGLE_PAY]\n\nval applePayEnabled = applePayDef?.evaluate(context)\nval googlePayEnabled = googlePayDef?.evaluate(context)\n</code></pre>"},{"location":"Registry/#taxonomy-based-isolation","title":"Taxonomy-Based Isolation","text":""},{"location":"Registry/#compile-time-isolation","title":"Compile-Time Isolation","text":"<p>Features are type-bound to their taxonomy, preventing cross-taxonomy usage:</p> <pre><code>object AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n}\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean(default = false)\n}\n\n// \u2713 Correct: Feature bound to Authentication taxonomy\nval authEnabled = context.evaluate(AuthFeatures.SOCIAL_LOGIN)\n\n// \u2717 Won't compile: SOCIAL_LOGIN belongs to Authentication, not Payments\nTaxonomy.Domain.Payments.featureFlag(AuthFeatures.SOCIAL_LOGIN)  // Type error\n</code></pre> <p>Benefits:</p> <ul> <li>Impossible to query flags from wrong taxonomy</li> <li>Refactoring is safe (types guide changes)</li> <li>Clear ownership boundaries</li> <li>No runtime taxonomy checks needed</li> </ul>"},{"location":"Registry/#runtime-isolation","title":"Runtime Isolation","text":"<p>Each taxonomy has its own <code>ModuleRegistry</code> instance:</p> <pre><code>// Authentication taxonomy has its own registry\nTaxonomy.Domain.Authentication.load(authConfig)\n\n// Payments taxonomy has its own registry\nTaxonomy.Domain.Payments.load(paymentsConfig)\n\n// Registries are independent - no shared state\n</code></pre> <p>Benefits:</p> <ul> <li>Independent deployment of taxonomy configurations</li> <li>No key collisions between taxonomies</li> <li>Team autonomy (each team owns their taxonomy)</li> <li>Isolated testing (load different configs per taxonomy)</li> </ul>"},{"location":"Registry/#governance-through-sealed-hierarchy","title":"Governance Through Sealed Hierarchy","text":"<p>All taxonomies must be defined in the sealed class:</p> <pre><code>sealed class Domain(id: String) : Taxonomy(id) {\n    data object Authentication : Domain(\"auth\")\n    data object Payments : Domain(\"payments\")\n    // All domains visible here\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Central registry of all taxonomies</li> <li>No duplicate taxonomy IDs</li> <li>Exhaustive when-expressions</li> <li>Clear organizational structure</li> </ul>"},{"location":"Registry/#thread-safety-guarantees","title":"Thread Safety Guarantees","text":"<p>Lock-free reads:</p> <pre><code>// Multiple threads can read simultaneously without contention\nval def1 = taxonomy.featureFlag(feature)  // Thread 1\nval def2 = taxonomy.featureFlag(feature)  // Thread 2 (concurrent)\n</code></pre> <p>Atomic updates:</p> <pre><code>// Update atomically replaces entire config\ntaxonomy.load(newKonfig)  // All flags update together\n</code></pre> <p>Read-write safety:</p> <pre><code>// Thread A: Reading\nval definition = taxonomy.featureFlag(feature)\nval result = definition?.evaluate(context)\n\n// Thread B: Updating (concurrent)\ntaxonomy.load(newKonfig)\n\n// Thread A's reference remains valid\n// Sees consistent snapshot (old or new, never mixed)\n</code></pre>"},{"location":"Registry/#performance-characteristics","title":"Performance Characteristics","text":"Operation Latency Throughput Read flag ~5-10 ns 100M+ ops/sec Read (contended) ~5-10 ns Linear scaling Load configuration ~1-10 \u00b5s Doesn't block reads <p>Key advantage: Lock-free reads scale linearly with CPU cores.</p>"},{"location":"Registry/#registry-operations-through-taxonomy","title":"Registry Operations Through Taxonomy","text":"<p>Since <code>Taxonomy</code> implements <code>ModuleRegistry</code> via delegation, you can call registry methods directly:</p>"},{"location":"Registry/#loading-configuration_1","title":"Loading Configuration","text":"<pre><code>// Old style (verbose)\nTaxonomy.Domain.Payments.registry.load(konfig)\n\n// New style (direct)\nTaxonomy.Domain.Payments.load(konfig)\n</code></pre>"},{"location":"Registry/#querying-state","title":"Querying State","text":"<pre><code>// Get current snapshot\nval snapshot = Taxonomy.Domain.Payments.konfig()\n\n// Query specific flag\nval definition = Taxonomy.Domain.Payments.featureFlag(PaymentFeatures.APPLE_PAY)\n\n// Get all flags\nval allFlags = Taxonomy.Domain.Payments.allFlags()\n</code></pre>"},{"location":"Registry/#example-loading-from-remote-config","title":"Example: Loading from Remote Config","text":"<pre><code>suspend fun loadRemoteConfig(taxonomy: Taxonomy.Domain.Payments) {\n    try {\n        // Fetch from remote\n        val json = httpClient.get(\"https://config.example.com/payments\")\n\n        // Deserialize\n        val result = TaxonomySnapshotSerializer.deserialize&lt;Taxonomy.Domain.Payments&gt;(json)\n\n        when (result) {\n            is ParseResult.Success -&gt; {\n                // Load directly into taxonomy\n                taxonomy.load(result.value)\n                logger.info(\"Loaded ${result.value.flags.size} payment flags\")\n            }\n            is ParseResult.Failure -&gt; {\n                logger.error(\"Failed to parse: ${result.error}\")\n            }\n        }\n    } catch (e: Exception) {\n        logger.error(\"Failed to fetch remote config\", e)\n    }\n}\n</code></pre>"},{"location":"Registry/#choosing-the-right-taxonomy","title":"Choosing the Right Taxonomy","text":""},{"location":"Registry/#use-taxonomyglobal-for","title":"Use <code>Taxonomy.Global</code> for:","text":"<p>System-wide flags: <pre><code>object SystemFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val KILL_SWITCH by boolean(default = false)\n    val MAINTENANCE_MODE by boolean(default = false)\n    val RATE_LIMITING by boolean(default = true)\n}\n</code></pre></p> <p>Infrastructure flags: <pre><code>object InfraFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val NEW_DATABASE by boolean(default = false)\n    val CIRCUIT_BREAKER by boolean(default = true)\n    val DEBUG_LOGGING by boolean(default = false)\n}\n</code></pre></p> <p>Cross-cutting concerns: <pre><code>object MonitoringFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val METRICS_ENABLED by boolean(default = true)\n    val TRACING_ENABLED by boolean(default = false)\n    val PROFILING_ENABLED by boolean(default = false)\n}\n</code></pre></p>"},{"location":"Registry/#use-taxonomydomain-for","title":"Use <code>Taxonomy.Domain.*</code> for:","text":"<p>Team-owned features: <pre><code>// Authentication team owns this taxonomy\nobject AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n    val PASSWORDLESS_LOGIN by boolean(default = false)\n}\n</code></pre></p> <p>Domain-specific experiments: <pre><code>// Payments team owns this taxonomy\nobject PaymentExperiments : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val NEW_CHECKOUT_FLOW by boolean(default = false)\n    val ONE_CLICK_PURCHASE by boolean(default = false)\n    val SAVED_PAYMENT_METHODS by boolean(default = true)\n}\n</code></pre></p> <p>Isolated deployments: <pre><code>// Search team can deploy independently\nobject SearchFeatures : FeatureContainer&lt;Taxonomy.Domain.Search&gt;(\n    Taxonomy.Domain.Search\n) {\n    val FUZZY_SEARCH by boolean(default = false)\n    val AUTOCOMPLETE by boolean(default = true)\n    val PERSONALIZED_RESULTS by boolean(default = false)\n}\n</code></pre></p>"},{"location":"Registry/#decision-matrix","title":"Decision Matrix","text":"Aspect Global Domain Ownership Central team / SRE Feature team Scope System-wide Domain-specific Deployment Coordinated Independent Governance Centralized Decentralized Key collisions Shared namespace (use prefixes) Isolated namespace Examples Kill switches, maintenance Team features, experiments"},{"location":"Registry/#featureregistry-deserialization-support","title":"FeatureRegistry: Deserialization Support","text":"<p><code>FeatureRegistry</code> is a separate registry for mapping string keys to <code>Feature</code> instances during deserialization:</p> <pre><code>object FeatureRegistry {\n    fun &lt;S, T, C&gt; register(conditional: Feature&lt;S, T, C, *&gt;)\n    fun get(key: String): ParseResult&lt;Feature&lt;*, *, *, *&gt;&gt;\n    fun contains(key: String): Boolean\n    fun clear()\n}\n</code></pre>"},{"location":"Registry/#why-it-exists","title":"Why It Exists","text":"<p>When deserializing flags from JSON, we need to reconstruct <code>Feature</code> references:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"apple_pay\",\n      \"default\": false\n    }\n  ]\n}\n</code></pre> <p>The deserializer needs to find <code>PaymentFeatures.APPLE_PAY</code> from the string <code>\"apple_pay\"</code>.</p>"},{"location":"Registry/#registration","title":"Registration","text":"<p>Register individual features:</p> <pre><code>FeatureRegistry.register(PaymentFeatures.APPLE_PAY)\nFeatureRegistry.register(PaymentFeatures.GOOGLE_PAY)\n</code></pre> <p>Register all enum members:</p> <pre><code>// If using enum-based features\nPaymentFeatures.values().forEach { FeatureRegistry.register(it) }\n</code></pre> <p>Register FeatureContainer features:</p> <pre><code>// FeatureContainer features auto-register when defined\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    // These auto-register during initialization\n    val APPLE_PAY by boolean(default = false)\n    val GOOGLE_PAY by boolean(default = false)\n}\n</code></pre>"},{"location":"Registry/#lookup-during-deserialization","title":"Lookup During Deserialization","text":"<pre><code>// Deserializer looks up feature by key\nwhen (val result = FeatureRegistry.get(\"apple_pay\")) {\n    is ParseResult.Success -&gt; {\n        val feature = result.value\n        // Use feature to build FlagDefinition\n    }\n    is ParseResult.Failure -&gt; {\n        logger.error(\"Feature not found: ${result.error}\")\n    }\n}\n</code></pre>"},{"location":"Registry/#thread-safety-warning","title":"Thread Safety Warning","text":"<p>FeatureRegistry is NOT thread-safe:</p> <pre><code>// \u2713 Good: Register during initialization\nfun main() {\n    // Register all features before concurrent access\n    PaymentFeatures.values().forEach { FeatureRegistry.register(it) }\n\n    // Now safe to deserialize concurrently\n    launch { deserializeConfig1() }\n    launch { deserializeConfig2() }\n}\n\n// \u2717 Bad: Concurrent registration\nlaunch { FeatureRegistry.register(feature1) }  // Race condition!\nlaunch { FeatureRegistry.register(feature2) }\n</code></pre> <p>Best practice: Complete all registration during application startup before any concurrent access.</p>"},{"location":"Registry/#testing","title":"Testing","text":"<p>Clear registry between tests:</p> <pre><code>@BeforeEach\nfun setup() {\n    FeatureRegistry.clear()\n    PaymentFeatures.values().forEach { FeatureRegistry.register(it) }\n}\n</code></pre>"},{"location":"Registry/#best-practices","title":"Best Practices","text":""},{"location":"Registry/#do-use-taxonomy-instances-directly","title":"Do: Use Taxonomy Instances Directly","text":"<pre><code>// \u2713 Good: Taxonomy implements ModuleRegistry\nTaxonomy.Domain.Payments.load(konfig)\nval snapshot = Taxonomy.Domain.Payments.konfig()\n\n// \u2717 Verbose: Accessing internal registry\nTaxonomy.Domain.Payments.registry.load(konfig)\n</code></pre>"},{"location":"Registry/#do-organize-by-domain","title":"Do: Organize by Domain","text":"<pre><code>// \u2713 Good: Clear ownership\nobject AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) { ... }\n\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) { ... }\n</code></pre>"},{"location":"Registry/#do-use-global-sparingly","title":"Do: Use Global Sparingly","text":"<pre><code>// \u2713 Good: True system-wide concern\nobject SystemFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val KILL_SWITCH by boolean(default = false)\n}\n\n// \u2717 Bad: Team feature in Global\nobject FeatureFlags : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val NEW_CHECKOUT by boolean(default = false)  // Should be in Payments domain\n}\n</code></pre>"},{"location":"Registry/#do-register-features-before-deserialization","title":"Do: Register Features Before Deserialization","text":"<pre><code>// \u2713 Good: Register during initialization\nobject AppInitializer {\n    fun init() {\n        // Register all features\n        PaymentFeatures.APPLE_PAY  // Access triggers registration\n        PaymentFeatures.GOOGLE_PAY\n\n        // Now safe to deserialize\n        loadConfigs()\n    }\n}\n</code></pre>"},{"location":"Registry/#do-use-isolated-registries-for-testing","title":"Do: Use Isolated Registries for Testing","text":"<pre><code>// \u2713 Good: Test isolation\n@Test\nfun `test payment feature`() {\n    val testRegistry = ModuleRegistry()\n\n    // Configure test registry\n    // (Advanced usage - prefer using Taxonomy in production)\n}\n</code></pre>"},{"location":"Registry/#dont-mix-taxonomies","title":"Don't: Mix Taxonomies","text":"<pre><code>// \u2717 Bad: Won't compile - type mismatch\nTaxonomy.Domain.Payments.featureFlag(AuthFeatures.SOCIAL_LOGIN)\n</code></pre>"},{"location":"Registry/#dont-modify-featureregistry-concurrently","title":"Don't: Modify FeatureRegistry Concurrently","text":"<pre><code>// \u2717 Bad: Race condition\nlaunch { FeatureRegistry.register(feature1) }\nlaunch { FeatureRegistry.register(feature2) }\n\n// \u2713 Good: Register sequentially during init\nfun init() {\n    FeatureRegistry.register(feature1)\n    FeatureRegistry.register(feature2)\n}\n</code></pre>"},{"location":"Registry/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing taxonomy-based organization:</p> <pre><code>// 1. Define domain-specific features\nobject PaymentFeatures : FeatureContainer&lt;Taxonomy.Domain.Payments&gt;(\n    Taxonomy.Domain.Payments\n) {\n    val APPLE_PAY by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            versions { min(2, 0, 0) }\n        } implies true\n    }\n\n    val GOOGLE_PAY by boolean(default = false) {\n        rule {\n            platforms(Platform.ANDROID)\n        } implies true\n    }\n\n    val CRYPTO_PAYMENTS by boolean(default = false) {\n        rule {\n            rollout = Rollout.of(10.0)  // 10% rollout\n        } implies true\n    }\n}\n\nobject AuthFeatures : FeatureContainer&lt;Taxonomy.Domain.Authentication&gt;(\n    Taxonomy.Domain.Authentication\n) {\n    val SOCIAL_LOGIN by boolean(default = false)\n    val TWO_FACTOR_AUTH by boolean(default = true)\n    val BIOMETRIC_AUTH by boolean(default = false)\n}\n\n// 2. Load configurations independently\nsuspend fun loadConfigurations() {\n    // Load payments config\n    val paymentsJson = httpClient.get(\"https://config.example.com/payments\")\n    val paymentsResult = TaxonomySnapshotSerializer\n        .deserialize&lt;Taxonomy.Domain.Payments&gt;(paymentsJson)\n\n    when (paymentsResult) {\n        is ParseResult.Success -&gt; {\n            Taxonomy.Domain.Payments.load(paymentsResult.value)\n        }\n        is ParseResult.Failure -&gt; {\n            logger.error(\"Failed to load payments config\")\n        }\n    }\n\n    // Load auth config independently\n    val authJson = httpClient.get(\"https://config.example.com/auth\")\n    val authResult = TaxonomySnapshotSerializer\n        .deserialize&lt;Taxonomy.Domain.Authentication&gt;(authJson)\n\n    when (authResult) {\n        is ParseResult.Success -&gt; {\n            Taxonomy.Domain.Authentication.load(authResult.value)\n        }\n        is ParseResult.Failure -&gt; {\n            logger.error(\"Failed to load auth config\")\n        }\n    }\n}\n\n// 3. Evaluate features\nfun processPayment(context: Context) {\n    val applePayEnabled = context.evaluateOrDefault(\n        PaymentFeatures.APPLE_PAY,\n        default = false\n    )\n\n    if (applePayEnabled) {\n        showApplePayButton()\n    }\n}\n\nfun handleLogin(context: Context) {\n    val socialLoginEnabled = context.evaluateOrDefault(\n        AuthFeatures.SOCIAL_LOGIN,\n        default = false\n    )\n\n    if (socialLoginEnabled) {\n        showSocialLoginOptions()\n    }\n}\n\n// 4. Export configurations\nfun exportConfigs() {\n    // Export payments config\n    val paymentsSnapshot = Taxonomy.Domain.Payments.konfig()\n    val paymentsJson = TaxonomySnapshotSerializer.serialize(paymentsSnapshot)\n    File(\"payments.json\").writeText(paymentsJson)\n\n    // Export auth config\n    val authSnapshot = Taxonomy.Domain.Authentication.konfig()\n    val authJson = TaxonomySnapshotSerializer.serialize(authSnapshot)\n    File(\"auth.json\").writeText(authJson)\n}\n\n// 5. Inspect registry state\nfun debugRegistries() {\n    // Inspect payments flags\n    println(\"=== Payments Flags ===\")\n    Taxonomy.Domain.Payments.allFlags().forEach { (feature, definition) -&gt;\n        println(\"${feature.key}: active=${definition.isActive}, default=${definition.defaultValue}\")\n    }\n\n    // Inspect auth flags\n    println(\"=== Auth Flags ===\")\n    Taxonomy.Domain.Authentication.allFlags().forEach { (feature, definition) -&gt;\n        println(\"${feature.key}: active=${definition.isActive}, default=${definition.defaultValue}\")\n    }\n}\n</code></pre>"},{"location":"Registry/#summary","title":"Summary","text":"Concept Purpose Taxonomy Organizational namespace with isolated registry Taxonomy.Global System-wide flags (kill switches, maintenance) Taxonomy.Domain Team-owned flags (domain-specific features) ModuleRegistry Interface for loading, querying flag configurations Konfig Immutable snapshot of all flags at a point in time InMemoryModuleRegistry Thread-safe registry implementation (AtomicReference) FeatureRegistry Maps string keys to Feature instances (deserialization) <p>Core Principle: Taxonomies provide compile-time and runtime isolation, enabling independent team ownership while maintaining system-wide type safety.</p>"},{"location":"Registry/#next-steps","title":"Next Steps","text":"<ul> <li>QuickStart - Get started with feature flags in 5 minutes</li> <li>Features - Define features using FeatureContainer</li> <li>Evaluation - Understand flag evaluation mechanics</li> <li>Serialization - Export/import configurations as JSON</li> <li>Configuration - DSL reference for building configurations</li> <li>Context - Custom evaluation contexts</li> </ul>"},{"location":"Results/","title":"Results: Type-Safe Error Handling","text":"<p>Konditional provides two result types for error handling: <code>EvaluationResult</code> for flag evaluation and <code>ParseResult</code> for parsing operations. Both follow the \"Parse, Don't Validate\" principle, making all failure modes explicit and type-safe.</p>"},{"location":"Results/#philosophy-parse-dont-validate","title":"Philosophy: Parse, Don't Validate","text":"<p>Traditional feature flag libraries often use nullable returns or throw exceptions:</p> <pre><code>// Nullable approach - loses error information\nval value: Boolean? = flags.get(\"my-flag\")  // Why is it null?\n\n// Exception approach - forces try-catch everywhere\ntry {\n    val value = flags.get(\"my-flag\")\n} catch (e: Exception) {\n    // What kind of error? Flag missing? Evaluation failed?\n}\n</code></pre> <p>Konditional's approach: Explicit result types that distinguish error cases:</p> <pre><code>// Type-safe - all outcomes are explicit\nwhen (val result = context.evaluateSafe(MY_FLAG)) {\n    is EvaluationResult.Success -&gt; use(result.value)\n    is EvaluationResult.FlagNotFound -&gt; handleMissing(result.key)\n    is EvaluationResult.EvaluationError -&gt; handleError(result.key, result.error)\n}\n</code></pre> <p>Benefits: - No surprises - all failure modes are documented in the type - Precise error handling - distinguish between different error cases - Compiler-enforced - can't forget to handle errors - Composable - transform results with <code>map</code>, <code>fold</code>, <code>flatMap</code></p>"},{"location":"Results/#evaluationresult-flag-evaluation-outcomes","title":"EvaluationResult: Flag Evaluation Outcomes","text":"<p><code>EvaluationResult&lt;T&gt;</code> represents the outcome of evaluating a feature flag.</p>"},{"location":"Results/#structure","title":"Structure","text":"<pre><code>sealed interface EvaluationResult&lt;out S&gt; {\n    data class Success&lt;S&gt;(val value: S) : EvaluationResult&lt;S&gt;\n    data class FlagNotFound(val key: String) : EvaluationResult&lt;Nothing&gt;\n    data class EvaluationError(val key: String, val error: Throwable) : EvaluationResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"Results/#variants","title":"Variants","text":""},{"location":"Results/#success","title":"Success","text":"<p>Flag was found and evaluated successfully:</p> <pre><code>val result: EvaluationResult&lt;Boolean&gt; = context.evaluateSafe(AppFeatures.DARK_MODE)\n\nwhen (result) {\n    is EvaluationResult.Success -&gt; {\n        val enabled: Boolean = result.value\n        applyDarkMode(enabled)\n    }\n    // ...\n}\n</code></pre>"},{"location":"Results/#flagnotfound","title":"FlagNotFound","text":"<p>Flag is not registered in the taxonomy:</p> <pre><code>when (result) {\n    is EvaluationResult.FlagNotFound -&gt; {\n        val flagKey: String = result.key\n        logger.warn(\"Flag not registered: $flagKey\")\n        // Use default behavior\n    }\n    // ...\n}\n</code></pre> <p>This typically indicates: - Flag hasn't been configured yet - Wrong taxonomy was used - Typo in feature key</p>"},{"location":"Results/#evaluationerror","title":"EvaluationError","text":"<p>Flag exists but evaluation threw an exception:</p> <pre><code>when (result) {\n    is EvaluationResult.EvaluationError -&gt; {\n        val flagKey: String = result.key\n        val error: Throwable = result.error\n        logger.error(\"Flag evaluation failed: $flagKey\", error)\n        // Use fallback or fail\n    }\n    // ...\n}\n</code></pre> <p>This is rare but can occur if: - Custom <code>Evaluable</code> throws an exception - Serialization/deserialization fails for complex types</p>"},{"location":"Results/#evaluationresult-utility-methods","title":"EvaluationResult Utility Methods","text":"<p>Transform and extract values from evaluation results:</p>"},{"location":"Results/#fold","title":"fold()","text":"<p>Transform result into any type by providing handlers for each case:</p> <pre><code>val outcome: Outcome&lt;MyError, Boolean&gt; = context.evaluateSafe(MY_FLAG).fold(\n    onSuccess = { Outcome.Success(it) },\n    onFlagNotFound = { key -&gt; Outcome.Failure(MyError.FlagNotRegistered(key)) },\n    onEvaluationError = { key, error -&gt; Outcome.Failure(MyError.EvaluationFailed(key, error)) }\n)\n</code></pre> <p>Use when: Adapting to your application's error handling system (Result, Either, Outcome, etc.)</p>"},{"location":"Results/#map","title":"map()","text":"<p>Transform the success value while preserving errors:</p> <pre><code>val result: EvaluationResult&lt;Int&gt; = context.evaluateSafe(MyFeatures.MAX_RETRIES)\n    .map { it * 2 }  // Double the retry count\n\n// Chain multiple transformations\nval upperCase: EvaluationResult&lt;String&gt; = context.evaluateSafe(MyFeatures.API_ENDPOINT)\n    .map { it.trim() }\n    .map { it.uppercase() }\n</code></pre> <p>Use when: Transforming success values without changing error handling</p>"},{"location":"Results/#getornull","title":"getOrNull()","text":"<p>Get the value if successful, null otherwise:</p> <pre><code>val value: Boolean? = context.evaluateSafe(AppFeatures.DARK_MODE).getOrNull()\n\nif (value != null) {\n    applyDarkMode(value)\n}\n</code></pre> <p>Use when: You don't need to distinguish error types and null is acceptable</p>"},{"location":"Results/#getordefault","title":"getOrDefault()","text":"<p>Get the value if successful, or a default value if failed:</p> <pre><code>val maxRetries: Int = context.evaluateSafe(MyFeatures.MAX_RETRIES)\n    .getOrDefault(default = 3)\n</code></pre> <p>Use when: You have a sensible fallback value</p>"},{"location":"Results/#getorelse","title":"getOrElse()","text":"<p>Get the value if successful, or compute a default based on the error:</p> <pre><code>val endpoint: String = context.evaluateSafe(MyFeatures.API_ENDPOINT)\n    .getOrElse { error -&gt;\n        when (error) {\n            is EvaluationResult.FlagNotFound -&gt; \"https://api.prod.example.com\"\n            is EvaluationResult.EvaluationError -&gt; \"https://api.backup.example.com\"\n        }\n    }\n</code></pre> <p>Use when: You need error-specific fallback logic</p>"},{"location":"Results/#issuccess-isfailure","title":"isSuccess() / isFailure()","text":"<p>Check the result status:</p> <pre><code>val result = context.evaluateSafe(MY_FLAG)\n\nif (result.isSuccess()) {\n    logger.info(\"Flag evaluated successfully\")\n}\n\nif (result.isFailure()) {\n    logger.warn(\"Flag evaluation failed\")\n}\n</code></pre> <p>Use when: You need boolean checks without extracting values</p>"},{"location":"Results/#toresult","title":"toResult()","text":"<p>Convert to Kotlin's <code>Result</code> type:</p> <pre><code>val result: Result&lt;Boolean&gt; = context.evaluateSafe(MY_FLAG).toResult()\n\nresult\n    .onSuccess { value -&gt; logger.info(\"Value: $value\") }\n    .onFailure { exception -&gt; logger.error(\"Failed\", exception) }\n</code></pre> <p>Note: Both <code>FlagNotFound</code> and <code>EvaluationError</code> become <code>Result.failure</code>. Use <code>fold()</code> if you need to distinguish them.</p> <p>Use when: Integrating with APIs that expect Kotlin's <code>Result</code> type</p>"},{"location":"Results/#evaluation-apis","title":"Evaluation APIs","text":"<p>Konditional provides multiple evaluation methods for different error handling needs:</p>"},{"location":"Results/#evaluatesafe-recommended","title":"evaluateSafe() - Recommended","text":"<p>Returns <code>EvaluationResult</code> with explicit error cases:</p> <pre><code>val result: EvaluationResult&lt;Boolean&gt; = context.evaluateSafe(AppFeatures.DARK_MODE)\n\nwhen (result) {\n    is EvaluationResult.Success -&gt; applyDarkMode(result.value)\n    is EvaluationResult.FlagNotFound -&gt; logger.warn(\"Flag not found: ${result.key}\")\n    is EvaluationResult.EvaluationError -&gt; logger.error(\"Evaluation failed\", result.error)\n}\n</code></pre> <p>Use when: You need precise error handling (recommended default)</p>"},{"location":"Results/#evaluateornull","title":"evaluateOrNull()","text":"<p>Returns <code>T?</code> - value on success, null on any failure:</p> <pre><code>val darkMode: Boolean? = context.evaluateOrNull(AppFeatures.DARK_MODE)\n\ndarkMode?.let { applyDarkMode(it) }\n</code></pre> <p>Use when: You don't need error details and null is acceptable</p>"},{"location":"Results/#evaluateordefault","title":"evaluateOrDefault()","text":"<p>Returns <code>T</code> - value on success, default on any failure:</p> <pre><code>val maxRetries: Int = context.evaluateOrDefault(\n    MyFeatures.MAX_RETRIES,\n    default = 3\n)\n</code></pre> <p>Use when: You have a sensible fallback and don't need error details</p>"},{"location":"Results/#evaluateorthrow","title":"evaluateOrThrow()","text":"<p>Returns <code>T</code> - value on success, throws exception on failure:</p> <pre><code>try {\n    val apiKey: String = context.evaluateOrThrow(MyFeatures.API_KEY)\n    initializeApi(apiKey)\n} catch (e: FlagNotFoundException) {\n    logger.error(\"Critical flag missing: ${e.key}\")\n    throw e\n} catch (e: FlagEvaluationException) {\n    logger.error(\"Evaluation failed: ${e.key}\", e)\n    throw e\n}\n</code></pre> <p>\u26a0\ufe0f Use sparingly: Only when flag absence is truly exceptional (programmer error)</p>"},{"location":"Results/#parseresult-parsing-outcomes","title":"ParseResult: Parsing Outcomes","text":"<p><code>ParseResult&lt;T&gt;</code> represents the outcome of parsing operations (versions, IDs, JSON, etc.).</p>"},{"location":"Results/#structure_1","title":"Structure","text":"<pre><code>sealed interface ParseResult&lt;out T&gt; {\n    data class Success&lt;T&gt;(val value: T) : ParseResult&lt;T&gt;\n    data class Failure(val error: ParseError) : ParseResult&lt;Nothing&gt;\n}\n</code></pre>"},{"location":"Results/#variants_1","title":"Variants","text":""},{"location":"Results/#success_1","title":"Success","text":"<p>Parsing succeeded:</p> <pre><code>val result: ParseResult&lt;Version&gt; = Version.parse(\"2.1.0\")\n\nwhen (result) {\n    is ParseResult.Success -&gt; {\n        val version: Version = result.value\n        println(\"Parsed: $version\")\n    }\n    // ...\n}\n</code></pre>"},{"location":"Results/#failure","title":"Failure","text":"<p>Parsing failed with structured error:</p> <pre><code>when (result) {\n    is ParseResult.Failure -&gt; {\n        val error: ParseError = result.error\n        logger.error(\"Parse failed: ${error.message}\")\n    }\n    // ...\n}\n</code></pre>"},{"location":"Results/#parseresult-utility-methods","title":"ParseResult Utility Methods","text":""},{"location":"Results/#fold_1","title":"fold()","text":"<p>Transform result into any type:</p> <pre><code>val outcome = Version.parse(input).fold(\n    onSuccess = { Outcome.Success(it) },\n    onFailure = { error -&gt; Outcome.Failure(MyError.InvalidVersion(error.message)) }\n)\n</code></pre>"},{"location":"Results/#map_1","title":"map()","text":"<p>Transform the success value:</p> <pre><code>val majorVersion: ParseResult&lt;Int&gt; = Version.parse(\"2.1.0\")\n    .map { it.major }  // Extract major version number\n</code></pre>"},{"location":"Results/#flatmap","title":"flatMap()","text":"<p>Chain dependent parsing operations:</p> <pre><code>val result: ParseResult&lt;Configuration&gt; = StableId.parse(idInput)\n    .flatMap { id -&gt;\n        Version.parse(versionInput).map { version -&gt;\n            Configuration(id, version)\n        }\n    }\n</code></pre> <p>Use when: Second parse depends on first parse's result</p>"},{"location":"Results/#getornull_1","title":"getOrNull()","text":"<p>Get value or null:</p> <pre><code>val version: Version? = Version.parse(\"2.1.0\").getOrNull()\n</code></pre>"},{"location":"Results/#getordefault_1","title":"getOrDefault()","text":"<p>Get value or default:</p> <pre><code>val version: Version = Version.parse(input).getOrDefault(Version(1, 0, 0))\n</code></pre>"},{"location":"Results/#getorelse_1","title":"getOrElse()","text":"<p>Get value or compute default from error:</p> <pre><code>val version: Version = Version.parse(input).getOrElse { error -&gt;\n    logger.warn(\"Invalid version: ${error.message}\")\n    Version(1, 0, 0)\n}\n</code></pre>"},{"location":"Results/#issuccess-isfailure_1","title":"isSuccess() / isFailure()","text":"<p>Check result status:</p> <pre><code>if (Version.parse(input).isSuccess()) {\n    println(\"Valid version\")\n}\n</code></pre>"},{"location":"Results/#onsuccess-onfailure","title":"onSuccess() / onFailure()","text":"<p>Execute side effects without changing the result:</p> <pre><code>val version = Version.parse(input)\n    .onSuccess { v -&gt; logger.info(\"Parsed version: $v\") }\n    .onFailure { e -&gt; logger.warn(\"Parse failed: ${e.message}\") }\n    .getOrDefault(Version(1, 0, 0))\n</code></pre> <p>Use when: Logging or metrics without transforming the result</p>"},{"location":"Results/#recover","title":"recover()","text":"<p>Recover from failure by providing a fallback value:</p> <pre><code>val version: Version = Version.parse(input)\n    .onFailure { error -&gt; logger.error(\"Invalid version: ${error.message}\") }\n    .recover { Version(1, 0, 0) }\n</code></pre> <p>Note: Unlike <code>getOrElse</code>, this always returns a value (not a <code>ParseResult</code>)</p>"},{"location":"Results/#toresult_1","title":"toResult()","text":"<p>Convert to Kotlin's <code>Result</code> type:</p> <pre><code>val result: Result&lt;Version&gt; = Version.parse(input).toResult()\n</code></pre>"},{"location":"Results/#getorthrow","title":"getOrThrow()","text":"<p>Get value or throw exception:</p> <pre><code>val version: Version = Version.parse(\"2.1.0\").getOrThrow()\n// Throws IllegalStateException if parsing fails\n</code></pre> <p>Use when: In tests or when you want fail-fast behavior</p>"},{"location":"Results/#parseerror-structured-parse-failures","title":"ParseError: Structured Parse Failures","text":"<p>All parse errors implement <code>ParseError</code> with structured error information:</p>"},{"location":"Results/#invalidhexid","title":"InvalidHexId","text":"<p>Failed to parse hexadecimal identifier:</p> <pre><code>data class InvalidHexId(val input: String, val message: String) : ParseError\n</code></pre> <p>Example: <pre><code>val result = StableId.parse(\"not-hex\")\n// Failure(InvalidHexId(\"not-hex\", \"Invalid hex format\"))\n</code></pre></p>"},{"location":"Results/#invalidrollout","title":"InvalidRollout","text":"<p>Rollout percentage outside valid range (0.0-100.0):</p> <pre><code>data class InvalidRollout(val value: Double, val message: String) : ParseError\n</code></pre> <p>Example: <pre><code>val result = Rollout.of(150.0)\n// Failure(InvalidRollout(150.0, \"Rollout must be between 0 and 100\"))\n</code></pre></p>"},{"location":"Results/#invalidversion","title":"InvalidVersion","text":"<p>Failed to parse semantic version:</p> <pre><code>data class InvalidVersion(val input: String, val message: String) : ParseError\n</code></pre> <p>Example: <pre><code>val result = Version.parse(\"1.x.0\")\n// Failure(InvalidVersion(\"1.x.0\", \"Invalid version format\"))\n</code></pre></p>"},{"location":"Results/#featurenotfound","title":"FeatureNotFound","text":"<p>Feature key not found in registry:</p> <pre><code>data class FeatureNotFound(val key: String) : ParseError {\n    val message: String get() = \"Feature not found: $key\"\n}\n</code></pre> <p>Example: <pre><code>val result = FeatureRegistry.get(\"unknown-feature\")\n// Failure(FeatureNotFound(\"unknown-feature\"))\n</code></pre></p>"},{"location":"Results/#flagnotfound_1","title":"FlagNotFound","text":"<p>Flag not found in registry:</p> <pre><code>data class FlagNotFound(val key: String) : ParseError {\n    val message: String get() = \"Flag not found: $key\"\n}\n</code></pre>"},{"location":"Results/#invalidsnapshot","title":"InvalidSnapshot","text":"<p>Failed to deserialize JSON snapshot:</p> <pre><code>data class InvalidSnapshot(val reason: String) : ParseError {\n    val message: String get() = \"Invalid snapshot: $reason\"\n}\n</code></pre> <p>Example: <pre><code>val result = SnapshotSerializer.fromJson(\"{invalid json}\")\n// Failure(InvalidSnapshot(\"Unexpected character...\"))\n</code></pre></p>"},{"location":"Results/#invalidjson","title":"InvalidJson","text":"<p>Invalid JSON data:</p> <pre><code>data class InvalidJson(val reason: String) : ParseError {\n    val message: String get() = \"Invalid JSON: $reason\"\n}\n</code></pre>"},{"location":"Results/#exception-types","title":"Exception Types","text":"<p>For APIs that throw exceptions instead of returning results:</p>"},{"location":"Results/#flagnotfoundexception","title":"FlagNotFoundException","text":"<p>Thrown when a flag is not registered:</p> <pre><code>class FlagNotFoundException(val key: String) : NoSuchElementException(\"Flag not found: $key\")\n</code></pre> <p>Thrown by: <code>context.evaluateOrThrow()</code> when flag doesn't exist</p> <p>Usage: <pre><code>try {\n    val value = context.evaluateOrThrow(MY_FLAG)\n} catch (e: FlagNotFoundException) {\n    logger.error(\"Missing flag: ${e.key}\")\n}\n</code></pre></p>"},{"location":"Results/#flagevaluationexception","title":"FlagEvaluationException","text":"<p>Thrown when flag evaluation fails:</p> <pre><code>class FlagEvaluationException(val key: String, cause: Throwable) :\n    RuntimeException(\"Flag evaluation failed: $key\", cause)\n</code></pre> <p>Thrown by: <code>context.evaluateOrThrow()</code> when evaluation throws</p> <p>Usage: <pre><code>try {\n    val value = context.evaluateOrThrow(MY_FLAG)\n} catch (e: FlagEvaluationException) {\n    logger.error(\"Evaluation failed: ${e.key}\", e.cause)\n}\n</code></pre></p>"},{"location":"Results/#parseexception","title":"ParseException","text":"<p>Wrapper for <code>ParseError</code> when using throwing APIs:</p> <pre><code>class ParseException(val error: ParseError) : Exception(error.message)\n</code></pre> <p>Usage: <pre><code>val result = Version.parse(input).toResult()\n\nresult.onFailure { exception -&gt;\n    if (exception is ParseException) {\n        when (val error = exception.error) {\n            is ParseError.InvalidVersion -&gt; handleInvalidVersion(error)\n            else -&gt; handleOtherError(error)\n        }\n    }\n}\n</code></pre></p>"},{"location":"Results/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"Results/#pattern-1-explicit-error-handling","title":"Pattern 1: Explicit Error Handling","text":"<p>When: You need precise control over each error case</p> <pre><code>when (val result = context.evaluateSafe(MY_FLAG)) {\n    is EvaluationResult.Success -&gt; {\n        // Use the value\n        processValue(result.value)\n    }\n    is EvaluationResult.FlagNotFound -&gt; {\n        // Flag not configured - use default\n        logger.warn(\"Flag not found: ${result.key}, using default\")\n        processValue(defaultValue)\n    }\n    is EvaluationResult.EvaluationError -&gt; {\n        // Evaluation failed - log and use fallback\n        logger.error(\"Evaluation failed: ${result.key}\", result.error)\n        processFallback()\n    }\n}\n</code></pre>"},{"location":"Results/#pattern-2-simple-default-fallback","title":"Pattern 2: Simple Default Fallback","text":"<p>When: You have a sensible default and don't need error details</p> <pre><code>val enabled = context.evaluateOrDefault(AppFeatures.NEW_UI, default = false)\n\nif (enabled) {\n    showNewUI()\n} else {\n    showLegacyUI()\n}\n</code></pre>"},{"location":"Results/#pattern-3-nullable-with-fallback-logic","title":"Pattern 3: Nullable with Fallback Logic","text":"<p>When: You want optional behavior based on flag presence</p> <pre><code>val customEndpoint: String? = context.evaluateOrNull(MyFeatures.CUSTOM_ENDPOINT)\n\nval endpoint = customEndpoint ?: defaultEndpoint\n\nhttpClient.configure { baseUrl = endpoint }\n</code></pre>"},{"location":"Results/#pattern-4-transformation-chains","title":"Pattern 4: Transformation Chains","text":"<p>When: Processing flag values through multiple steps</p> <pre><code>val config = context.evaluateSafe(MyFeatures.CONFIG_JSON)\n    .map { parseConfig(it) }\n    .map { validateConfig(it) }\n    .map { enrichConfig(it) }\n    .getOrElse { error -&gt;\n        logger.warn(\"Config loading failed: $error\")\n        defaultConfig\n    }\n</code></pre>"},{"location":"Results/#pattern-5-fail-fast-in-critical-paths","title":"Pattern 5: Fail-Fast in Critical Paths","text":"<p>When: Flag absence indicates programmer error</p> <pre><code>// During application initialization\nfun initializeApp() {\n    val apiKey = context.evaluateOrThrow(CriticalConfig.API_KEY)\n    val dbUrl = context.evaluateOrThrow(CriticalConfig.DATABASE_URL)\n\n    // If we get here, all critical config exists\n    initializeServices(apiKey, dbUrl)\n}\n</code></pre>"},{"location":"Results/#pattern-6-parsing-with-recovery","title":"Pattern 6: Parsing with Recovery","text":"<p>When: Parsing user input with graceful degradation</p> <pre><code>val version = Version.parse(userInput)\n    .onFailure { e -&gt; logger.warn(\"Invalid version: ${e.message}\") }\n    .getOrDefault(Version(1, 0, 0))\n</code></pre>"},{"location":"Results/#when-to-use-which-result-type","title":"When to Use Which Result Type","text":""},{"location":"Results/#use-evaluationresult-when","title":"Use EvaluationResult when:","text":"<ul> <li>Evaluating feature flags</li> <li>You need to distinguish between \"flag not found\" and \"evaluation failed\"</li> <li>Building monitoring/metrics around flag evaluation</li> <li>You want explicit, type-safe error handling</li> </ul>"},{"location":"Results/#use-parseresult-when","title":"Use ParseResult when:","text":"<ul> <li>Parsing version strings, IDs, rollout percentages</li> <li>Deserializing JSON configurations</li> <li>Loading snapshots from external sources</li> <li>You need structured error information for user feedback</li> </ul>"},{"location":"Results/#use-evaluateordefault-when","title":"Use evaluateOrDefault when:","text":"<ul> <li>You have a sensible default value</li> <li>Error details aren't important for your use case</li> <li>You want the simplest possible API</li> </ul>"},{"location":"Results/#use-evaluateornull-when","title":"Use evaluateOrNull when:","text":"<ul> <li>Null is semantically meaningful in your context</li> <li>You're working with nullable types already</li> <li>Error details aren't important</li> </ul>"},{"location":"Results/#use-evaluateorthrow-when","title":"Use evaluateOrThrow when:","text":"<ul> <li>Flag absence is a programmer error (should never happen in production)</li> <li>During application initialization with critical configuration</li> <li>In test code where fail-fast is desired</li> </ul>"},{"location":"Results/#summary","title":"Summary","text":"<p>EvaluationResult: - Three variants: <code>Success</code>, <code>FlagNotFound</code>, <code>EvaluationError</code> - Utilities: <code>fold</code>, <code>map</code>, <code>getOrNull</code>, <code>getOrDefault</code>, <code>getOrElse</code>, <code>isSuccess</code>, <code>isFailure</code>, <code>toResult</code> - Use for flag evaluation with precise error handling</p> <p>ParseResult: - Two variants: <code>Success</code>, <code>Failure</code> - Utilities: <code>fold</code>, <code>map</code>, <code>flatMap</code>, <code>getOrNull</code>, <code>getOrDefault</code>, <code>getOrElse</code>, <code>isSuccess</code>, <code>isFailure</code>, <code>onSuccess</code>, <code>onFailure</code>, <code>recover</code>, <code>toResult</code>, <code>getOrThrow</code> - Use for parsing operations with structured errors</p> <p>ParseError: - Seven variants: <code>InvalidHexId</code>, <code>InvalidRollout</code>, <code>InvalidVersion</code>, <code>FeatureNotFound</code>, <code>FlagNotFound</code>, <code>InvalidSnapshot</code>, <code>InvalidJson</code> - All provide structured error information with descriptive messages</p> <p>Exception Types: - <code>FlagNotFoundException</code>: Flag not registered - <code>FlagEvaluationException</code>: Evaluation threw an exception - <code>ParseException</code>: Wrapper for <code>ParseError</code> in throwing APIs</p> <p>Core Principle: Prefer result types (<code>evaluateSafe</code>, <code>ParseResult</code>) over exceptions for expected failure modes. Only use throwing APIs (<code>evaluateOrThrow</code>) when failure is truly exceptional.</p>"},{"location":"Results/#next-steps","title":"Next Steps","text":"<ul> <li>Evaluation: Understand rule matching and specificity</li> <li>Features: Define type-safe feature flags</li> <li>Serialization: Export and import configurations</li> <li>Overview: Back to API overview</li> </ul>"},{"location":"Rules/","title":"Rules: Advanced Targeting and Rollouts","text":"<p>This guide covers Konditional's rule system for sophisticated feature flag targeting, including platform/locale/version targeting, custom business logic, rollout strategies, and specificity-based evaluation ordering.</p>"},{"location":"Rules/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Rule Fundamentals</li> <li>RuleScope DSL</li> <li>Basic Targeting</li> <li>Version Targeting</li> <li>Rollout Strategies</li> <li>Specificity and Ordering</li> <li>Custom Evaluables</li> <li>Rule Composition</li> <li>Best Practices</li> <li>Testing Rules</li> </ul>"},{"location":"Rules/#rule-fundamentals","title":"Rule Fundamentals","text":""},{"location":"Rules/#what-are-rules","title":"What Are Rules?","text":"<p>A Rule defines when a specific value should be used for a feature flag. Rules combine targeting criteria (platform, locale, version, custom logic) with rollout percentages to enable sophisticated feature deployment strategies.</p> <pre><code>object AppFeatures : FeatureContainer&lt;Taxonomy.Global&gt;(Taxonomy.Global) {\n    val DARK_MODE by boolean(default = false) {\n        rule {\n            platforms(Platform.IOS)\n            rollout { 50.0 }\n        } implies true\n    }\n}\n</code></pre>"},{"location":"Rules/#how-rules-work","title":"How Rules Work","text":"<p>All criteria must match for a rule to apply (AND logic):</p> <pre><code>flowchart LR\n    Context[Context] --&gt; Platform{Platform&lt;br/&gt;matches?}\n    Platform --&gt;|No| Skip[Skip rule]\n    Platform --&gt;|Yes| Locale{Locale&lt;br/&gt;matches?}\n    Locale --&gt;|No| Skip\n    Locale --&gt;|Yes| Version{Version&lt;br/&gt;matches?}\n    Version --&gt;|No| Skip\n    Version --&gt;|Yes| Extension{Extension&lt;br/&gt;matches?}\n    Extension --&gt;|No| Skip\n    Extension --&gt;|Yes| Rollout{In rollout&lt;br/&gt;bucket?}\n    Rollout --&gt;|No| Skip\n    Rollout --&gt;|Yes| Return[Return&lt;br/&gt;rule value]\n\n    style Context fill:#e1f5ff\n    style Return fill:#c8e6c9\n    style Skip fill:#ffcdd2</code></pre> <p>If any criterion fails, the rule is skipped and evaluation continues to the next rule.</p>"},{"location":"Rules/#rulescope-dsl","title":"RuleScope DSL","text":"<p>The <code>RuleScope</code> interface provides the DSL for configuring rules. All methods are available within <code>rule { }</code> blocks:</p>"},{"location":"Rules/#available-methods","title":"Available Methods","text":"<pre><code>interface RuleScope&lt;C : Context&gt; {\n    // Platform targeting\n    fun platforms(vararg ps: Platform)\n\n    // Locale targeting\n    fun locales(vararg appLocales: AppLocale)\n\n    // Version range targeting\n    fun versions(build: VersionRangeScope.() -&gt; Unit)\n\n    // Custom business logic\n    fun extension(function: () -&gt; Evaluable&lt;C&gt;)\n\n    // Documentation note\n    fun note(text: String)\n\n    // Rollout percentage (0-100)\n    fun rollout(function: () -&gt; Number)\n}\n</code></pre>"},{"location":"Rules/#basic-rule-structure","title":"Basic Rule Structure","text":"<pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)\n    locales(AppLocale.EN_US, AppLocale.EN_CA)\n    versions {\n        min(2, 0, 0)\n        max(3, 0, 0)\n    }\n    extension {\n        // Custom business logic\n    }\n    rollout { 50.0 }\n    note(\"Mobile users, English locales, 50% rollout\")\n} implies value\n</code></pre> <p>All targeting criteria are optional - omitted criteria match everything.</p>"},{"location":"Rules/#basic-targeting","title":"Basic Targeting","text":""},{"location":"Rules/#platform-targeting","title":"Platform Targeting","text":"<p>Target specific platforms using <code>platforms()</code>:</p> <pre><code>// Single platform\nrule {\n    platforms(Platform.IOS)\n} implies \"ios-value\"\n\n// Multiple platforms (OR logic within platforms)\nrule {\n    platforms(Platform.IOS, Platform.ANDROID)\n} implies \"mobile-value\"\n</code></pre> <p>Available platforms: - <code>Platform.IOS</code> - <code>Platform.ANDROID</code> - <code>Platform.WEB</code> - <code>Platform.DESKTOP</code> - <code>Platform.SERVER</code></p> <p>Empty means all: Omitting <code>platforms()</code> matches all platforms.</p>"},{"location":"Rules/#locale-targeting","title":"Locale Targeting","text":"<p>Target users by language and region using <code>locales()</code>:</p> <pre><code>// Single locale\nrule {\n    locales(AppLocale.EN_US)\n} implies \"us-english\"\n\n// Multiple locales\nrule {\n    locales(AppLocale.EN_US, AppLocale.EN_CA, AppLocale.EN_GB)\n} implies \"english-value\"\n</code></pre> <p>Available locales: <code>EN_US</code>, <code>EN_CA</code>, <code>EN_GB</code>, <code>FR_FR</code>, <code>DE_DE</code>, <code>ES_US</code>, <code>ES_ES</code>, <code>IT_IT</code>, <code>PT_BR</code>, <code>JA_JP</code>, <code>ZH_CN</code>, <code>KO_KR</code>, <code>HI_IN</code>, <code>AR_SA</code>, <code>RU_RU</code>, <code>NL_NL</code>, <code>SV_SE</code>, <code>PL_PL</code>, <code>TR_TR</code>, <code>TH_TH</code></p> <p>Empty means all: Omitting <code>locales()</code> matches all locales.</p>"},{"location":"Rules/#combined-targeting","title":"Combined Targeting","text":"<p>Combine multiple criteria - all must match:</p> <pre><code>rule {\n    platforms(Platform.IOS, Platform.ANDROID)  // Must be iOS or Android\n    locales(AppLocale.EN_US)                   // AND must be US English\n    rollout { 50.0 }                           // AND must be in 50% bucket\n} implies value\n</code></pre>"},{"location":"Rules/#version-targeting","title":"Version Targeting","text":"<p>The <code>versions { }</code> block provides semantic version targeting through the <code>VersionRangeScope</code> interface.</p>"},{"location":"Rules/#versionrangescope-methods","title":"VersionRangeScope Methods","text":"<pre><code>interface VersionRangeScope {\n    // Minimum version (inclusive)\n    fun min(major: Int, minor: Int = 0, patch: Int = 0)\n\n    // Maximum version (exclusive)\n    fun max(major: Int, minor: Int = 0, patch: Int = 0)\n}\n</code></pre>"},{"location":"Rules/#version-ranges","title":"Version Ranges","text":"<pre><code>// Minimum version only (&gt;= 2.0.0)\nrule {\n    versions { min(2, 0, 0) }\n} implies \"new-feature\"\n\n// Maximum version only (&lt; 2.0.0)\nrule {\n    versions { max(2, 0, 0) }\n} implies \"legacy-value\"\n\n// Bounded range [1.5.0, 2.0.0)\nrule {\n    versions {\n        min(1, 5, 0)  // &gt;= 1.5.0\n        max(2, 0, 0)  // &lt; 2.0.0\n    }\n} implies \"transition-value\"\n\n// Exact version targeting\nrule {\n    versions {\n        min(2, 1, 3)\n        max(2, 1, 4)  // Matches only 2.1.3\n    }\n} implies \"specific-version\"\n</code></pre>"},{"location":"Rules/#version-range-types","title":"Version Range Types","text":"<p>Internally, version ranges are represented by sealed class types:</p> Type Description Example <code>FullyBound</code> Min and max specified <code>min(1, 0, 0); max(2, 0, 0)</code> <code>LeftBound</code> Only min specified <code>min(2, 0, 0)</code> <code>RightBound</code> Only max specified <code>max(2, 0, 0)</code> <code>Unbounded</code> No bounds (matches all) (omit versions block) <p>Empty means all: Omitting the <code>versions { }</code> block matches all versions.</p>"},{"location":"Rules/#rollout-strategies","title":"Rollout Strategies","text":"<p>Rollouts enable gradual feature deployment using deterministic, SHA-256-based bucketing.</p>"},{"location":"Rules/#setting-rollout-percentage","title":"Setting Rollout Percentage","text":"<p>Use the <code>rollout { }</code> function with a percentage value (0-100):</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    rollout { 25.0 }  // 25% of iOS users\n} implies true\n\n// Common rollout values\nrollout { 0.0 }    // 0% - effectively disabled\nrollout { 10.0 }   // 10% - canary/pilot\nrollout { 50.0 }   // 50% - A/B test\nrollout { 100.0 }  // 100% - full rollout (default if omitted)\n</code></pre>"},{"location":"Rules/#rollout-bucketing","title":"Rollout Bucketing","text":"<p>Konditional uses SHA-256 hashing for deterministic user bucketing:</p> <pre><code>flowchart LR\n    Salt[Salt: 'v1'] --&gt; Concat\n    Key[Flag Key] --&gt; Concat\n    StableId[StableId: 'user-123'] --&gt; Concat\n\n    Concat[Concatenate:&lt;br/&gt;'v1:flag_key:user-123'] --&gt; Hash[SHA-256&lt;br/&gt;Hash]\n    Hash --&gt; Bytes[First 4 bytes&lt;br/&gt;\u2192 int]\n    Bytes --&gt; Mod[Modulo&lt;br/&gt;10,000]\n    Mod --&gt; Bucket[Bucket:&lt;br/&gt;0-9999]\n    Bucket --&gt; Compare{Bucket &lt;&lt;br/&gt;rollout \u00d7 100?}\n\n    Compare --&gt;|Yes| Enabled[User ENABLED]\n    Compare --&gt;|No| Disabled[User DISABLED]\n\n    style Salt fill:#e1f5ff\n    style Key fill:#e1f5ff\n    style StableId fill:#e1f5ff\n    style Enabled fill:#c8e6c9\n    style Disabled fill:#ffcdd2</code></pre> <p>Key Properties:</p> Property Benefit Deterministic Same user always gets same bucket Independent Each flag has separate bucketing space Platform-Stable Same bucket across JVM, Android, iOS, web Fine-Grained 0.01% granularity (10,000 buckets) Redistributable Change salt to reassign buckets"},{"location":"Rules/#gradual-rollout-pattern","title":"Gradual Rollout Pattern","text":"<p>Increase rollout percentage over time for safe deployment:</p> <pre><code>// Phase 1: Start with 10%\nval NEW_CHECKOUT by boolean(default = false) {\n    rule {\n        rollout { 10.0 }\n        note(\"Phase 1 - Initial rollout\")\n    } implies true\n}\n\n// Phase 2: Increase to 50%\nval NEW_CHECKOUT by boolean(default = false) {\n    rule {\n        rollout { 50.0 }\n        note(\"Phase 2 - Expanded rollout\")\n    } implies true\n}\n\n// Phase 3: Full rollout\nval NEW_CHECKOUT by boolean(default = false) {\n    rule {\n        rollout { 100.0 }\n        note(\"Phase 3 - Complete rollout\")\n    } implies true\n}\n</code></pre>"},{"location":"Rules/#segmented-rollout-pattern","title":"Segmented Rollout Pattern","text":"<p>Different rollout percentages for different user segments:</p> <pre><code>val BETA_FEATURE by boolean(default = false) {\n    // 100% for internal users (highest specificity)\n    rule {\n        extension {\n            Evaluable.factory { ctx: EnterpriseContext -&gt;\n                ctx.organizationId == \"internal\"\n            }\n        }\n        rollout { 100.0 }\n    } implies true\n\n    // 50% for enterprise customers\n    rule {\n        extension {\n            Evaluable.factory { ctx: EnterpriseContext -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n            }\n        }\n        rollout { 50.0 }\n    } implies true\n\n    // 10% for all other users\n    rule {\n        rollout { 10.0 }\n    } implies true\n}\n</code></pre>"},{"location":"Rules/#changing-salt-for-redistribution","title":"Changing Salt for Redistribution","text":"<p>The <code>salt</code> affects bucketing. Change it to redistribute users:</p> <pre><code>val EXPERIMENT by boolean(default = false) {\n    salt(\"v1\")  // Original bucketing\n    rule {\n        rollout { 50.0 }\n    } implies true\n}\n\n// Later: Redistribute users by changing salt\nval EXPERIMENT by boolean(default = false) {\n    salt(\"v2\")  // New bucketing - different users enabled\n    rule {\n        rollout { 50.0 }\n    } implies true\n}\n</code></pre> <p>Use cases: Reset A/B tests, fix biased distributions, run new experiments.</p>"},{"location":"Rules/#specificity-and-ordering","title":"Specificity and Ordering","text":"<p>When multiple rules match a context, the most specific rule wins. Rules are automatically sorted by specificity (descending) at configuration time.</p>"},{"location":"Rules/#specificity-calculation","title":"Specificity Calculation","text":"<p>Formula: <pre><code>specificity = (platforms specified? 1 : 0)\n            + (locales specified? 1 : 0)\n            + (version range specified? 1 : 0)\n            + extension.specificity()\n</code></pre></p> <pre><code>graph TD\n    subgraph \"Specificity Rankings\"\n        S0[\"Specificity 0&lt;br/&gt;rule { } implies value\"]\n        S1[\"Specificity 1&lt;br/&gt;platforms(IOS)\"]\n        S2[\"Specificity 2&lt;br/&gt;platforms(IOS) + locales(EN_US)\"]\n        S3[\"Specificity 3&lt;br/&gt;platforms + locales + versions\"]\n        S4[\"Specificity 4+&lt;br/&gt;All base + extension\"]\n    end\n\n    S4 --&gt;|Evaluated first| S3\n    S3 --&gt; S2\n    S2 --&gt; S1\n    S1 --&gt;|Evaluated last| S0\n\n    style S4 fill:#4caf50\n    style S3 fill:#8bc34a\n    style S2 fill:#cddc39\n    style S1 fill:#ffeb3b\n    style S0 fill:#ffc107</code></pre>"},{"location":"Rules/#specificity-examples","title":"Specificity Examples","text":"<pre><code>// Specificity = 0 (no constraints)\nrule {\n} implies \"default-value\"\n\n// Specificity = 1 (one constraint)\nrule {\n    platforms(Platform.IOS)\n} implies \"ios-value\"\n\n// Specificity = 2 (two constraints)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n} implies \"ios-us-value\"\n\n// Specificity = 3 (three constraints)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n} implies \"ios-us-v2-value\"\n\n// Specificity = 4 (base + extension)\nrule {\n    platforms(Platform.IOS)\n    locales(AppLocale.EN_US)\n    versions { min(2, 0, 0) }\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt; {\n            override fun matches(context: EnterpriseContext) =\n                context.subscriptionTier == SubscriptionTier.ENTERPRISE\n            override fun specificity() = 1  // Adds +1 to total\n        }\n    }\n} implies \"enterprise-ios-us-v2-value\"\n</code></pre>"},{"location":"Rules/#evaluation-order-example","title":"Evaluation Order Example","text":"<pre><code>val THEME by string(default = \"light\") {\n    // Specificity = 2, evaluated FIRST\n    rule {\n        platforms(Platform.IOS)\n        locales(AppLocale.EN_US)\n    } implies \"dark-us-ios\"\n\n    // Specificity = 1, evaluated SECOND\n    rule {\n        platforms(Platform.IOS)\n    } implies \"dark-ios\"\n}\n\n// iOS + EN_US \u2192 \"dark-us-ios\" (most specific wins)\n// iOS + FR_FR \u2192 \"dark-ios\" (only second rule matches)\n// Android + * \u2192 \"light\" (default, no rules match)\n</code></pre>"},{"location":"Rules/#tie-breaking","title":"Tie-Breaking","text":"<p>When multiple rules have the same specificity, rules are sorted by <code>note</code> text alphabetically:</p> <pre><code>rule {\n    platforms(Platform.IOS)\n    note(\"A - First rule\")\n} implies value1\n\nrule {\n    platforms(Platform.IOS)\n    note(\"B - Second rule\")\n} implies value2\n\n// Both have specificity 1, sorted by note: \"A\" before \"B\"\n</code></pre>"},{"location":"Rules/#custom-evaluables","title":"Custom Evaluables","text":"<p>The <code>Evaluable</code> interface enables custom business logic beyond standard targeting.</p>"},{"location":"Rules/#evaluable-interface","title":"Evaluable Interface","text":"<pre><code>fun interface Evaluable&lt;in C : Context&gt; : Specifier {\n    fun matches(context: C): Boolean\n\n    companion object {\n        fun &lt;C : Context&gt; factory(matcher: (C) -&gt; Boolean): Evaluable&lt;C&gt;\n    }\n}\n\ninterface Specifier {\n    fun specificity(): Int = 1\n}\n</code></pre>"},{"location":"Rules/#pattern-1-factory-function-simplest","title":"Pattern 1: Factory Function (Simplest)","text":"<p>For simple lambda-based logic:</p> <pre><code>rule {\n    extension {\n        Evaluable.factory { ctx: EnterpriseContext -&gt;\n            ctx.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n            ctx.organizationId.startsWith(\"ent-\")\n        }\n    }\n} implies value\n</code></pre> <p>Note: Factory-created evaluables have default <code>specificity() = 1</code>.</p>"},{"location":"Rules/#pattern-2-object-expression","title":"Pattern 2: Object Expression","text":"<p>For inline logic with custom specificity:</p> <pre><code>rule {\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt; {\n            override fun matches(context: EnterpriseContext): Boolean {\n                return context.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n                       context.userRole == UserRole.ADMIN &amp;&amp;\n                       context.organizationSize &gt; 1000\n            }\n\n            override fun specificity(): Int = 3  // Three conditions = specificity 3\n        }\n    }\n} implies value\n</code></pre>"},{"location":"Rules/#pattern-3-reusable-classes","title":"Pattern 3: Reusable Classes","text":"<p>For complex logic used across multiple features:</p> <pre><code>class SubscriptionTierEvaluable(\n    private val allowedTiers: Set&lt;SubscriptionTier&gt;\n) : Evaluable&lt;EnterpriseContext&gt; {\n    override fun matches(context: EnterpriseContext): Boolean =\n        context.subscriptionTier in allowedTiers\n\n    override fun specificity(): Int = 1\n}\n\n// Reuse across features\nval PREMIUM_EXPORT by boolean(default = false) {\n    rule {\n        extension {\n            SubscriptionTierEvaluable(setOf(\n                SubscriptionTier.PROFESSIONAL,\n                SubscriptionTier.ENTERPRISE\n            ))\n        }\n    } implies true\n}\n\nval ADVANCED_ANALYTICS by boolean(default = false) {\n    rule {\n        extension {\n            SubscriptionTierEvaluable(setOf(SubscriptionTier.ENTERPRISE))\n        }\n    } implies true\n}\n</code></pre>"},{"location":"Rules/#specificity-best-practices","title":"Specificity Best Practices","text":"<p>Match specificity to constraint count:</p> <pre><code>object : Evaluable&lt;AppContext&gt; {\n    override fun matches(context: AppContext) =\n        context.userId.startsWith(\"test-\")  // 1 condition\n\n    override fun specificity() = 1  // Match constraint count\n}\n\nobject : Evaluable&lt;AppContext&gt; {\n    override fun matches(context: AppContext) =\n        context.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n        context.userRole == UserRole.ADMIN &amp;&amp;\n        context.organizationSize &gt; 100  // 3 conditions\n\n    override fun specificity() = 3  // Match constraint count\n}\n</code></pre> <p>This ensures more specific business logic is evaluated before less specific logic.</p>"},{"location":"Rules/#rule-composition","title":"Rule Composition","text":"<p>Rules compose base targeting (platform/locale/version) with custom extensions - all criteria must match.</p>"},{"location":"Rules/#composition-architecture","title":"Composition Architecture","text":"<pre><code>flowchart TD\n    Rule[Rule] --&gt; Base[Base Evaluable]\n    Rule --&gt; Ext[Extension Evaluable]\n\n    Base --&gt; Platform[Platform matching]\n    Base --&gt; Locale[Locale matching]\n    Base --&gt; Version[Version matching]\n\n    Ext --&gt; Custom[Custom business logic]\n\n    Platform --&gt; Combine{All&lt;br/&gt;criteria&lt;br/&gt;match?}\n    Locale --&gt; Combine\n    Version --&gt; Combine\n    Custom --&gt; Combine\n\n    Combine --&gt;|Yes| Rollout{In rollout&lt;br/&gt;bucket?}\n    Combine --&gt;|No| Skip[Skip rule]\n\n    Rollout --&gt;|Yes| Return[Return value]\n    Rollout --&gt;|No| Skip\n\n    style Rule fill:#e1f5ff\n    style Base fill:#fff9c4\n    style Ext fill:#f8d7da\n    style Return fill:#c8e6c9\n    style Skip fill:#ffcdd2</code></pre> <p>Matching formula: <pre><code>rule.matches(context) =\n    baseEvaluable.matches(context) &amp;&amp; extension.matches(context)\n</code></pre></p> <p>Specificity formula: <pre><code>rule.specificity() =\n    baseEvaluable.specificity() + extension.specificity()\n</code></pre></p>"},{"location":"Rules/#composition-example","title":"Composition Example","text":"<pre><code>rule {\n    // Base targeting (specificity = 2)\n    platforms(Platform.WEB)\n    locales(AppLocale.EN_US)\n\n    // Custom extension (specificity = 1)\n    extension {\n        object : Evaluable&lt;EnterpriseContext&gt; {\n            override fun matches(context: EnterpriseContext) =\n                context.organizationId.startsWith(\"ent-\")\n            override fun specificity() = 1\n        }\n    }\n\n    // Rollout bucketing\n    rollout { 50.0 }\n} implies value\n// Total specificity = 2 + 1 = 3\n</code></pre> <p>This rule matches only when: 1. Platform is WEB AND 2. Locale is EN_US AND 3. Organization ID starts with \"ent-\" AND 4. User is in the 50% rollout bucket</p>"},{"location":"Rules/#best-practices","title":"Best Practices","text":""},{"location":"Rules/#1-design-rules-from-specific-to-general","title":"1. Design Rules from Specific to General","text":"<p>While Konditional auto-sorts by specificity, organizing rules from most to least specific makes configurations clearer:</p> <pre><code>val API_ENDPOINT by string(default = \"https://api.prod.com\") {\n    // Most specific: enterprise iOS users on v2\n    rule {\n        platforms(Platform.IOS)\n        versions { min(2, 0, 0) }\n        extension {\n            Evaluable.factory { ctx: EnterpriseContext -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n            }\n        }\n    } implies \"https://api-enterprise-ios-v2.com\"\n\n    // Less specific: all enterprise users\n    rule {\n        extension {\n            Evaluable.factory { ctx: EnterpriseContext -&gt;\n                ctx.subscriptionTier == SubscriptionTier.ENTERPRISE\n            }\n        }\n    } implies \"https://api-enterprise.com\"\n\n    // Least specific: iOS users\n    rule {\n        platforms(Platform.IOS)\n    } implies \"https://api-ios.com\"\n}\n</code></pre>"},{"location":"Rules/#2-separate-technical-and-business-concerns","title":"2. Separate Technical and Business Concerns","text":"<p>Use base targeting for technical criteria, extensions for business logic:</p> <pre><code>rule {\n    // Technical targeting\n    platforms(Platform.WEB)\n    versions { min(2, 0, 0) }\n\n    // Business logic\n    extension {\n        SubscriptionTierEvaluable(setOf(SubscriptionTier.ENTERPRISE))\n    }\n} implies value\n</code></pre>"},{"location":"Rules/#3-document-non-obvious-logic","title":"3. Document Non-Obvious Logic","text":"<p>Use <code>note()</code> to explain complex targeting decisions:</p> <pre><code>rule {\n    platforms(Platform.ANDROID)\n    versions {\n        min(1, 9, 0)\n        max(2, 1, 0)\n    }\n    rollout { 15.0 }\n    note(\"Workaround for Android bug #1234 - affects v1.9.0-2.0.x only\")\n} implies workaroundValue\n</code></pre>"},{"location":"Rules/#4-use-type-safe-custom-contexts","title":"4. Use Type-Safe Custom Contexts","text":"<p>Define custom contexts for domain-specific targeting:</p> <pre><code>data class EnterpriseContext(\n    override val locale: AppLocale,\n    override val platform: Platform,\n    override val appVersion: Version,\n    override val stableId: StableId,\n    val subscriptionTier: SubscriptionTier,\n    val organizationId: String,\n    val userRole: UserRole,\n) : Context\n\n// Use in features\nenum class EnterpriseFeatures(override val key: String) :\n    Conditional&lt;Boolean, EnterpriseContext&gt; {\n    ADVANCED_ANALYTICS(\"advanced_analytics\")\n}\n\n// Extensions are type-safe\nrule {\n    extension {\n        Evaluable.factory { ctx: EnterpriseContext -&gt;\n            ctx.subscriptionTier == SubscriptionTier.ENTERPRISE  // \u2713 Type-safe\n        }\n    }\n} implies true\n</code></pre>"},{"location":"Rules/#5-match-specificity-to-constraint-count","title":"5. Match Specificity to Constraint Count","text":"<p>Your custom <code>specificity()</code> should reflect the number of constraints:</p> <pre><code>// 1 constraint \u2192 specificity 1\nobject : Evaluable&lt;AppContext&gt; {\n    override fun matches(context: AppContext) =\n        context.userId.startsWith(\"beta-\")\n    override fun specificity() = 1\n}\n\n// 3 constraints \u2192 specificity 3\nobject : Evaluable&lt;AppContext&gt; {\n    override fun matches(context: AppContext) =\n        context.subscriptionTier == SubscriptionTier.ENTERPRISE &amp;&amp;\n        context.userRole == UserRole.ADMIN &amp;&amp;\n        context.organizationSize &gt; 1000\n    override fun specificity() = 3\n}\n</code></pre>"},{"location":"Rules/#6-test-rollout-distribution","title":"6. Test Rollout Distribution","text":"<p>For probabilistic rollouts, test with multiple stable IDs:</p> <pre><code>@Test\nfun `50 percent rollout distributes approximately evenly`() {\n    val enabled = (1..1000).count { i -&gt;\n        val ctx = Context(\n            locale = AppLocale.EN_US,\n            platform = Platform.IOS,\n            appVersion = Version(1, 0, 0),\n            stableId = StableId.of(\"user-$i\")\n        )\n        ctx.evaluateOrDefault(Features.NEW_FEATURE, default = false)\n    }\n\n    // Expect ~50% with 10% variance\n    assertTrue(enabled in 450..550)\n}\n</code></pre>"},{"location":"Rules/#testing-rules","title":"Testing Rules","text":""},{"location":"Rules/#test-rule-matching","title":"Test Rule Matching","text":"<pre><code>@Test\nfun `enterprise iOS users on v2 get premium endpoint`() {\n    val context = EnterpriseContext(\n        platform = Platform.IOS,\n        appVersion = Version(2, 1, 0),\n        subscriptionTier = SubscriptionTier.ENTERPRISE,\n        stableId = StableId.of(\"test-user\"),\n        // ...\n    )\n\n    val result = context.evaluateSafe(Features.API_ENDPOINT)\n    assertEquals(\"https://api-enterprise-ios-v2.com\",\n                 (result as EvaluationResult.Success).value)\n}\n</code></pre>"},{"location":"Rules/#test-specificity-ordering","title":"Test Specificity Ordering","text":"<pre><code>@Test\nfun `most specific rule wins when multiple match`() {\n    val context = Context(\n        platform = Platform.IOS,\n        locale = AppLocale.EN_US,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"test-user\")\n    )\n\n    val result = context.evaluateOrDefault(Features.THEME, default = \"light\")\n\n    // Both rules match, but specificity=2 wins over specificity=1\n    assertEquals(\"dark-us-ios\", result)\n}\n</code></pre>"},{"location":"Rules/#test-rollout-determinism","title":"Test Rollout Determinism","text":"<pre><code>@Test\nfun `rollout is deterministic for same user`() {\n    val context = Context(\n        platform = Platform.IOS,\n        locale = AppLocale.EN_US,\n        appVersion = Version(1, 0, 0),\n        stableId = StableId.of(\"user-123\")\n    )\n\n    val result1 = context.evaluateOrDefault(Features.NEW_FEATURE, default = false)\n    val result2 = context.evaluateOrDefault(Features.NEW_FEATURE, default = false)\n\n    assertEquals(result1, result2)  // Always same result\n}\n</code></pre>"},{"location":"Rules/#test-custom-evaluables","title":"Test Custom Evaluables","text":"<pre><code>@Test\nfun `custom evaluable matches correct contexts`() {\n    val evaluable = SubscriptionTierEvaluable(setOf(\n        SubscriptionTier.PROFESSIONAL,\n        SubscriptionTier.ENTERPRISE\n    ))\n\n    val enterpriseCtx = mockEnterpriseContext(\n        subscriptionTier = SubscriptionTier.ENTERPRISE\n    )\n    assertTrue(evaluable.matches(enterpriseCtx))\n\n    val basicCtx = mockEnterpriseContext(\n        subscriptionTier = SubscriptionTier.BASIC\n    )\n    assertFalse(evaluable.matches(basicCtx))\n}\n</code></pre>"},{"location":"Rules/#summary-rule-system-guarantees","title":"Summary: Rule System Guarantees","text":"Aspect Guarantee Matching Logic All criteria must match (AND logic) Specificity More specific rules always evaluated first Rollout Bucketing SHA-256 ensures deterministic, independent bucketing Type Safety Context and value types enforced at compile time Determinism Same inputs always produce same outputs Composability Base + extension evaluables compose cleanly Thread Safety Lock-free reads, immutable rule data <p>Core Principle: Rules provide compile-time type-safe, deterministic targeting with automatic specificity-based ordering.</p>"},{"location":"Rules/#next-steps","title":"Next Steps","text":"<ul> <li>Evaluation - Deep dive into flag evaluation mechanics</li> <li>Context - Design custom evaluation contexts</li> <li>Features - Feature flag definition patterns</li> <li>Overview - Complete API overview</li> </ul>"},{"location":"Serialization/","title":"Serialization","text":"<p>Export and import feature flag configurations as JSON for remote configuration, database persistence, and version control.</p>"},{"location":"Serialization/#overview","title":"Overview","text":"<p>Konditional's serialization system provides type-safe JSON conversion for feature flag configurations. The serialization API follows parse-don't-validate principles, returning <code>ParseResult</code> instead of throwing exceptions, enabling compile-time-checked error handling.</p> <p>Core Principles:</p> <ul> <li>Storage-agnostic: Serialization handles only JSON conversion - you choose the storage (files, databases, cloud storage)</li> <li>Type-safe parsing: All deserialization returns <code>ParseResult&lt;T&gt;</code> for structured error handling</li> <li>Taxonomy isolation: Serialize and load configurations per taxonomy for independent deployment</li> <li>Patch support: Apply incremental updates without replacing entire configurations</li> </ul> <p>Use Cases:</p> <ul> <li>Remote configuration delivery from servers or CDNs</li> <li>Database persistence for dynamic flag management</li> <li>Configuration versioning and rollback</li> <li>Backup and restore operations</li> <li>A/B test configuration management</li> </ul>"},{"location":"Serialization/#snapshotserializer","title":"SnapshotSerializer","text":"<p><code>SnapshotSerializer</code> is the primary serialization API for converting entire <code>Konfig</code> snapshots to and from JSON.</p>"},{"location":"Serialization/#serializing-configurations","title":"Serializing Configurations","text":"<p>Convert a <code>Konfig</code> to JSON format:</p> <pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\nimport io.amichne.konditional.core.Taxonomy\n\n// Get current configuration\nval konfig = Taxonomy.Global.konfig()\n\n// Serialize to JSON string\nval json = SnapshotSerializer.serialize(konfig)\n\n// Store however you like\nFile(\"config/flags.json\").writeText(json)\n</code></pre> <p>Output format: 2-space indented JSON for readability.</p>"},{"location":"Serialization/#deserializing-configurations","title":"Deserializing Configurations","text":"<p>Parse JSON back into a <code>Konfig</code>:</p> <pre><code>// Load JSON from your storage\nval json = File(\"config/flags.json\").readText()\n\n// Deserialize with type-safe error handling\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; {\n        val konfig = result.value\n        println(\"Loaded ${konfig.flags.size} flags\")\n\n        // Load into taxonomy\n        Taxonomy.Global.load(konfig)\n    }\n    is ParseResult.Failure -&gt; {\n        when (val error = result.error) {\n            is ParseError.InvalidJson -&gt;\n                println(\"JSON parsing failed: ${error.message}\")\n            is ParseError.FeatureNotFound -&gt;\n                println(\"Unknown feature: ${error.key}\")\n            is ParseError.InvalidSnapshot -&gt;\n                println(\"Invalid configuration: ${error.message}\")\n        }\n    }\n}\n</code></pre> <p>Important: <code>fromJson()</code> does NOT automatically load the configuration into any taxonomy. You must explicitly call <code>Taxonomy.load()</code> if you want to update the runtime configuration.</p>"},{"location":"Serialization/#applying-patch-updates","title":"Applying Patch Updates","text":"<p>Apply incremental changes to an existing configuration without replacing it entirely:</p> <pre><code>// Current configuration\nval currentKonfig = Taxonomy.Global.konfig()\n\n// Patch JSON (adds, updates, or removes specific flags)\nval patchJson = \"\"\"\n{\n  \"flags\": [\n    {\n      \"key\": \"new_feature\",\n      \"defaultValue\": {\n        \"type\": \"BOOLEAN\",\n        \"value\": true\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": []\n    }\n  ],\n  \"removeKeys\": [\"deprecated_flag\"]\n}\n\"\"\".trimIndent()\n\n// Apply patch\nwhen (val result = SnapshotSerializer.applyPatchJson(currentKonfig, patchJson)) {\n    is ParseResult.Success -&gt; {\n        val patchedKonfig = result.value\n        Taxonomy.Global.load(patchedKonfig)\n        println(\"Patch applied successfully\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Patch failed: ${result.error}\")\n    }\n}\n</code></pre> <p>Patch operations: - Flags in <code>flags</code> array are added or updated (by key) - Keys in <code>removeKeys</code> array are removed from configuration - Existing flags not mentioned are preserved unchanged</p>"},{"location":"Serialization/#custom-moshi-configuration","title":"Custom Moshi Configuration","text":"<p>Access the default Moshi instance for advanced use cases:</p> <pre><code>import com.squareup.moshi.Moshi\n\nval moshi: Moshi = SnapshotSerializer.defaultMoshi()\n\n// Use for custom adapters or inspection\n</code></pre> <p>Note: The default Moshi includes all necessary adapters for Konditional types (version ranges, flag values, etc.). Most users never need to access this directly.</p>"},{"location":"Serialization/#taxonomysnapshotserializer","title":"TaxonomySnapshotSerializer","text":"<p><code>TaxonomySnapshotSerializer</code> provides taxonomy-scoped serialization, enabling independent configuration management per domain.</p>"},{"location":"Serialization/#creating-a-taxonomy-serializer","title":"Creating a Taxonomy Serializer","text":"<p>Create a serializer for a specific taxonomy:</p> <pre><code>import io.amichne.konditional.serialization.TaxonomySnapshotSerializer\n\n// Constructor approach\nval serializer = TaxonomySnapshotSerializer(Taxonomy.Domain.Payments)\n\n// Or factory method\nval serializer = TaxonomySnapshotSerializer.forModule(Taxonomy.Domain.Payments)\n</code></pre>"},{"location":"Serialization/#serializing-a-taxonomy","title":"Serializing a Taxonomy","text":"<p>Export only the flags from a specific taxonomy:</p> <pre><code>val serializer = TaxonomySnapshotSerializer(Taxonomy.Domain.Payments)\n\n// Serialize current state\nval json = serializer.toJson()\n\n// Save to taxonomy-specific storage\nFile(\"configs/payments.json\").writeText(json)\n</code></pre> <p>Isolation: Only flags from the specified taxonomy are included in the output.</p>"},{"location":"Serialization/#deserializing-into-a-taxonomy","title":"Deserializing into a Taxonomy","text":"<p>Load JSON and automatically update the taxonomy:</p> <pre><code>val serializer = TaxonomySnapshotSerializer(Taxonomy.Domain.Payments)\n\n// Load from storage\nval json = File(\"configs/payments.json\").readText()\n\n// Deserialize and load (automatic side effect)\nwhen (val result = serializer.fromJson(json)) {\n    is ParseResult.Success -&gt; {\n        // Configuration already loaded into Taxonomy.Domain.Payments\n        println(\"Loaded ${result.value.flags.size} payment flags\")\n    }\n    is ParseResult.Failure -&gt; {\n        println(\"Failed to load: ${result.error}\")\n    }\n}\n</code></pre> <p>Important side effect: Unlike <code>SnapshotSerializer.fromJson()</code>, this method automatically loads the deserialized configuration into the taxonomy upon success. The taxonomy's runtime state is immediately updated.</p>"},{"location":"Serialization/#taxonomy-isolation-example","title":"Taxonomy Isolation Example","text":"<p>Manage multiple domains independently:</p> <pre><code>// Serialize each taxonomy separately\nval authSerializer = TaxonomySnapshotSerializer(Taxonomy.Domain.Authentication)\nval paymentSerializer = TaxonomySnapshotSerializer(Taxonomy.Domain.Payments)\n\nval authJson = authSerializer.toJson()\nval paymentJson = paymentSerializer.toJson()\n\n// Store in separate locations\ns3.put(\"configs/auth.json\", authJson)\ns3.put(\"configs/payments.json\", paymentJson)\n\n// Load independently (e.g., different deployment schedules)\nauthSerializer.fromJson(s3.get(\"configs/auth.json\"))\npaymentSerializer.fromJson(s3.get(\"configs/payments.json\"))\n</code></pre> <p>Benefits: - Independent deployment schedules per domain - Reduced blast radius (errors in one taxonomy don't affect others) - Team ownership boundaries (each team manages their own config)</p>"},{"location":"Serialization/#serializer-interface","title":"Serializer Interface","text":"<p>The <code>Serializer&lt;T&gt;</code> interface provides a common contract for custom serialization implementations.</p> <pre><code>interface Serializer&lt;T&gt; {\n    fun toJson(): String\n    fun fromJson(json: String): ParseResult&lt;T&gt;\n}\n</code></pre>"},{"location":"Serialization/#when-to-use","title":"When to Use","text":"<ul> <li><code>TaxonomySnapshotSerializer</code> implements this interface for taxonomy-scoped serialization</li> <li><code>SnapshotSerializer</code> is an object with static methods and does NOT implement this interface</li> <li>Custom implementations for specialized serialization needs</li> </ul>"},{"location":"Serialization/#example-usage","title":"Example Usage","text":"<pre><code>val serializer: Serializer&lt;Konfig&gt; = TaxonomySnapshotSerializer(Taxonomy.Global)\n\n// Polymorphic usage\nfun saveConfig(serializer: Serializer&lt;Konfig&gt;, path: String) {\n    val json = serializer.toJson()\n    File(path).writeText(json)\n}\n\nfun loadConfig(serializer: Serializer&lt;Konfig&gt;, path: String): ParseResult&lt;Konfig&gt; {\n    val json = File(path).readText()\n    return serializer.fromJson(json)\n}\n</code></pre>"},{"location":"Serialization/#json-format-reference","title":"JSON Format Reference","text":"<p>Konditional uses a structured JSON format for flag configurations.</p>"},{"location":"Serialization/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>{\n  \"flags\": [\n    // Array of flag definitions\n  ]\n}\n</code></pre>"},{"location":"Serialization/#flag-definition-format","title":"Flag Definition Format","text":"<p>Each flag has this structure:</p> <pre><code>{\n  \"key\": \"feature_key\",\n  \"defaultValue\": {\n    \"type\": \"BOOLEAN\",\n    \"value\": true\n  },\n  \"salt\": \"v1\",\n  \"isActive\": true,\n  \"rules\": [\n    // Array of rule definitions\n  ]\n}\n</code></pre> <p>Fields:</p> <ul> <li><code>key</code> (string, required): Unique flag identifier</li> <li><code>defaultValue</code> (object, required): Default value with type</li> <li><code>salt</code> (string, optional): Salt for rollout bucketing (default: \"v1\")</li> <li><code>isActive</code> (boolean, optional): Whether flag is active (default: true)</li> <li><code>rules</code> (array, optional): Conditional value rules (default: empty)</li> </ul>"},{"location":"Serialization/#rule-format","title":"Rule Format","text":"<p>Rules define targeting criteria and conditional values:</p> <pre><code>{\n  \"value\": {\n    \"type\": \"BOOLEAN\",\n    \"value\": true\n  },\n  \"rampUp\": 50.0,\n  \"note\": \"iOS users, 50% rollout\",\n  \"platforms\": [\"IOS\", \"ANDROID\"],\n  \"locales\": [\"EN_US\", \"EN_CA\"],\n  \"versionRange\": {\n    \"type\": \"MIN_AND_MAX_BOUND\",\n    \"min\": {\n      \"major\": 2,\n      \"minor\": 0,\n      \"patch\": 0\n    },\n    \"max\": {\n      \"major\": 3,\n      \"minor\": 0,\n      \"patch\": 0\n    }\n  }\n}\n</code></pre> <p>Fields:</p> <ul> <li><code>value</code> (object, required): Value to return when rule matches</li> <li><code>rampUp</code> (number, optional): Rollout percentage 0.0-100.0 (default: 100.0)</li> <li><code>note</code> (string, optional): Documentation note</li> <li><code>platforms</code> (array, optional): Allowed platforms (default: all)</li> <li><code>locales</code> (array, optional): Allowed locales (default: all)</li> <li><code>versionRange</code> (object, optional): Version constraints (default: all versions)</li> </ul>"},{"location":"Serialization/#supported-value-types","title":"Supported Value Types","text":"<p>Konditional supports five value types in JSON.</p>"},{"location":"Serialization/#boolean","title":"BOOLEAN","text":"<p>Boolean true/false values:</p> <pre><code>{\n  \"type\": \"BOOLEAN\",\n  \"value\": true\n}\n</code></pre>"},{"location":"Serialization/#string","title":"STRING","text":"<p>Text values:</p> <pre><code>{\n  \"type\": \"STRING\",\n  \"value\": \"production-api-endpoint\"\n}\n</code></pre>"},{"location":"Serialization/#int","title":"INT","text":"<p>Integer values:</p> <pre><code>{\n  \"type\": \"INT\",\n  \"value\": 42\n}\n</code></pre>"},{"location":"Serialization/#double","title":"DOUBLE","text":"<p>Decimal values:</p> <pre><code>{\n  \"type\": \"DOUBLE\",\n  \"value\": 3.14159\n}\n</code></pre>"},{"location":"Serialization/#json-data-classes","title":"JSON (Data Classes)","text":"<p>Complex structured data:</p> <pre><code>{\n  \"type\": \"JSON\",\n  \"value\": {\n    \"primaryColor\": \"#FFFFFF\",\n    \"fontSize\": 14,\n    \"darkMode\": false\n  }\n}\n</code></pre> <p>Note: JSON values must match the data class structure expected by the feature definition.</p>"},{"location":"Serialization/#version-range-types","title":"Version Range Types","text":"<p>Version ranges use different JSON structures based on bound type.</p>"},{"location":"Serialization/#unbounded-all-versions","title":"Unbounded (All Versions)","text":"<pre><code>{\n  \"type\": \"UNBOUNDED\"\n}\n</code></pre> <p>Matches all versions.</p>"},{"location":"Serialization/#minimum-bound-only","title":"Minimum Bound Only","text":"<pre><code>{\n  \"type\": \"MIN_BOUND\",\n  \"min\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre> <p>Matches version &gt;= 2.0.0.</p>"},{"location":"Serialization/#maximum-bound-only","title":"Maximum Bound Only","text":"<pre><code>{\n  \"type\": \"MAX_BOUND\",\n  \"max\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre> <p>Matches version &lt;= 2.0.0.</p>"},{"location":"Serialization/#both-bounds","title":"Both Bounds","text":"<pre><code>{\n  \"type\": \"MIN_AND_MAX_BOUND\",\n  \"min\": {\n    \"major\": 1,\n    \"minor\": 5,\n    \"patch\": 0\n  },\n  \"max\": {\n    \"major\": 2,\n    \"minor\": 0,\n    \"patch\": 0\n  }\n}\n</code></pre> <p>Matches version &gt;= 1.5.0 AND &lt;= 2.0.0.</p>"},{"location":"Serialization/#patch-format","title":"Patch Format","text":"<p>Patches enable incremental configuration updates.</p>"},{"location":"Serialization/#patch-structure","title":"Patch Structure","text":"<pre><code>{\n  \"flags\": [\n    // Flags to add or update\n  ],\n  \"removeKeys\": [\n    // Flag keys to remove\n  ]\n}\n</code></pre>"},{"location":"Serialization/#adding-a-flag","title":"Adding a Flag","text":"<pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"new_feature\",\n      \"defaultValue\": {\n        \"type\": \"BOOLEAN\",\n        \"value\": false\n      },\n      \"salt\": \"v1\",\n      \"isActive\": true,\n      \"rules\": []\n    }\n  ],\n  \"removeKeys\": []\n}\n</code></pre>"},{"location":"Serialization/#updating-a-flag","title":"Updating a Flag","text":"<p>Same structure - flags are matched by key:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"existing_feature\",\n      \"defaultValue\": {\n        \"type\": \"BOOLEAN\",\n        \"value\": true\n      },\n      \"salt\": \"v2\",\n      \"isActive\": true,\n      \"rules\": [\n        {\n          \"value\": {\n            \"type\": \"BOOLEAN\",\n            \"value\": false\n          },\n          \"rampUp\": 50.0,\n          \"platforms\": [\"IOS\"]\n        }\n      ]\n    }\n  ],\n  \"removeKeys\": []\n}\n</code></pre>"},{"location":"Serialization/#removing-a-flag","title":"Removing a Flag","text":"<pre><code>{\n  \"flags\": [],\n  \"removeKeys\": [\"deprecated_feature\", \"old_experiment\"]\n}\n</code></pre>"},{"location":"Serialization/#combined-operations","title":"Combined Operations","text":"<p>Add, update, and remove in a single patch:</p> <pre><code>{\n  \"flags\": [\n    {\n      \"key\": \"updated_feature\",\n      \"defaultValue\": {\n        \"type\": \"STRING\",\n        \"value\": \"new-default\"\n      }\n    },\n    {\n      \"key\": \"new_feature\",\n      \"defaultValue\": {\n        \"type\": \"INT\",\n        \"value\": 100\n      }\n    }\n  ],\n  \"removeKeys\": [\"old_feature\"]\n}\n</code></pre>"},{"location":"Serialization/#common-patterns","title":"Common Patterns","text":""},{"location":"Serialization/#remote-configuration","title":"Remote Configuration","text":"<p>Fetch configuration from a remote server:</p> <pre><code>import io.amichne.konditional.serialization.SnapshotSerializer\nimport java.net.URL\n\nsuspend fun fetchRemoteConfig(url: String) {\n    try {\n        // Fetch JSON from server\n        val json = URL(url).readText()\n\n        // Parse and validate\n        when (val result = SnapshotSerializer.fromJson(json)) {\n            is ParseResult.Success -&gt; {\n                // Load into taxonomy\n                Taxonomy.Global.load(result.value)\n                println(\"Remote config loaded successfully\")\n            }\n            is ParseResult.Failure -&gt; {\n                println(\"Failed to parse remote config: ${result.error}\")\n                // Fall back to local cached config\n                loadCachedConfig()\n            }\n        }\n    } catch (e: Exception) {\n        println(\"Network error: ${e.message}\")\n        loadCachedConfig()\n    }\n}\n\n// Periodic polling\nsuspend fun pollRemoteConfig(url: String, intervalMs: Long) {\n    while (true) {\n        fetchRemoteConfig(url)\n        delay(intervalMs)\n    }\n}\n</code></pre> <p>Best practices: - Cache configurations locally for offline support - Validate JSON before loading to avoid partial updates - Use versioning to prevent applying stale configurations</p>"},{"location":"Serialization/#database-storage","title":"Database Storage","text":"<p>Store configurations in a database:</p> <pre><code>import io.amichne.konditional.serialization.TaxonomySnapshotSerializer\n\n// Save to database\nfun saveToDatabase(taxonomy: Taxonomy, db: Database) {\n    val serializer = TaxonomySnapshotSerializer(taxonomy)\n    val json = serializer.toJson()\n\n    db.execute(\n        \"INSERT OR REPLACE INTO configurations (taxonomy_id, json, updated_at) VALUES (?, ?, ?)\",\n        taxonomy.id,\n        json,\n        System.currentTimeMillis()\n    )\n}\n\n// Load from database\nfun loadFromDatabase(taxonomy: Taxonomy, db: Database) {\n    val row = db.query(\n        \"SELECT json FROM configurations WHERE taxonomy_id = ?\",\n        taxonomy.id\n    ).firstOrNull()\n\n    if (row != null) {\n        val serializer = TaxonomySnapshotSerializer(taxonomy)\n        when (val result = serializer.fromJson(row[\"json\"] as String)) {\n            is ParseResult.Success -&gt;\n                println(\"Loaded from database: ${result.value.flags.size} flags\")\n            is ParseResult.Failure -&gt;\n                println(\"Database config invalid: ${result.error}\")\n        }\n    }\n}\n\n// Audit trail\nfun saveWithHistory(taxonomy: Taxonomy, db: Database, userId: String) {\n    val serializer = TaxonomySnapshotSerializer(taxonomy)\n    val json = serializer.toJson()\n\n    db.transaction {\n        // Update current config\n        execute(\n            \"INSERT OR REPLACE INTO configurations (taxonomy_id, json) VALUES (?, ?)\",\n            taxonomy.id, json\n        )\n\n        // Save to history\n        execute(\n            \"INSERT INTO config_history (taxonomy_id, json, user_id, created_at) VALUES (?, ?, ?, ?)\",\n            taxonomy.id, json, userId, System.currentTimeMillis()\n        )\n    }\n}\n</code></pre>"},{"location":"Serialization/#backup-and-restore","title":"Backup and Restore","text":"<p>Version control and rollback:</p> <pre><code>// Backup current configuration\nfun backupConfiguration(taxonomy: Taxonomy, backupDir: File) {\n    val serializer = TaxonomySnapshotSerializer(taxonomy)\n    val json = serializer.toJson()\n\n    val timestamp = System.currentTimeMillis()\n    val filename = \"${taxonomy.id}-$timestamp.json\"\n\n    backupDir.resolve(filename).writeText(json)\n    println(\"Backed up to $filename\")\n}\n\n// List available backups\nfun listBackups(taxonomy: Taxonomy, backupDir: File): List&lt;File&gt; {\n    return backupDir.listFiles { file -&gt;\n        file.name.startsWith(\"${taxonomy.id}-\") &amp;&amp; file.extension == \"json\"\n    }?.sortedByDescending { it.name } ?: emptyList()\n}\n\n// Restore from backup\nfun restoreConfiguration(taxonomy: Taxonomy, backupFile: File) {\n    val json = backupFile.readText()\n    val serializer = TaxonomySnapshotSerializer(taxonomy)\n\n    when (val result = serializer.fromJson(json)) {\n        is ParseResult.Success -&gt;\n            println(\"Restored from ${backupFile.name}\")\n        is ParseResult.Failure -&gt;\n            println(\"Failed to restore: ${result.error}\")\n    }\n}\n\n// Automated backup on change\nfun configureAutoBackup(taxonomy: Taxonomy, backupDir: File) {\n    var lastJson = \"\"\n\n    // Poll for changes (or use observer pattern)\n    Timer().scheduleAtFixedRate(0, 60_000) { // Every minute\n        val currentJson = TaxonomySnapshotSerializer(taxonomy).toJson()\n\n        if (currentJson != lastJson) {\n            backupConfiguration(taxonomy, backupDir)\n            lastJson = currentJson\n        }\n    }\n}\n</code></pre>"},{"location":"Serialization/#configuration-versioning","title":"Configuration Versioning","text":"<p>Track configuration versions:</p> <pre><code>data class VersionedConfig(\n    val version: Int,\n    val json: String,\n    val timestamp: Long,\n    val author: String\n)\n\nclass ConfigVersionManager(private val taxonomy: Taxonomy) {\n    private val versions = mutableListOf&lt;VersionedConfig&gt;()\n    private var currentVersion = 0\n\n    fun saveVersion(author: String) {\n        val serializer = TaxonomySnapshotSerializer(taxonomy)\n        val json = serializer.toJson()\n\n        val version = VersionedConfig(\n            version = ++currentVersion,\n            json = json,\n            timestamp = System.currentTimeMillis(),\n            author = author\n        )\n\n        versions.add(version)\n        println(\"Saved version $currentVersion by $author\")\n    }\n\n    fun rollbackToVersion(version: Int) {\n        val config = versions.find { it.version == version }\n            ?: error(\"Version $version not found\")\n\n        val serializer = TaxonomySnapshotSerializer(taxonomy)\n        when (val result = serializer.fromJson(config.json)) {\n            is ParseResult.Success -&gt;\n                println(\"Rolled back to version $version\")\n            is ParseResult.Failure -&gt;\n                println(\"Rollback failed: ${result.error}\")\n        }\n    }\n\n    fun listVersions(): List&lt;VersionedConfig&gt; = versions.toList()\n}\n</code></pre>"},{"location":"Serialization/#best-practices","title":"Best Practices","text":""},{"location":"Serialization/#validate-before-loading","title":"Validate Before Loading","text":"<p>Always validate configurations before applying:</p> <pre><code>// Good: Validate first\nwhen (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -&gt; {\n        // Validation passed, safe to load\n        Taxonomy.Global.load(result.value)\n    }\n    is ParseResult.Failure -&gt; {\n        // Handle error, don't load\n        logError(\"Invalid config: ${result.error}\")\n    }\n}\n\n// Bad: Blindly applying without validation\nval konfig = SnapshotSerializer.fromJson(json) as ParseResult.Success\nTaxonomy.Global.load(konfig.value)  // Crashes if parsing failed\n</code></pre>"},{"location":"Serialization/#cache-configurations-locally","title":"Cache Configurations Locally","text":"<p>Always maintain a local cache:</p> <pre><code>suspend fun syncConfiguration(remoteUrl: String, cacheFile: File) {\n    try {\n        // Try to fetch remote\n        val remoteJson = fetchFromServer(remoteUrl)\n\n        when (val result = SnapshotSerializer.fromJson(remoteJson)) {\n            is ParseResult.Success -&gt; {\n                // Valid remote config - cache it\n                cacheFile.writeText(remoteJson)\n                Taxonomy.Global.load(result.value)\n            }\n            is ParseResult.Failure -&gt; {\n                // Invalid remote - use cache\n                loadFromCache(cacheFile)\n            }\n        }\n    } catch (e: Exception) {\n        // Network error - use cache\n        loadFromCache(cacheFile)\n    }\n}\n</code></pre>"},{"location":"Serialization/#use-taxonomy-isolation","title":"Use Taxonomy Isolation","text":"<p>Organize flags by domain for independent deployment:</p> <pre><code>// Good: Independent taxonomies\nTaxonomySnapshotSerializer(Taxonomy.Domain.Payments).fromJson(paymentsJson)\nTaxonomySnapshotSerializer(Taxonomy.Domain.Search).fromJson(searchJson)\n\n// Better: Each team manages their own\nobject PaymentsTeam {\n    fun deployConfig(json: String) {\n        TaxonomySnapshotSerializer(Taxonomy.Domain.Payments).fromJson(json)\n    }\n}\n</code></pre>"},{"location":"Serialization/#version-your-configurations","title":"Version Your Configurations","text":"<p>Track changes for debugging and rollback:</p> <pre><code>// Include version metadata in storage\ndata class StoredConfig(\n    val version: String,\n    val timestamp: Long,\n    val author: String,\n    val json: String\n)\n\nfun saveWithMetadata(konfig: Konfig, author: String) {\n    val json = SnapshotSerializer.serialize(konfig)\n\n    val stored = StoredConfig(\n        version = \"1.2.3\",\n        timestamp = System.currentTimeMillis(),\n        author = author,\n        json = json\n    )\n\n    database.save(stored)\n}\n</code></pre>"},{"location":"Serialization/#handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Provide fallbacks for all error cases:</p> <pre><code>fun loadConfigWithFallback(\n    primarySource: () -&gt; String,\n    fallbackSource: () -&gt; String\n): Konfig {\n    // Try primary source\n    val primaryResult = try {\n        SnapshotSerializer.fromJson(primarySource())\n    } catch (e: Exception) {\n        ParseResult.Failure(ParseError.InvalidJson(\"Primary source error: ${e.message}\"))\n    }\n\n    when (primaryResult) {\n        is ParseResult.Success -&gt; return primaryResult.value\n        is ParseResult.Failure -&gt; {\n            // Log primary failure\n            logWarning(\"Primary source failed: ${primaryResult.error}\")\n\n            // Try fallback\n            when (val fallbackResult = SnapshotSerializer.fromJson(fallbackSource())) {\n                is ParseResult.Success -&gt; return fallbackResult.value\n                is ParseResult.Failure -&gt; {\n                    // Both failed - use empty konfig\n                    logError(\"All sources failed: ${fallbackResult.error}\")\n                    return Konfig(emptyMap())\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Serialization/#use-patches-for-incremental-updates","title":"Use Patches for Incremental Updates","text":"<p>Prefer patches over full replacements when possible:</p> <pre><code>// Good: Incremental patch\nval patch = \"\"\"\n{\n  \"flags\": [\n    {\"key\": \"new_feature\", \"defaultValue\": {\"type\": \"BOOLEAN\", \"value\": true}}\n  ],\n  \"removeKeys\": []\n}\n\"\"\"\nSnapshotSerializer.applyPatchJson(currentKonfig, patch)\n\n// Less efficient: Full replacement\nval fullConfig = \"\"\"\n{\n  \"flags\": [\n    // Entire configuration repeated\n  ]\n}\n\"\"\"\n</code></pre>"},{"location":"Serialization/#complete-example","title":"Complete Example","text":"<p>End-to-end remote configuration with caching:</p> <pre><code>import io.amichne.konditional.serialization.TaxonomySnapshotSerializer\nimport io.amichne.konditional.core.Taxonomy\nimport io.amichne.konditional.core.result.ParseResult\nimport java.io.File\n\nclass RemoteConfigManager(\n    private val taxonomy: Taxonomy,\n    private val remoteUrl: String,\n    private val cacheFile: File\n) {\n    private val serializer = TaxonomySnapshotSerializer(taxonomy)\n\n    suspend fun initialize() {\n        // Load from cache immediately\n        loadFromCache()\n\n        // Then fetch remote in background\n        fetchRemote()\n    }\n\n    suspend fun fetchRemote() {\n        try {\n            val json = httpClient.get(remoteUrl).bodyAsText()\n\n            when (val result = serializer.fromJson(json)) {\n                is ParseResult.Success -&gt; {\n                    // Cache successful remote config\n                    cacheFile.writeText(json)\n                    println(\"Remote config loaded: ${result.value.flags.size} flags\")\n                }\n                is ParseResult.Failure -&gt; {\n                    println(\"Remote config invalid: ${result.error}\")\n                }\n            }\n        } catch (e: Exception) {\n            println(\"Failed to fetch remote: ${e.message}\")\n        }\n    }\n\n    private fun loadFromCache() {\n        if (!cacheFile.exists()) {\n            println(\"No cache found, using defaults\")\n            return\n        }\n\n        val json = cacheFile.readText()\n        when (val result = serializer.fromJson(json)) {\n            is ParseResult.Success -&gt;\n                println(\"Loaded from cache: ${result.value.flags.size} flags\")\n            is ParseResult.Failure -&gt;\n                println(\"Cache invalid: ${result.error}\")\n        }\n    }\n\n    fun backup(backupDir: File) {\n        val json = serializer.toJson()\n        val filename = \"${taxonomy.id}-${System.currentTimeMillis()}.json\"\n        backupDir.resolve(filename).writeText(json)\n    }\n}\n\n// Usage\nsuspend fun main() {\n    val manager = RemoteConfigManager(\n        taxonomy = Taxonomy.Domain.Payments,\n        remoteUrl = \"https://config.example.com/payments.json\",\n        cacheFile = File(\"cache/payments.json\")\n    )\n\n    // Initialize with cache, then fetch remote\n    manager.initialize()\n\n    // Periodic sync\n    Timer().scheduleAtFixedRate(0, 300_000) { // Every 5 minutes\n        runBlocking {\n            manager.fetchRemote()\n        }\n    }\n}\n</code></pre>"},{"location":"Serialization/#summary","title":"Summary","text":"<p>Key Takeaways:</p> <ul> <li>Use <code>SnapshotSerializer</code> for global serialization without automatic loading</li> <li>Use <code>TaxonomySnapshotSerializer</code> for taxonomy-scoped serialization with automatic loading</li> <li>All deserialization returns <code>ParseResult</code> for type-safe error handling</li> <li>Patches enable incremental updates without full configuration replacement</li> <li>Always validate configurations before loading</li> <li>Maintain local caches for offline support</li> <li>Use taxonomy isolation for independent deployment</li> </ul>"},{"location":"Serialization/#next-steps","title":"Next Steps","text":"<ul> <li>Registry - Taxonomy management and registry operations</li> <li>Results - Error handling with ParseResult and EvaluationResult</li> <li>Configuration - DSL reference for building configurations</li> <li>Context - Custom contexts for domain-specific logic</li> </ul>"},{"location":"venv/lib/python3.14/site-packages/backrefs-5.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/idna-3.11.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/markdown-3.9.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pip-25.2.dist-info/licenses/src/pip/_vendor/idna/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/pymdown_extensions-10.16.1.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"venv/lib/python3.14/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}