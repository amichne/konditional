---
name: value-architecture-signature-linker
description: Create and maintain adoption-focused technical documentation for any information architecture (new or existing), linking narrative claims to JVM signatures and tests. Use when writing or updating product documentation, migration guides, implementation guidance, architecture overviews, or rollout messaging that must stay synchronized with `signatures/*.sig` (or `.signatures/*.sig`) and support deterministic claim validation.
---

# Value architecture signature linker

## Overview

Use this skill to create documentation that is persuasive, technically credible,
and maintainable across **any documentation structure**.

This skill is intentionally **information-architecture agnostic**. It can be
applied to:

- existing pages,
- existing documentation trees,
- incremental page updates,
- new documentation sections,
- full documentation rewrites (when needed, but not required).

The output should read like modern technical/product documentation, not an audit
log. Evidence is embedded directly in the narrative with compact inline citation
tokens, while traceability remains machine-checkable in JSON artifacts.

## Primary objective

Produce or update a documentation portfolio (one page or many) that answers
core adoption and decision questions across the document set:

1. What concrete problems, risks, or constraints are addressed, and how
2. Why this approach is stronger than alternatives or status quo
3. What adoption, migration, or operational risk profile looks like
4. What evidence supports the claims being made

## Applicability and migration posture

This skill must work without forcing a new top-level documentation model.

### Required posture

- **Do not require a "journey" structure.**
- **Do not require page reconstruction.**
- Prefer adapting to the existing IA and page taxonomy.
- Support incremental retrofitting of citations and claims on existing pages.
- Allow mixed maturity states:
    - some pages fully citation-backed,
    - some pages partially upgraded,
    - some pages awaiting signature/test linkage.

### Acceptable documentation shapes

Examples (not exhaustive):

- product overview + concepts + reference
- architecture decision records
- migration guides
- rollout docs
- operator runbooks
- tutorial + deep-dive + API reference
- FAQ + troubleshooting + comparison pages
- single-page technical narratives

## Required artifacts

Produce these artifacts for each documentation batch:

1. Documentation pages (existing locations preferred; do not force a path move)
   with inline claim citations and page-local citation footers.
2. A link map (`docs/claim-trace/claim-signature-links.json`) following
   `references/claim_signature_link_schema.md`.
3. A centralized claims registry (`docs/claim-trace/claims-registry.json`)
   following `docs/claim-trace/claims-registry.schema.json`.
4. A validation report (`docs/claim-trace/claims-report.json`) generated by
   `scripts/validate_claim_signature_links.py`.

If the repo already has equivalent paths/files, reuse them instead of creating
new ones.

## Narrative posture

- Write with calm confidence; avoid hype and avoid sterile checklist tone.
- Keep technical certainty high while minimizing "proof theater."
- Prefer implicit credibility: concise claims with inline citations.
- Keep detailed evidence traceability available in structured artifacts.
- Match the page's purpose:
    - decision support pages can be more persuasive,
    - implementation/reference pages can be more direct and technical.

## Citation and claims contract

Use compact claim citations in prose, for example:

`... deterministic under stable identity tuples [CLM-TH-003].`

### Rules

1. Every non-trivial claim in narrative prose must include at least one claim
   citation token.
2. Citation tokens must map to a claim ID in `claims-registry.json`.
3. Signature/test traceability remains in JSON artifacts even when not shown in
   full on the page.
4. If a page is high-level or audience-facing, keep heavy evidence details in:
    - the page footer citation table, and/or
    - a linked technical companion page, and/or
    - the centralized claim registry.
5. Citation tokens should be stable over time unless the underlying claim is
   materially changed.

## Page-level citation footer contract

Each page that contains claim citations must include a **footer citation table**
at the bottom of the page.

### Footer table purpose

The footer table makes claims auditable without cluttering the prose. It should
be human-readable and easy to scan.

### Required columns

Each row must include:

1. **Claim ID** — stable identifier used inline (e.g., `CLM-TH-003`)
2. **Explicit Claim** — the concrete statement being asserted on this page
3. **Local Evidence Linkage** — link(s) to local anchors/sections/examples on
   the page or companion page (if applicable)
4. **Registry Link** — link to the canonical claim entry in the centralized
   claim registry page or registry viewer

### Example footer table shape (conceptual)

| Claim ID   | Explicit Claim                                        | Local Evidence Linkage | Registry Link                   |
|------------|-------------------------------------------------------|------------------------|---------------------------------|
| CLM-TH-003 | Deterministic evaluation under stable identity tuples | `#determinism`         | `claims-registry.md#clm-th-003` |

### Footer table rules

- Include only claims cited on that page.
- Keep rows ordered by claim ID for determinism.
- The "Explicit Claim" text should be concrete and reviewable (not shorthand).
- The "Registry Link" must point to the canonical claim record.

## Centralized claim registry contract

Maintain a documentation-visible, searchable claim registry separate from page
content.

### Purpose

The registry is the canonical source of claim metadata and traceability, while
pages remain readable and audience-appropriate.

### Registry characteristics

- Searchable by:
    - claim ID
    - topic
    - page
    - signature
    - test
    - risk category
- Accessible to documentation viewers (not hidden as an internal-only artifact)
- Linkable from page footer citation tables
- Canonicalized claim records (single source of truth per claim ID)

### Registry entry should support

- Claim ID
- Canonical claim text
- Short rationale / interpretation notes (optional)
- Source pages where cited
- Signature links
- Test links
- Confidence / evidence status (optional but recommended)
- Related claims (optional)
- Change history metadata if available (optional, but stable)

## Formatting contract (IA-agnostic)

There is no single required page order and no required page taxonomy.

Build or update pages using reusable modules based on audience and purpose.

### Common modules (optional, mix as needed)

- value proposition / decision framing
- problem or risk framing
- architecture overview
- how it works
- alternatives comparison
- migration/adoption guidance
- operational behavior and failure modes
- evidence notes / claim references
- troubleshooting / edge cases
- success metrics / rollout indicators
- concise call to action

### Required coverage across the document set (not per page)

1. Value case and decision framing
2. Alternative or status-quo comparison
3. Citation-backed claims
4. Adoption and/or operational guidance
5. Clear linkage to verifiable evidence

## Sub-agent orchestration playbook

Use sub-agents when generating or refactoring multiple pages, audiences, or
sections.

### Suggested roles

1. **IA adapter**
    - Maps the existing docs structure and decides where to retrofit claims/citations
    - Avoids unnecessary page churn
2. **Story strategist**
    - Defines audience, objections, and page intent
3. **Evidence curator**
    - Maps claims to signatures, tests, and confidence bounds
4. **Comparison analyst**
    - Builds fair baseline/alternative comparisons
5. **Doc composer**
    - Drafts or updates pages with inline citations and footer tables
6. **Verifier**
    - Validates claims/links, footer completeness, and tone/evidence balance

### Orchestration pattern

1. Run IA adapter and evidence curator first.
2. Run story strategist and comparison analyst in parallel (if needed).
3. Feed outputs to doc composer for page updates/drafts.
4. Run verifier last and resolve:
    - missing claim citations,
    - footer table gaps,
    - registry linkage gaps,
    - signature/test traceability gaps.

## Workflow

1. Ensure signature artifacts exist.
2. Build public-surface bootstrap context.
3. Inventory existing documentation IA and identify target pages/sections.
4. Decide update scope:
    - patch existing pages,
    - add companion pages,
    - create new pages only where necessary.
5. Define claim model and citation ID strategy.
6. Orchestrate sub-agents for IA adaptation, evidence, and comparisons.
7. Draft/update pages with inline claim citations.
8. Add page-level footer citation tables.
9. Map all cited claims to signatures/tests in centralized JSON artifacts.
10. Publish/update the centralized claim registry view/page.
11. Validate links and claims.
12. Continue generation with unresolved evidence in `--ci-mode warn` only.

## Documentation quality contract

Across the documentation portfolio, ensure readers can answer:

- Why this matters
- What changes for implementers and operators
- Why this is preferable to alternatives or status quo
- Why the evidence is credible
- What adoption success and operational safety look like

## Commands

1. Generate or refresh signatures:

```bash
.agents/skills/llm-native-signature-spec/scripts/generate_signatures.sh --repo-root . --output-dir .signatures
```

2. Build public-surface context:

```bash
python3 .agents/skills/public-surface-init-context/scripts/build_public_surface_context.py \
  --repo-root . \
  --signatures-dir .signatures \
  --output .signatures/PUBLIC_SURFACE.ctx
```

3. Validate claim/signature links:

```bash
python3 .agents/skills/value-architecture-signature-linker/scripts/validate_claim_signature_links.py \
  --repo-root . \
  --links-file docs/claim-trace/claim-signature-links.json \
  --report-out docs/claim-trace/claims-report.json \
  --auto-refresh
```

4. Retrieve deterministic evidence (RAG supervisor mode):

```bash
python3 .agents/skills/value-architecture-signature-linker/scripts/query_claim_evidence.py \
  --repo-root . \
  --links-file docs/claim-trace/claim-signature-links.json \
  --docs-glob 'docusaurus/docs/**/*.md' \
  --query 'deterministic evaluation claim linkage' \
  --top-k 20 \
  --report-out docs/claim-trace/claim-evidence-query.json
```

5. Use `--strict` only when you intentionally want missing claims or empty
   retrieval results to fail the run (for example CI gating).

## Missing-evidence protocol

When required evidence is not found:

1. Regenerate signatures and public-surface context.
2. Re-run claim validation.
3. If still unresolved, continue generation and mark claim linkage as
   `missing`.
4. Add deterministic gap notes including:
   - claim id
   - requested symbol or test reference
   - search scope (`signatures` or `.signatures`)
   - next action

Do not stop execution solely because one claim is unresolved unless strict mode
is explicitly required.

## Determinism and boundary rules

- Treat claim maps and retrieval queries as untrusted boundary input.
- Parse into typed structures before deriving reports.
- Keep ordering stable:
  - claims by claim id
  - links by kind, then signature
  - retrieval results by descending score, then deterministic tie-breakers
- Keep JSON deterministic (`sort_keys=true`).
- Never add timestamps or random IDs to generated artifacts.
