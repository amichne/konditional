---
name: value-journey-signature-linker
description: Create and maintain adoption-focused technical documentation that starts from compelling value propositions and user journeys, then links each narrative claim to JVM signatures and tests. Use when writing or updating product narratives, rollout messaging, migration documentation, or implementation guidance that must stay synchronized with `signatures/*.sig` (or `.signatures/*.sig`) and support deterministic claim validation.
---

# Value journey signature linker

## Overview

Use this skill to make documentation persuasive and technically grounded. Start
with the customer value proposition and user journey arc, then anchor each
journey claim to explicit signatures and tests so future code changes can be
validated with low drift.

## Required artifacts

Produce these artifacts for each documentation batch:

1. Value journey documents (`docs/value-journeys/*.md`) using the template in
   `references/journey_doc_template.md`.
2. A link map (`docs/value-journeys/journey-signature-links.json`) following
   `references/journey_signature_link_schema.md`.
3. A claims registry (`docs/value-journeys/journey-claims.json`) following
   `docs/value-journeys/journey-claims.schema.json`.
4. A validation report (`docs/value-journeys/journey-claims-report.json`)
   generated by `scripts/validate_journey_signature_links.py`.

## Workflow

1. Ensure signature artifacts exist.
2. Build public-surface bootstrap context.
3. Define a value proposition for each journey.
4. Draft or update journey docs with a clear narrative arc.
5. Add claim tables in docs and map claims in `journey-claims.json`.
6. Map each journey step to explicit signatures.
7. Map each claim to tests and owner modules.
8. Validate links and claims.
9. Continue generation even with unresolved evidence when `--ci-mode warn`.

## Storytelling contract

Every journey document must answer:

- Why this matters now (business and user urgency).
- What changes for the user (before versus after).
- How Konditional behavior proves each claim (signature and test evidence).
- What success looks like (observable adoption signals).

Use concrete verbs and outcome statements, not feature-list prose.

## Commands

1. Generate or refresh signatures:

```bash
.agents/skills/llm-native-signature-spec/scripts/generate_signatures.sh --repo-root . --output-dir .signatures
```

2. Build public-surface context:

```bash
.agents/skills/public-surface-init-context/scripts/build_public_surface_context.py --repo-root . --signatures-dir .signatures --output .signatures/PUBLIC_SURFACE.ctx
```

3. Validate journey links and claims in warn mode:

```bash
python3 .agents/skills/value-journey-signature-linker/scripts/validate_journey_signature_links.py \
  --repo-root . \
  --links-file docs/value-journeys/journey-signature-links.json \
  --claims-file docs/value-journeys/journey-claims.json \
  --report-out docs/value-journeys/journey-claims-report.json \
  --signatures-dir .signatures \
  --require-tests \
  --ci-mode warn
```

4. Validate in strict CI mode:

```bash
python3 .agents/skills/value-journey-signature-linker/scripts/validate_journey_signature_links.py \
  --repo-root . \
  --links-file docs/value-journeys/journey-signature-links.json \
  --claims-file docs/value-journeys/journey-claims.json \
  --report-out docs/value-journeys/journey-claims-report.json \
  --signatures-dir .signatures \
  --require-tests \
  --ci-mode strict
```

## Determinism and boundary rules

- Treat journey markdown and JSON files as untrusted boundary input.
- Parse into typed structures before deriving reports.
- Keep ordering stable:
  - unresolved links: `journey_id`, `kind`, `signature`
  - claims: `journey_id`, `claim_id`
- Keep report JSON deterministic (`sort_keys=true`).
- Do not emit timestamps or random identifiers in generated artifacts.
