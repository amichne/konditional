---
name: value-journey-signature-linker
description: Create and maintain adoption-focused technical documentation that starts from compelling value propositions and user journeys, then links each narrative claim to JVM signatures and public-surface artifacts. Use when writing or updating product narratives, rollout messaging, migration documentation, or implementation guidance that must stay synchronized with `signatures/*.sig` (or `.signatures/*.sig`) and support deterministic update checks after code changes.
---

# Value journey signature linker

## Overview

Use this skill to make documentation persuasive and technically grounded. Start
with the customer value proposition and user journey arc, then anchor each
journey step to explicit signatures so future code changes can be traced and
updated with low drift. Keep generation deterministic and continue execution
even when signature coverage is incomplete.

## Required artifacts

Produce these artifacts for each documentation batch:

1. Value journey documents (`docs/value-journeys/*.md`) using the template in
   `references/journey_doc_template.md`.
2. A link map (`docs/value-journeys/journey-signature-links.json`) following
   `references/journey_signature_link_schema.md`.
3. A validation report (`docs/value-journeys/journey-signature-report.json`)
   generated by `scripts/validate_journey_signature_links.py`.

## Workflow

1. Ensure signature artifacts exist.
2. Build public-surface bootstrap context.
3. Define a value proposition for each journey:
   - who benefits
   - which pain is removed
   - which gain is created
4. Draft or update journey docs with a clear narrative arc.
5. Map each journey step to explicit signatures.
6. Validate links and auto-refresh signature artifacts if links are missing.
7. Continue documentation generation even if some links remain unresolved.
8. Record unresolved links in the report and in each journey's "Open questions"
   section.

## Storytelling contract

Every journey document must answer:

- Why this matters now (business and user urgency).
- What changes for the user (before versus after).
- How Konditional behavior proves the claim (signature-linked evidence).
- What success looks like (observable adoption signals).

Use concrete verbs and outcome statements, not feature-list prose.

## Commands

1. Generate or refresh signatures:

```bash
.agents/skills/llm-native-signature-spec/scripts/generate_signatures.sh --repo-root . --output-dir signatures
```

2. Build public-surface context:

```bash
.agents/skills/public-surface-init-context/scripts/build_public_surface_context.py --repo-root . --signatures-dir signatures --output signatures/PUBLIC_SURFACE.ctx
```

3. Validate journey/signature link coverage with automatic refresh and
   non-blocking behavior:

```bash
python3 .agents/skills/value-journey-signature-linker/scripts/validate_journey_signature_links.py \
  --repo-root . \
  --links-file docs/value-journeys/journey-signature-links.json \
  --report-out docs/value-journeys/journey-signature-report.json \
  --auto-refresh
```

4. Use `--strict` only when you intentionally want missing links to fail the
   run (for example, CI gating).

## Missing-signature protocol

When a required symbol is not found:

1. Regenerate signatures and public-surface context.
2. Re-run link validation.
3. If still unresolved, keep generating docs and mark the link status as
   `missing`.
4. Add a deterministic gap note with:
   - journey id
   - requested symbol
   - search scope (`signatures` or `.signatures`)
   - next action

Do not stop execution solely because one signature link is unresolved.

## Determinism and boundary rules

- Treat value journey inputs and link-map JSON as untrusted boundary input.
- Parse into typed structures (script-backed) before deriving reports.
- Keep ordering stable:
  - sort unresolved findings by `journey_id`, then `kind`, then `signature`
  - keep output JSON deterministic (`sort_keys=true`)
- Never add timestamps or random IDs to generated linkage artifacts.
