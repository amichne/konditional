package io.amichne.konditional.adversarial

import io.amichne.konditional.context.AppLocale
import io.amichne.konditional.context.Context
import io.amichne.konditional.context.Platform
import io.amichne.konditional.context.Rollout
import io.amichne.konditional.context.Version
import io.amichne.konditional.core.TestNamespace
import io.amichne.konditional.core.features.FeatureContainer
import io.amichne.konditional.core.features.evaluate
import io.amichne.konditional.core.id.StableId
import io.amichne.konditional.core.test
import io.amichne.konditional.rules.evaluable.Evaluable
import io.amichne.konditional.rules.versions.FullyBound
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertTrue

/**
 * EXPLOITATION ATTACK TESTS
 *
 * These tests demonstrate specific exploits that compile successfully
 * but create semantically invalid, misleading, or dangerous configurations.
 *
 * Each test documents a specific attack vector and its implications.
 */
class ExploitationAttacksTest {

    // ============================================
    // EXPLOIT 1: Version Parsing Data Loss
    // ============================================

    @Test
    fun `EXPLOIT - version parsing silently loses data from malformed versions`() {
        /*
         * ATTACK: Pass a version string with invalid parts
         * RESULT: Invalid parts are silently converted to 0, losing information
         * DANGER: Version "1.hack.2" becomes (1,0,0), completely losing the intended patch version
         */

        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe("1.hack.2")
        }

        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe("2.3.exploit")
        }
        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe("1..3") // Double dot
        }

        /*
         * IMPACT: A malicious or confused user could:
         * 1. Think they're targeting version 1.0.2 when actually targeting 1.0.0
         * 2. Create ambiguous version configurations
         * 3. Bypass version checks if they expect string validation
         */
    }

    @Test
    fun `EXPLOIT - version with only dots parses as all zeros`() {
        assertThrows<IllegalArgumentException> {
            val dotsOnly = Version.parseUnsafe(".")
        }
//        assertEquals(Version(0, 0, 0), dotsOnly)

        assertThrows<IllegalArgumentException> {
            val multiDots = Version.parseUnsafe("..")
        }
//        assertEquals(Version(0, 0, 0), multiDots)

        /*
         * IMPACT: Version "." is indistinguishable from "0.0.0"
         * Could be used to create confusing configs
         */
    }

    @Test
    fun `EXPLOIT - negative version components create illogical semantic versions`() {
        /*
         * ATTACK: Create negative version numbers
         * RESULT: They work but violate semantic versioning spec
         * DANGER: Comparison logic works but semantics are meaningless
         */

        val zero = Version(0, 0, 0)
        val positive = Version(1, 0, 0)

        // Comparisons work but are semantically nonsense
//        assertTrue(negative < zero)
        assertTrue(zero < positive)

        assertThrows<IllegalArgumentException> {
            Version(-5, -10, -20)
        }

        // What does "version -5.-10.-20" mean? Nothing!
        // But it compiles and runs...

        /*
         * IMPACT: Creates impossible version numbers that:
         * 1. Violate semantic versioning specification
         * 2. Could confuse version comparison logic
         * 3. Make debugging harder (is -1 a sentinel value or bug?)
         */
    }

    // ============================================
    // EXPLOIT 2: Rule Specificity Manipulation
    // ============================================

    @Test
    fun `EXPLOIT - rules with same specificity create order-dependent behavior`() {
        /*
         * ATTACK: Create multiple rules with identical specificity
         * RESULT: Winner is determined by implementation-dependent sort order
         * DANGER: Behavior changes based on rule declaration order
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val conflictingRules by boolean<Context>(default = false) {
                rule {
                    platforms(Platform.ANDROID) // Specificity = 1
                    note("first-rule")
                } returns true

                rule {
                    locales(AppLocale.EN_US) // Also specificity = 1
                    note("second-rule")
                } returns false
            }
        }

        val context = Context(
            locale = AppLocale.EN_US,
            platform = Platform.ANDROID,
            appVersion = Version(1, 0, 0),
            stableId = StableId.of("12345678901234567890123456789012")
        )

        // Both rules match and have same specificity (1)
        // Winner determined by note comparison: "first-rule" < "second-rule"
        // So first rule wins
        val result = TestNamespaceFeatures.conflictingRules.evaluate(context)
        assertEquals(true, result)

        /*
         * IMPACT: Non-obvious rule resolution:
         * 1. Adding/removing rules changes behavior in unexpected ways
         * 2. Rule order matters but isn't documented clearly
         * 3. Tiebreaker uses note field which is optional
         * 4. If notes are null, sort order is unstable
         */
    }

    @Test
    fun `EXPLOIT - more specific rule always wins even if lower in config`() {
        /*
         * ATTACK: Rely on implicit specificity ordering
         * RESULT: Later rules can shadow earlier ones
         * DANGER: User might think rules are checked in order
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val shadowedRules by string<Context>(default = "default") {
                // User writes this first, thinking it's a "catch-all"
                rule {
                    // Specificity = 0 (no constraints)
                } returns "catch-all"

                // Then adds specific rules later
                rule {
                    platforms(Platform.WEB) // Specificity = 1
                } returns "web-specific"
            }
        }

        val webContext = Context(
            locale = AppLocale.EN_US,
            platform = Platform.WEB,
            appVersion = Version(1, 0, 0),
            stableId = StableId.of("12345678901234567890123456789012")
        )

        // Even though "catch-all" is first in code, "web-specific" wins
        // because it has higher specificity
        assertEquals("web-specific", TestNamespaceFeatures.shadowedRules.evaluate(webContext))

        /*
         * IMPACT: Declaration order != evaluation order
         * Can surprise users who expect sequential evaluation
         */
    }

    // ============================================
    // EXPLOIT 3: Rollout Percentage Confusion
    // ============================================

    @Test
    fun `EXPLOIT - rollout percentage easy to misconfigure by 100x`() {
        /*
         * ATTACK: User thinks 0.5 means 50% when it actually means 0.5%
         * RESULT: Feature rolls out to 100x fewer users than intended
         * DANGER: Silent under-deployment
         */

        val confusingRollout = Rollout.of(0.5) // Is this 0.5% or 50%?
        assertEquals(0.5, confusingRollout.value) // It's 0.5%!

        // User probably meant:
        val intendedRollout = Rollout.of(50.0) // 50%
        assertEquals(50.0, intendedRollout.value)

        /*
         * IMPACT:
         * 1. 0.5 looks like "half" but it's 0.5%
         * 2. Could deploy critical feature to almost no one by mistake
         * 3. Hard to debug - everything "works", just wrong scale
         */
    }

    @Test
    fun `EXPLOIT - rollout at exactly 0 means nobody ever sees the feature`() {
        /*
         * ATTACK: Set rollout to 0.0
         * RESULT: Feature is unreachable even if all other rules match
         * DANGER: Dead code that compiles but never executes
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val deadFeature by boolean<Context>(default = false) {
                rule {
                    platforms(Platform.WEB)
                    rollout { 0.0 } // 0% = nobody
                } returns true
            }
        }

        val context = Context(
            locale = AppLocale.EN_US,
            platform = Platform.WEB,
            appVersion = Version(1, 0, 0),
            stableId = StableId.of("12345678901234567890123456789012")
        )

        // Rule matches but rollout excludes everyone
        assertEquals(false, TestNamespaceFeatures.deadFeature.evaluate(context))

        /*
         * IMPACT: Creates unreachable code paths
         * User might think feature is broken when it's just rolled out to 0%
         */
    }

    // ============================================
    // EXPLOIT 4: Special Numeric Values
    // ============================================

    @Test
    fun `EXPLOIT - NaN in double feature creates inequality paradox`() {
        /*
         * ATTACK: Use NaN as a default value
         * RESULT: Creates value that doesn't equal itself
         * DANGER: Breaks equality assumptions
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val nanFeature by double<Context>(default = Double.NaN)
        }

        val nanDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.nanFeature)
        val value = nanDef?.defaultValue
        assertTrue(value != null && value.isNaN())
        assertFalse(value != null && value == value) // NaN != NaN!

        /*
         * IMPACT:
         * 1. Breaks == checks
         * 2. Can't use in when statements or equality comparisons
         * 3. Propagates through calculations, infecting results
         * 4. Could break JSON serialization
         */
    }

    @Test
    fun `EXPLOIT - infinity in double feature creates unbounded values`() {
        /*
         * ATTACK: Use Infinity as feature value
         * RESULT: Compiles but creates unbounded numeric value
         * DANGER: Mathematical operations can produce unexpected results
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val infiniteTimeout by double<Context>(default = Double.POSITIVE_INFINITY) {
                rule {
                    platforms(Platform.WEB)
                } returns Double.NEGATIVE_INFINITY
            }
        }

        val infiniteDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.infiniteTimeout)
        assertEquals(Double.POSITIVE_INFINITY, infiniteDef?.defaultValue)

        // User code might do:
        val timeout = infiniteDef?.defaultValue ?: Double.POSITIVE_INFINITY
        // timeout * 2 == Infinity
        // timeout + 1000 == Infinity
        // if (timeout > 1000) // always true!

        /*
         * IMPACT:
         * 1. Breaks numeric comparisons
         * 2. Can cause infinite loops if used as loop bound
         * 3. May not serialize to JSON correctly
         */
    }

    @Test
    fun `EXPLOIT - Int MAX_VALUE can overflow in user code`() {
        /*
         * ATTACK: Use Int.MAX_VALUE as feature value
         * RESULT: Compiles but user code adding to it will overflow
         * DANGER: Silent overflow to negative values
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val maxRetries by int<Context>(default = Int.MAX_VALUE)
        }

        val maxRetriesDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.maxRetries)
        val retries = maxRetriesDef?.defaultValue ?: Int.MAX_VALUE
        assertEquals(Int.MAX_VALUE, retries)

        // User code might do:
        val nextRetry = retries + 1 // Overflows to Int.MIN_VALUE!
        assertEquals(Int.MIN_VALUE, nextRetry)

        /*
         * IMPACT:
         * 1. Silent overflow (no exception in Kotlin)
         * 2. Wraps to negative value
         * 3. Could break retry logic, timeouts, counters
         */
    }

    // ============================================
    // EXPLOIT 5: String Edge Cases
    // ============================================

    @Test
    fun `EXPLOIT - empty string is valid feature value but may break assumptions`() {
        /*
         * ATTACK: Use empty string as default or rule value
         * RESULT: Compiles but may violate business logic
         * DANGER: APIs expecting non-empty strings get empty ones
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val apiEndpoint by string<Context>(default = "") {
                rule {
                    platforms(Platform.WEB)
                } returns "   " // Whitespace-only
            }
        }

        val apiEndpointDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.apiEndpoint)
        assertEquals("", apiEndpointDef?.defaultValue)

        // User code might do:
        // val url = URL(apiEndpoint) // Throws MalformedURLException!

        /*
         * IMPACT:
         * 1. Empty strings may not be valid for use case (URLs, paths, etc.)
         * 2. No validation that string is non-empty
         * 3. Whitespace-only strings also pass through
         */
    }

    @Test
    fun `EXPLOIT - string with control characters and null bytes`() {
        /*
         * ATTACK: Include control characters in string values
         * RESULT: Compiles and stores unusual characters
         * DANGER: May break parsing, display, or storage
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val maliciousString by string<Context>(
                default = "Line1\u0000NullByte\u0007Bell\u001BEscape"
            )
        }

        val maliciousDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.maliciousString)
        val value = maliciousDef?.defaultValue
        assertTrue(value != null && value.contains('\u0000')) // Null byte
        assertTrue(value != null && value.contains('\u0007')) // Bell character
        assertTrue(value != null && value.contains('\u001B')) // Escape character

        /*
         * IMPACT:
         * 1. Null bytes can truncate strings in C-interop
         * 2. Control chars may break terminal output
         * 3. Could break parsers expecting sanitized strings
         * 4. May not display correctly in UIs
         */
    }

    @Test
    fun `EXPLOIT - extremely long string with no length validation`() {
        /*
         * ATTACK: Create feature with megabyte-sized string
         * RESULT: Compiles and allocates huge string
         * DANGER: Memory exhaustion, slow serialization
         */

        val hugeString = "X".repeat(10_000_000) // 10MB string

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val massiveFeature by string<Context>(default = hugeString)
        }

        val massiveDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.massiveFeature)
        assertEquals(10_000_000, massiveDef?.defaultValue?.length)

        /*
         * IMPACT:
         * 1. Can exhaust memory if many flags have huge strings
         * 2. Serialization becomes very slow
         * 3. Network transmission of config is expensive
         * 4. No practical limits enforced
         */
    }

    // ============================================
    // EXPLOIT 6: Inverted Version Ranges
    // ============================================

    @Test
    fun `EXPLOIT - inverted version range compiles but matches nothing`() {
        /*
         * ATTACK: Create version range where max < min
         * RESULT: Compiles but creates impossible condition
         * DANGER: Dead code that looks valid
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val impossibleFlag by boolean<Context>(default = false) {
                rule {
                    versions {
                        min(5, 0, 0)
                        max(1, 0, 0) // max < min!
                    }
                } returns true
            }
        }

        // TestNamespace various versions - none should match
        val testVersions = listOf(
            Version(0, 0, 0),
            Version(1, 0, 0),
            Version(3, 0, 0),
            Version(5, 0, 0),
            Version(10, 0, 0)
        )

        testVersions.forEach { version ->
            val context = Context(
                locale = AppLocale.EN_US,
                platform = Platform.WEB,
                appVersion = version,
                stableId = StableId.of("12345678901234567890123456789012")
            )

            // No version satisfies: v >= 5.0.0 AND v <= 1.0.0
            assertThrows<IllegalArgumentException> {
                TestNamespaceFeatures.impossibleFlag.evaluate(context)
            }
        }

        /*
         * IMPACT:
         * 1. Rule never matches any version
         * 2. Looks like valid config at first glance
         * 3. Could be user error thinking max is inclusive upper bound
         * 4. Creates unreachable code
         */
    }

    @Test
    fun `EXPLOIT - version range with same min and max targets single version`() {
        /*
         * ATTACK: Set minimum == maximum to target exact version
         * RESULT: Works but behavior depends on inclusive/exclusive bounds
         * DANGER: Brittle - breaks if bound semantics change
         */

        val range = FullyBound(
            min = Version(2, 5, 0),
            max = Version(2, 5, 0)
        )

        // Exact match
        assertTrue(range.contains(Version(2, 5, 0)))

        // Patch version changes break it
        assertFalse(range.contains(Version(2, 5, 1)))
        assertFalse(range.contains(Version(2, 4, 9)))

        /*
         * IMPACT:
         * 1. Very brittle - any version change breaks targeting
         * 2. Users might not realize they need exact match
         * 3. Depends on inclusive vs exclusive bound semantics
         */
    }

    // ============================================
    // EXPLOIT 7: Salt Manipulation
    // ============================================

    @Test
    fun `EXPLOIT - empty salt changes hash input format`() {
        /*
         * ATTACK: Set salt to empty string
         * RESULT: Hash input becomes ":flagKey:id" instead of "salt:flagKey:id"
         * DANGER: Different bucketing distribution
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val emptySaltFlag by boolean<Context>(default = false) {
                salt("") // Empty salt
            }
        }

        val emptySaltDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.emptySaltFlag)
        assertEquals("", emptySaltDef?.salt)

        // Hash input will be ":flagKey:userId" with leading colon
        // This is different distribution than "v1:flagKey:userId"

        /*
         * IMPACT:
         * 1. Bucketing distribution changes
         * 2. Users get re-bucketed compared to non-empty salt
         * 3. Leading colon might affect hash in unexpected ways
         */
    }

    @Test
    fun `EXPLOIT - salt with colons confuses hash format`() {
        /*
         * ATTACK: Include colons in salt value
         * RESULT: Hash input has unexpected structure
         * DANGER: Hash format becomes "a:b:flagKey:id" which looks like 4 parts
         */

        val TestNamespaceFeatures = object : FeatureContainer<TestNamespace>(test()) {
            val colonSaltFlag by boolean<Context>(default = false) {
                salt("a:b:c") // Colons in salt
            }
        }

        val colonSaltDef = TestNamespaceFeatures.namespace.flag(TestNamespaceFeatures.colonSaltFlag)
        assertEquals("a:b:c", colonSaltDef?.salt)

        // Hash input will be "a:b:c:flagKey:userId"
        // Format is ambiguous - could be interpreted different ways

        /*
         * IMPACT:
         * 1. Breaks assumption that salt is single token
         * 2. Could confuse parsing if hash is logged/debugged
         * 3. Might affect hash distribution
         */
    }

    // ============================================
    // EXPLOIT 8: Context Default Values
    // ============================================

    // ============================================
    // CRITICAL SECURITY FINDING
    // ============================================

    @Test
    fun `CRITICAL - custom evaluable can bypass all type safety`() {
        /*
         * MOST DANGEROUS ATTACK: Implement custom Evaluable
         * RESULT: Can run arbitrary code in matching logic
         * DANGER: User code executes during flag evaluation
         */

        // Custom evaluable that does something unexpected
        class MaliciousEvaluable<C : Context> : Evaluable<C> {
            private var callCount = 0

            override fun matches(context: C): Boolean {
                // Side effects during "matching"!
                callCount++

                // Could do anything here:
                // - Network calls
                // - File I/O
                // - Modify global state
                // - Throw exceptions
                // - Infinite loops

                return true // Always match
            }

            override fun specificity(): Int = 999 // Claim max specificity
        }

        /*
         * IMPACT: CRITICAL SECURITY ISSUE
         * 1. Custom Evaluable can execute arbitrary code
         * 2. Runs during every flag evaluation
         * 3. Can have side effects
         * 4. Can modify state
         * 5. Can throw exceptions
         * 6. No validation or sandboxing
         * 7. Could be used for:
         *    - Logging sensitive context data
         *    - Making network requests
         *    - DOS via infinite loop
         *    - Breaking immutability assumptions
         */
    }
}
