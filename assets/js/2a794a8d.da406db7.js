"use strict";(self.webpackChunkkonditional_docs=self.webpackChunkkonditional_docs||[]).push([[297],{1284(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"why-konditional","title":"Why Konditional Exists","description":"The Problem","source":"@site/docs/why-konditional.md","sourceDirName":".","slug":"/why-konditional","permalink":"/konditional/why-konditional","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Persistence & Storage Format","permalink":"/konditional/persistence-format"}}');var t=i(86070),r=i(48193);const l={},o="Why Konditional Exists",a={},d=[{value:"The Problem",id:"the-problem",level:2},{value:"String-keyed systems create invisible failure modes",id:"string-keyed-systems-create-invisible-failure-modes",level:3},{value:"Boolean-only systems turn into boolean matrices",id:"boolean-only-systems-turn-into-boolean-matrices",level:3},{value:"Each team reimplements ramp-up logic differently",id:"each-team-reimplements-ramp-up-logic-differently",level:3},{value:"Type safety disappears at the boundary",id:"type-safety-disappears-at-the-boundary",level:3},{value:"What Konditional Does Differently",id:"what-konditional-does-differently",level:2},{value:"What you get",id:"what-you-get",level:3},{value:"Comparison to Alternatives",id:"comparison-to-alternatives",level:2},{value:"Why This Matters",id:"why-this-matters",level:2},{value:"For engineers writing features",id:"for-engineers-writing-features",level:3},{value:"For teams running experiments",id:"for-teams-running-experiments",level:3},{value:"For systems that grow",id:"for-systems-that-grow",level:3},{value:"When Konditional Fits",id:"when-konditional-fits",level:2},{value:"The Three Models at a Glance",id:"the-three-models-at-a-glance",level:2},{value:"Real Problems Konditional Prevents",id:"real-problems-konditional-prevents",level:2},{value:"Production incident: Type coercion",id:"production-incident-type-coercion",level:3},{value:"Experiment contamination: Inconsistent bucketing",id:"experiment-contamination-inconsistent-bucketing",level:3},{value:"Maintenance burden: Boolean explosion",id:"maintenance-burden-boolean-explosion",level:3},{value:"Configuration drift: Silent deployment",id:"configuration-drift-silent-deployment",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"why-konditional-exists",children:"Why Konditional Exists"})}),"\n",(0,t.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,t.jsx)(n.p,{children:"Feature flags and configuration systems seem simple until they bite you in production. Here's what actually happens:"}),"\n",(0,t.jsx)(n.h3,{id:"string-keyed-systems-create-invisible-failure-modes",children:"String-keyed systems create invisible failure modes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Somewhere in onboarding code\nval newFlow = flagClient.getBool("new_onboaring_flow", false)  // typo\n\n// Somewhere in analytics\ntrack("new_onboarding_flow_completed")  // correct spelling\n\n// Somewhere in config JSON\n{ "new_onboarding_flow": true }  // correct spelling\n'})}),"\n",(0,t.jsx)(n.p,{children:"The typo ships. The flag never activates. Your A/B test runs for weeks with 0% treatment. Nobody notices until you check\nthe results."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"String keys fail silently."})," The compiler can't help you. Your IDE can't help you. You find out in production or in\npost-mortems."]}),"\n",(0,t.jsx)(n.h3,{id:"boolean-only-systems-turn-into-boolean-matrices",children:"Boolean-only systems turn into boolean matrices"}),"\n",(0,t.jsx)(n.p,{children:"You start clean:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"enum class Capability {\n    NEW_CHECKOUT\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then you need variants:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"enum class Capability {\n    NEW_CHECKOUT,\n    NEW_CHECKOUT_V2,\n    NEW_CHECKOUT_V3,\n    CHECKOUT_FAST_PATH,\n    CHECKOUT_STRIPE_INTEGRATION\n}\n\n// And now your code looks like:\nif (isEnabled(NEW_CHECKOUT) && !isEnabled(NEW_CHECKOUT_V2)) {\n    // original new checkout\n} else if (isEnabled(NEW_CHECKOUT_V2) && !isEnabled(CHECKOUT_FAST_PATH)) {\n    // v2 without fast path\n} else if (isEnabled(NEW_CHECKOUT_V3) || isEnabled(CHECKOUT_FAST_PATH)) {\n    // ... which logic wins?\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Boolean-only forces you to encode variants as control flow."})," Every combination requires explicit handling. Testing\nbecomes exponential. Bugs hide in interactions."]}),"\n",(0,t.jsx)(n.h3,{id:"each-team-reimplements-ramp-up-logic-differently",children:"Each team reimplements ramp-up logic differently"}),"\n",(0,t.jsx)(n.p,{children:"The account team implements ramp-ups with modulo arithmetic. The payments team uses random number generators. The growth\nteam copies some Stack Overflow answer. Each has different edge cases:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Do they bucket consistently for the same user?"}),"\n",(0,t.jsx)(n.li,{children:"Can you replay decisions deterministically in logs?"}),"\n",(0,t.jsx)(n.li,{children:"Does the same user get the same experience on web and mobile?"}),"\n",(0,t.jsx)(n.li,{children:"What happens when you change the percentage?"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Inconsistent ramp-up semantics create A/B testing landmines."})," Results become untrustworthy. Debugging requires\nreading five different implementations."]}),"\n",(0,t.jsx)(n.h3,{id:"type-safety-disappears-at-the-boundary",children:"Type safety disappears at the boundary"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// You define this\nval maxRetries: Int = flagClient.getInt("max_retries", 3)\n\n// Someone deploys this\n{ "max_retries": "five" }\n\n// Production gets this\nmaxRetries = 0  // or throws, or returns default, depends on the SDK\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Runtime configuration breaks compile-time contracts."})," JSON is stringly-typed. Your code expects ints. The gap causes\nincidents."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"what-konditional-does-differently",children:"What Konditional Does Differently"}),"\n",(0,t.jsx)(n.p,{children:"Konditional makes three structural commitments:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flags are properties, not strings"})," \u2014 keys are bound at compile-time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Types flow from definitions to callsites"})," \u2014 no type casting or runtime coercion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"One evaluation semantics for the entire codebase"})," \u2014 centralized, deterministic, testable"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'enum class CheckoutVariant { CLASSIC, OPTIMIZED, EXPERIMENTAL }\n\nobject AppFlags : Namespace("app") {\n    val checkoutVariant by enum<CheckoutVariant, Context>(default = CheckoutVariant.CLASSIC) {\n        rule(CheckoutVariant.OPTIMIZED) { platforms(Platform.IOS, Platform.ANDROID) }\n        rule(CheckoutVariant.EXPERIMENTAL) { rampUp { 50.0 } }\n    }\n\n    val maxRetries by integer<Context>(default = 3) {\n        rule(5) { platforms(Platform.WEB) }\n    }\n}\n\n// Usage\nval checkoutVariant: CheckoutVariant = AppFlags.checkoutVariant.evaluate(ctx)  // typed, cannot be wrong\nval retries: Int = AppFlags.maxRetries.evaluate(ctx)                           // typed, cannot be wrong\n'})}),"\n",(0,t.jsx)(n.h3,{id:"what-you-get",children:"What you get"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Typos become compile errors:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"AppFlags.NEW_ONBOARING_FLOW  // doesn't compile\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Type mismatches become compile errors:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val retries: String = AppFlags.maxRetries.evaluate(ctx)  // doesn't compile\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Variants are values, not boolean matrices:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"when (AppFlags.checkoutVariant.evaluate(ctx)) {\n    CheckoutVariant.CLASSIC -> classicCheckout()\n    CheckoutVariant.OPTIMIZED -> optimizedCheckout()\n    CheckoutVariant.EXPERIMENTAL -> experimentalCheckout()\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Ramp-ups are deterministic and consistent:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Same user, same flag, same percentage \u2192 same bucket\n// SHA-256("$salt:$flagKey:${stableId.hexId}") determines bucket\n// No random numbers, no modulo edge cases, reproducible in logs\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Configuration boundaries are explicit:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'when (val result = AppFlags.fromJson(remoteConfig)) {\n    is ParseResult.Success -> Unit // loaded into AppFlags\n    is ParseResult.Failure -> {\n        // Invalid JSON rejected, last-known-good remains active\n        logError("Config parse failed: ${result.error}")\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"If the payload references unknown or not-yet-registered feature keys, parsing fails (or can be configured to skip\nunknown keys during migrations)."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"comparison-to-alternatives",children:"Comparison to Alternatives"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"String-keyed SDKs"}),(0,t.jsx)(n.th,{children:"Enum + boolean capabilities"}),(0,t.jsx)(n.th,{children:"Konditional"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Typo safety"})}),(0,t.jsx)(n.td,{children:"Runtime failure (silent or crash)"}),(0,t.jsx)(n.td,{children:"Compile-time (enum typos caught)"}),(0,t.jsx)(n.td,{children:"Compile-time (property references)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Type safety"})}),(0,t.jsx)(n.td,{children:"Runtime coercion (often unsafe)"}),(0,t.jsx)(n.td,{children:"Boolean only"}),(0,t.jsx)(n.td,{children:"Compile-time types (Boolean/String/Int/Double/Enum/custom)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Variants"})}),(0,t.jsx)(n.td,{children:"Supported but runtime-typed"}),(0,t.jsx)(n.td,{children:"Requires multiple booleans + control flow"}),(0,t.jsx)(n.td,{children:"First-class typed values"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Ramp-up logic"})}),(0,t.jsx)(n.td,{children:"SDK-dependent, varies"}),(0,t.jsx)(n.td,{children:"Reimplemented per domain/team"}),(0,t.jsx)(n.td,{children:"Centralized, deterministic (SHA-256 bucketing)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Evaluation semantics"})}),(0,t.jsx)(n.td,{children:"SDK-defined, often opaque"}),(0,t.jsx)(n.td,{children:"Ad-hoc per evaluator (account, card, merchant, etc.)"}),(0,t.jsx)(n.td,{children:"Single DSL with specificity ordering"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Configuration drift"})}),(0,t.jsx)(n.td,{children:"Implicit boundary, often fails silently"}),(0,t.jsx)(n.td,{children:"Ad-hoc validation per evaluator"}),(0,t.jsxs)(n.td,{children:["Explicit ",(0,t.jsx)(n.code,{children:"ParseResult"})," boundary, rejects invalid JSON"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Null/missing values"})}),(0,t.jsx)(n.td,{children:"Depends on SDK (null, exception, or default)"}),(0,t.jsx)(n.td,{children:"Depends on implementation"}),(0,t.jsx)(n.td,{children:"Total evaluation (defaults required, no null returns)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Testing"})}),(0,t.jsx)(n.td,{children:"Mock SDK or replay config snapshots"}),(0,t.jsx)(n.td,{children:"Mock evaluators or stub booleans"}),(0,t.jsx)(n.td,{children:"Evaluate against typed contexts (deterministic, no mocks needed)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Consistency"})}),(0,t.jsx)(n.td,{children:"Depends on SDK discipline and process"}),(0,t.jsx)(n.td,{children:"Depends on how many evaluators you maintain"}),(0,t.jsx)(n.td,{children:"One rule DSL, one evaluation engine, one set of semantics"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,t.jsx)(n.h3,{id:"for-engineers-writing-features",children:"For engineers writing features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Autocomplete works:"})," Your IDE shows available flags. You can't reference flags that don't exist."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Types flow:"})," Return types are known at compile-time. No casting, no runtime surprises."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Refactoring is safe:"})," Rename a flag property and all callsites update. No grep-and-hope."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"for-teams-running-experiments",children:"For teams running experiments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ramp-ups are reproducible:"})," Same user always gets same bucket. You can replay decisions from logs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Percentages are stable:"})," Increasing 10% \u2192 20% only adds users for the same ",(0,t.jsx)(n.code,{children:"(stableId, flagKey, salt)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Targeting is consistent:"})," Platform/locale/version targeting works the same across all flags."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"for-systems-that-grow",children:"For systems that grow"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No boolean explosion:"})," Variants are values, not combinatorial boolean checks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No evaluation logic duplication:"})," One DSL, one evaluation engine, shared across all domains."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clear boundaries:"})," Compile-time correctness for definitions. Runtime validation for remote config. No blurred\nlines."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"when-konditional-fits",children:"When Konditional Fits"}),"\n",(0,t.jsx)(n.p,{children:"Choose Konditional when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"You want compile-time correctness"})," for flag definitions and callsites"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"You need typed values"})," beyond on/off booleans (variants, thresholds, configuration)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"You value consistency"})," over bespoke per-domain solutions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"You run experiments"})," and need deterministic, reproducible ramp-ups"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"You have remote configuration"})," and want explicit validation boundaries"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Konditional might not fit if:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"You need vendor-hosted dashboards"})," more than you need compile-time safety"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Your flags are fully dynamic"})," with zero static definitions (though you can still use Konditional for the static\nsubset)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"You're okay with process and tooling"})," to prevent string key drift (code review, linters, integration tests)"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"the-three-models-at-a-glance",children:"The Three Models at a Glance"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Approach"}),(0,t.jsx)(n.th,{children:"Key/Definition"}),(0,t.jsx)(n.th,{children:"Evaluation"}),(0,t.jsx)(n.th,{children:"Result"}),(0,t.jsx)(n.th,{children:"Main Trade-off"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"String-based"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"flag-name"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"getVal/..."})}),(0,t.jsx)(n.td,{children:"Value (runtime)"}),(0,t.jsx)(n.td,{children:"Flexibility vs. runtime safety"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Enum-bool"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"enum Capability"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"isEnabled(ctx)"})}),(0,t.jsx)(n.td,{children:"Boolean"}),(0,t.jsx)(n.td,{children:"Compile-time keys vs. boolean-only values"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Konditional"}),(0,t.jsx)(n.td,{children:"Compiled property"}),(0,t.jsx)(n.td,{children:"Rules + default"}),(0,t.jsx)(n.td,{children:"Typed value"}),(0,t.jsx)(n.td,{children:"Static definitions vs. dynamic configuration"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"real-problems-konditional-prevents",children:"Real Problems Konditional Prevents"}),"\n",(0,t.jsx)(n.h3,{id:"production-incident-type-coercion",children:"Production incident: Type coercion"}),"\n",(0,t.jsxs)(n.p,{children:["A string-keyed SDK returns ",(0,t.jsx)(n.code,{children:"0"})," when parsing ",(0,t.jsx)(n.code,{children:'"max_retries": "disabled"'})," from JSON. The service retries 0 times. All\nrequests fail immediately. Incident lasts 45 minutes."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"With Konditional:"})," The JSON parse fails at the boundary. ",(0,t.jsx)(n.code,{children:"ParseResult.Failure"})," is logged. Last-known-good\nconfiguration remains active. No incident."]}),"\n",(0,t.jsx)(n.h3,{id:"experiment-contamination-inconsistent-bucketing",children:"Experiment contamination: Inconsistent bucketing"}),"\n",(0,t.jsx)(n.p,{children:"Two teams implement ramp-ups with different hashing. Same user gets opposite buckets for related features. A/B test\nresults are polluted. Experiment analysis is invalid."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"With Konditional:"})," All ramp-ups use the same deterministic SHA-256 bucketing. Same user, same flag, same bucket.\nResults are clean."]}),"\n",(0,t.jsx)(n.h3,{id:"maintenance-burden-boolean-explosion",children:"Maintenance burden: Boolean explosion"}),"\n",(0,t.jsx)(n.p,{children:"A feature has 5 boolean flags for variants. Testing requires 2^5 = 32 combinations. Most combinations are undefined.\nBugs hide in interactions. Engineers avoid touching the code."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"With Konditional:"})," One flag, one typed value, explicit variants. Testing covers defined cases. Code is readable."]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-drift-silent-deployment",children:"Configuration drift: Silent deployment"}),"\n",(0,t.jsxs)(n.p,{children:["Someone changes ",(0,t.jsx)(n.code,{children:'"new_onboarding_flow"'})," to ",(0,t.jsx)(n.code,{children:'"new_onboarding_experience"'})," in the remote config. Half the codebase uses\nthe old key, half uses the new key. Ramp-up percentage splits across both. Metrics are nonsense."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"With Konditional:"})," Flag keys are derived from property names. Renaming the property updates all callsites (\ncompile-time). If remote config still sends the old key, loading fails (or emits a warning if configured to skip unknown\nkeys) instead of silently splitting traffic."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,t.jsx)(n.p,{children:"If you're coming from a boolean capability system:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Mirror existing flags"})," as properties on a ",(0,t.jsx)(n.code,{children:"Namespace"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'object Features : Namespace("app") {\n    val featureX by boolean(default = false)\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Centralize evaluation logic"})," into rules:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'object Features : Namespace("app") {\n    val featureX by boolean(default = false) {\n        rule(true) { platforms(Platform.WEB) }\n        rule(true) { rampUp { 25.0 } }\n    }\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Replace boolean matrices"})," with typed values where variants exist:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Before: CHECKOUT_V1, CHECKOUT_V2, CHECKOUT_V3 (3 booleans)\n// After:\nenum class CheckoutVersion { V1, V2, V3 }\nobject CheckoutFlags : Namespace("checkout") {\n    val checkoutVersion by enum(default = CheckoutVersion.V1) {\n        rule(CheckoutVersion.V2) { rampUp { 33.0 } }\n        rule(CheckoutVersion.V3) { rampUp { 66.0 } }\n    }\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Introduce namespaces"})," only if you need independent registries:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'sealed class Domain(id: String) : Namespace(id) {\n    data object Account : Domain("account")\n    data object Payments : Domain("payments")\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Add remote config"})," with explicit boundaries:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"when (val result = Features.fromJson(json)) {\n    is ParseResult.Success -> Unit // loaded into Features\n    is ParseResult.Failure -> keepLastKnownGood()\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Feature flags and configuration aren't just \"nice to have\" features. They're load-bearing infrastructure. When they\nfail, they fail at scale, in production, with user impact."}),"\n",(0,t.jsxs)(n.p,{children:["Konditional exists because ",(0,t.jsx)(n.strong,{children:"stringly-typed systems cause production incidents"}),", ",(0,t.jsx)(n.strong,{children:"boolean-only systems create\nmaintenance nightmares"}),", and ",(0,t.jsx)(n.strong,{children:"inconsistent evaluation semantics make experiments untrustworthy"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The solution isn't more process or better code review. The solution is structural: bind types at compile-time,\ncentralize evaluation semantics, and draw explicit boundaries between static definitions and dynamic configuration."}),"\n",(0,t.jsx)(n.p,{children:"That's what Konditional does."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},48193(e,n,i){i.d(n,{R:()=>l,x:()=>o});var s=i(30758);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);