"use strict";(self.webpackChunkkonditional_docs=self.webpackChunkkonditional_docs||[]).push([[30],{88924(i){i.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"link","label":"Konditional","href":"/konditional/","docId":"index","unlisted":false},{"type":"link","label":"Getting Started","href":"/konditional/getting-started","docId":"getting-started","unlisted":false},{"type":"link","label":"Migration Guide","href":"/konditional/migration","docId":"migration","unlisted":false},{"type":"link","label":"Core Concepts","href":"/konditional/core-concepts","docId":"core-concepts","unlisted":false},{"type":"link","label":"Targeting & Ramp-ups","href":"/konditional/targeting-ramp-ups","docId":"targeting-ramp-ups","unlisted":false},{"type":"link","label":"Evaluation","href":"/konditional/evaluation","docId":"evaluation","unlisted":false},{"type":"link","label":"Remote Configuration","href":"/konditional/remote-config","docId":"remote-config","unlisted":false},{"type":"link","label":"Theory: What \u201cIf it compiles, it works\u201d means","href":"/konditional/theory","docId":"theory","unlisted":false},{"type":"link","label":"Persistence & Storage Format","href":"/konditional/persistence-format","docId":"persistence-format","unlisted":false},{"type":"link","label":"Why Konditional Exists","href":"/konditional/why-konditional","docId":"why-konditional","unlisted":false}]},"docs":{"core-concepts":{"id":"core-concepts","title":"Core Concepts","description":"Konditional\u2019s public surface is intentionally small. Understanding three primitives\u2014Features, Context, and Namespaces\u2014is enough to reason about correctness, organization, and runtime behavior.","sidebar":"docs"},"evaluation":{"id":"evaluation","title":"Evaluation","description":"Konditional evaluation is designed to be predictable","sidebar":"docs"},"getting-started":{"id":"getting-started","title":"Getting Started","description":"Konditional is a Kotlin feature-flag DSL designed to make configuration typed, deterministic, and non-null.","sidebar":"docs"},"index":{"id":"index","title":"Konditional","description":"Type-safe feature flags for Kotlin that won\'t break in production.","sidebar":"docs"},"migration":{"id":"migration","title":"Migration Guide","description":"This guide maps the conceptual shift from string-based flags to Konditional\u2019s typed, property-based model.","sidebar":"docs"},"openapi/fetch-a-configuration-snapshot":{"id":"openapi/fetch-a-configuration-snapshot","title":"Fetch a configuration snapshot","description":"Fetch a configuration snapshot"},"openapi/konditional-serialization-schema":{"id":"openapi/konditional-serialization-schema","title":"Konditional Serialization Schema","description":""},"persistence-format":{"id":"persistence-format","title":"Persistence & Storage Format","description":"This page documents the JSON formats used to persist and transport Konditional configuration:","sidebar":"docs"},"remote-config":{"id":"remote-config","title":"Remote Configuration","description":"Konditional supports dynamic configuration via JSON, but treats JSON as a trust boundary:","sidebar":"docs"},"targeting-ramp-ups":{"id":"targeting-ramp-ups","title":"Targeting & Ramp-ups","description":"Rules let you target specific contexts and ramp up behavior safely. A rule is a typed mapping:","sidebar":"docs"},"theory":{"id":"theory","title":"Theory: What \u201cIf it compiles, it works\u201d means","description":"Konditional\u2019s core claim is intentionally narrow and testable: for statically-defined flags and rules, the compiler","sidebar":"docs"},"why-konditional":{"id":"why-konditional","title":"Why Konditional Exists","description":"The Problem","sidebar":"docs"}}}}')}}]);