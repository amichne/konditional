"use strict";(self.webpackChunkkonditional_docs=self.webpackChunkkonditional_docs||[]).push([[187],{12944(e,n,a){a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"remote-config","title":"Remote Configuration","description":"Konditional supports dynamic configuration via JSON, but treats JSON as a trust boundary:","source":"@site/docs/remote-config.md","sourceDirName":".","slug":"/remote-config","permalink":"/remote-config","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Evaluation","permalink":"/evaluation"},"next":{"title":"Theory: What \u201cIf it compiles, it works\u201d means","permalink":"/theory"}}');var r=a(86070),t=a(48193);const i={},l="Remote Configuration",o={},d=[{value:"The lifecycle (end-to-end)",id:"the-lifecycle-end-to-end",level:2},{value:"Prerequisite: features must be registered",id:"prerequisite-features-must-be-registered",level:2},{value:"Exporting configuration",id:"exporting-configuration",level:2},{value:"Loading configuration (validated boundary)",id:"loading-configuration-validated-boundary",level:2},{value:"Incremental updates via patching",id:"incremental-updates-via-patching",level:2},{value:"Error handling model (<code>ParseResult</code>)",id:"error-handling-model-parseresult",level:2},{value:"Hot-reload semantics (atomicity)",id:"hot-reload-semantics-atomicity",level:2},{value:"Lenient deserialization (forward compatibility)",id:"lenient-deserialization-forward-compatibility",level:2},{value:"Versioning metadata (audit + rollback)",id:"versioning-metadata-audit--rollback",level:2},{value:"What\u2019s validated (and what is not)",id:"whats-validated-and-what-is-not",level:2},{value:"Integration patterns",id:"integration-patterns",level:2},{value:"Polling",id:"polling",level:3},{value:"Push-based (streams)",id:"push-based-streams",level:3},{value:"Where Kontracts fits",id:"where-kontracts-fits",level:2},{value:"Next steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"remote-configuration",children:"Remote Configuration"})}),"\n",(0,r.jsxs)(n.p,{children:["Konditional supports dynamic configuration via JSON, but treats JSON as a ",(0,r.jsx)(n.strong,{children:"trust boundary"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"compile-time guarantees apply to statically-defined flags and rules"}),"\n",(0,r.jsxs)(n.li,{children:["runtime JSON is accepted only after validation (",(0,r.jsx)(n.code,{children:"ParseResult.Success"}),"), otherwise rejected (",(0,r.jsx)(n.code,{children:"ParseResult.Failure"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"the-lifecycle-end-to-end",children:"The lifecycle (end-to-end)"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n  Code["Flags defined in code"] --\x3e Snap["namespace.toJson()"]\n  Snap --\x3e Json["JSON snapshot"]\n  Json --\x3e Parse["namespace.fromJson(json)"]\n  Parse --\x3e|Success| Load["Loads into namespace"]\n  Parse --\x3e|Failure| Reject["Keep last-known-good + log"]\n  Load --\x3e Eval["Evaluation uses active snapshot"]\n  style Load fill:#c8e6c9\n  style Reject fill:#ffcdd2'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"prerequisite-features-must-be-registered",children:"Prerequisite: features must be registered"}),"\n",(0,r.jsxs)(n.p,{children:["Deserialization can only succeed for features that exist in the process. In practice, this means your\n",(0,r.jsx)(n.code,{children:"Namespace"})," objects must be initialized (so features are registered) before you call\n",(0,r.jsx)(n.code,{children:"SnapshotSerializer.fromJson(...)"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If a snapshot references a feature that has not been registered yet, deserialization fails with\n",(0,r.jsx)(n.code,{children:"ParseError.FeatureNotFound"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"One simple pattern is to reference your namespaces at application startup (t0):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'object Payments : Namespace("payments") {\n    val applePay by boolean(default = false)\n}\n\nval _ = Payments // ensure registration at startup (t0)\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"exporting-configuration",children:"Exporting configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"val json = Payments.toJson()\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use this when you want to externalize a namespace\u2019s current configuration state into JSON for storage or transport."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"loading-configuration-validated-boundary",children:"Loading configuration (validated boundary)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'val json = File("flags.json").readText()\nwhen (val result = Payments.fromJson(json)) {\n    is ParseResult.Success -> Unit // loaded into Payments\n    is ParseResult.Failure -> handleError(result.error)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The contract is explicit:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Success"})," means you have a type-correct, internally consistent snapshot representation (validated at the boundary)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Failure"})," means the payload is rejected before it can affect evaluation."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"incremental-updates-via-patching",children:"Incremental updates via patching"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"val currentConfig = Payments.configuration\nwhen (val result = SnapshotSerializer.applyPatchJson(currentConfig, patchJson)) {\n    is ParseResult.Success -> Payments.load(result.value)\n    is ParseResult.Failure -> handleError(result.error)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This supports applying incremental JSON updates, then atomically swapping the active configuration via ",(0,r.jsx)(n.code,{children:"Namespace.load"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"error-handling-model-parseresult",children:["Error handling model (",(0,r.jsx)(n.code,{children:"ParseResult"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Remote configuration is designed to force explicit handling of invalid input:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"sealed interface ParseResult<out T> {\n    data class Success<T>(val value: T) : ParseResult<T>()\n    data class Failure(val error: ParseError) : ParseResult<Nothing>()\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Operationally, treat failures as non-fatal: keep last-known-good configuration, log for alerting, and retry on the next\nupdate."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"hot-reload-semantics-atomicity",children:"Hot-reload semantics (atomicity)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Namespace.load(newConfiguration)"})," applies updates with atomic replacement semantics:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"readers see either the old snapshot or the new snapshot"}),"\n",(0,r.jsx)(n.li,{children:"readers never see a partially-applied configuration"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This aligns with the evaluation model documented in ",(0,r.jsx)(n.a,{href:"/evaluation",children:'"Evaluation"'}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"lenient-deserialization-forward-compatibility",children:"Lenient deserialization (forward compatibility)"}),"\n",(0,r.jsx)(n.p,{children:"During migrations, you may prefer to skip unknown keys instead of failing the entire snapshot:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'val options = SnapshotLoadOptions.skipUnknownKeys { warning ->\n    log.warn("Skipping unknown key: ${warning.key}")\n}\n\nwhen (val result = SnapshotSerializer.fromJson(json, options)) {\n    is ParseResult.Success -> Payments.load(result.value)\n    is ParseResult.Failure -> handleError(result.error)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This preserves strict correctness by default while enabling operationally-safe forward compatibility when needed."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"versioning-metadata-audit--rollback",children:"Versioning metadata (audit + rollback)"}),"\n",(0,r.jsxs)(n.p,{children:["Snapshots optionally carry ",(0,r.jsx)(n.code,{children:"meta"})," fields (version, timestamp, source). You can also attach metadata after parsing:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'when (val result = SnapshotSerializer.fromJson(json)) {\n    is ParseResult.Success -> Payments.load(\n        result.value.withMetadata(\n            version = "rev-123",\n            source = "s3://configs/global.json",\n        )\n    )\n    is ParseResult.Failure -> handleError(result.error)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Registries keep a bounded history of prior configurations for operational rollback:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"val rolledBack: Boolean = Payments.rollback(steps = 1)\nval history = Payments.historyMetadata\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"whats-validated-and-what-is-not",children:"What\u2019s validated (and what is not)"}),"\n",(0,r.jsx)(n.p,{children:"Validated at the boundary:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"JSON syntax validity"}),"\n",(0,r.jsx)(n.li,{children:"schema/structure validity"}),"\n",(0,r.jsx)(n.li,{children:"value type checking against declared feature types"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Not validated by the type system:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"semantic correctness (e.g., whether 50% is the intended ramp-up)"}),"\n",(0,r.jsx)(n.li,{children:"business correctness (e.g., whether the targeted segment is correct)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"integration-patterns",children:"Integration patterns"}),"\n",(0,r.jsx)(n.h3,{id:"polling",children:"Polling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'while (running) {\n    val json = fetchFromServer()\n    when (val result = SnapshotSerializer.fromJson(json)) {\n        is ParseResult.Success -> Payments.load(result.value)\n        is ParseResult.Failure -> log.error("Config parse failed: ${result.error}")\n    }\n    delay(pollInterval)\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"push-based-streams",children:"Push-based (streams)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'configStream.collect { json ->\n    when (val result = SnapshotSerializer.fromJson(json)) {\n        is ParseResult.Success -> Payments.load(result.value)\n        is ParseResult.Failure -> log.error("Config parse failed: ${result.error}")\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"where-kontracts-fits",children:"Where Kontracts fits"}),"\n",(0,r.jsx)(n.p,{children:"Konditional uses Kontracts (a standalone, zero-dependency JSON Schema DSL) for schema validation of configuration\npayloads."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Understand the \u201cif it compiles\u201d claim boundary: ",(0,r.jsx)(n.a,{href:"/theory",children:'"Theory"'})]}),"\n",(0,r.jsxs)(n.li,{children:["Understand bucketing determinism inputs: ",(0,r.jsx)(n.a,{href:"/targeting-ramp-ups",children:'"Targeting & Ramp-ups"'})]}),"\n",(0,r.jsxs)(n.li,{children:["See the concrete snapshot/patch payload shapes: ",(0,r.jsx)(n.a,{href:"/persistence-format",children:'"Persistence & Storage Format"'})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},48193(e,n,a){a.d(n,{R:()=>i,x:()=>l});var s=a(30758);const r={},t=s.createContext(r);function i(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);