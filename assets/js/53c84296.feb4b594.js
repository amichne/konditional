"use strict";(self.webpackChunkkonditional_docs=self.webpackChunkkonditional_docs||[]).push([[581],{48193(e,n,i){i.d(n,{R:()=>s,x:()=>r});var t=i(30758);const a={},l=t.createContext(a);function s(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(l.Provider,{value:n},e.children)}},88407(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"evaluation","title":"Evaluation","description":"Konditional evaluation is designed to be predictable","source":"@site/docs/evaluation.md","sourceDirName":".","slug":"/evaluation","permalink":"/konditional/evaluation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Targeting & Ramp-ups","permalink":"/konditional/targeting-ramp-ups"},"next":{"title":"Remote Configuration","permalink":"/konditional/remote-config"}}');var a=i(86070),l=i(48193);const s={},r="Evaluation",d={},c=[{value:"Konditional evaluation is designed to be predictable",id:"konditional-evaluation-is-designed-to-be-predictable",level:3},{value:"<code>Feature.evaluate(context)</code> (recommended)",id:"featureevaluatecontext-recommended",level:2},{value:"Explain / trace (operational debugging)",id:"explain--trace-operational-debugging",level:2},{value:"Evaluation flow",id:"evaluation-flow",level:2},{value:"Emergency kill switch (namespace-scoped)",id:"emergency-kill-switch-namespace-scoped",level:2},{value:"Bucketing utility (ramp-up debugging)",id:"bucketing-utility-ramp-up-debugging",level:2},{value:"Rule matching (AND semantics)",id:"rule-matching-and-semantics",level:3},{value:"Specificity ordering (most specific wins)",id:"specificity-ordering-most-specific-wins",level:3},{value:"Performance model",id:"performance-model",level:2},{value:"Concurrency model",id:"concurrency-model",level:2},{value:"Testing evaluation",id:"testing-evaluation",level:2},{value:"Rule matching",id:"rule-matching",level:3},{value:"Determinism",id:"determinism",level:3},{value:"Ramp-up distribution (statistical sanity check)",id:"ramp-up-distribution-statistical-sanity-check",level:3},{value:"Guarantees (and boundaries)",id:"guarantees-and-boundaries",level:2},{value:"Next steps",id:"next-steps",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"evaluation",children:"Evaluation"})}),"\n",(0,a.jsx)(n.h3,{id:"konditional-evaluation-is-designed-to-be-predictable",children:"Konditional evaluation is designed to be predictable"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Total"})," \u2014 Evaluation always returns a value (rule value or default)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Deterministic"})," \u2014 The same inputs produce the same outputs."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Non-null"})," \u2014 Defaults are required, so evaluation does not return ",(0,a.jsx)(n.code,{children:"T?"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.h2,{id:"featureevaluatecontext-recommended",children:[(0,a.jsx)(n.code,{children:"Feature.evaluate(context)"})," (recommended)"]}),"\n",(0,a.jsx)(n.p,{children:"Concise evaluation with an explicit context:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val darkMode = Features.darkMode.evaluate(context)\napplyDarkMode(darkMode)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Use this when:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"defaults are meaningful"}),"\n",(0,a.jsx)(n.li,{children:"you want the smallest call-site surface"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Evaluation is always via ",(0,a.jsx)(n.code,{children:"Feature.evaluate(...)"})," (or ",(0,a.jsx)(n.code,{children:"evaluateWithReason(...)"}),") and requires an explicit ",(0,a.jsx)(n.code,{children:"Context"}),"."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"explain--trace-operational-debugging",children:"Explain / trace (operational debugging)"}),"\n",(0,a.jsx)(n.p,{children:"When you need to diagnose a specific user\u2019s outcome, evaluate with a structured reason:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val result = Features.darkMode.evaluateWithReason(context)\nprintln(result.decision)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"EvaluationResult"})," includes:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"decision kind (rule/default/inactive/disabled)"}),"\n",(0,a.jsx)(n.li,{children:"matched rule constraints + specificity"}),"\n",(0,a.jsx)(n.li,{children:"deterministic ramp-up bucket information"}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"evaluation-flow",children:"Evaluation flow"}),"\n",(0,a.jsx)(n.mermaid,{value:'flowchart TD\n    Start["Context available"] --\x3e Lookup["Registry lookup"]\n    Lookup --\x3e Disabled{Registry disabled?}\n    Disabled --\x3e|Yes| Default0["Return default"]\n    Disabled --\x3e|No| Active{Flag active?}\n    Active --\x3e|No| Default1["Return default"]\n    Active --\x3e|Yes| Sort["Sort rules by specificity"]\n    Sort --\x3e Next{Next rule?}\n    Next --\x3e|No| Default2["Return default"]\n    Next --\x3e|Yes| Match{All criteria match?}\n    Match --\x3e|No| Next\n    Match --\x3e|Yes| Roll{In ramp-up or allowlisted?}\n    Roll --\x3e|No| Next\n    Roll --\x3e|Yes| Value["Return rule value"]\n    style Default0 fill: #fff3cd\n    style Default1 fill: #fff3cd\n    style Default2 fill: #fff3cd\n    style Value fill: #c8e6c9'}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"emergency-kill-switch-namespace-scoped",children:"Emergency kill switch (namespace-scoped)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"Features.disableAll()\n// ... all evaluations in this namespace return declared defaults ...\nFeatures.enableAll()\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"bucketing-utility-ramp-up-debugging",children:"Bucketing utility (ramp-up debugging)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val info = RampUpBucketing.explain(\n    stableId = context.stableId,\n    featureKey = Features.darkMode.key,\n    salt = Features.flag(Features.darkMode).salt,\n    rampUp = RampUp.of(10.0),\n)\nprintln(info)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"rule-matching-and-semantics",children:"Rule matching (AND semantics)"}),"\n",(0,a.jsx)(n.p,{children:"All specified criteria must match; empty constraint sets match everything."}),"\n",(0,a.jsx)(n.p,{children:"Evaluation applies the first matching rule that is in-ramp-up (or allowlisted), otherwise it falls back to the default."}),"\n",(0,a.jsx)(n.h3,{id:"specificity-ordering-most-specific-wins",children:"Specificity ordering (most specific wins)"}),"\n",(0,a.jsx)(n.p,{children:"Rules are sorted by targeting specificity (platforms/locales/version bounds/axes) plus extension specificity.\nRamp-up percentage does not affect specificity; it gates whether a matching rule is applied."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"performance-model",children:"Performance model"}),"\n",(0,a.jsx)(n.p,{children:"The evaluation path is designed to be predictable:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Registry lookup:"})," O(1)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Rule iteration:"})," O(n) where n is rules per flag (typically small)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Ramp-up bucketing:"})," 0 or 1 SHA-256 hash per evaluation (bucket is computed only after a rule matches by criteria)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Space model:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"evaluation allocates a small trace object internally and may allocate for hashing inputs"}),"\n",(0,a.jsx)(n.li,{children:"rule structures are pre-built and reused across evaluations"}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"concurrency-model",children:"Concurrency model"}),"\n",(0,a.jsx)(n.p,{children:"Evaluation is designed for concurrent reads:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lock-free reads"}),": evaluation does not require synchronization."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Atomic updates"}),": configuration updates swap the active snapshot atomically (",(0,a.jsx)(n.code,{children:"Namespace.load"}),")."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"// Thread 1\nFeatures.load(newConfig)\n\n// Thread 2 (during update)\nval value = Features.darkMode.evaluate(context) // sees old OR new, never a mixed state\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"testing-evaluation",children:"Testing evaluation"}),"\n",(0,a.jsx)(n.h3,{id:"rule-matching",children:"Rule matching"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'@Test\nfun `iOS users in US get dark mode`() {\n    val context = Context(\n        locale = AppLocale.UNITED_STATES,\n        platform = Platform.IOS,\n        appVersion = Version.of(2, 1, 0),\n        stableId = StableId.of("user-123"),\n    )\n\n    val enabled = Features.darkMode.evaluate(context)\n    assertTrue(enabled)\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"determinism",children:"Determinism"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'@Test\nfun `evaluation is deterministic`() {\n    val context = Context(/*...*/)\n    val results = (1..100).map { Features.darkMode.evaluate(context) }\n    assertTrue(results.distinct().size == 1, "Non-deterministic!")\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"ramp-up-distribution-statistical-sanity-check",children:"Ramp-up distribution (statistical sanity check)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@Test\nfun `50 percent ramp-up distributes correctly`() {\n    val sampleSize = 10_000\n    val enabled = (0 until sampleSize).count { i ->\n        val ctx = Context(/*..., */\n                          stableId = StableId.of(i.toString(16).padStart(32, '0'))\n        )\n        Features.rampUpFlag.evaluate(ctx)\n    }\n\n    val percentage = (enabled.toDouble() / sampleSize) * 100\n    assertTrue(percentage in 48.0..52.0)\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"guarantees-and-boundaries",children:"Guarantees (and boundaries)"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Aspect"}),(0,a.jsx)(n.th,{children:"Guarantee"}),(0,a.jsx)(n.th,{children:"Boundary"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Type safety"}),(0,a.jsx)(n.td,{children:"return type matches definition"}),(0,a.jsx)(n.td,{children:"compile-time for statically-defined flags"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Non-null"}),(0,a.jsx)(n.td,{children:"evaluation never returns null"}),(0,a.jsx)(n.td,{children:"relies on required defaults"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Determinism"}),(0,a.jsx)(n.td,{children:"same inputs \u2192 same outputs"}),(0,a.jsx)(n.td,{children:"excludes malformed runtime JSON (see remote config)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Updates"}),(0,a.jsx)(n.td,{children:"atomic swap of configuration"}),(0,a.jsxs)(n.td,{children:["correctness depends on using ",(0,a.jsx)(n.code,{children:"Namespace.load"})]})]})]})]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Understand ramp-ups and bucketing inputs: ",(0,a.jsx)(n.a,{href:"/targeting-ramp-ups",children:'"Targeting & Ramp-ups"'})]}),"\n",(0,a.jsxs)(n.li,{children:["Add runtime-validated JSON configuration: ",(0,a.jsx)(n.a,{href:"/remote-config",children:'"Remote Configuration"'})]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);