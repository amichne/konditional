<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>ImplicitDefaultLocale:ConcurrencyAttacksTest.kt$ConcurrencyAttacksTest$String.format("%032d", 0)</ID>
    <ID>ImplicitDefaultLocale:ConcurrencyAttacksTest.kt$ConcurrencyAttacksTest$String.format("%032d", i)</ID>
    <ID>LongMethod:FeatureEvaluation.kt$@PublishedApi internal fun &lt;T : Any, C : Context, M : Namespace&gt; Feature&lt;T, C, M&gt;.evaluateInternal( context: C, registry: NamespaceRegistry, mode: Metrics.Evaluation.EvaluationMode, ): EvaluationResult&lt;T&gt;</ID>
    <ID>LongParameterList:Namespace.kt$Namespace$( thisRef: M, property: KProperty&lt;*&gt;, default: T, configScope: FlagScope&lt;T, C&gt;.() -&gt; Unit, featureFactory: (String, M) -&gt; F, featureSetter: (F) -&gt; Unit, delegateInstance: D, )</ID>
    <ID>MagicNumber:Bucketing.kt$Bucketing$0xFF</ID>
    <ID>MagicNumber:Bucketing.kt$Bucketing$0xFFFF_FFFFL</ID>
    <ID>MagicNumber:Bucketing.kt$Bucketing$100.0</ID>
    <ID>MagicNumber:Bucketing.kt$Bucketing$16</ID>
    <ID>MagicNumber:Bucketing.kt$Bucketing$24</ID>
    <ID>MagicNumber:Bucketing.kt$Bucketing$3</ID>
    <ID>MagicNumber:Bucketing.kt$Bucketing$8</ID>
    <ID>MagicNumber:Version.kt$Version.Companion$3</ID>
    <ID>MatchingDeclarationName:BaseRuleGuaranteesTest.kt$RuleGuaranteesTest</ID>
    <ID>MaxLineLength:AppLocale.kt$AppLocale$*</ID>
    <ID>MaxLineLength:AxisRegistry.kt$AxisRegistry$*</ID>
    <ID>MaxLineLength:ConditionEvaluationTest.kt$ConditionEvaluationTest$fun</ID>
    <ID>MaxLineLength:EvaluationResult.kt$EvaluationResult.Decision.Default$*</ID>
    <ID>MaxLineLength:Feature.kt$Feature$*</ID>
    <ID>MaxLineLength:FeatureEvaluation.kt$"konditional.explain namespaceId=${result.namespaceId} key=${result.featureKey} decision=${result.decision::class.simpleName} version=${result.configVersion}"</ID>
    <ID>MaxLineLength:FeatureEvaluation.kt$matchedRuleSpecificity = (result.decision as? EvaluationResult.Decision.Rule)?.matched?.rule?.totalSpecificity</ID>
    <ID>MaxLineLength:Namespace.kt$Namespace$*</ID>
    <ID>MaxLineLength:Predicate.kt$Predicate$*</ID>
    <ID>MaxLineLength:RuleMatchingTest.kt$RuleMatchingTest$fun</ID>
    <ID>ReturnCount:FlagDefinition.kt$FlagDefinition$internal fun evaluateTrace(context: C): Trace&lt;T, C&gt;</ID>
    <ID>TooManyFunctions:Namespace.kt$Namespace : NamespaceRegistry</ID>
    <ID>TooManyFunctions:ParseResultUtils.kt$io.amichne.konditional.core.result.utils.ParseResultUtils.kt</ID>
    <ID>TooManyFunctions:RuleScope.kt$RuleScope&lt;C : Context&gt;</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-ambiguous-rules") { // Both rules have specificity = 1 (platform only) // Order matters but this is implicit and undocumented val ambiguousFlag by boolean&lt;Context&gt;(default = false) { enable { platforms(Platform.ANDROID) } enable { platforms(Platform.IOS) // Also specificity 1 } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-empty-string") { val emptyStringFlag by string&lt;Context&gt;(default = "") { rule(" ") { // Whitespace-only also valid android() } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-huge-string") { val hugeStringFlag by string&lt;Context&gt;(default = longString) }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-infinity") { val infinityFlag by double&lt;Context&gt;(default = Double.POSITIVE_INFINITY) { rule(Double.NEGATIVE_INFINITY) { android() } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-max-int") { val maxIntFlag by integer&lt;Context&gt;(default = Int.MAX_VALUE) { rule(Int.MIN_VALUE) { android() } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-nan") { val nanFlag by double&lt;Context&gt;(default = Double.NaN) { // This compiles! But NaN != NaN by IEEE 754 } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-salt-defaults") { val defaultSaltFlag by boolean&lt;Context&gt;(default = false) { // Salt defaults to "v1" } val customSaltFlag by boolean&lt;Context&gt;(default = false) { salt("custom-salt-value") } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-salt-empty") { val emptySaltFlag by boolean&lt;Context&gt;(default = false) { salt("") // Empty salt compiles fine } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-salt-special") { val specialSaltFlag by boolean&lt;Context&gt;(default = false) { salt("salt:with:colons\nand\nnewlines") } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-shadowed-rules") { val shadowedFlag by boolean&lt;Context&gt;(default = false) { // Specificity 3: platform + locale + version enable { platforms(Platform.ANDROID) locales(AppLocale.UNITED_STATES) versions { min(1, 0, 0) } } // Specificity 1: platform only // This rule never fires for Android UNITED_STATES v1+ users // even if they intended it as a fallback disable { platforms(Platform.ANDROID) } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-special-chars") { val specialCharsFlag by string&lt;Context&gt;( default = "Line1\nLine2\tTab\u0000Null\r\nCRLF" ) }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-tiny-rampUp") { val tinyRolloutFlag by boolean&lt;Context&gt;(default = false) { enable { android() rampUp { 0.01 } // User might think this is 1%, but it's 0.01% } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-version-boundaries") { val boundedFlag by boolean&lt;Context&gt;(default = false) { enable { versions { min(1, 0, 0) max(2, 0, 0) } } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("adversarial-version-exact") { val exactVersionFlag by boolean&lt;Context&gt;(default = false) { enable { versions { min(1, 0, 0) max(1, 0, 0) } } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("rampUp-fallthrough") { val rolloutBlockedFlag by boolean&lt;Context&gt;(default = false) { enable { android() rampUp { 0.0 } // 0% rampUp - no one gets this } disable { android() rampUp { 100.0 } // Everyone gets this } } }</ID>
    <ID>VariableNaming:AdversarialConfigTest.kt$AdversarialConfigTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("rule-specificity") { val catchAllFlag by boolean&lt;Context&gt;(default = false) { // Specific rule: specificity = 1 enable { platforms(Platform.ANDROID) } // Catch-all rule: specificity = 0 disable { // No constraints = matches everything } } }</ID>
    <ID>VariableNaming:ConcurrencyAttacksTest.kt$ConcurrencyAttacksTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("concurrent-digest") { // Create many flags to stress digest usage val flag1 by boolean&lt;Context&gt;(default = false) { enable { rampUp { 50.0 } } } val flag2 by boolean&lt;Context&gt;(default = false) { enable { rampUp { 50.0 } } } val flag3 by boolean&lt;Context&gt;(default = false) { enable { rampUp { 50.0 } } } }</ID>
    <ID>VariableNaming:ConcurrencyAttacksTest.kt$ConcurrencyAttacksTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("concurrent-iteration") { val manyRulesFlag by boolean&lt;Context&gt;(default = false) { // Create many rules to increase iteration time repeat(100) { i -&gt; rule(i % 2 == 0) { note("rule-$i") if (i % 2 == 0) android() if (i % 2 != 0) ios() rampUp { (i % 100).toDouble() } } } } }</ID>
    <ID>VariableNaming:ConcurrencyAttacksTest.kt$ConcurrencyAttacksTest$val TestNamespaceFeatures = object : Namespace.TestNamespaceFacade("mutable-context") { val contextDependentFlag by boolean&lt;Context&gt;(default = false) { enable { platforms(Platform.ANDROID) } disable { platforms(Platform.IOS) } } }</ID>
  </CurrentIssues>
</SmellBaseline>
