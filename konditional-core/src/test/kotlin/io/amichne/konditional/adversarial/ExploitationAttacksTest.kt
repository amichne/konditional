@file:OptIn(KonditionalInternalApi::class)

package io.amichne.konditional.adversarial

import io.amichne.konditional.api.KonditionalInternalApi
import io.amichne.konditional.api.evaluate
import io.amichne.konditional.context.AppLocale
import io.amichne.konditional.context.Context
import io.amichne.konditional.context.Platform
import io.amichne.konditional.context.RampUp
import io.amichne.konditional.context.Version
import io.amichne.konditional.core.Namespace
import io.amichne.konditional.core.dsl.disable
import io.amichne.konditional.core.dsl.enable
import io.amichne.konditional.core.id.StableId
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertTrue

/**
 * EXPLOITATION ATTACK TESTS
 *
 * These tests demonstrate specific exploits that compile successfully
 * but of semantically invalid, misleading, or dangerous configurations.
 *
 * Each test documents a specific attack vector and its implications.
 */
class ExploitationAttacksTest {

    // ============================================
    // EXPLOIT 1: Version Parsing Data Loss
    // ============================================

    @Test
    fun `EXPLOIT - version parsing silently loses data from malformed versions`() {
        /*
         * ATTACK: Pass a version string with invalid parts
         * RESULT: Invalid parts are silently converted to 0, losing information
         * DANGER: Version "1.hack.2" becomes (1,0,0), completely losing the intended patch version
         */

        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe("1.hack.2")
        }

        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe("2.3.exploit")
        }
        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe("1..3") // Double dot
        }

        /*
         * IMPACT: A malicious or confused user could:
         * 1. Think they're targeting version 1.0.2 when actually targeting 1.0.0
         * 2. Create ambiguous version configurations
         * 3. Bypass version checks if they expect string validation
         */
    }

    @Test
    fun `EXPLOIT - version with only dots parses as all zeros`() {
        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe(".")
        }
//        assertEquals(Version(0, 0, 0), dotsOnly)

        assertThrows<IllegalArgumentException> {
            Version.parseUnsafe("..")
        }
//        assertEquals(Version(0, 0, 0), multiDots)

        /*
         * IMPACT: Version "." is indistinguishable from "0.0.0"
         * Could be used to of confusing configs
         */
    }

    @Test
    fun `EXPLOIT - negative version components create illogical semantic versions`() {
        /*
         * ATTACK: Create negative version numbers
         * RESULT: They work but violate semantic versioning spec
         * DANGER: Comparison logic works but semantics are meaningless
         */

        val zero = Version(0, 0, 0)
        val positive = Version(1, 0, 0)

        // Comparisons work but are semantically nonsense
//        assertTrue(negative < zero)
        assertTrue(zero < positive)

        assertThrows<IllegalArgumentException> {
            Version(-5, -10, -20)
        }

        // What does "version -5.-10.-20" mean? Nothing!
        // But it compiles and runs...

        /*
         * IMPACT: Creates impossible version numbers that:
         * 1. Violate semantic versioning specification
         * 2. Could confuse version comparison logic
         * 3. Make debugging harder (is -1 a sentinel value or bug?)
         */
    }

    // ============================================
    // EXPLOIT 2: Rule Specificity Manipulation
    // ============================================

    @Test
    fun `EXPLOIT - rules with same specificity create order-dependent behavior`() {
        /*
         * ATTACK: Create multiple rules with identical specificity
         * RESULT: Winner is determined by implementation-dependent sort order
         * DANGER: Behavior changes based on rule declaration order
         */

        val testNamespaceFeatures = object : Namespace.TestNamespaceFacade("exploit-rule-order") {
            val conflictingRules by boolean<Context>(default = false) {
                enable {
                    platforms(Platform.ANDROID) // Specificity = 1
                    note("first-rule")
                }

                disable {
                    locales(AppLocale.UNITED_STATES) // Also specificity = 1
                    note("second-rule")
                }
            }
        }

        val context = Context(
            locale = AppLocale.UNITED_STATES,
            platform = Platform.ANDROID,
            appVersion = Version(1, 0, 0),
            stableId = StableId.of("12345678901234567890123456789012")
        )

        // Both rules match and have same specificity (1)
        // Winner determined by note comparison: "first-rule" < "second-rule"
        // So first rule wins
        val result = testNamespaceFeatures.conflictingRules.evaluate(context)
        assertEquals(true, result)

        /*
         * IMPACT: Non-obvious rule resolution:
         * 1. Adding/removing rules changes behavior in unexpected ways
         * 2. Rule order matters but isn't documented clearly
         * 3. Tiebreaker uses note field which is optional
         * 4. If notes are null, sort order is unstable
         */
    }

    @Test
    fun `EXPLOIT - more specific rule always wins even if lower in config`() {
        /*
         * ATTACK: Rely on implicit specificity ordering
         * RESULT: Later rules can shadow earlier ones
         * DANGER: User might think rules are checked in order
         */

        val testNamespaceFeatures = object : Namespace.TestNamespaceFacade("exploit-specificity-shadowing") {
            val shadowedRules by string<Context>(default = "default") {
                // User writes this first, thinking it's a "catch-all"
                rule("catch-all") {
                    // Specificity = 0 (no constraints)
                }

                // Then adds specific rules later
                rule("android-specific") {
                    android() // Specificity = 1
                }
            }
        }

        val androidContext = Context(
            locale = AppLocale.UNITED_STATES,
            platform = Platform.ANDROID,
            appVersion = Version(1, 0, 0),
            stableId = StableId.of("12345678901234567890123456789012")
        )

        // Even though "catch-all" is first in code, "android-specific" wins
        // because it has higher specificity
        assertEquals("android-specific", testNamespaceFeatures.shadowedRules.evaluate(androidContext))

        /*
         * IMPACT: Declaration order != evaluation order
         * Can surprise users who expect sequential evaluation
         */
    }

    // ============================================
    // EXPLOIT 3: RampUp Percentage Confusion
    // ============================================

    @Test
    fun `EXPLOIT - rollout percentage easy to misconfigure by 100x`() {
        /*
         * ATTACK: User thinks 0.5 means 50% when it actually means 0.5%
         * RESULT: Feature rolls out to 100x fewer users than intended
         * DANGER: Silent under-deployment
         */

        val confusingRollout = RampUp.of(0.5) // Is this 0.5% or 50%?
        assertEquals(0.5, confusingRollout.value) // It's 0.5%!

        // User probably meant:
        val intendedRollout = RampUp.of(50.0) // 50%
        assertEquals(50.0, intendedRollout.value)

        /*
         * IMPACT:
         * 1. 0.5 looks like "half" but it's 0.5%
         * 2. Could deploy critical feature to almost no one by mistake
         * 3. Hard to debug - everything "works", just wrong scale
         */
    }

    @Test
    fun `EXPLOIT - rollout at exactly 0 means nobody ever sees the feature`() {
        /*
         * ATTACK: Set rampUp to 0.0
         * RESULT: Feature is unreachable even if all other rules match
         * DANGER: Dead code that compiles but never executes
         */

        val testNamespaceFeatures = object : Namespace.TestNamespaceFacade("exploit-rampUp-zero") {
            val deadFeature by boolean<Context>(default = false) {
                enable {
                    android()
                    rampUp { 0.0 } // 0% = nobody
                }
            }
        }

        val context = Context(
            locale = AppLocale.UNITED_STATES,
            platform = Platform.ANDROID,
            appVersion = Version(1, 0, 0),
            stableId = StableId.of("12345678901234567890123456789012")
        )

        // Rule matches but rampUp excludes everyone
        assertEquals(false, testNamespaceFeatures.deadFeature.evaluate(context))

        /*
         * IMPACT: Creates unreachable code paths
         * User might think feature is broken when it's just rolled out to 0%
         */
    }

    // ============================================
    // EXPLOIT 4: Special Numeric Values
    // ============================================

    @Test
    fun `EXPLOIT - NaN in double feature creates inequality paradox`() {
        /*
         * ATTACK: Use NaN as a default value
         * RESULT: Creates value that doesn't equal itself
         * DANGER: Breaks equality assumptions
         */

        val testNamespaceFeatures = object : Namespace.TestNamespaceFacade("exploit-nan") {
            val nanFeature by double<Context>(default = Double.NaN)
        }

        val nanDef = testNamespaceFeatures.flag(testNamespaceFeatures.nanFeature)
        val value = nanDef.defaultValue
        assertTrue(value.isNaN())
        assertFalse(value == value) // NaN != NaN!

        /*
         * IMPACT:
         * 1. Breaks == checks
         * 2. Can't use in when statements or equality comparisons
         * 3. Propagates through calculations, infecting results
         * 4. Could break JSON serialization
         */
    }

    @Test
    fun `EXPLOIT - infinity in double feature creates unbounded values`() {
        /*
         * ATTACK: Use Infinity as feature value
         * RESULT: Compiles but creates unbounded numeric value
         * DANGER: Mathematical operations can produce unexpected results
         */

        val testNamespaceFeatures = object : Namespace.TestNamespaceFacade("exploit-infinity") {
            val infiniteTimeout by double<Context>(default = Double.POSITIVE_INFINITY) {
                rule(Double.NEGATIVE_INFINITY) {
                    android()
                }
            }
        }

        val infiniteDef = testNamespaceFeatures.flag(testNamespaceFeatures.infiniteTimeout)
        assertEquals(Double.POSITIVE_INFINITY, infiniteDef.defaultValue)

        // User code might do:
        infiniteDef.defaultValue
        // timeout * 2 == Infinity
        // timeout + 1000 == Infinity
        // if (timeout > 1000) // always true!

        /*
         * IMPACT:
         * 1. Breaks numeric comparisons
         * 2. Can cause infinite loops if used as loop bound
         * 3. May not serialize to JSON correctly
         */
    }

    @Test
    fun `EXPLOIT - Int MAX_VALUE can overflow in user code`() {
        /*
         * ATTACK: Use Int.MAX_VALUE as feature value
         * RESULT: Compiles but user code adding to it will overflow
         * DANGER: Silent overflow to negative values
         */

        val testNamespaceFeatures = object : Namespace.TestNamespaceFacade("exploit-max-int") {
            val maxRetries by integer<Context>(default = Int.MAX_VALUE)
        }

        val maxRetriesDef = testNamespaceFeatures.flag(testNamespaceFeatures.maxRetries)
        val retries = maxRetriesDef.defaultValue
        assertEquals(Int.MAX_VALUE, retries)

        // User code might do:
        val nextRetry = retries + 1 // Overflows to Int.MIN_VALUE!
        assertEquals(Int.MIN_VALUE, nextRetry)

        /*
         * IMPACT:
         * 1. Silent overflow (no exception in Kotlin)
         * 2. Wraps to negative value
         * 3. Could break retry logic, timeouts, counters
         */
    }

    // ============================================
    // EXPLOIT 5: String Edge Cases
    // ============================================

}
